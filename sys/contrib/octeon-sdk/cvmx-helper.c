begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Helper functions for common, but complicated tasks.  *  *<hr>$Revision: 42150 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pip.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ipd.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-asx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-gmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-version.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-check-defines.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * cvmx_override_pko_queue_priority(int ipd_port, uint64_t  * priorities[16]) is a function pointer. It is meant to allow  * customization of the PKO queue priorities based on the port  * number. Users should set this pointer to a function before  * calling any cvmx-helper operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|void
function_decl|(
modifier|*
name|cvmx_override_pko_queue_priority
function_decl|)
parameter_list|(
name|int
name|pko_port
parameter_list|,
name|uint64_t
name|priorities
index|[
literal|16
index|]
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/**  * cvmx_override_ipd_port_setup(int ipd_port) is a function  * pointer. It is meant to allow customization of the IPD port  * setup before packet input/output comes online. It is called  * after cvmx-helper does the default IPD configuration, but  * before IPD is enabled. Users should set this pointer to a  * function before calling any cvmx-helper operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|void
function_decl|(
modifier|*
name|cvmx_override_ipd_port_setup
function_decl|)
parameter_list|(
name|int
name|ipd_port
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* Port count per interface */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|int
name|interface_port_count
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Port last configured link info index by IPD/PKO port */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_helper_link_info_t
name|port_link_info
index|[
name|CVMX_PIP_NUM_INPUT_PORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Return the number of interfaces the chip has. Each interface  * may have multiple ports. Most chips support two interfaces,  * but the CNX0XX and CNX1XX are exceptions. These only support  * one interface.  *  * @return Number of interfaces on chip  */
end_comment

begin_function
name|int
name|cvmx_helper_get_number_of_interfaces
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
return|return
literal|2
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|3
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of ports on an interface. Depending on the  * chip and configuration, this can be 1-16. A value of 0  * specifies that the interface doesn't exist or isn't usable.  *  * @param interface Interface to get the port count for  *  * @return Number of ports on interface. Can be Zero.  */
end_comment

begin_function
name|int
name|cvmx_helper_ports_on_interface
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
return|return
name|interface_port_count
index|[
name|interface
index|]
return|;
block|}
end_function

begin_comment
comment|/**  * Get the operating mode of an interface. Depending on the Octeon  * chip and configuration, this function returns an enumeration  * of the type of packet I/O supported by an interface.  *  * @param interface Interface to probe  *  * @return Mode of the interface. Unknown or unsupported interfaces return  *         DISABLED.  */
end_comment

begin_function
name|cvmx_helper_interface_mode_t
name|cvmx_helper_interface_get_mode
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
if|if
condition|(
name|interface
operator|==
literal|2
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_NPI
return|;
if|if
condition|(
name|interface
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_LOOP
return|;
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
if|if
condition|(
name|interface
operator|==
literal|0
operator|&&
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
operator|&&
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_rev_major
operator|==
literal|1
condition|)
block|{
comment|/* Lie about interface type of CN3005 board.  This board has a switch on port 1 like         ** the other evaluation boards, but it is connected over RGMII instead of GMII.  Report         ** GMII mode so that the speed is forced to 1 Gbit full duplex.  Other than some initial configuration         ** (which does not use the output of this function) there is no difference in setup between GMII and RGMII modes.         */
return|return
name|CVMX_HELPER_INTERFACE_MODE_GMII
return|;
block|}
comment|/* Interface 1 is always disabled on CN31XX and CN30XX */
if|if
condition|(
operator|(
name|interface
operator|==
literal|1
operator|)
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
operator|.
name|cn56xx
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
case|case
literal|1
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_XAUI
return|;
case|case
literal|2
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_SGMII
return|;
case|case
literal|3
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_PICMG
return|;
default|default:
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mode
operator|.
name|s
operator|.
name|en
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_SPI
return|;
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_GMII
return|;
block|}
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_RGMII
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure the IPD/PIP tagging and QoS options for a specific  * port. This function determines the POW work queue entry  * contents for a port. The setup performed here is controlled by  * the defines in executive-config.h.  *  * @param ipd_port Port to configure. This follows the IPD numbering, not the  *                 per interface numbering  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_port_setup_ipd
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_pip_port_cfg_t
name|port_config
decl_stmt|;
name|cvmx_pip_port_tag_cfg_t
name|tag_config
decl_stmt|;
name|port_config
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_CFGX
argument_list|(
name|ipd_port
argument_list|)
argument_list|)
expr_stmt|;
name|tag_config
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|ipd_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have each port go to a different POW queue */
name|port_config
operator|.
name|s
operator|.
name|qos
operator|=
name|ipd_port
operator|&
literal|0x7
expr_stmt|;
comment|/* Process the headers and place the IP header in the work queue */
name|port_config
operator|.
name|s
operator|.
name|mode
operator|=
name|CVMX_HELPER_INPUT_PORT_SKIP_MODE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_src_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_SRC_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_dst_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_DST_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_sprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_SRC_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_dprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_DST_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_nxth_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_NEXT_HEADER
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_src_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_SRC_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_dst_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_DST_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_sprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_SRC_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_dprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_DST_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_pctl_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_PROTOCOL
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|inc_prt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_INPUT_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|tcp6_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|tcp4_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|non_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
comment|/* Put all packets in group 0. Other groups can be used by the app */
name|tag_config
operator|.
name|s
operator|.
name|grp
operator|=
literal|0
expr_stmt|;
name|cvmx_pip_config_port
argument_list|(
name|ipd_port
argument_list|,
name|port_config
argument_list|,
name|tag_config
argument_list|)
expr_stmt|;
comment|/* Give the user a chance to override our setting for each port */
if|if
condition|(
name|cvmx_override_ipd_port_setup
condition|)
name|cvmx_override_ipd_port_setup
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This function probes an interface to determine the actual  * number of hardware ports connected to it. It doesn't setup the  * ports or enable them. The main goal here is to set the global  * interface_port_count[interface] correctly. Hardware setup of the  * ports will be performed later.  *  * @param interface Interface to probe  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_interface_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
comment|/* At this stage in the game we don't want packets to be moving yet.         The following probe calls should perform hardware setup         needed to determine port counts. Receive must still be disabled */
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
comment|/* These types don't support ports to IPD/PKO */
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* XAUI is a single high speed port */
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_xaui_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_rgmii_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SPI4 can have 1-16 ports depending on the device at the other end */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_spi_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SGMII can have 1-4 ports depending on how many are hooked up */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_sgmii_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* PCI target Network Packet Interface */
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_npi_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* Special loopback only ports. These are not the same as other ports             in loopback mode */
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_loop_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
block|}
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_board_interface_probe
argument_list|(
name|interface
argument_list|,
name|interface_port_count
index|[
name|interface
index|]
argument_list|)
expr_stmt|;
comment|/* Make sure all global variables propagate to other cores */
name|CVMX_SYNCWS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup the IPD/PIP for the ports on an interface. Packet  * classification and tagging are set for every port on the  * interface. The number of ports on the interface must already  * have been probed.  *  * @param interface Interface to setup IPD/PIP for  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_interface_setup_ipd
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|ipd_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_ports
init|=
name|interface_port_count
index|[
name|interface
index|]
decl_stmt|;
while|while
condition|(
name|num_ports
operator|--
condition|)
block|{
name|__cvmx_helper_port_setup_ipd
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
name|ipd_port
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global setting for IPD/PIP not related to a specific  * interface or port. This must be called before IPD is enabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_ipd
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Setup the global packet input options */
name|cvmx_ipd_config
argument_list|(
name|CVMX_FPA_PACKET_POOL_SIZE
operator|/
literal|8
argument_list|,
name|CVMX_HELPER_FIRST_MBUFF_SKIP
operator|/
literal|8
argument_list|,
name|CVMX_HELPER_NOT_FIRST_MBUFF_SKIP
operator|/
literal|8
argument_list|,
operator|(
name|CVMX_HELPER_FIRST_MBUFF_SKIP
operator|+
literal|8
operator|)
operator|/
literal|128
argument_list|,
comment|/* The +8 is to account for the next ptr */
operator|(
name|CVMX_HELPER_NOT_FIRST_MBUFF_SKIP
operator|+
literal|8
operator|)
operator|/
literal|128
argument_list|,
comment|/* The +8 is to account for the next ptr */
name|CVMX_FPA_WQE_POOL
argument_list|,
name|CVMX_IPD_OPC_MODE_STT
argument_list|,
name|CVMX_HELPER_ENABLE_BACK_PRESSURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup the PKO for the ports on an interface. The number of  * queues per port and the priority of each PKO output queue  * is set here. PKO must be disabled when this function is called.  *  * @param interface Interface to setup PKO for  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_interface_setup_pko
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
comment|/* Each packet output queue has an associated priority. The higher the         priority, the more often it can send a packet. A priority of 8 means         it can send in all 8 rounds of contention. We're going to make each         queue one less than the last.         The vector of priorities has been extended to support CN5xxx CPUs,         where up to 16 queues can be associated to a port.         To keep backward compatibility we don't change the initial 8         priorities and replicate them in the second half.         With per-core PKO queues (PKO lockless operation) all queues have         the same priority. */
name|uint64_t
name|priorities
index|[
literal|16
index|]
init|=
block|{
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Setup the IPD/PIP and PKO for the ports discovered above. Here packet         classification, tagging and output priorities are set */
name|int
name|ipd_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_ports
init|=
name|interface_port_count
index|[
name|interface
index|]
decl_stmt|;
while|while
condition|(
name|num_ports
operator|--
condition|)
block|{
comment|/* Give the user a chance to override the per queue priorities */
if|if
condition|(
name|cvmx_override_pko_queue_priority
condition|)
name|cvmx_override_pko_queue_priority
argument_list|(
name|ipd_port
argument_list|,
name|priorities
argument_list|)
expr_stmt|;
name|cvmx_pko_config_port
argument_list|(
name|ipd_port
argument_list|,
name|cvmx_pko_get_base_queue_per_core
argument_list|(
name|ipd_port
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cvmx_pko_get_num_queues
argument_list|(
name|ipd_port
argument_list|)
argument_list|,
name|priorities
argument_list|)
expr_stmt|;
name|ipd_port
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global setting for PKO not related to a specific  * interface or port. This must be called before PKO is enabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_pko
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Disable tagwait FAU timeout. This needs to be done before anyone might         start packet output using tags */
name|cvmx_iob_fau_timeout_t
name|fau_to
decl_stmt|;
name|fau_to
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|fau_to
operator|.
name|s
operator|.
name|tout_val
operator|=
literal|0xfff
expr_stmt|;
name|fau_to
operator|.
name|s
operator|.
name|tout_enb
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IOB_FAU_TIMEOUT
argument_list|,
name|fau_to
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global backpressure setting.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_backpressure
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|CVMX_HELPER_DISABLE_RGMII_BACKPRESSURE
comment|/* Disable backpressure if configured to do so */
comment|/* Disable backpressure (pause frame) generation */
name|int
name|num_interfaces
init|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
decl_stmt|;
name|int
name|interface
decl_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|cvmx_gmx_set_backpressure_override
argument_list|(
name|interface
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|//cvmx_dprintf("Disabling backpressure\n");
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Enable packet input/output from the hardware. This function is  * called after all internal setup is complete and IPD is enabled.  * After this function completes, packets will be accepted from the  * hardware ports. PKO should still be disabled to make sure packets  * aren't sent out partially setup hardware.  *  * @param interface Interface to enable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_packet_hardware_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
comment|/* These types don't support ports to IPD/PKO */
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
comment|/* Nothing to do */
break|break;
comment|/* XAUI is a single high speed port */
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SPI4 can have 1-16 ports depending on the device at the other end */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SGMII can have 1-4 ports depending on how many are hooked up */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* PCI target Network Packet Interface */
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
name|result
operator|=
name|__cvmx_helper_npi_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* Special loopback only ports. These are not the same as other ports             in loopback mode */
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
name|result
operator|=
name|__cvmx_helper_loop_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator||=
name|__cvmx_helper_board_hardware_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Called after all internal packet IO paths are setup. This  * function enables IPD/PIP and begins packet input and output.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_ipd_and_packet_input_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num_interfaces
decl_stmt|;
name|int
name|interface
decl_stmt|;
comment|/* Enable IPD */
name|cvmx_ipd_enable
argument_list|()
expr_stmt|;
comment|/* Time to enable hardware ports packet input and output. Note that at this         point IPD/PIP must be fully functional and PKO must be disabled */
name|num_interfaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
if|if
condition|(
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//cvmx_dprintf("Enabling packet I/O on interface %d\n", interface);
name|__cvmx_helper_packet_hardware_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally enable PKO now that the entire path is up and running */
name|cvmx_pko_enable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX_PASS1
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX_PASS1
argument_list|)
operator|)
operator|&&
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
operator|)
condition|)
name|__cvmx_helper_errata_fix_ipd_ptr_alignment
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the PIP, IPD, and PKO hardware to support  * simple priority based queues for the ethernet ports. Each  * port is configured with a number of priority queues based  * on CVMX_PKO_QUEUES_PER_PORT_* where each queue is lower  * priority than the previous.  *  * @return Zero on success, non-zero on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_initialize_packet_io_global
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|cvmx_smix_en_t
name|smix_en
decl_stmt|;
specifier|const
name|int
name|num_interfaces
init|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
decl_stmt|;
comment|/* CN52XX pass 1: Due to a bug in 2nd order CDR, it needs to be disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_0
argument_list|)
condition|)
name|__cvmx_helper_errata_qlm_disable_2nd_order_cdr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell L2 to give the IOB statically higher priority compared to the         cores. This avoids conditions where IO blocks might be starved under         very high L2 loads */
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
name|l2c_cfg
operator|.
name|s
operator|.
name|lrf_arb_mode
operator|=
literal|0
expr_stmt|;
name|l2c_cfg
operator|.
name|s
operator|.
name|rfb_arb_mode
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|,
name|l2c_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure SMI/MDIO is enabled so we can query PHYs */
name|smix_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smix_en
operator|.
name|s
operator|.
name|en
condition|)
block|{
name|smix_en
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|smix_en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Newer chips actually have two SMI/MDIO interfaces */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|smix_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smix_en
operator|.
name|s
operator|.
name|en
condition|)
block|{
name|smix_en
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|1
argument_list|)
argument_list|,
name|smix_en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_pko_initialize_global
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
name|result
operator||=
name|cvmx_helper_interface_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
operator|>
literal|0
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Interface %d has %d ports (%s)\n"
argument_list|,
name|interface
argument_list|,
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_helper_interface_mode_to_string
argument_list|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_interface_setup_ipd
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_interface_setup_pko
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
name|result
operator||=
name|__cvmx_helper_global_setup_ipd
argument_list|()
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_global_setup_pko
argument_list|()
expr_stmt|;
comment|/* Enable any flow control and backpressure */
name|result
operator||=
name|__cvmx_helper_global_setup_backpressure
argument_list|()
expr_stmt|;
if|#
directive|if
name|CVMX_HELPER_ENABLE_IPD
name|result
operator||=
name|cvmx_helper_ipd_and_packet_input_enable
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Does core local initialization for packet io  *  * @return Zero on success, non-zero on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_initialize_packet_io_local
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_pko_initialize_local
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * Auto configure an IPD/PKO port link state and speed. This  * function basically does the equivalent of:  * cvmx_helper_link_set(ipd_port, cvmx_helper_link_get(ipd_port));  *  * @param ipd_port IPD/PKO port to auto configure  *  * @return Link state after configure  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|cvmx_helper_link_autoconf
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|link_info
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
block|{
name|link_info
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|link_info
return|;
block|}
name|link_info
operator|=
name|cvmx_helper_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|u64
operator|==
name|port_link_info
index|[
name|ipd_port
index|]
operator|.
name|u64
condition|)
return|return
name|link_info
return|;
comment|/* If we fail to set the link speed, port_link_info will not change */
name|cvmx_helper_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
comment|/* port_link_info should be the current value, which will be different         than expect if cvmx_helper_link_set() failed */
return|return
name|port_link_info
index|[
name|ipd_port
index|]
return|;
block|}
end_function

begin_comment
comment|/**  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|cvmx_helper_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
comment|/* The default result will be a down link unless the code below         changes it */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
name|result
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
comment|/* Network links are not supported */
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|result
operator|=
name|__cvmx_helper_rgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
comment|/* Network links are not supported */
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
break|break;
block|}
comment|/* Set the port_link_info here so that the link status is updated        no matter how cvmx_helper_link_set is called. We don't change        the value if link_set failed */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|port_link_info
index|[
name|ipd_port
index|]
operator|.
name|u64
operator|=
name|link_info
operator|.
name|u64
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_helper_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

