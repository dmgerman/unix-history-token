begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Helper functions for common, but complicated tasks.  *  *<hr>$Revision: 52004 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootmem.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriox-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pip-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-asxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-smix-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dbg-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-fpa.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pip.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ipd.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spi.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-errata.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-version.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-check-defines.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-gmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pip.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ipd.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * cvmx_override_pko_queue_priority(int ipd_port, uint64_t  * priorities[16]) is a function pointer. It is meant to allow  * customization of the PKO queue priorities based on the port  * number. Users should set this pointer to a function before  * calling any cvmx-helper operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|void
function_decl|(
modifier|*
name|cvmx_override_pko_queue_priority
function_decl|)
parameter_list|(
name|int
name|pko_port
parameter_list|,
name|uint64_t
name|priorities
index|[
literal|16
index|]
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_override_pko_queue_priority
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_override_ipd_port_setup(int ipd_port) is a function  * pointer. It is meant to allow customization of the IPD port  * setup before packet input/output comes online. It is called  * after cvmx-helper does the default IPD configuration, but  * before IPD is enabled. Users should set this pointer to a  * function before calling any cvmx-helper operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|void
function_decl|(
modifier|*
name|cvmx_override_ipd_port_setup
function_decl|)
parameter_list|(
name|int
name|ipd_port
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* Port count per interface */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|int
name|interface_port_count
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Port last configured link info index by IPD/PKO port */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_helper_link_info_t
name|port_link_info
index|[
name|CVMX_PIP_NUM_INPUT_PORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Return the number of interfaces the chip has. Each interface  * may have multiple ports. Most chips support two interfaces,  * but the CNX0XX and CNX1XX are exceptions. These only support  * one interface.  *  * @return Number of interfaces on chip  */
end_comment

begin_function
name|int
name|cvmx_helper_get_number_of_interfaces
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
return|return
literal|2
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|3
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_number_of_interfaces
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Return the number of ports on an interface. Depending on the  * chip and configuration, this can be 1-16. A value of 0  * specifies that the interface doesn't exist or isn't usable.  *  * @param interface Interface to get the port count for  *  * @return Number of ports on interface. Can be Zero.  */
end_comment

begin_function
name|int
name|cvmx_helper_ports_on_interface
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
return|return
name|interface_port_count
index|[
name|interface
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_ports_on_interface
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the operating mode of an interface. Depending on the Octeon  * chip and configuration, this function returns an enumeration  * of the type of packet I/O supported by an interface.  *  * @param interface Interface to probe  *  * @return Mode of the interface. Unknown or unsupported interfaces return  *         DISABLED.  */
end_comment

begin_function
name|cvmx_helper_interface_mode_t
name|cvmx_helper_interface_get_mode
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
if|if
condition|(
name|interface
operator|==
literal|2
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_NPI
return|;
if|if
condition|(
name|interface
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_LOOP
return|;
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|&&
operator|(
name|interface
operator|==
literal|4
operator|||
name|interface
operator|==
literal|5
operator|)
condition|)
block|{
name|cvmx_sriox_status_reg_t
name|sriox_status_reg
decl_stmt|;
name|sriox_status_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|interface
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sriox_status_reg
operator|.
name|s
operator|.
name|srio
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_SRIO
return|;
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
if|if
condition|(
name|interface
operator|==
literal|0
operator|&&
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
operator|&&
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_rev_major
operator|==
literal|1
condition|)
block|{
comment|/* Lie about interface type of CN3005 board.  This board has a switch on port 1 like         ** the other evaluation boards, but it is connected over RGMII instead of GMII.  Report         ** GMII mode so that the speed is forced to 1 Gbit full duplex.  Other than some initial configuration         ** (which does not use the output of this function) there is no difference in setup between GMII and RGMII modes.         */
return|return
name|CVMX_HELPER_INTERFACE_MODE_GMII
return|;
block|}
comment|/* Interface 1 is always disabled on CN31XX and CN30XX */
if|if
condition|(
operator|(
name|interface
operator|==
literal|1
operator|)
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
operator|.
name|cn56xx
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
case|case
literal|1
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_XAUI
return|;
case|case
literal|2
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_SGMII
return|;
case|case
literal|3
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_PICMG
return|;
default|default:
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
operator|.
name|cn63xx
operator|.
name|mode
condition|)
block|{
case|case
literal|0
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_SGMII
return|;
case|case
literal|1
case|:
return|return
name|CVMX_HELPER_INTERFACE_MODE_XAUI
return|;
default|default:
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|mode
operator|.
name|s
operator|.
name|en
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
return|;
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
return|return
name|CVMX_HELPER_INTERFACE_MODE_SPI
return|;
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_GMII
return|;
block|}
else|else
return|return
name|CVMX_HELPER_INTERFACE_MODE_RGMII
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_interface_get_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Configure the IPD/PIP tagging and QoS options for a specific  * port. This function determines the POW work queue entry  * contents for a port. The setup performed here is controlled by  * the defines in executive-config.h.  *  * @param ipd_port Port to configure. This follows the IPD numbering, not the  *                 per interface numbering  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_port_setup_ipd
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_pip_prt_cfgx_t
name|port_config
decl_stmt|;
name|cvmx_pip_prt_tagx_t
name|tag_config
decl_stmt|;
name|port_config
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_CFGX
argument_list|(
name|ipd_port
argument_list|)
argument_list|)
expr_stmt|;
name|tag_config
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|ipd_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have each port go to a different POW queue */
name|port_config
operator|.
name|s
operator|.
name|qos
operator|=
name|ipd_port
operator|&
literal|0x7
expr_stmt|;
comment|/* Process the headers and place the IP header in the work queue */
name|port_config
operator|.
name|s
operator|.
name|mode
operator|=
name|CVMX_HELPER_INPUT_PORT_SKIP_MODE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_src_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_SRC_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_dst_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_DST_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_sprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_SRC_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_dprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_DST_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_nxth_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV6_NEXT_HEADER
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_src_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_SRC_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_dst_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_DST_IP
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_sprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_SRC_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_dprt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_DST_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_pctl_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_IPV4_PROTOCOL
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|inc_prt_flag
operator|=
name|CVMX_HELPER_INPUT_TAG_INPUT_PORT
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|tcp6_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|tcp4_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip6_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|ip4_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
name|tag_config
operator|.
name|s
operator|.
name|non_tag_type
operator|=
name|CVMX_HELPER_INPUT_TAG_TYPE
expr_stmt|;
comment|/* Put all packets in group 0. Other groups can be used by the app */
name|tag_config
operator|.
name|s
operator|.
name|grp
operator|=
literal|0
expr_stmt|;
name|cvmx_pip_config_port
argument_list|(
name|ipd_port
argument_list|,
name|port_config
argument_list|,
name|tag_config
argument_list|)
expr_stmt|;
comment|/* Give the user a chance to override our setting for each port */
if|if
condition|(
name|cvmx_override_ipd_port_setup
condition|)
name|cvmx_override_ipd_port_setup
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This function probes an interface to determine the actual  * number of hardware ports connected to it. It doesn't setup the  * ports or enable them. The main goal here is to set the global  * interface_port_count[interface] correctly. Hardware setup of the  * ports will be performed later.  *  * @param interface Interface to probe  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_interface_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
comment|/* At this stage in the game we don't want packets to be moving yet.         The following probe calls should perform hardware setup         needed to determine port counts. Receive must still be disabled */
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
comment|/* These types don't support ports to IPD/PKO */
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* XAUI is a single high speed port */
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_xaui_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_rgmii_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SPI4 can have 1-16 ports depending on the device at the other end */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_spi_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SGMII can have 1-4 ports depending on how many are hooked up */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_sgmii_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* PCI target Network Packet Interface */
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_npi_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* Special loopback only ports. These are not the same as other ports             in loopback mode */
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_loop_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SRIO has 2^N ports, where N is number of interfaces */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_srio_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
block|}
name|interface_port_count
index|[
name|interface
index|]
operator|=
name|__cvmx_helper_board_interface_probe
argument_list|(
name|interface
argument_list|,
name|interface_port_count
index|[
name|interface
index|]
argument_list|)
expr_stmt|;
comment|/* Make sure all global variables propagate to other cores */
name|CVMX_SYNCWS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup the IPD/PIP for the ports on an interface. Packet  * classification and tagging are set for every port on the  * interface. The number of ports on the interface must already  * have been probed.  *  * @param interface Interface to setup IPD/PIP for  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_interface_setup_ipd
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|ipd_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_ports
init|=
name|interface_port_count
index|[
name|interface
index|]
decl_stmt|;
while|while
condition|(
name|num_ports
operator|--
condition|)
block|{
name|__cvmx_helper_port_setup_ipd
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
name|ipd_port
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global setting for IPD/PIP not related to a specific  * interface or port. This must be called before IPD is enabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_ipd
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_HELPER_IPD_DRAM_MODE
define|#
directive|define
name|CVMX_HELPER_IPD_DRAM_MODE
value|CVMX_IPD_OPC_MODE_STT
endif|#
directive|endif
comment|/* Setup the global packet input options */
name|cvmx_ipd_config
argument_list|(
name|CVMX_FPA_PACKET_POOL_SIZE
operator|/
literal|8
argument_list|,
name|CVMX_HELPER_FIRST_MBUFF_SKIP
operator|/
literal|8
argument_list|,
name|CVMX_HELPER_NOT_FIRST_MBUFF_SKIP
operator|/
literal|8
argument_list|,
operator|(
name|CVMX_HELPER_FIRST_MBUFF_SKIP
operator|+
literal|8
operator|)
operator|/
literal|128
argument_list|,
comment|/* The +8 is to account for the next ptr */
operator|(
name|CVMX_HELPER_NOT_FIRST_MBUFF_SKIP
operator|+
literal|8
operator|)
operator|/
literal|128
argument_list|,
comment|/* The +8 is to account for the next ptr */
name|CVMX_FPA_WQE_POOL
argument_list|,
name|CVMX_HELPER_IPD_DRAM_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup the PKO for the ports on an interface. The number of  * queues per port and the priority of each PKO output queue  * is set here. PKO must be disabled when this function is called.  *  * @param interface Interface to setup PKO for  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_interface_setup_pko
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
comment|/* Each packet output queue has an associated priority. The higher the         priority, the more often it can send a packet. A priority of 8 means         it can send in all 8 rounds of contention. We're going to make each         queue one less than the last.         The vector of priorities has been extended to support CN5xxx CPUs,         where up to 16 queues can be associated to a port.         To keep backward compatibility we don't change the initial 8         priorities and replicate them in the second half.         With per-core PKO queues (PKO lockless operation) all queues have         the same priority. */
name|uint64_t
name|priorities
index|[
literal|16
index|]
init|=
block|{
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
comment|/* Setup the IPD/PIP and PKO for the ports discovered above. Here packet         classification, tagging and output priorities are set */
name|int
name|ipd_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_ports
init|=
name|interface_port_count
index|[
name|interface
index|]
decl_stmt|;
while|while
condition|(
name|num_ports
operator|--
condition|)
block|{
comment|/* Give the user a chance to override the per queue priorities */
if|if
condition|(
name|cvmx_override_pko_queue_priority
condition|)
name|cvmx_override_pko_queue_priority
argument_list|(
name|ipd_port
argument_list|,
name|priorities
argument_list|)
expr_stmt|;
name|cvmx_pko_config_port
argument_list|(
name|ipd_port
argument_list|,
name|cvmx_pko_get_base_queue_per_core
argument_list|(
name|ipd_port
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cvmx_pko_get_num_queues
argument_list|(
name|ipd_port
argument_list|)
argument_list|,
name|priorities
argument_list|)
expr_stmt|;
name|ipd_port
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global setting for PKO not related to a specific  * interface or port. This must be called before PKO is enabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_pko
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Disable tagwait FAU timeout. This needs to be done before anyone might         start packet output using tags */
name|cvmx_iob_fau_timeout_t
name|fau_to
decl_stmt|;
name|fau_to
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|fau_to
operator|.
name|s
operator|.
name|tout_val
operator|=
literal|0xfff
expr_stmt|;
name|fau_to
operator|.
name|s
operator|.
name|tout_enb
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IOB_FAU_TIMEOUT
argument_list|,
name|fau_to
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup global backpressure setting.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_global_setup_backpressure
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|CVMX_HELPER_DISABLE_RGMII_BACKPRESSURE
comment|/* Disable backpressure if configured to do so */
comment|/* Disable backpressure (pause frame) generation */
name|int
name|num_interfaces
init|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
decl_stmt|;
name|int
name|interface
decl_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|cvmx_gmx_set_backpressure_override
argument_list|(
name|interface
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|//cvmx_dprintf("Disabling backpressure\n");
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Verify the per port IPD backpressure is aligned properly.  * @return Zero if working, non zero if misaligned  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_backpressure_is_misaligned
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|ipd_int_enb
decl_stmt|;
name|cvmx_ipd_ctl_status_t
name|ipd_reg
decl_stmt|;
name|uint64_t
name|bp_status0
decl_stmt|;
name|uint64_t
name|bp_status1
decl_stmt|;
specifier|const
name|int
name|port0
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|port1
init|=
literal|16
decl_stmt|;
name|cvmx_helper_interface_mode_t
name|mode0
init|=
name|cvmx_helper_interface_get_mode
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|cvmx_helper_interface_mode_t
name|mode1
init|=
name|cvmx_helper_interface_get_mode
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* Disable error interrupts while we check backpressure */
name|ipd_int_enb
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_INT_ENB
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_INT_ENB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable per port backpressure */
name|ipd_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|)
expr_stmt|;
name|ipd_reg
operator|.
name|s
operator|.
name|pbp_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|,
name|ipd_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode0
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
condition|)
block|{
comment|/* Enable backpressure for port with a zero threshold */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_PORTX_BP_PAGE_CNT
argument_list|(
name|port0
argument_list|)
argument_list|,
literal|1
operator|<<
literal|17
argument_list|)
expr_stmt|;
comment|/* Add 1000 to the page count to simulate packets coming in */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_BP_PAGE_CNT
argument_list|,
operator|(
name|port0
operator|<<
literal|25
operator|)
operator||
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode1
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
condition|)
block|{
comment|/* Enable backpressure for port with a zero threshold */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_PORTX_BP_PAGE_CNT
argument_list|(
name|port1
argument_list|)
argument_list|,
literal|1
operator|<<
literal|17
argument_list|)
expr_stmt|;
comment|/* Add 1000 to the page count to simulate packets coming in */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_BP_PAGE_CNT
argument_list|,
operator|(
name|port1
operator|<<
literal|25
operator|)
operator||
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* Wait 500 cycles for the BP to update */
name|cvmx_wait
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Read the BP state from the debug select register */
switch|switch
condition|(
name|mode0
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
literal|0x9004
argument_list|)
expr_stmt|;
name|bp_status0
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DBG_DATA
argument_list|)
expr_stmt|;
name|bp_status0
operator|=
literal|0xffff
operator|&
operator|~
name|bp_status0
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
literal|0x0e00
argument_list|)
expr_stmt|;
name|bp_status0
operator|=
literal|0xffff
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_DBG_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
literal|0x0e00
argument_list|)
expr_stmt|;
name|bp_status0
operator|=
literal|0xffff
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bp_status0
operator|=
literal|1
operator|<<
name|port0
expr_stmt|;
break|break;
block|}
comment|/* Read the BP state from the debug select register */
switch|switch
condition|(
name|mode1
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
literal|0x9804
argument_list|)
expr_stmt|;
name|bp_status1
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DBG_DATA
argument_list|)
expr_stmt|;
name|bp_status1
operator|=
literal|0xffff
operator|&
operator|~
name|bp_status1
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
literal|0x1600
argument_list|)
expr_stmt|;
name|bp_status1
operator|=
literal|0xffff
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_DBG_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
literal|0x1600
argument_list|)
expr_stmt|;
name|bp_status1
operator|=
literal|0xffff
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bp_status1
operator|=
literal|1
operator|<<
operator|(
name|port1
operator|-
literal|16
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mode0
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
condition|)
block|{
comment|/* Shutdown BP */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_BP_PAGE_CNT
argument_list|,
operator|(
name|port0
operator|<<
literal|25
operator|)
operator||
operator|(
literal|0x1ffffff
operator|&
operator|-
literal|1000
operator|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_PORTX_BP_PAGE_CNT
argument_list|(
name|port0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode1
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
condition|)
block|{
comment|/* Shutdown BP */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_SUB_PORT_BP_PAGE_CNT
argument_list|,
operator|(
name|port1
operator|<<
literal|25
operator|)
operator||
operator|(
literal|0x1ffffff
operator|&
operator|-
literal|1000
operator|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_PORTX_BP_PAGE_CNT
argument_list|(
name|port1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clear any error interrupts that might have been set */
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_INT_SUM
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_INT_ENB
argument_list|,
name|ipd_int_enb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|bp_status0
operator|!=
literal|1ull
operator|<<
name|port0
operator|)
operator|||
operator|(
name|bp_status1
operator|!=
literal|1ull
operator|<<
operator|(
name|port1
operator|-
literal|16
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Enable packet input/output from the hardware. This function is  * called after all internal setup is complete and IPD is enabled.  * After this function completes, packets will be accepted from the  * hardware ports. PKO should still be disabled to make sure packets  * aren't sent out partially setup hardware.  *  * @param interface Interface to enable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_packet_hardware_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
comment|/* These types don't support ports to IPD/PKO */
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
comment|/* Nothing to do */
break|break;
comment|/* XAUI is a single high speed port */
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SPI4 can have 1-16 ports depending on the device at the other end */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SGMII can have 1-4 ports depending on how many are hooked up */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* PCI target Network Packet Interface */
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
name|result
operator|=
name|__cvmx_helper_npi_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* Special loopback only ports. These are not the same as other ports             in loopback mode */
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
name|result
operator|=
name|__cvmx_helper_loop_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
comment|/* SRIO has 2^N ports, where N is number of interfaces */
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
name|result
operator|=
name|__cvmx_helper_srio_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator||=
name|__cvmx_helper_board_hardware_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Called after all internal packet IO paths are setup. This  * function enables IPD/PIP and begins packet input and output.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_ipd_and_packet_input_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|num_interfaces
decl_stmt|;
name|int
name|interface
decl_stmt|;
comment|/* Enable IPD */
name|cvmx_ipd_enable
argument_list|()
expr_stmt|;
comment|/* Time to enable hardware ports packet input and output. Note that at this         point IPD/PIP must be fully functional and PKO must be disabled */
name|num_interfaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
if|if
condition|(
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//cvmx_dprintf("Enabling packet I/O on interface %d\n", interface);
name|__cvmx_helper_packet_hardware_enable
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally enable PKO now that the entire path is up and running */
name|cvmx_pko_enable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX_PASS1
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX_PASS1
argument_list|)
operator|)
operator|&&
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
operator|)
condition|)
name|__cvmx_helper_errata_fix_ipd_ptr_alignment
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_ipd_and_packet_input_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Initialize the PIP, IPD, and PKO hardware to support  * simple priority based queues for the ethernet ports. Each  * port is configured with a number of priority queues based  * on CVMX_PKO_QUEUES_PER_PORT_* where each queue is lower  * priority than the previous.  *  * @return Zero on success, non-zero on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_initialize_packet_io_global
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|cvmx_smix_en_t
name|smix_en
decl_stmt|;
specifier|const
name|int
name|num_interfaces
init|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
decl_stmt|;
comment|/* CN52XX pass 1: Due to a bug in 2nd order CDR, it needs to be disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_0
argument_list|)
condition|)
name|__cvmx_helper_errata_qlm_disable_2nd_order_cdr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Tell L2 to give the IOB statically higher priority compared to the         cores. This avoids conditions where IO blocks might be starved under         very high L2 loads */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_ctl_t
name|l2c_ctl
decl_stmt|;
name|l2c_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CTL
argument_list|)
expr_stmt|;
name|l2c_ctl
operator|.
name|s
operator|.
name|rsp_arb_mode
operator|=
literal|1
expr_stmt|;
name|l2c_ctl
operator|.
name|s
operator|.
name|xmc_arb_mode
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_CTL
argument_list|,
name|l2c_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
name|l2c_cfg
operator|.
name|s
operator|.
name|lrf_arb_mode
operator|=
literal|0
expr_stmt|;
name|l2c_cfg
operator|.
name|s
operator|.
name|rfb_arb_mode
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|,
name|l2c_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
comment|/* Make sure SMI/MDIO is enabled so we can query PHYs */
name|smix_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smix_en
operator|.
name|s
operator|.
name|en
condition|)
block|{
name|smix_en
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|0
argument_list|)
argument_list|,
name|smix_en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Newer chips actually have two SMI/MDIO interfaces */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|smix_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smix_en
operator|.
name|s
operator|.
name|en
condition|)
block|{
name|smix_en
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_EN
argument_list|(
literal|1
argument_list|)
argument_list|,
name|smix_en
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
name|result
operator||=
name|cvmx_helper_interface_probe
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|cvmx_pko_initialize_global
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
if|if
condition|(
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
operator|>
literal|0
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Interface %d has %d ports (%s)\n"
argument_list|,
name|interface
argument_list|,
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_helper_interface_mode_to_string
argument_list|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_interface_setup_ipd
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_interface_setup_pko
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
name|result
operator||=
name|__cvmx_helper_global_setup_ipd
argument_list|()
expr_stmt|;
name|result
operator||=
name|__cvmx_helper_global_setup_pko
argument_list|()
expr_stmt|;
comment|/* Enable any flow control and backpressure */
name|result
operator||=
name|__cvmx_helper_global_setup_backpressure
argument_list|()
expr_stmt|;
if|#
directive|if
name|CVMX_HELPER_ENABLE_IPD
name|result
operator||=
name|cvmx_helper_ipd_and_packet_input_enable
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_initialize_packet_io_global
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Does core local initialization for packet io  *  * @return Zero on success, non-zero on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_initialize_packet_io_local
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_pko_initialize_local
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * Undo the initialization performed in  * cvmx_helper_initialize_packet_io_global(). After calling this routine and the  * local version on each core, packet IO for Octeon will be disabled and placed  * in the initial reset state. It will then be safe to call the initialize  * later on. Note that this routine does not empty the FPA pools. It frees all  * buffers used by the packet IO hardware to the FPA so a function emptying the  * FPA after shutdown should find all packet buffers in the FPA.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_helper_shutdown_packet_io_global
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|timeout
init|=
literal|5
decl_stmt|;
comment|/* Wait up to 5 seconds for timeouts */
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|num_interfaces
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|int
name|num_ports
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|pool0_count
decl_stmt|;
name|cvmx_wqe_t
modifier|*
name|work
decl_stmt|;
comment|/* Step 1: Disable all backpressure */
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
literal|2
condition|;
name|interface
operator|++
control|)
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
condition|)
name|cvmx_gmx_set_backpressure_override
argument_list|(
name|interface
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|step2
label|:
comment|/* Step 2: Wait for the PKO queues to drain */
name|num_interfaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|num_interfaces
condition|;
name|interface
operator|++
control|)
block|{
name|num_ports
operator|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|int
name|pko_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|int
name|queue
init|=
name|cvmx_pko_get_base_queue
argument_list|(
name|pko_port
argument_list|)
decl_stmt|;
name|int
name|max_queue
init|=
name|queue
operator|+
name|cvmx_pko_get_num_queues
argument_list|(
name|pko_port
argument_list|)
decl_stmt|;
while|while
condition|(
name|queue
operator|<
name|max_queue
condition|)
block|{
name|int
name|count
init|=
name|cvmx_cmd_queue_length
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
name|uint64_t
name|stop_cycle
init|=
name|start_cycle
operator|+
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|*
name|timeout
decl_stmt|;
while|while
condition|(
name|count
operator|&&
operator|(
name|cvmx_get_cycle
argument_list|()
operator|<
name|stop_cycle
operator|)
condition|)
block|{
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|=
name|cvmx_cmd_queue_length
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PKO port %d, queue %d, timeout waiting for idle\n"
argument_list|,
name|pko_port
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|queue
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Step 3: Disable TX and RX on all ports */
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
literal|2
condition|;
name|interface
operator|++
control|)
block|{
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
comment|/* Not a packet interface */
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
comment|/* We don't handle the NPI/NPEI/SRIO packet engines. The caller                     must know these are idle */
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
comment|/* Nothing needed. Once PKO is idle, the loopback devices                     must be idle */
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
comment|/* SPI cannot be disabled from Octeon. It is the responsibility                     of the caller to make sure SPI is idle before doing                     shutdown */
comment|/* Fall through and do the same processing as RGMII/GMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
comment|/* Disable outermost RX at the ASX block */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|>
literal|4
condition|)
name|num_ports
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Poll the GMX state machine waiting for it to become idle */
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
name|interface
operator|*
literal|0x800
operator|+
name|index
operator|*
literal|0x100
operator|+
literal|0x880
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_DBG_DATA
argument_list|,
name|cvmx_dbg_data_t
argument_list|,
name|data
operator|&
literal|7
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|timeout
operator|*
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"GMX RX path timeout waiting for idle\n"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_DBG_DATA
argument_list|,
name|cvmx_dbg_data_t
argument_list|,
name|data
operator|&
literal|0xf
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|timeout
operator|*
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"GMX TX path timeout waiting for idle\n"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Disable outermost TX at the ASX block */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable interrupts for interface */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|num_ports
operator|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|>
literal|4
condition|)
name|num_ports
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|rx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
name|timeout
operator|*
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"GMX RX path timeout waiting for idle\n"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|tx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
name|timeout
operator|*
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"GMX TX path timeout waiting for idle\n"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* Step 4: Retrieve all packets from the POW and free them */
while|while
condition|(
operator|(
name|work
operator|=
name|cvmx_pow_work_request_sync
argument_list|(
name|CVMX_POW_WAIT
argument_list|)
operator|)
condition|)
block|{
name|cvmx_helper_free_packet_data
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|cvmx_fpa_free
argument_list|(
name|work
argument_list|,
name|CVMX_FPA_WQE_POOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Step 4b: Special workaround for pass 2 errata */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX_PASS2
argument_list|)
condition|)
block|{
name|cvmx_ipd_ptr_count_t
name|ipd_cnt
decl_stmt|;
name|int
name|to_add
decl_stmt|;
name|ipd_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_PTR_COUNT
argument_list|)
expr_stmt|;
name|to_add
operator|=
operator|(
name|ipd_cnt
operator|.
name|s
operator|.
name|wqev_cnt
operator|+
name|ipd_cnt
operator|.
name|s
operator|.
name|wqe_pcnt
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|to_add
condition|)
block|{
name|int
name|port
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Aligning CN38XX pass 2 IPD counters\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
literal|0
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RGMII
condition|)
name|port
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
literal|1
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RGMII
condition|)
name|port
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|port
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_PACKET_POOL
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|int
name|queue
init|=
name|cvmx_pko_get_base_queue
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|cvmx_pko_command_word0_t
name|pko_command
decl_stmt|;
name|cvmx_buf_ptr_t
name|packet
decl_stmt|;
name|uint64_t
name|start_cycle
decl_stmt|;
name|uint64_t
name|stop_cycle
decl_stmt|;
comment|/* Populate a minimal packet */
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0xff
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer
operator|+
literal|6
argument_list|,
literal|0
argument_list|,
literal|54
argument_list|)
expr_stmt|;
name|pko_command
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|dontfree
operator|=
literal|1
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|total_bytes
operator|=
literal|60
expr_stmt|;
name|pko_command
operator|.
name|s
operator|.
name|segs
operator|=
literal|1
expr_stmt|;
name|packet
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|packet
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|packet
operator|.
name|s
operator|.
name|size
operator|=
name|CVMX_FPA_PACKET_POOL_SIZE
expr_stmt|;
name|__cvmx_helper_rgmii_configure_loopback
argument_list|(
name|port
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|to_add
operator|--
condition|)
block|{
name|cvmx_pko_send_packet_prepare
argument_list|(
name|port
argument_list|,
name|queue
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_pko_send_packet_finish
argument_list|(
name|port
argument_list|,
name|queue
argument_list|,
name|pko_command
argument_list|,
name|packet
argument_list|,
name|CVMX_PKO_LOCK_CMD_QUEUE
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unable to align IPD counters (PKO failed)\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cvmx_fpa_free
argument_list|(
name|buffer
argument_list|,
name|CVMX_FPA_PACKET_POOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the packets to loop back */
name|start_cycle
operator|=
name|cvmx_get_cycle
argument_list|()
expr_stmt|;
name|stop_cycle
operator|=
name|start_cycle
operator|+
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|*
name|timeout
expr_stmt|;
while|while
condition|(
name|cvmx_cmd_queue_length
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|)
operator|&&
operator|(
name|cvmx_get_cycle
argument_list|()
operator|<
name|stop_cycle
operator|)
condition|)
block|{
name|cvmx_wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|cvmx_wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|__cvmx_helper_rgmii_configure_loopback
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_add
operator|==
operator|-
literal|1
condition|)
goto|goto
name|step2
goto|;
block|}
else|else
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unable to align IPD counters (Packet pool empty)\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unable to align IPD counters\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Step 5: Disable IPD and PKO. PIP is taken care of in the next step */
name|cvmx_ipd_disable
argument_list|()
expr_stmt|;
name|cvmx_pko_disable
argument_list|()
expr_stmt|;
comment|/* Step 6: Drain all prefetched buffers from IPD/PIP. Note that IPD/PIP         have not been reset yet */
name|__cvmx_ipd_free_ptr
argument_list|()
expr_stmt|;
comment|/* Step 7: Free the PKO command buffers and put PKO in reset */
name|cvmx_pko_shutdown
argument_list|()
expr_stmt|;
comment|/* Step 8: Disable MAC address filtering */
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
literal|2
condition|;
name|interface
operator|++
control|)
block|{
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|num_ports
operator|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|>
literal|4
condition|)
name|num_ports
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CTL
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM_EN
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM0
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM1
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM2
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM3
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM4
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_ADR_CAM5
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Step 9: Drain all FPA buffers out of pool 0 before we reset IPD/PIP.         This is needed to keep IPD_QUE0_FREE_PAGE_CNT in sync. We use pool 1         for temporary storage */
name|pool0_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|void
modifier|*
name|buffer
init|=
name|cvmx_fpa_alloc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|cvmx_fpa_free
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pool0_count
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Step 10: Reset IPD and PIP */
block|{
name|cvmx_ipd_ctl_status_t
name|ipd_ctl_status
decl_stmt|;
name|ipd_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|)
expr_stmt|;
name|ipd_ctl_status
operator|.
name|s
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|,
name|ipd_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
operator|)
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
block|{
comment|/* only try 1000 times.  Normally if this works it will happen in             ** the first 50 loops. */
name|int
name|max_loops
init|=
literal|1000
decl_stmt|;
name|int
name|loop
init|=
literal|0
decl_stmt|;
comment|/* Per port backpressure counters can get misaligned after an                IPD reset. This code realigns them by performing repeated                resets. See IPD-13473 */
name|cvmx_wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_helper_backpressure_is_misaligned
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Starting to align per port backpressure counters.\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|__cvmx_helper_backpressure_is_misaligned
argument_list|()
operator|&&
operator|(
name|loop
operator|++
operator|<
name|max_loops
operator|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|,
name|ipd_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|123
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|<
name|max_loops
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Completed aligning per port backpressure counters (%d loops).\n"
argument_list|,
name|loop
argument_list|)
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: unable to align per port backpressure counters.\n"
argument_list|)
expr_stmt|;
comment|/* For now, don't hang.... */
block|}
block|}
block|}
comment|/* PIP_SFT_RST not present in CN38XXp{1,2} */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX_PASS2
argument_list|)
condition|)
block|{
name|cvmx_pip_sft_rst_t
name|pip_sft_rst
decl_stmt|;
name|pip_sft_rst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_SFT_RST
argument_list|)
expr_stmt|;
name|pip_sft_rst
operator|.
name|s
operator|.
name|rst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_SFT_RST
argument_list|,
name|pip_sft_rst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Step 11: Restore the FPA buffers into pool 0 */
while|while
condition|(
name|pool0_count
operator|--
condition|)
name|cvmx_fpa_free
argument_list|(
name|cvmx_fpa_alloc
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_shutdown_packet_io_global
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Does core local shutdown of packet io  *  * @return Zero on success, non-zero on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_shutdown_packet_io_local
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Currently there is nothing to do per core. This may change in         the future */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Auto configure an IPD/PKO port link state and speed. This  * function basically does the equivalent of:  * cvmx_helper_link_set(ipd_port, cvmx_helper_link_get(ipd_port));  *  * @param ipd_port IPD/PKO port to auto configure  *  * @return Link state after configure  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|cvmx_helper_link_autoconf
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|link_info
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
block|{
name|link_info
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|link_info
return|;
block|}
name|link_info
operator|=
name|cvmx_helper_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|u64
operator|==
name|port_link_info
index|[
name|ipd_port
index|]
operator|.
name|u64
condition|)
return|return
name|link_info
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
name|cvmx_error_disable_group
argument_list|(
name|CVMX_ERROR_GROUP_ETHERNET
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we fail to set the link speed, port_link_info will not change */
name|cvmx_helper_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_ETHERNET
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* port_link_info should be the current value, which will be different         than expect if cvmx_helper_link_set() failed */
return|return
name|port_link_info
index|[
name|ipd_port
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_link_autoconf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|cvmx_helper_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
comment|/* The default result will be a down link unless the code below         changes it */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
name|result
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
comment|/* Network links are not supported */
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|result
operator|=
name|__cvmx_helper_rgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
name|result
operator|=
name|__cvmx_helper_srio_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
comment|/* Network links are not supported */
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_link_get
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
comment|/* RGMII/GMII/MII are all treated about the same. Most functions             refer to these ports as RGMII */
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
name|result
operator|=
name|__cvmx_helper_spi_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
name|result
operator|=
name|__cvmx_helper_srio_link_set
argument_list|(
name|ipd_port
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
break|break;
block|}
comment|/* Set the port_link_info here so that the link status is updated        no matter how cvmx_helper_link_set is called. We don't change        the value if link_set failed */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|port_link_info
index|[
name|ipd_port
index|]
operator|.
name|u64
operator|=
name|link_info
operator|.
name|u64
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_link_set
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_helper_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
name|result
operator|=
name|__cvmx_helper_xaui_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
name|result
operator|=
name|__cvmx_helper_rgmii_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
name|result
operator|=
name|__cvmx_helper_sgmii_configure_loopback
argument_list|(
name|ipd_port
argument_list|,
name|enable_internal
argument_list|,
name|enable_external
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

