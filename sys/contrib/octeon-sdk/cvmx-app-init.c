begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|<octeon-app-init.h>
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-uart.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-core.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ebt3000.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sim-magic.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-debug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-qlm.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-scratch.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-cfg.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-jtag.h"
end_include

begin_include
include|#
directive|include
file|<octeon_mem_map.h>
end_include

begin_include
include|#
directive|include
file|"libfdt.h"
end_include

begin_decl_stmt
name|int
name|cvmx_debug_uart
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @file  *  * Main entry point for all simple executive based programs.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|cvmx_interrupt_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Main entry point for all simple executive based programs.  * This is the first C function called. It completes  * initialization, calls main, and performs C level cleanup.  *  * @param app_desc_addr  *               Address of the application description structure passed  *               brom the boot loader.  */
end_comment

begin_function_decl
name|EXTERN_ASM
name|void
name|__cvmx_app_init
parameter_list|(
name|uint64_t
name|app_desc_addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Set up sysinfo structure from boot descriptor versions 6 and higher.  * In these versions, the interesting data in not in the boot info structure  * defined by the toolchain, but is in the cvmx_bootinfo structure defined in  * the simple exec.  *  * @param app_desc_ptr  *               pointer to boot descriptor block  *  * @param sys_info_ptr  *               pointer to sysinfo structure to fill in  */
end_comment

begin_function
specifier|static
name|void
name|process_boot_desc_ver_6
parameter_list|(
name|octeon_boot_descriptor_t
modifier|*
name|app_desc_ptr
parameter_list|,
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
parameter_list|)
block|{
name|cvmx_bootinfo_t
modifier|*
name|cvmx_bootinfo_ptr
init|=
name|CASTPTR
argument_list|(
name|cvmx_bootinfo_t
argument_list|,
name|app_desc_ptr
operator|->
name|cvmx_desc_vaddr
argument_list|)
decl_stmt|;
comment|/* copy application information for simple exec use */
comment|/* Populate the sys_info structure from the boot descriptor block created by the bootloader.     ** The boot descriptor block is put in the top of the heap, so it will be overwritten when the     ** heap is fully used.  Information that is to be used must be copied before that.     ** Applications should only use the sys_info structure, not the boot descriptor     */
if|if
condition|(
name|cvmx_bootinfo_ptr
operator|->
name|major_version
operator|==
literal|1
condition|)
block|{
name|sys_info_ptr
operator|->
name|core_mask
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|core_mask
expr_stmt|;
name|sys_info_ptr
operator|->
name|heap_base
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|heap_base
expr_stmt|;
name|sys_info_ptr
operator|->
name|heap_size
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|heap_end
operator|-
name|cvmx_bootinfo_ptr
operator|->
name|heap_base
expr_stmt|;
name|sys_info_ptr
operator|->
name|stack_top
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|stack_top
expr_stmt|;
name|sys_info_ptr
operator|->
name|stack_size
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|stack_size
expr_stmt|;
name|sys_info_ptr
operator|->
name|init_core
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|sys_info_ptr
operator|->
name|phy_mem_desc_addr
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|phy_mem_desc_addr
expr_stmt|;
name|sys_info_ptr
operator|->
name|exception_base_addr
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|exception_base_addr
expr_stmt|;
name|sys_info_ptr
operator|->
name|cpu_clock_hz
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|eclock_hz
expr_stmt|;
name|sys_info_ptr
operator|->
name|dram_data_rate_hz
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|dclock_hz
operator|*
literal|2
expr_stmt|;
name|sys_info_ptr
operator|->
name|board_type
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|board_type
expr_stmt|;
name|sys_info_ptr
operator|->
name|board_rev_major
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|board_rev_major
expr_stmt|;
name|sys_info_ptr
operator|->
name|board_rev_minor
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|board_rev_minor
expr_stmt|;
name|memcpy
argument_list|(
name|sys_info_ptr
operator|->
name|mac_addr_base
argument_list|,
name|cvmx_bootinfo_ptr
operator|->
name|mac_addr_base
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|sys_info_ptr
operator|->
name|mac_addr_count
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|mac_addr_count
expr_stmt|;
name|memcpy
argument_list|(
name|sys_info_ptr
operator|->
name|board_serial_number
argument_list|,
name|cvmx_bootinfo_ptr
operator|->
name|board_serial_number
argument_list|,
name|CVMX_BOOTINFO_OCTEON_SERIAL_LEN
argument_list|)
expr_stmt|;
name|sys_info_ptr
operator|->
name|console_uart_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvmx_bootinfo_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_CONSOLE_UART1
condition|)
name|sys_info_ptr
operator|->
name|console_uart_num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cvmx_bootinfo_ptr
operator|->
name|dram_size
operator|>
literal|32
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|sys_info_ptr
operator|->
name|system_dram_size
operator|=
operator|(
name|uint64_t
operator|)
name|cvmx_bootinfo_ptr
operator|->
name|dram_size
expr_stmt|;
comment|/* older bootloaders incorrectly gave this in bytes, so don't convert */
else|else
name|sys_info_ptr
operator|->
name|system_dram_size
operator|=
operator|(
name|uint64_t
operator|)
name|cvmx_bootinfo_ptr
operator|->
name|dram_size
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
comment|/* convert from Megabytes to bytes */
if|if
condition|(
name|cvmx_bootinfo_ptr
operator|->
name|minor_version
operator|>=
literal|1
condition|)
block|{
name|sys_info_ptr
operator|->
name|compact_flash_common_base_addr
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|compact_flash_common_base_addr
expr_stmt|;
name|sys_info_ptr
operator|->
name|compact_flash_attribute_base_addr
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|compact_flash_attribute_base_addr
expr_stmt|;
name|sys_info_ptr
operator|->
name|led_display_base_addr
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|led_display_base_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sys_info_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBT3000
operator|||
name|sys_info_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBT5800
operator|||
name|sys_info_ptr
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBT5810
condition|)
block|{
comment|/* Default these variables so that users of structure can be the same no             ** matter what version fo boot info block the bootloader passes */
name|sys_info_ptr
operator|->
name|compact_flash_common_base_addr
operator|=
literal|0x1d000000
operator|+
literal|0x800
expr_stmt|;
name|sys_info_ptr
operator|->
name|compact_flash_attribute_base_addr
operator|=
literal|0x1d010000
expr_stmt|;
if|if
condition|(
name|sys_info_ptr
operator|->
name|board_rev_major
operator|==
literal|1
condition|)
name|sys_info_ptr
operator|->
name|led_display_base_addr
operator|=
literal|0x1d020000
expr_stmt|;
else|else
name|sys_info_ptr
operator|->
name|led_display_base_addr
operator|=
literal|0x1d020000
operator|+
literal|0xf8
expr_stmt|;
block|}
else|else
block|{
name|sys_info_ptr
operator|->
name|compact_flash_common_base_addr
operator|=
literal|0
expr_stmt|;
name|sys_info_ptr
operator|->
name|compact_flash_attribute_base_addr
operator|=
literal|0
expr_stmt|;
name|sys_info_ptr
operator|->
name|led_display_base_addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_bootinfo_ptr
operator|->
name|minor_version
operator|>=
literal|2
condition|)
block|{
name|sys_info_ptr
operator|->
name|dfa_ref_clock_hz
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|dfa_ref_clock_hz
expr_stmt|;
name|sys_info_ptr
operator|->
name|bootloader_config_flags
operator|=
name|cvmx_bootinfo_ptr
operator|->
name|config_flags
expr_stmt|;
block|}
else|else
block|{
name|sys_info_ptr
operator|->
name|dfa_ref_clock_hz
operator|=
literal|0
expr_stmt|;
name|sys_info_ptr
operator|->
name|bootloader_config_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_DEBUG
condition|)
name|sys_info_ptr
operator|->
name|bootloader_config_flags
operator||=
name|CVMX_BOOTINFO_CFG_FLAG_DEBUG
expr_stmt|;
if|if
condition|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_NO_MAGIC
condition|)
name|sys_info_ptr
operator|->
name|bootloader_config_flags
operator||=
name|CVMX_BOOTINFO_CFG_FLAG_NO_MAGIC
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ERROR: Incompatible CVMX descriptor passed by bootloader: %d.%d\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootinfo_ptr
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootinfo_ptr
operator|->
name|minor_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cvmx_bootinfo_ptr
operator|->
name|minor_version
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|cvmx_bootinfo_ptr
operator|->
name|fdt_addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|sys_info_ptr
operator|->
name|fdt_addr
operator|=
name|UNMAPPED_PTR
argument_list|(
name|cvmx_bootinfo_ptr
operator|->
name|fdt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdt_check_header
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|sys_info_ptr
operator|->
name|fdt_addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR : Corrupt Device Tree.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Using device tree\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sys_info_ptr
operator|->
name|fdt_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Interrupt handler for calling exit on Control-C interrupts.  *  * @param irq_number IRQ interrupt number  * @param registers  CPU registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|process_break_interrupt
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
comment|/* Exclude new functionality when building with older toolchains */
if|#
directive|if
name|OCTEON_APP_INIT_H_VERSION
operator|>=
literal|3
name|int
name|uart
init|=
name|irq_number
operator|-
name|CVMX_IRQ_UART0
decl_stmt|;
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
comment|/* Check for a Control-C interrupt from the console. This loop will eat         all input received on the uart */
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|uart
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|lsrval
operator|.
name|s
operator|.
name|dr
condition|)
block|{
name|int
name|c
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_RBR
argument_list|(
name|uart
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\003'
condition|)
block|{
specifier|register
name|uint64_t
name|tmp
decl_stmt|;
comment|/* Wait for an another Control-C if right now we have no                access to the console.  After this point we hold the                lock and use a different lock to synchronize between                the memfile dumps from different cores.  As a                consequence regular printfs *don't* work after this                point! */
if|if
condition|(
name|__octeon_uart_trylock
argument_list|()
operator|==
literal|1
condition|)
return|return;
comment|/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also                set the MCD0 to be not masked by this core so we know                the signal is received by someone */
asm|asm
specifier|volatile
asm|(                 "dmfc0 %0, $22\n"                 "ori   %0, %0, 0x1110\n"                 "dmtc0 %0, $22\n"                 : "=r" (tmp));
block|}
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|uart
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * This is the debug exception handler with "break".  Before calling exit to  * dump the profile-feedback output it releases the lock on the console.  * This way if there is buffered data in stdout it can still be flushed.  * stdio is required to flush all output during an fread.  */
end_comment

begin_function
specifier|static
name|void
name|exit_on_break
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|OCTEON_APP_INIT_H_VERSION
operator|>=
literal|4
name|unsigned
name|int
name|coremask
init|=
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
decl_stmt|;
name|cvmx_coremask_barrier_sync
argument_list|(
name|coremask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|coremask
argument_list|)
condition|)
name|__octeon_uart_unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add string signature to applications so that we can easily tell what ** Octeon revision they were compiled for. Don't make static to avoid unused ** variable warning. */
end_comment

begin_define
define|#
directive|define
name|xstr
parameter_list|(
name|s
parameter_list|)
value|str(s)
end_define

begin_define
define|#
directive|define
name|str
parameter_list|(
name|s
parameter_list|)
value|#s
end_define

begin_function_decl
name|int
name|octeon_model_version_check
parameter_list|(
name|uint32_t
name|chip_id
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OMS
value|xstr(OCTEON_MODEL)
end_define

begin_decl_stmt
name|char
name|octeon_rev_signature
index|[]
init|=
ifdef|#
directive|ifdef
name|USE_RUNTIME_MODEL_CHECKS
literal|"Compiled for runtime Octeon model checking"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|"Compiled for Octeon processor id: "
name|OMS
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OCTEON_BL_FLAG_HPLUG_CORES
value|(1<< 6)
end_define

begin_function
name|void
name|__cvmx_app_init
parameter_list|(
name|uint64_t
name|app_desc_addr
parameter_list|)
block|{
comment|/* App descriptor used by bootloader */
name|octeon_boot_descriptor_t
modifier|*
name|app_desc_ptr
init|=
name|CASTPTR
argument_list|(
name|octeon_boot_descriptor_t
argument_list|,
name|app_desc_addr
argument_list|)
decl_stmt|;
comment|/* app info structure used by the simple exec */
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|int
name|breakflag
init|=
literal|0
decl_stmt|;
comment|//printf("coremask=%08x flags=%08x \n", app_desc_ptr->core_mask, app_desc_ptr->flags);
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|app_desc_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
comment|/* Intialize the bootmem allocator with the descriptor that was provided by         * the bootloader         * IMPORTANT:  All printfs must happen after this since PCI console uses named         * blocks.         */
name|cvmx_bootmem_init
argument_list|(
name|CASTPTR
argument_list|(
name|cvmx_bootinfo_t
argument_list|,
name|app_desc_ptr
operator|->
name|cvmx_desc_vaddr
argument_list|)
operator|->
name|phy_mem_desc_addr
argument_list|)
expr_stmt|;
comment|/* do once per application setup  */
if|if
condition|(
name|app_desc_ptr
operator|->
name|desc_version
operator|<
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"Obsolete bootloader, can't run application\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle all newer versions here.... */
if|if
condition|(
name|app_desc_ptr
operator|->
name|desc_version
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: newer boot descripter version than expected\n"
argument_list|)
expr_stmt|;
block|}
name|process_boot_desc_ver_6
argument_list|(
name|app_desc_ptr
argument_list|,
name|sys_info_ptr
argument_list|)
expr_stmt|;
block|}
comment|/*          * set up the feature map and config.          */
name|octeon_feature_init
argument_list|()
expr_stmt|;
name|__cvmx_helper_cfg_init
argument_list|()
expr_stmt|;
block|}
comment|/* The flags varibale get copied over at some places and tracing the origins        found that        ** In octeon_setup_boot_desc_block          . cvmx_bootinfo_array[core].flags is initialized and the various bits are set          . cvmx_bootinfo_array[core].flags gets copied to  boot_desc[core].flags          . Then boot_desc then get copied over to the end of the application heap and             boot_info_block_array[core].boot_descr_addr is set to point to the boot_desc             in heap.        ** In start_app boot_vect->boot_info_addr->boot_desc_addr is referenced and passed on        to octeon_setup_crt0_tlb() and this puts it into r16        ** In ctr0.S of the toolchain r16 is picked up and passed on as a parameter to        __cvmx_app_init         Note : boot_vect->boot_info_addr points to  boot_info_block_array[core] and this        pointer is setup in octeon_setup_boot_vector()     */
if|if
condition|(
operator|!
operator|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_HPLUG_CORES
operator|)
condition|)
name|cvmx_coremask_barrier_sync
argument_list|(
name|app_desc_ptr
operator|->
name|core_mask
argument_list|)
expr_stmt|;
name|breakflag
operator|=
name|sys_info_ptr
operator|->
name|bootloader_config_flags
operator|&
name|CVMX_BOOTINFO_CFG_FLAG_BREAK
expr_stmt|;
comment|/* No need to initialize bootmem, interrupts, interrupt handler and error handler        if version does not match. */
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
comment|/* Check to make sure the Chip version matches the configured version */
name|uint32_t
name|chip_id
init|=
name|cvmx_get_proc_id
argument_list|()
decl_stmt|;
comment|/* Make sure we can properly run on this chip */
name|octeon_model_version_check
argument_list|(
name|chip_id
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
name|int
name|break_uart
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|breakflag
operator|&&
name|cvmx_debug_booted
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Using debug and break together in not supported.\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
comment|/* Search through the arguments for a break=X or a debug=X. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|app_desc_ptr
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argv
init|=
name|CASTPTR
argument_list|(
specifier|const
name|char
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|app_desc_ptr
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|argv
argument_list|,
literal|"break="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|break_uart
operator|=
name|atoi
argument_list|(
name|argv
operator|+
literal|6
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
argument_list|,
literal|"debug="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|cvmx_debug_uart
operator|=
name|atoi
argument_list|(
name|argv
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|breakflag
condition|)
block|{
name|int32_t
modifier|*
name|trampoline
init|=
name|CASTPTR
argument_list|(
name|int32_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|BOOTLOADER_DEBUG_TRAMPOLINE
argument_list|)
argument_list|)
decl_stmt|;
comment|/* On debug exception, call exit_on_break from all cores. */
operator|*
name|trampoline
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|long
argument_list|)
operator|&
name|exit_on_break
expr_stmt|;
name|cvmx_uart_enable_intr
argument_list|(
name|break_uart
argument_list|,
name|process_break_interrupt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_HPLUG_CORES
operator|)
condition|)
name|cvmx_coremask_barrier_sync
argument_list|(
name|app_desc_ptr
operator|->
name|core_mask
argument_list|)
expr_stmt|;
comment|/* Clear BEV now that we have installed exception handlers. */
name|uint64_t
name|tmp
decl_stmt|;
asm|asm
specifier|volatile
asm|(                "   .set push                  \n"                "   .set mips64                  \n"                "   .set noreorder               \n"                "   .set noat               \n"                "   mfc0 %[tmp], $12, 0          \n"                "   li   $at, 1<< 22            \n"                "   not  $at, $at                \n"                "   and  %[tmp], $at             \n"                "   mtc0 %[tmp], $12, 0          \n"                "   .set pop                  \n"                   : [tmp] "=&r" (tmp) : );
comment|/* Set all cores to stop on MCD0 signals */
asm|asm
specifier|volatile
asm|(         "dmfc0 %0, $22, 0\n"         "or %0, %0, 0x1100\n"         "dmtc0 %0, $22, 0\n" : "=r" (tmp));
name|CVMX_SYNC
expr_stmt|;
comment|/* Now intialize the debug exception handler as BEV is cleared. */
if|if
condition|(
operator|(
operator|!
name|breakflag
operator|)
operator|&&
operator|(
operator|!
operator|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_HPLUG_CORES
operator|)
operator|)
condition|)
name|cvmx_debug_init
argument_list|()
expr_stmt|;
comment|/* Synchronise all cores at this point */
if|if
condition|(
operator|!
operator|(
name|app_desc_ptr
operator|->
name|flags
operator|&
name|OCTEON_BL_FLAG_HPLUG_CORES
operator|)
condition|)
name|cvmx_coremask_barrier_sync
argument_list|(
name|app_desc_ptr
operator|->
name|core_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cvmx_user_app_init
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|bist_val
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|bist_errors
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tmp
decl_stmt|;
name|uint64_t
name|base_addr
decl_stmt|;
comment|/* Put message on LED display */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
condition|)
name|ebt3000_str_write
argument_list|(
literal|"CVMX    "
argument_list|)
expr_stmt|;
comment|/* Check BIST results for COP0 registers, some values only meaningful in pass 2 */
name|CVMX_MF_CACHE_ERR
argument_list|(
name|bist_val
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x3fULL
operator|<<
literal|32
operator|)
expr_stmt|;
comment|// Icache;BHT;AES;HSH/GFM;LRU;register file
name|bist_val
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|bist_val
condition|)
block|{
name|printf
argument_list|(
literal|"BIST FAILURE: COP0_CACHE_ERR: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|bist_val
argument_list|)
expr_stmt|;
name|bist_errors
operator|++
expr_stmt|;
block|}
name|mask
operator|=
literal|0xfc00000000000000ull
expr_stmt|;
name|CVMX_MF_CVM_MEM_CTL
argument_list|(
name|bist_val
argument_list|)
expr_stmt|;
name|bist_val
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|bist_val
condition|)
block|{
name|printf
argument_list|(
literal|"BIST FAILURE: COP0_CVM_MEM_CTL: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|bist_val
argument_list|)
expr_stmt|;
name|bist_errors
operator|++
expr_stmt|;
block|}
comment|/* Set up 4 cache lines of local memory, make available from Kernel space */
name|CVMX_MF_CVM_MEM_CTL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x1ffull
expr_stmt|;
name|tmp
operator||=
literal|0x104ull
expr_stmt|;
comment|/* Set WBTHRESH=4 as per Core-14752 errata in cn63xxp1.X. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|tmp
operator|&=
operator|~
operator|(
literal|0xfull
operator|<<
literal|11
operator|)
expr_stmt|;
name|tmp
operator||=
literal|4
operator|<<
literal|11
expr_stmt|;
block|}
name|CVMX_MT_CVM_MEM_CTL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_X
argument_list|)
condition|)
block|{
comment|/* Clear the lines of scratch memory configured, for         ** 63XX pass 2 errata Core-15169. */
name|uint64_t
name|addr
decl_stmt|;
name|unsigned
name|num_lines
decl_stmt|;
name|CVMX_MF_CVM_MEM_CTL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|num_lines
operator|=
name|tmp
operator|&
literal|0x3f
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|CVMX_CACHE_LINE_SIZE
operator|*
name|num_lines
condition|;
name|addr
operator|+=
literal|8
control|)
name|cvmx_scratch_write64
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
comment|/* Check to see if the bootloader is indicating that the application is outside     ** of the 0x10000000 0x20000000 range, in which case we can't use 1-1 mappings */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|bootloader_config_flags
operator|&
name|CVMX_BOOTINFO_CFG_FLAG_OVERSIZE_TLB_MAPPING
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: 1-1 TLB mappings configured and oversize application loaded.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ERROR: Either 1-1 TLB mappings must be disabled or application size reduced.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create 1-1 Mappings for all DRAM up to 8 gigs, excluding the low 1 Megabyte.  This area     ** is reserved for the bootloader and exception vectors.  By not mapping this area, NULL pointer     ** dereferences will be caught with TLB exceptions.  Exception handlers should be written     ** using XKPHYS or KSEG0 addresses. */
if|#
directive|if
name|CVMX_NULL_POINTER_PROTECT
comment|/* Exclude low 1 MByte from mapping to detect NULL pointer accesses.     ** The only down side of this is it uses more TLB mappings */
name|cvmx_core_add_fixed_tlb_mapping_bits
argument_list|(
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0x100000
operator||
name|TLB_DIRTY
operator||
name|TLB_VALID
operator||
name|TLB_GLOBAL
argument_list|,
name|CVMX_TLB_PAGEMASK_1M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x200000
argument_list|,
literal|0x200000
argument_list|,
literal|0x300000
argument_list|,
name|CVMX_TLB_PAGEMASK_1M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x400000
argument_list|,
literal|0x400000
argument_list|,
literal|0x500000
argument_list|,
name|CVMX_TLB_PAGEMASK_1M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x600000
argument_list|,
literal|0x600000
argument_list|,
literal|0x700000
argument_list|,
name|CVMX_TLB_PAGEMASK_1M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x800000
argument_list|,
literal|0x800000
argument_list|,
literal|0xC00000
argument_list|,
name|CVMX_TLB_PAGEMASK_4M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x1000000
argument_list|,
literal|0x1000000
argument_list|,
literal|0x1400000
argument_list|,
name|CVMX_TLB_PAGEMASK_4M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x1800000
argument_list|,
literal|0x1800000
argument_list|,
literal|0x1c00000
argument_list|,
name|CVMX_TLB_PAGEMASK_4M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x2000000
argument_list|,
literal|0x2000000
argument_list|,
literal|0x3000000
argument_list|,
name|CVMX_TLB_PAGEMASK_16M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x4000000
argument_list|,
literal|0x4000000
argument_list|,
literal|0x5000000
argument_list|,
name|CVMX_TLB_PAGEMASK_16M
argument_list|)
expr_stmt|;
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x6000000
argument_list|,
literal|0x6000000
argument_list|,
literal|0x7000000
argument_list|,
name|CVMX_TLB_PAGEMASK_16M
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Map entire low 128 Megs, including 0x0 */
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x0
argument_list|,
literal|0x0
argument_list|,
literal|0x4000000ULL
argument_list|,
name|CVMX_TLB_PAGEMASK_64M
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
literal|0x8000000ULL
argument_list|,
literal|0x8000000ULL
argument_list|,
literal|0xc000000ULL
argument_list|,
name|CVMX_TLB_PAGEMASK_64M
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
for|for
control|(
name|base_addr
operator|=
literal|0x20000000ULL
init|;
name|base_addr
operator|<
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|system_dram_size
operator|+
literal|0x10000000ULL
operator|)
condition|;
name|base_addr
operator|+=
literal|0x20000000ULL
control|)
block|{
if|if
condition|(
literal|0
operator|>
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
name|base_addr
argument_list|,
name|base_addr
argument_list|,
name|base_addr
operator|+
literal|0x10000000ULL
argument_list|,
name|CVMX_TLB_PAGEMASK_256M
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR adding 1-1 TLB mapping for address 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|base_addr
argument_list|)
expr_stmt|;
comment|/* Exit from here, as expected memory mappings aren't set                    up if this fails */
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Create 1-1 mapping for next 256 megs         ** bottom page is not valid */
name|cvmx_core_add_fixed_tlb_mapping_bits
argument_list|(
literal|0x400000000ULL
argument_list|,
literal|0
argument_list|,
literal|0x410000000ULL
operator||
name|TLB_DIRTY
operator||
name|TLB_VALID
operator||
name|TLB_GLOBAL
argument_list|,
name|CVMX_TLB_PAGEMASK_256M
argument_list|)
expr_stmt|;
comment|/* Map from 0.5 up to the installed memory size in 512 MByte chunks.  If this loop runs out of memory,         ** the NULL pointer detection can be disabled to free up more TLB entries. */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|system_dram_size
operator|>
literal|0x20000000ULL
condition|)
block|{
for|for
control|(
name|base_addr
operator|=
literal|0x20000000ULL
init|;
name|base_addr
operator|<=
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|system_dram_size
operator|-
literal|0x20000000ULL
operator|)
condition|;
name|base_addr
operator|+=
literal|0x20000000ULL
control|)
block|{
if|if
condition|(
literal|0
operator|>
name|cvmx_core_add_fixed_tlb_mapping
argument_list|(
name|base_addr
argument_list|,
name|base_addr
argument_list|,
name|base_addr
operator|+
literal|0x10000000ULL
argument_list|,
name|CVMX_TLB_PAGEMASK_256M
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR adding 1-1 TLB mapping for address 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|base_addr
argument_list|)
expr_stmt|;
comment|/* Exit from here, as expected memory mappings                        aren't set up if this fails */
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|cvmx_bootmem_init
argument_list|(
name|sys_info_ptr
operator|->
name|phy_mem_desc_addr
argument_list|)
expr_stmt|;
comment|/* Initialize QLM and JTAG settings. Also apply any erratas. */
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
argument_list|)
condition|)
name|cvmx_qlm_init
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|__cvmx_app_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_debug_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
name|CVMX_BREAK
expr_stmt|;
block|}
comment|/* Hang forever, until more appropriate stand alone simple executive        exit() is implemented */
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
end_function

end_unit

