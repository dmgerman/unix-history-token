begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-gpio-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon gpio.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_GPIO_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_GPIO_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_BIT_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_BIT_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_BIT_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000000800ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_GPIO_BOOT_ENA
value|CVMX_GPIO_BOOT_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_BOOT_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_BOOT_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_BOOT_ENA
value|(CVMX_ADD_IO_SEG(0x00010700000008A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_CLK_GENX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_CLK_GENX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_CLK_GENX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000008C0ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_CLK_QLMX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_CLK_QLMX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008E0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_CLK_QLMX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000008E0ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_GPIO_DBG_ENA
value|CVMX_GPIO_DBG_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_DBG_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_DBG_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_DBG_ENA
value|(CVMX_ADD_IO_SEG(0x00010700000008A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_GPIO_INT_CLR
value|(CVMX_ADD_IO_SEG(0x0001070000000898ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_GPIO_MULTI_CAST
value|CVMX_GPIO_MULTI_CAST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_MULTI_CAST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_MULTI_CAST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_MULTI_CAST
value|(CVMX_ADD_IO_SEG(0x00010700000008B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_GPIO_PIN_ENA
value|CVMX_GPIO_PIN_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_PIN_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_PIN_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_PIN_ENA
value|(CVMX_ADD_IO_SEG(0x00010700000008B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_GPIO_RX_DAT
value|(CVMX_ADD_IO_SEG(0x0001070000000880ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_GPIO_TIM_CTL
value|CVMX_GPIO_TIM_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_TIM_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_TIM_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000008A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_TIM_CTL
value|(CVMX_ADD_IO_SEG(0x00010700000008A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_GPIO_TX_CLR
value|(CVMX_ADD_IO_SEG(0x0001070000000890ull))
end_define

begin_define
define|#
directive|define
name|CVMX_GPIO_TX_SET
value|(CVMX_ADD_IO_SEG(0x0001070000000888ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GPIO_XBIT_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|23
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|23
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|23
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GPIO_XBIT_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000900ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GPIO_XBIT_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000000900ull) + ((offset)& 31) * 8 - 8*16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_gpio_bit_cfg#  *  * Notes:  * Only first 16 GPIO pins can introduce interrupts, GPIO_XBIT_CFG16(17,18,19)[INT_EN] and [INT_TYPE]  * will not be used, read out always zero.  */
end_comment

begin_union
union|union
name|cvmx_gpio_bit_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_bit_cfgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|synce_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects the QLM clock output                                                          x0=Normal GPIO output                                                          01=GPIO QLM clock selected by CSR GPIO_CLK_QLM0                                                          11=GPIO QLM clock selected by CSR GPIO_CLK_QLM1 */
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
comment|/**< When TX_OE is set, GPIO pin becomes a clock */
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which of the 4 GPIO clock generators */
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
comment|/**< Global counter bit-select (controls sample rate) */
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive samples to change state */
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
comment|/**< Type of interrupt                                                          0 = level (default)                                                          1 = rising edge */
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask to indicate which bits to raise interrupt */
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
comment|/**< Invert the GPIO pin */
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
comment|/**< Drive the GPIO pin as an output pin */
else|#
directive|else
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synce_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gpio_bit_cfgx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
comment|/**< Global counter bit-select (controls sample rate) */
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive samples to change state */
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
comment|/**< Type of interrupt                                                          0 = level (default)                                                          1 = rising edge */
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask to indicate which bits to raise interrupt */
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
comment|/**< Invert the GPIO pin */
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
comment|/**< Drive the GPIO pin as an output pin */
else|#
directive|else
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gpio_bit_cfgx_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
comment|/**< When TX_OE is set, GPIO pin becomes a clock */
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which of the 4 GPIO clock generators */
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
comment|/**< Global counter bit-select (controls sample rate) */
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive samples to change state */
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
comment|/**< Type of interrupt                                                          0 = level (default)                                                          1 = rising edge */
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask to indicate which bits to raise interrupt */
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
comment|/**< Invert the GPIO pin */
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
comment|/**< Drive the GPIO pin as an output pin */
else|#
directive|else
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gpio_bit_cfgx_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_bit_cfgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_bit_cfgx
name|cvmx_gpio_bit_cfgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_boot_ena  */
end_comment

begin_union
union|union
name|cvmx_gpio_boot_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_boot_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|boot_ena
range|:
literal|4
decl_stmt|;
comment|/**< Drive boot bus chip enables [7:4] on gpio [11:8] */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|boot_ena
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_boot_ena_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_boot_ena_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gpio_boot_ena_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_boot_ena
name|cvmx_gpio_boot_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_clk_gen#  */
end_comment

begin_union
union|union
name|cvmx_gpio_clk_genx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_clk_genx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|n
range|:
literal|32
decl_stmt|;
comment|/**< Determines the frequency of the GPIO clk generator                                                          NOTE: Fgpio_clk = Feclk * N / 2^32                                                                N = (Fgpio_clk / Feclk) * 2^32                                                          NOTE: writing N == 0 stops the clock generator                                                          N  should be<= 2^31-1. */
else|#
directive|else
name|uint64_t
name|n
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_genx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_clk_genx
name|cvmx_gpio_clk_genx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_clk_qlm#  *  * Notes:  * QLM0(A) and QLM1(B) can configured to source any of QLM0 or QLM2 as clock source.  * Clock speed output for different modes ...  *  *                        Speed With      Speed with  * SERDES speed (Gbaud)   DIV=0 (MHz)     DIV=1 (MHz)  * **********************************************************  *      1.25                 62.5            31.25  *      2.5                 125              62.5  *      3.125               156.25           78.125  *      5.0                 250             125  *      6.25                312.5           156.25  */
end_comment

begin_union
union|union
name|cvmx_gpio_clk_qlmx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_clk_qlmx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|qlm_sel
range|:
literal|3
decl_stmt|;
comment|/**< Selects which DLM to select from                                                          x0 = select DLM0 as clock source                                                          x1 = Disabled */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
comment|/**< Internal clock divider                                                          0=DIV2                                                          1=DIV4 */
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which RX lane clock from QLMx to use as                                                          the GPIO internal QLMx clock.  The GPIO block can                                                          support upto two unique clocks to send out any                                                          GPIO pin as configured by $GPIO_BIT_CFG[SYNCE_SEL]                                                          The clock can either be a divided by 2 or divide                                                          by 4 of the selected RX lane clock. */
else|#
directive|else
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm_sel
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gpio_clk_qlmx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|qlm_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which QLM to select from                                                          01 = select QLM0 as clock source                                                          1x = select QLM2 as clock source                                                          0  = Disabled */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
comment|/**< Internal clock divider                                                          0=DIV2                                                          1=DIV4 */
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which RX lane clock from QLMx to use as                                                          the GPIO internal QLMx clock.  The GPIO block can                                                          support upto two unique clocks to send out any                                                          GPIO pin as configured by $GPIO_BIT_CFG[SYNCE_SEL]                                                          The clock can either be a divided by 2 or divide                                                          by 4 of the selected RX lane clock. */
else|#
directive|else
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_gpio_clk_qlmx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
comment|/**< Internal clock divider                                                          0=DIV2                                                          1=DIV4 */
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which RX lane clock from QLM2 to use as                                                          the GPIO internal QLMx clock.  The GPIO block can                                                          support upto two unique clocks to send out any                                                          GPIO pin as configured by $GPIO_BIT_CFG[SYNCE_SEL]                                                          The clock can either be a divided by 2 or divide                                                          by 4 of the selected RX lane clock. */
else|#
directive|else
name|uint64_t
name|lane_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|div
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_gpio_clk_qlmx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_qlmx_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_qlmx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_clk_qlmx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_clk_qlmx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_clk_qlmx
name|cvmx_gpio_clk_qlmx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_dbg_ena  */
end_comment

begin_union
union|union
name|cvmx_gpio_dbg_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_dbg_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|dbg_ena
range|:
literal|21
decl_stmt|;
comment|/**< Enable the debug port to be driven on the gpio */
else|#
directive|else
name|uint64_t
name|dbg_ena
range|:
literal|21
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_dbg_ena_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_dbg_ena_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gpio_dbg_ena_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_dbg_ena
name|cvmx_gpio_dbg_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_int_clr  *  * Notes:  * Only 16 out of 20 GPIOs support interrupt.GPIO_INT_CLR only apply to GPIO0-GPIO15.  *  */
end_comment

begin_union
union|union
name|cvmx_gpio_int_clr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_int_clr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
comment|/**< Clear the interrupt rising edge detector */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_int_clr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_int_clr
name|cvmx_gpio_int_clr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_multi_cast  *  * Notes:  * GPIO<7:4> have the option of operating in GPIO Interrupt Multicast mode.  In  * this mode, the PP GPIO interrupts (CIU_INT<0-7>_SUM0/CIU_INT<0-3>_SUM4[GPIO<7:4>] values are  * stored per cnMIPS core.  * For GPIO<7:4> (x=4-7):  *    When GPIO_MULTI_CAST[EN] = 1:  *        When GPIO_BIT_CFGx[INT_EN]==1&  GPIO_BIT_CFGx[INT_TYPE]==1 (edge detection and interrupt enabled):  *          * Reads to CIU_INT<0-7>_SUM0/<0-3>_SUM4[GPIO<x>] will return a unique interrupt state per  *            cnMIPS core.  *          * Reads to CIU_INT32/33_SUM0/4[GPIO<x>] will return the common GPIO<x>  *            interrupt state.  *          * Write of '1' to CIU_INT<0-7>_SUM0/<0-3>_SUM4[GPIO<x>] will clear the individual  *            interrupt associated with the cnMIPS core.  *          * Write of '1' to CIU_INT32/33_SUM0/4[GPIO<x>] will clear the common GPIO<x>  *            interrupt state.  *          * Write of '1' to GPIO_INT_CLR[TYPE<x>] will clear all  *            CIU_INT*_SUM0/4[GPIO<x>] state across all cnMIPS cores and common GPIO<x> interrupt states.  *        When GPIO_BIT_CFGx[INT_EN]==0 or GPIO_BIT_CFGx[INT_TYPE]==0,  *          * either leveled interrupt or interrupt not enabled, write of '1' to CIU_INT*_SUM0/4[GPIO<x>]  *            will have no effects.  *     When GPIO_MULTI_CAST[EN] = 0:  *        * Write of '1' to CIU_INT_SUM0/4[GPIO<x>] will have no effects, as this field is RO,  *          backward compatible with o63.  *        When GPIO_BIT_CFGx[INT_EN]==1&  GPIO_BIT_CFGx[INT_TYPE]==1 (edge detection and interrupt enabled):  *          * Reads to CIU_INT*_SUM0/4[GPIO<x>] will return the common GPIO<X> interrupt state.  *          * Write of '1' to GPIO_INT_CLR[TYPE<x>] will clear all  *            CIU_INT*_SUM0/4[GPIO<x>] state across all cnMIPS cores and common GPIO<x> interrupt states.  *        When GPIO_BIT_CFGx[INT_EN]==0 or GPIO_BIT_CFGx[INT_TYPE]==0,  *          * either leveled interrupt or interrupt not enabled, write of '1' to CIU_INT*_SUM0/4[GPIO<x>]  *            will have no effects.  *  * GPIO<15:8> and GPIO<3:0> will never be in multicast mode as those don't have per cnMIPS capabilities.  * For GPIO<y> (y=0-3,8-15):  *    When GPIO_BIT_CFGx[INT_EN]==1&  GPIO_BIT_CFGx[INT_TYPE]==1 (edge detection and interrupt enabled):  *       * Reads to CIU_INT*_SUM0/4[GPIO<y>] will return the common GPIO<y> interrupt state.  *       * Write of '1' to GPIO_INT_CLR[TYPE<y>] will clear all CIU_INT*_SUM0/4[GPIO<y>] common GPIO<y>  *         interrupt states.  *       When GPIO_MULTI_CAST[EN] = 1:  *         * Write of '1' to CIU_INT*_SUM0/4[GPIO<y>] will clear the common GPIO<y> interrupt state.  *       When GPIO_MULTI_CAST[EN] = 0:  *         * Write of '1' to CIU_INT*_SUM0/4[GPIO<y>] has no effect, as this field is RO,  *           backward compatible to o63.  *    When GPIO_BIT_CFGx[INT_EN]==0 or GPIO_BIT_CFGx[INT_TYPE]==0,  *       * either leveled interrupt or interrupt not enabled, write of '1' to CIU_INT*_SUM0/4[GPIO<y>]  *         will have no effects.  *  * Whenever there is mode change, (GPIO_BIT_CFGx[INT_EN] or  GPIO_BIT_CFGx[INT_TYPE] or GPIO_MULTI_CAST[EN])  * software needs to write to  $GPIO_INT_CLR to clear up all pending/stale interrupts.  */
end_comment

begin_union
union|union
name|cvmx_gpio_multi_cast
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_multi_cast_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Enable GPIO Interrupt Multicast mode                                                          When EN is set, GPIO<7:4> will function in                                                          multicast mode allowing these four GPIOs to                                                          interrupt multi-cores.                                                          Multicast functionality allows the GPIO to exist                                                          as per cnMIPS interrupts as opposed to a global                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_multi_cast_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gpio_multi_cast_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_multi_cast
name|cvmx_gpio_multi_cast_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_pin_ena  *  * Notes:  * GPIO0-GPIO17 has dedicated pins.  * GPIO18 share pin with UART (UART0_CTS_L/GPIO_18), GPIO18 enabled when $GPIO_PIN_ENA[ENA18]=1  * GPIO19 share pin with UART (UART1_CTS_L/GPIO_19), GPIO18 enabled when $GPIO_PIN_ENA[ENA19]=1  */
end_comment

begin_union
union|union
name|cvmx_gpio_pin_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_pin_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|ena19
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART1_CTS_L/GPIO_19 pin is UART pin                                                          If 1, UART1_CTS_L/GPIO_19 pin is GPIO19 pin */
name|uint64_t
name|ena18
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_CTS_L/GPIO_18 pin is UART pin                                                          If 1, UART0_CTS_L/GPIO_18 pin is GPIO18 pin */
name|uint64_t
name|reserved_0_17
range|:
literal|18
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_17
range|:
literal|18
decl_stmt|;
name|uint64_t
name|ena18
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_pin_ena_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_pin_ena
name|cvmx_gpio_pin_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_rx_dat  */
end_comment

begin_union
union|union
name|cvmx_gpio_rx_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_rx_dat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|24
decl_stmt|;
comment|/**< GPIO Read Data */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_rx_dat_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_gpio_rx_dat_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
comment|/**< GPIO Read Data */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gpio_rx_dat_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|20
decl_stmt|;
comment|/**< GPIO Read Data */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn38xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_rx_dat_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_rx_dat
name|cvmx_gpio_rx_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_tim_ctl  */
end_comment

begin_union
union|union
name|cvmx_gpio_tim_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_tim_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|sel
range|:
literal|4
decl_stmt|;
comment|/**< Selects the GPIO pin to route to TIM */
else|#
directive|else
name|uint64_t
name|sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_tim_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_tim_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_tim_ctl
name|cvmx_gpio_tim_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_tx_clr  */
end_comment

begin_union
union|union
name|cvmx_gpio_tx_clr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_clr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|24
decl_stmt|;
comment|/**< Bit mask to indicate which GPIO_TX_DAT bits to set                                                          to '0'. When read, CLR returns the GPIO_TX_DAT                                                          storage. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_tx_clr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_clr_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask to indicate which bits to drive to '0'. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_clr_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|20
decl_stmt|;
comment|/**< Bit mask to indicate which GPIO_TX_DAT bits to set                                                          to '0'. When read, CLR returns the GPIO_TX_DAT                                                          storage. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn38xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_clr_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_tx_clr
name|cvmx_gpio_tx_clr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_tx_set  */
end_comment

begin_union
union|union
name|cvmx_gpio_tx_set
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_set_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|set
range|:
literal|24
decl_stmt|;
comment|/**< Bit mask to indicate which GPIO_TX_DAT bits to set                                                          to '1'. When read, SET returns the GPIO_TX_DAT                                                          storage. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gpio_tx_set_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_set_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|set
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask to indicate which bits to drive to '1'. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gpio_tx_set_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|set
range|:
literal|20
decl_stmt|;
comment|/**< Bit mask to indicate which GPIO_TX_DAT bits to set                                                          to '1'. When read, SET returns the GPIO_TX_DAT                                                          storage. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn38xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gpio_tx_set_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_tx_set
name|cvmx_gpio_tx_set_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gpio_xbit_cfg#  *  * Notes:  * Only first 16 GPIO pins can introduce interrupts, GPIO_XBIT_CFG16(17,18,19)[INT_EN] and [INT_TYPE]  * will not be used, read out always zero.  */
end_comment

begin_union
union|union
name|cvmx_gpio_xbit_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gpio_xbit_cfgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|synce_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects the QLM clock output                                                          x0=Normal GPIO output                                                          01=GPIO QLM clock selected by CSR GPIO_CLK_QLM0                                                          11=GPIO QLM clock selected by CSR GPIO_CLK_QLM1 */
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
comment|/**< When TX_OE is set, GPIO pin becomes a clock */
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
comment|/**< Selects which of the 4 GPIO clock generators */
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
comment|/**< Global counter bit-select (controls sample rate) */
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive samples to change state */
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
comment|/**< Type of interrupt                                                          0 = level (default)                                                          1 = rising edge */
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask to indicate which bits to raise interrupt */
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
comment|/**< Invert the GPIO pin */
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
comment|/**< Drive the GPIO pin as an output pin */
else|#
directive|else
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clk_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clk_gen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synce_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gpio_xbit_cfgx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
comment|/**< Global counter bit-select (controls sample rate) */
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive samples to change state */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
comment|/**< Invert the GPIO pin */
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
comment|/**< Drive the GPIO pin as an output pin */
else|#
directive|else
name|uint64_t
name|tx_oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_xor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fil_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fil_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gpio_xbit_cfgx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gpio_xbit_cfgx_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gpio_xbit_cfgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gpio_xbit_cfgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gpio_xbit_cfgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gpio_xbit_cfgx
name|cvmx_gpio_xbit_cfgx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

