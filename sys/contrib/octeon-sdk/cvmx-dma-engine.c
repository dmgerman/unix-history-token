begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the PCI / PCIe DMA engines. These are only avialable  * on chips with PCI / PCIe.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/octeon-model.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-cmd-queue.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dma-engine.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/octeon-feature.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npei-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dpi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-cfg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-cmd-queue.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-dma-engine.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-cfg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * Return the number of DMA engimes supported by this chip  *  * @return Number of DMA engines  */
end_comment

begin_function
name|int
name|cvmx_dma_engine_get_num
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|5
return|;
block|}
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
return|return
literal|8
return|;
else|else
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the DMA engines for use  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_dma_engine_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|engine
decl_stmt|;
for|for
control|(
name|engine
operator|=
literal|0
init|;
name|engine
operator|<
name|cvmx_dma_engine_get_num
argument_list|()
condition|;
name|engine
operator|++
control|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_initialize
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|,
literal|0
argument_list|,
name|CVMX_FPA_OUTPUT_BUFFER_POOL
argument_list|,
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|CVMX_CMD_QUEUE_SUCCESS
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_dmax_ibuff_saddr_t
name|dmax_ibuff_saddr
decl_stmt|;
name|dmax_ibuff_saddr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|dmax_ibuff_saddr
operator|.
name|s
operator|.
name|saddr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_cmd_queue_buffer
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
argument_list|)
operator|>>
literal|7
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMAX_IBUFF_SADDR
argument_list|(
name|engine
argument_list|)
argument_list|,
name|dmax_ibuff_saddr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|cvmx_dpi_dmax_ibuff_saddr_t
name|dpi_dmax_ibuff_saddr
decl_stmt|;
name|dpi_dmax_ibuff_saddr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|dpi_dmax_ibuff_saddr
operator|.
name|s
operator|.
name|csize
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
operator|/
literal|8
expr_stmt|;
name|dpi_dmax_ibuff_saddr
operator|.
name|s
operator|.
name|saddr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_cmd_queue_buffer
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
argument_list|)
operator|>>
literal|7
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMAX_IBUFF_SADDR
argument_list|(
name|engine
argument_list|)
argument_list|,
name|dpi_dmax_ibuff_saddr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|address
init|=
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_cmd_queue_buffer
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|engine
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_HIGHP_IBUFF_SADDR
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_LOWP_IBUFF_SADDR
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_dma_control_t
name|dma_control
decl_stmt|;
name|dma_control
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvmx_dma_engine_get_num
argument_list|()
operator|>=
literal|5
condition|)
name|dma_control
operator|.
name|s
operator|.
name|dma4_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma3_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma2_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma1_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma0_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|o_mode
operator|=
literal|1
expr_stmt|;
comment|/* Pull NS and RO from this register, not the pointers */
comment|//dma_control.s.dwb_denb = 1;
comment|//dma_control.s.dwb_ichk = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE/128;
name|dma_control
operator|.
name|s
operator|.
name|fpa_que
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|csize
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
operator|/
literal|8
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* As a workaround for errata PCIE-811 we only allow a single             outstanding DMA read over PCIe at a time. This limits performance,             but works in all cases. If you need higher performance, remove             this code and implement the more complicated workaround documented             in the errata. This only affects CN56XX pass 2.0 chips */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS2_0
argument_list|)
condition|)
block|{
name|cvmx_npei_dma_pcie_req_num_t
name|pcie_req_num
decl_stmt|;
name|pcie_req_num
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_PCIE_REQ_NUM
argument_list|)
expr_stmt|;
name|pcie_req_num
operator|.
name|s
operator|.
name|dma_cnt
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_PCIE_REQ_NUM
argument_list|,
name|pcie_req_num
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|cvmx_dpi_engx_buf_t
name|dpi_engx_buf
decl_stmt|;
name|cvmx_dpi_dma_engx_en_t
name|dpi_dma_engx_en
decl_stmt|;
name|cvmx_dpi_dma_control_t
name|dma_control
decl_stmt|;
name|cvmx_dpi_ctl_t
name|dpi_ctl
decl_stmt|;
comment|/* Give engine 0-4 1KB, and 5 3KB. This gives the packet engines better             performance. Total must not exceed 8KB */
name|dpi_engx_buf
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|dpi_engx_buf
operator|.
name|s
operator|.
name|blks
operator|=
literal|2
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|0
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|1
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|2
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|3
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|4
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dpi_engx_buf
operator|.
name|s
operator|.
name|blks
operator|=
literal|6
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_ENGX_BUF
argument_list|(
literal|5
argument_list|)
argument_list|,
name|dpi_engx_buf
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dma_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_DMA_CONTROL
argument_list|)
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|pkt_hp
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|pkt_en
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma_enb
operator|=
literal|0x1f
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dwb_denb
operator|=
name|cvmx_helper_cfg_opt_get
argument_list|(
name|CVMX_HELPER_CFG_OPT_USE_DWB
argument_list|)
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dwb_ichk
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
operator|/
literal|128
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|fpa_que
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|o_mode
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* When dma_control[pkt_en] = 1, engine 5 is used for packets and is not            available for DMA. */
name|dpi_dma_engx_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_DMA_ENGX_EN
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|dpi_dma_engx_en
operator|.
name|s
operator|.
name|qen
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMA_ENGX_EN
argument_list|(
literal|5
argument_list|)
argument_list|,
name|dpi_dma_engx_en
operator|.
name|u64
argument_list|)
expr_stmt|;
name|dpi_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_CTL
argument_list|)
expr_stmt|;
name|dpi_ctl
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_CTL
argument_list|,
name|dpi_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_npi_dma_control_t
name|dma_control
decl_stmt|;
name|dma_control
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|//dma_control.s.dwb_denb = 1;
comment|//dma_control.s.dwb_ichk = CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE/128;
name|dma_control
operator|.
name|s
operator|.
name|o_add1
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|fpa_que
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|hp_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|lp_enb
operator|=
literal|1
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|csize
operator|=
name|CVMX_FPA_OUTPUT_BUFFER_POOL_SIZE
operator|/
literal|8
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_dma_engine_initialize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Shutdown all DMA engines. The engines must be idle when this  * function is called.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_dma_engine_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|engine
decl_stmt|;
for|for
control|(
name|engine
operator|=
literal|0
init|;
name|engine
operator|<
name|cvmx_dma_engine_get_num
argument_list|()
condition|;
name|engine
operator|++
control|)
block|{
if|if
condition|(
name|cvmx_cmd_queue_length
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_dma_engine_shutdown: Engine not idle.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_dma_control_t
name|dma_control
decl_stmt|;
name|dma_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_dma_engine_get_num
argument_list|()
operator|>=
literal|5
condition|)
name|dma_control
operator|.
name|s
operator|.
name|dma4_enb
operator|=
literal|0
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma3_enb
operator|=
literal|0
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma2_enb
operator|=
literal|0
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma1_enb
operator|=
literal|0
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma0_enb
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure the disable completes */
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMA_CONTROL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|cvmx_dpi_dma_control_t
name|dma_control
decl_stmt|;
name|dma_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_DMA_CONTROL
argument_list|)
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|dma_enb
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure the disable completes */
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_DMA_CONTROL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_npi_dma_control_t
name|dma_control
decl_stmt|;
name|dma_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NPI_DMA_CONTROL
argument_list|)
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|hp_enb
operator|=
literal|0
expr_stmt|;
name|dma_control
operator|.
name|s
operator|.
name|lp_enb
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DMA_CONTROL
argument_list|,
name|dma_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure the disable completes */
name|cvmx_read_csr
argument_list|(
name|CVMX_NPI_DMA_CONTROL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|engine
operator|=
literal|0
init|;
name|engine
operator|<
name|cvmx_dma_engine_get_num
argument_list|()
condition|;
name|engine
operator|++
control|)
block|{
name|cvmx_cmd_queue_shutdown
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMAX_IBUFF_SADDR
argument_list|(
name|engine
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMAX_IBUFF_SADDR
argument_list|(
name|engine
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|engine
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_HIGHP_IBUFF_SADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_LOWP_IBUFF_SADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_dma_engine_shutdown
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Submit a series of DMA command to the DMA engines.  *  * @param engine  Engine to submit to (0 to cvmx_dma_engine_get_num()-1)  * @param header  Command header  * @param num_buffers  *                The number of data pointers  * @param buffers Command data pointers  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_dma_engine_submit
parameter_list|(
name|int
name|engine
parameter_list|,
name|cvmx_dma_engine_header_t
name|header
parameter_list|,
name|int
name|num_buffers
parameter_list|,
name|cvmx_dma_engine_buffer_t
name|buffers
index|[]
parameter_list|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
name|int
name|cmd_count
init|=
literal|1
decl_stmt|;
name|uint64_t
name|cmds
index|[
name|num_buffers
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
condition|)
block|{
comment|/* Check for Errata PCIe-604 */
if|if
condition|(
operator|(
name|header
operator|.
name|s
operator|.
name|nfst
operator|>
literal|11
operator|)
operator|||
operator|(
name|header
operator|.
name|s
operator|.
name|nlst
operator|>
literal|11
operator|)
operator|||
operator|(
name|header
operator|.
name|s
operator|.
name|nfst
operator|+
name|header
operator|.
name|s
operator|.
name|nlst
operator|>
literal|15
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"DMA engine submit too large\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|cmds
index|[
literal|0
index|]
operator|=
name|header
operator|.
name|u64
expr_stmt|;
while|while
condition|(
name|num_buffers
operator|--
condition|)
block|{
name|cmds
index|[
name|cmd_count
operator|++
index|]
operator|=
name|buffers
operator|->
name|u64
expr_stmt|;
name|buffers
operator|++
expr_stmt|;
block|}
comment|/* Due to errata PCIE-13315, it is necessary to have the queue lock while we         ring the doorbell for the DMA engines. This prevents doorbells from         possibly arriving out of order with respect to the command queue         entries */
name|__cvmx_cmd_queue_lock
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|,
name|__cvmx_cmd_queue_get_state
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_write
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|,
literal|0
argument_list|,
name|cmd_count
argument_list|,
name|cmds
argument_list|)
expr_stmt|;
comment|/* This SYNCWS is needed since the command queue didn't do locking, which         normally implies the SYNCWS. This one makes sure the command queue         updates make it to L2 before we ring the doorbell */
name|CVMX_SYNCWS
expr_stmt|;
comment|/* A syncw isn't needed here since the command queue did one as part of the queue unlock */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|result
operator|==
name|CVMX_CMD_QUEUE_SUCCESS
argument_list|)
condition|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
comment|/* DMA doorbells are 32bit writes in little endian space. This means we need to xor the address with 4 */
name|cvmx_write64_uint32
argument_list|(
name|CVMX_PEXP_NPEI_DMAX_DBELL
argument_list|(
name|engine
argument_list|)
operator|^
literal|4
argument_list|,
name|cmd_count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_DMAX_DBELL
argument_list|(
name|engine
argument_list|)
argument_list|,
name|cmd_count
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|engine
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_HIGHP_DBELL
argument_list|,
name|cmd_count
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_LOWP_DBELL
argument_list|,
name|cmd_count
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here is the unlock for the above errata workaround */
name|__cvmx_cmd_queue_unlock
argument_list|(
name|__cvmx_cmd_queue_get_state
argument_list|(
name|CVMX_CMD_QUEUE_DMA
argument_list|(
name|engine
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Function used by cvmx_dma_engine_transfer() to build the  * internal address list.  *  * @param buffers Location to store the list  * @param address Address to build list for  * @param size    Length of the memory pointed to by address  *  * @return Number of internal pointer chunks created  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_dma_engine_build_internal_pointers
parameter_list|(
name|cvmx_dma_engine_buffer_t
modifier|*
name|buffers
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|segments
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
comment|/* Each internal chunk can contain a maximum of 8191 bytes */
name|int
name|chunk
init|=
name|size
decl_stmt|;
if|if
condition|(
name|chunk
operator|>
literal|8191
condition|)
name|chunk
operator|=
literal|8191
expr_stmt|;
name|buffers
index|[
name|segments
index|]
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|buffers
index|[
name|segments
index|]
operator|.
name|internal
operator|.
name|size
operator|=
name|chunk
expr_stmt|;
name|buffers
index|[
name|segments
index|]
operator|.
name|internal
operator|.
name|addr
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|chunk
expr_stmt|;
name|size
operator|-=
name|chunk
expr_stmt|;
name|segments
operator|++
expr_stmt|;
block|}
return|return
name|segments
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Function used by cvmx_dma_engine_transfer() to build the PCI / PCIe address  * list.  * @param buffers Location to store the list  * @param address Address to build list for  * @param size    Length of the memory pointed to by address  *  * @return Number of PCI / PCIe address chunks created. The number of words used  *         will be segments + (segments-1)/4 + 1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_dma_engine_build_external_pointers
parameter_list|(
name|cvmx_dma_engine_buffer_t
modifier|*
name|buffers
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|int
name|MAX_SIZE
init|=
literal|65535
decl_stmt|;
name|int
name|segments
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
comment|/* Each block of 4 PCI / PCIe pointers uses one dword for lengths followed by             up to 4 addresses. This then repeats if more data is needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|MAX_SIZE
condition|)
block|{
comment|/* Only one more segment needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len0
operator|=
name|size
expr_stmt|;
name|buffers
index|[
literal|1
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|segments
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|MAX_SIZE
operator|*
literal|2
condition|)
block|{
comment|/* Two more segments needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len0
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len1
operator|=
name|size
operator|-
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|1
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|2
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|segments
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|MAX_SIZE
operator|*
literal|3
condition|)
block|{
comment|/* Three more segments needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len0
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len1
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len2
operator|=
name|size
operator|-
name|MAX_SIZE
operator|*
literal|2
expr_stmt|;
name|buffers
index|[
literal|1
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|2
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|3
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|segments
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|MAX_SIZE
operator|*
literal|4
condition|)
block|{
comment|/* Four more segments needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len0
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len1
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len2
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len3
operator|=
name|size
operator|-
name|MAX_SIZE
operator|*
literal|3
expr_stmt|;
name|buffers
index|[
literal|1
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|2
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|3
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|4
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|segments
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Five or more segments are needed */
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len0
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len1
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len2
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|0
index|]
operator|.
name|pcie_length
operator|.
name|len3
operator|=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|1
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|2
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|3
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|buffers
index|[
literal|4
index|]
operator|.
name|u64
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|MAX_SIZE
expr_stmt|;
name|size
operator|-=
name|MAX_SIZE
operator|*
literal|4
expr_stmt|;
name|buffers
operator|+=
literal|5
expr_stmt|;
name|segments
operator|+=
literal|4
expr_stmt|;
block|}
block|}
return|return
name|segments
return|;
block|}
end_function

begin_comment
comment|/**  * Build the first and last pointers based on a DMA engine header  * and submit them to the engine. The purpose of this function is  * to simplify the building of DMA engine commands by automatically  * converting a simple address and size into the apropriate internal  * or PCI / PCIe address list. This function does not support gather lists,  * so you will need to build your own lists in that case.  *  * @param engine Engine to submit to (0 to cvmx_dma_engine_get_num()-1)  * @param header DMA Command header. Note that the nfst and nlst fields do not  *               need to be filled in. All other fields must be set properly.  * @param first_address  *               Address to use for the first pointers. In the case of INTERNAL,  *               INBOUND, and OUTBOUND this is an Octeon memory address. In the  *               case of EXTERNAL, this is the source PCI / PCIe address.  * @param last_address  *               Address to use for the last pointers. In the case of EXTERNAL,  *               INBOUND, and OUTBOUND this is a PCI / PCIe address. In the  *               case of INTERNAL, this is the Octeon memory destination address.  * @param size   Size of the transfer to perform.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_dma_engine_transfer
parameter_list|(
name|int
name|engine
parameter_list|,
name|cvmx_dma_engine_header_t
name|header
parameter_list|,
name|uint64_t
name|first_address
parameter_list|,
name|uint64_t
name|last_address
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|cvmx_dma_engine_buffer_t
name|buffers
index|[
literal|32
index|]
decl_stmt|;
name|int
name|words
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|header
operator|.
name|s
operator|.
name|type
condition|)
block|{
case|case
name|CVMX_DMA_ENGINE_TRANSFER_INTERNAL
case|:
name|header
operator|.
name|s
operator|.
name|nfst
operator|=
name|__cvmx_dma_engine_build_internal_pointers
argument_list|(
name|buffers
argument_list|,
name|first_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nfst
expr_stmt|;
name|header
operator|.
name|s
operator|.
name|nlst
operator|=
name|__cvmx_dma_engine_build_internal_pointers
argument_list|(
name|buffers
operator|+
name|words
argument_list|,
name|last_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nlst
expr_stmt|;
break|break;
case|case
name|CVMX_DMA_ENGINE_TRANSFER_INBOUND
case|:
case|case
name|CVMX_DMA_ENGINE_TRANSFER_OUTBOUND
case|:
name|header
operator|.
name|s
operator|.
name|nfst
operator|=
name|__cvmx_dma_engine_build_internal_pointers
argument_list|(
name|buffers
argument_list|,
name|first_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nfst
expr_stmt|;
name|header
operator|.
name|s
operator|.
name|nlst
operator|=
name|__cvmx_dma_engine_build_external_pointers
argument_list|(
name|buffers
operator|+
name|words
argument_list|,
name|last_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nlst
operator|+
operator|(
operator|(
name|header
operator|.
name|s
operator|.
name|nlst
operator|-
literal|1
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_DMA_ENGINE_TRANSFER_EXTERNAL
case|:
name|header
operator|.
name|s
operator|.
name|nfst
operator|=
name|__cvmx_dma_engine_build_external_pointers
argument_list|(
name|buffers
argument_list|,
name|first_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nfst
operator|+
operator|(
operator|(
name|header
operator|.
name|s
operator|.
name|nfst
operator|-
literal|1
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|header
operator|.
name|s
operator|.
name|nlst
operator|=
name|__cvmx_dma_engine_build_external_pointers
argument_list|(
name|buffers
operator|+
name|words
argument_list|,
name|last_address
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|words
operator|+=
name|header
operator|.
name|s
operator|.
name|nlst
operator|+
operator|(
operator|(
name|header
operator|.
name|s
operator|.
name|nlst
operator|-
literal|1
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|cvmx_dma_engine_submit
argument_list|(
name|engine
argument_list|,
name|header
argument_list|,
name|words
argument_list|,
name|buffers
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_dma_engine_transfer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

