begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * "cvmx-usb.c" defines a set of low level USB functions to help  * developers create Octeon USB drivers for various operating  * systems. These functions provide a generic API to the Octeon  * USB blocks, hiding the internal hardware specific  * operations.  *  *<hr>$Revision: 32636 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-usb.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-csr-db.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_define
define|#
directive|define
name|MAX_RETRIES
value|3
end_define

begin_comment
comment|/* Maximum number of times to retry failed transactions */
end_comment

begin_define
define|#
directive|define
name|MAX_PIPES
value|32
end_define

begin_comment
comment|/* Maximum number of pipes that can be open at once */
end_comment

begin_define
define|#
directive|define
name|MAX_TRANSACTIONS
value|256
end_define

begin_comment
comment|/* Maximum number of outstanding transactions across all pipes */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANNELS
value|8
end_define

begin_comment
comment|/* Maximum number of hardware channels supported by the USB block */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_ADDRESS
value|127
end_define

begin_comment
comment|/* The highest valid USB device address */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_ENDPOINT
value|15
end_define

begin_comment
comment|/* The highest valid USB endpoint number */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_HUB_PORT
value|15
end_define

begin_comment
comment|/* The highest valid port number on a hub */
end_comment

begin_define
define|#
directive|define
name|ALLOW_CSR_DECODES
value|0
end_define

begin_comment
comment|/* CSR decoding when CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS is set                                     enlarges the code a lot. This define overrides the ability to do CSR                                     decoding since it isn't necessary 99% of the time. Change this to a                                     one if you need CSR decoding */
end_comment

begin_comment
comment|/* These defines disable the normal read and write csr. This is so I can add     extra debug stuff to the usb specific version and I won't use the normal     version by mistake */
end_comment

begin_define
define|#
directive|define
name|cvmx_read_csr
value|use_cvmx_usb_read_csr64_instead_of_cvmx_read_csr
end_define

begin_define
define|#
directive|define
name|cvmx_write_csr
value|use_cvmx_usb_write_csr64_instead_of_cvmx_write_csr
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
init|=
literal|1
operator|<<
literal|16
block|, }
name|cvmx_usb_transaction_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * Logical transactions may take numerous low level  * transactions, especially when splits are concerned. This  * enum represents all of the possible stages a transaction can  * be in. Note that split completes are always even. This is so  * the NAK handler can backup to the previous low level  * transaction with a simple clearing of bit 0.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|CVMX_USB_STAGE_NON_CONTROL
block|,
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_SETUP
block|,
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_DATA
block|,
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_STATUS
block|,
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
block|, }
name|cvmx_usb_stage_t
typedef|;
end_typedef

begin_comment
comment|/**  * This structure describes each pending USB transaction  * regardless of type. These are linked together to form a list  * of pending requests for a pipe.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cvmx_usb_transaction
block|{
name|struct
name|cvmx_usb_transaction
modifier|*
name|prev
decl_stmt|;
comment|/**< Transaction before this one in the pipe */
name|struct
name|cvmx_usb_transaction
modifier|*
name|next
decl_stmt|;
comment|/**< Transaction after this one in the pipe */
name|cvmx_usb_transfer_t
name|type
decl_stmt|;
comment|/**< Type of transaction, duplicated of the pipe */
name|cvmx_usb_transaction_flags_t
name|flags
decl_stmt|;
comment|/**< State flags for this transaction */
name|uint64_t
name|buffer
decl_stmt|;
comment|/**< User's physical buffer address to read/write */
name|int
name|buffer_length
decl_stmt|;
comment|/**< Size of the user's buffer in bytes */
name|uint64_t
name|control_header
decl_stmt|;
comment|/**< For control transactions, physical address of the 8 byte standard header */
name|int
name|iso_start_frame
decl_stmt|;
comment|/**< For ISO transactions, the starting frame number */
name|int
name|iso_number_packets
decl_stmt|;
comment|/**< For ISO transactions, the number of packets in the request */
name|cvmx_usb_iso_packet_t
modifier|*
name|iso_packets
decl_stmt|;
comment|/**< For ISO transactions, the sub packets in the request */
name|int
name|xfersize
decl_stmt|;
name|int
name|pktcnt
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|actual_bytes
decl_stmt|;
comment|/**< Actual bytes transfer for this transaction */
name|cvmx_usb_stage_t
name|stage
decl_stmt|;
comment|/**< For control transactions, the current stage */
name|cvmx_usb_callback_func_t
name|callback
decl_stmt|;
comment|/**< User's callback function when complete */
name|void
modifier|*
name|callback_data
decl_stmt|;
comment|/**< User's data */
block|}
name|cvmx_usb_transaction_t
typedef|;
end_typedef

begin_comment
comment|/**  * A pipe represents a virtual connection between Octeon and some  * USB device. It contains a list of pending request to the device.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cvmx_usb_pipe
block|{
name|struct
name|cvmx_usb_pipe
modifier|*
name|prev
decl_stmt|;
comment|/**< Pipe before this one in the list */
name|struct
name|cvmx_usb_pipe
modifier|*
name|next
decl_stmt|;
comment|/**< Pipe after this one in the list */
name|cvmx_usb_transaction_t
modifier|*
name|head
decl_stmt|;
comment|/**< The first pending transaction */
name|cvmx_usb_transaction_t
modifier|*
name|tail
decl_stmt|;
comment|/**< The last pending transaction */
name|uint64_t
name|interval
decl_stmt|;
comment|/**< For periodic pipes, the interval between packets in cycles */
name|uint64_t
name|next_tx_cycle
decl_stmt|;
comment|/**< The next cycle this pipe is allowed to transmit on */
name|cvmx_usb_pipe_flags_t
name|flags
decl_stmt|;
comment|/**< State flags for this pipe */
name|cvmx_usb_speed_t
name|device_speed
decl_stmt|;
comment|/**< Speed of device connected to this pipe */
name|cvmx_usb_transfer_t
name|transfer_type
decl_stmt|;
comment|/**< Type of transaction supported by this pipe */
name|cvmx_usb_direction_t
name|transfer_dir
decl_stmt|;
comment|/**< IN or OUT. Ignored for Control */
name|int
name|multi_count
decl_stmt|;
comment|/**< Max packet in a row for the device */
name|uint16_t
name|max_packet
decl_stmt|;
comment|/**< The device's maximum packet size in bytes */
name|uint8_t
name|device_addr
decl_stmt|;
comment|/**< USB device address at other end of pipe */
name|uint8_t
name|endpoint_num
decl_stmt|;
comment|/**< USB endpoint number at other end of pipe */
name|uint8_t
name|hub_device_addr
decl_stmt|;
comment|/**< Hub address this device is connected to */
name|uint8_t
name|hub_port
decl_stmt|;
comment|/**< Hub port this device is connected to */
name|uint8_t
name|pid_toggle
decl_stmt|;
comment|/**< This toggles between 0/1 on every packet send to track the data pid needed */
name|uint8_t
name|channel
decl_stmt|;
comment|/**< Hardware DMA channel for this pipe */
name|int8_t
name|split_sc_frame
decl_stmt|;
comment|/**< The low order bits of the frame number the split complete should be sent on */
block|}
name|cvmx_usb_pipe_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_usb_pipe_t
modifier|*
name|head
decl_stmt|;
comment|/**< Head of the list, or NULL if empty */
name|cvmx_usb_pipe_t
modifier|*
name|tail
decl_stmt|;
comment|/**< Tail if the list, or NULL if empty */
block|}
name|cvmx_usb_pipe_list_t
typedef|;
end_typedef

begin_comment
comment|/**  * The state of the USB block is stored in this structure  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|init_flags
decl_stmt|;
comment|/**< Flags passed to initialize */
name|int
name|index
decl_stmt|;
comment|/**< Which USB block this is for */
name|int
name|idle_hardware_channels
decl_stmt|;
comment|/**< Bit set for every idle hardware channel */
name|int
name|active_transactions
decl_stmt|;
comment|/**< Number of active transactions across all pipes */
name|cvmx_usbcx_hprt_t
name|usbcx_hprt
decl_stmt|;
comment|/**< Stored port status so we don't need to read a CSR to determine splits */
name|cvmx_usb_pipe_t
modifier|*
name|pipe_for_channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/**< Map channels to pipes */
name|cvmx_usb_transaction_t
modifier|*
name|free_transaction_head
decl_stmt|;
comment|/**< List of free transactions head */
name|cvmx_usb_transaction_t
modifier|*
name|free_transaction_tail
decl_stmt|;
comment|/**< List of free transactions tail */
name|cvmx_usb_pipe_t
name|pipe
index|[
name|MAX_PIPES
index|]
decl_stmt|;
comment|/**< Storage for pipes */
name|cvmx_usb_transaction_t
name|transaction
index|[
name|MAX_TRANSACTIONS
index|]
decl_stmt|;
comment|/**< Storage for transactions */
name|cvmx_usb_callback_func_t
name|callback
index|[
name|__CVMX_USB_CALLBACK_END
index|]
decl_stmt|;
comment|/**< User global callbacks */
name|void
modifier|*
name|callback_data
index|[
name|__CVMX_USB_CALLBACK_END
index|]
decl_stmt|;
comment|/**< User data for each callback */
name|int
name|indent
decl_stmt|;
comment|/**< Used by debug output to indent functions */
name|cvmx_usb_port_status_t
name|port_status
decl_stmt|;
comment|/**< Last port status used for change notification */
name|cvmx_usb_pipe_list_t
name|free_pipes
decl_stmt|;
comment|/**< List of all pipes that are currently closed */
name|cvmx_usb_pipe_list_t
name|idle_pipes
decl_stmt|;
comment|/**< List of open pipes that have no transactions */
name|cvmx_usb_pipe_list_t
name|active_pipes
index|[
literal|4
index|]
decl_stmt|;
comment|/**< Active pipes indexed by transfer type */
block|}
name|cvmx_usb_internal_state_t
typedef|;
end_typedef

begin_comment
comment|/* This macro logs out whenever a function is called if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_LOG_CALLED
parameter_list|()
define|\
value|if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \         cvmx_dprintf("%*s%s: called\n", 2*usb->indent++, "", __FUNCTION__);
end_define

begin_comment
comment|/* This macro logs out each function parameter if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_LOG_PARAM
parameter_list|(
name|format
parameter_list|,
name|param
parameter_list|)
define|\
value|if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \         cvmx_dprintf("%*s%s: param %s = " format "\n", 2*usb->indent, "", __FUNCTION__, #param, param);
end_define

begin_comment
comment|/* This macro logs out when a function returns a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_RETURN
parameter_list|(
name|v
parameter_list|)
define|\
value|do {                                                                \         __typeof(v) r = v;                                              \         if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \             cvmx_dprintf("%*s%s: returned %s(%d)\n", 2*--usb->indent, "", __FUNCTION__, #v, r); \         return r;                                                       \     } while (0);
end_define

begin_comment
comment|/* This macro logs out when a function doesn't return a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_RETURN_NOTHING
parameter_list|()
define|\
value|do {                                                                \         if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \             cvmx_dprintf("%*s%s: returned\n", 2*--usb->indent, "", __FUNCTION__); \         return;                                                         \     } while (0);
end_define

begin_comment
comment|/* This macro spins on a field waiting for it to reach a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_WAIT_FOR_FIELD32
parameter_list|(
name|address
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|op
parameter_list|,
name|value
parameter_list|,
name|timeout_usec
parameter_list|)
define|\
value|({int result;                                                       \     do {                                                                \         uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec *     \                            cvmx_sysinfo_get()->cpu_clock_hz / 1000000;  \         type c;                                                         \         while (1)                                                       \         {                                                               \             c.u32 = __cvmx_usb_read_csr32(usb, address);                \             if (c.s.field op (value)) {                                 \                 result = 0;                                             \                 break;                                                  \             } else if (cvmx_get_cycle()> done) {                       \                 result = -1;                                            \                 break;                                                  \             } else                                                      \                 cvmx_wait(100);                                         \         }                                                               \     } while (0);                                                        \     result;})
end_define

begin_comment
comment|/* This macro logically sets a single field in a CSR. It does the sequence     read, modify, and write */
end_comment

begin_define
define|#
directive|define
name|USB_SET_FIELD32
parameter_list|(
name|address
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|do {                                            \         type c;                                     \         c.u32 = __cvmx_usb_read_csr32(usb, address);\         c.s.field = value;                          \         __cvmx_usb_write_csr32(usb, address, c.u32);\     } while (0)
end_define

begin_comment
comment|/**  * @INTERNAL  * Read a USB 32bit CSR. It performs the necessary address swizzle  * for 32bit CSRs and logs the value in a readable format if  * debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|__cvmx_usb_read_csr32
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|)
block|{
name|uint32_t
name|result
init|=
name|cvmx_read64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|)
decl_stmt|;
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Read: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a USB 32bit CSR. It performs the necessary address  * swizzle for 32bit CSRs and logs the value in a readable format  * if debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to write  * @param value   Value to write  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_write_csr32
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Write: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cvmx_write64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Read a USB 64bit CSR. It logs the value in a readable format if  * debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_usb_read_csr64
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|)
block|{
name|uint64_t
name|result
init|=
name|cvmx_read64_uint64
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Read: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a USB 64bit CSR. It logs the value in a readable format  * if debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to write  * @param value   Value to write  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_write_csr64
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Write: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cvmx_write64_uint64
argument_list|(
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Uitility function to convert complete codes into strings  *  * @param complete_code  *               Code to convert  *  * @return Human readable string  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|__cvmx_usb_complete_to_string
parameter_list|(
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
switch|switch
condition|(
name|complete_code
condition|)
block|{
case|case
name|CVMX_USB_COMPLETE_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|CVMX_USB_COMPLETE_SHORT
case|:
return|return
literal|"SHORT"
return|;
case|case
name|CVMX_USB_COMPLETE_CANCEL
case|:
return|return
literal|"CANCEL"
return|;
case|case
name|CVMX_USB_COMPLETE_ERROR
case|:
return|return
literal|"ERROR"
return|;
case|case
name|CVMX_USB_COMPLETE_STALL
case|:
return|return
literal|"STALL"
return|;
case|case
name|CVMX_USB_COMPLETE_XACTERR
case|:
return|return
literal|"XACTERR"
return|;
case|case
name|CVMX_USB_COMPLETE_DATATGLERR
case|:
return|return
literal|"DATATGLERR"
return|;
case|case
name|CVMX_USB_COMPLETE_BABBLEERR
case|:
return|return
literal|"BABBLEERR"
return|;
case|case
name|CVMX_USB_COMPLETE_FRAMEERR
case|:
return|return
literal|"FRAMEERR"
return|;
block|}
return|return
literal|"Update __cvmx_usb_complete_to_string"
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return non zero if this pipe connects to a non HIGH speed  * device through a high speed hub.  *  * @param usb    USB block this access is for  * @param pipe   Pipe to check  *  * @return Non zero if we need to do split transactions  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_pipe_needs_split
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pipe
operator|->
name|device_speed
operator|!=
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Trivial utility function to return the correct PID for a pipe  *  * @param pipe   pipe to check  *  * @return PID for pipe  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_data_pid
parameter_list|(
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
operator|->
name|pid_toggle
condition|)
return|return
literal|2
return|;
comment|/* Data1 */
else|else
return|return
literal|0
return|;
comment|/* Data0 */
block|}
end_function

begin_comment
comment|/**  * Return the number of USB ports supported by this Octeon  * chip. If the chip doesn't support USB, or is not supported  * by this API, a zero will be returned. Most Octeon chips  * support one usb port, but some support two ports.  * cvmx_usb_initialize() must be called on independent  * cvmx_usb_state_t structures.  *  * This utilizes cvmx_helper_board_usb_get_num_ports()  * to get any board specific variatons.  *  * @return Number of port, zero if usb isn't supported  */
end_comment

begin_function
name|int
name|cvmx_usb_get_num_ports
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|arch_ports
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|0
expr_stmt|;
comment|/* This chip has USB but it doesn't support DMA */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|0
expr_stmt|;
else|else
name|arch_ports
operator|=
literal|1
expr_stmt|;
return|return
name|__cvmx_helper_board_usb_get_num_ports
argument_list|(
name|arch_ports
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Allocate a usb transaction for use  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  *  * @return Transaction or NULL  */
end_comment

begin_function
specifier|static
specifier|inline
name|cvmx_usb_transaction_t
modifier|*
name|__cvmx_usb_alloc_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|usb
operator|->
name|free_transaction_head
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|usb
operator|->
name|free_transaction_head
operator|=
name|t
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|usb
operator|->
name|free_transaction_head
condition|)
name|usb
operator|->
name|free_transaction_tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Failed to allocate a transaction\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a usb transaction  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param transaction  *               Transaction to free  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_free_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|)
block|{
name|transaction
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|transaction
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|free_transaction_tail
condition|)
name|usb
operator|->
name|free_transaction_tail
operator|->
name|next
operator|=
name|transaction
expr_stmt|;
else|else
name|usb
operator|->
name|free_transaction_head
operator|=
name|transaction
expr_stmt|;
name|usb
operator|->
name|free_transaction_tail
operator|=
name|transaction
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Add a pipe to the tail of a list  * @param list   List to add pipe to  * @param pipe   Pipe to add  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_append_pipe
parameter_list|(
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|list
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|tail
condition|)
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|pipe
expr_stmt|;
else|else
name|list
operator|->
name|head
operator|=
name|pipe
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|pipe
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Remove a pipe from a list  * @param list   List to remove pipe from  * @param pipe   Pipe to remove  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_remove_pipe
parameter_list|(
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|list
operator|->
name|head
operator|==
name|pipe
condition|)
block|{
name|list
operator|->
name|head
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|head
condition|)
name|list
operator|->
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
else|else
name|list
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list
operator|->
name|tail
operator|==
name|pipe
condition|)
block|{
name|list
operator|->
name|tail
operator|=
name|pipe
operator|->
name|prev
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pipe
operator|->
name|prev
operator|->
name|next
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
name|pipe
operator|->
name|next
operator|->
name|prev
operator|=
name|pipe
operator|->
name|prev
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Perfrom USB device mode initialization after a reset completes.  * This should be called after USBC0/1_GINTSTS[USBRESET] and  * coresponds to section 22.6.1.1, "Initialization on USB Reset",  * in the manual.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
specifier|static
name|cvmx_usb_status_t
name|__cvmx_usb_device_reset_complete
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_ghwcfg3_t
name|usbcx_ghwcfg3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
comment|/* 1. Set USBC0/1_DOEPCTLn[SNAK] = 1 (for all OUT endpoints, n = 0-4). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doepctlx_t
argument_list|,
name|snak
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 2. Unmask the following interrupt bits:         USBC0/1_DAINTMSK[INEPMSK] = 1 (control 0 IN endpoint)         USBC0/1_DAINTMSK[OUTEPMSK] = 1 (control 0 OUT endpoint)         USBC0/1_DOEPMSK[SETUPMSK] = 1         USBC0/1_DOEPMSK[XFERCOMPLMSK] = 1         USBC0/1_DIEPMSK[XFERCOMPLMSK] = 1         USBC0/1_DIEPMSK[TIMEOUTMSK] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_daintmsk_t
argument_list|,
name|inepmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_daintmsk_t
argument_list|,
name|outepmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doepmsk_t
argument_list|,
name|setupmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doepmsk_t
argument_list|,
name|xfercomplmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DIEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_diepmsk_t
argument_list|,
name|xfercomplmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DIEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_diepmsk_t
argument_list|,
name|timeoutmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 3. To transmit or receive data, the device must initialize more         registers as specified in Section 22.6.1.7 */
comment|/* Nothing needed */
comment|/* 4. Set up the data FIFO RAM for each of the FIFOs:         Program USBC0/1_GRXFSIZ to be able to receive control OUT data and         SETUP data. This must equal at least one maximum packet size of         control endpoint 0 + 2 Dwords (for the status of the control OUT         data packet) + 10 Dwords (for SETUP packets).         Program USBC0/1_GNPTXFSIZ to be able to transmit control IN data. This         must equal at least one maximum packet size of control endpoint 0. */
comment|/* Read the HWCFG3 register so we know how much space is in the FIFO */
name|usbcx_ghwcfg3
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GHWCFG3
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|cvmx_usbcx_gnptxfsiz_t
name|gnptxfsiz
decl_stmt|;
name|int
name|fifo_space
init|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Start at the top of the FIFO and assign space for each periodic             fifo */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cvmx_usbcx_dptxfsizx_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DPTXFSIZX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|fifo_space
operator|-=
name|siz
operator|.
name|s
operator|.
name|dptxfsize
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|dptxfstaddr
operator|=
name|fifo_space
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DPTXFSIZX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Assign half the leftover space to the non periodic tx fifo */
name|gnptxfsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfdep
operator|=
name|fifo_space
operator|/
literal|2
expr_stmt|;
name|fifo_space
operator|-=
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfdep
expr_stmt|;
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfstaddr
operator|=
name|fifo_space
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|gnptxfsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Assign the remain space to the RX fifo */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grxfsiz_t
argument_list|,
name|rxfdep
argument_list|,
name|fifo_space
argument_list|)
expr_stmt|;
block|}
comment|/* 5. Program the following fields in the endpoint-specific registers for         control OUT endpoint 0 to receive a SETUP packet         USBC0/1_DOEPTSIZ0[SUPCNT] = 0x3 (to receive up to three back-to-back         SETUP packets)         In DMA mode, USBC0/1_DOEPDMA0 register with a memory address to         store any SETUP packets received */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPTSIZX
argument_list|(
literal|0
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doeptsizx_t
argument_list|,
name|mc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|// FIXME
comment|/* At this point, all initialization required to receive SETUP packets is         done. */
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize a USB port for use. This must be called before any  * other access to the Octeon USB port is made. The port starts  * off in the disabled state.  *  * @param state  Pointer to an empty cvmx_usb_state_t structure  *               that will be populated by the initialize call.  *               This structure is then passed to all other USB  *               functions.  * @param usb_port_number  *               Which Octeon USB port to initialize.  * @param flags  Flags to control hardware initialization. See  *               cvmx_usb_initialize_flags_t for the flag  *               definitions. Some flags are mandatory.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_initialize
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|usb_port_number
parameter_list|,
name|cvmx_usb_initialize_flags_t
name|flags
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
name|cvmx_usbnx_usbp_ctl_status_t
name|usbn_usbp_ctl_status
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|usb
operator|->
name|init_flags
operator|=
name|flags
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|usb_port_number
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Make sure that state is large enough to store the internal state */
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|usb
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* At first allow 0-1 for the usb port number */
if|if
condition|(
operator|(
name|usb_port_number
operator|<
literal|0
operator|)
operator|||
operator|(
name|usb_port_number
operator|>
literal|1
operator|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* For all chips except 52XX there is only one port */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
name|usb_port_number
operator|>
literal|0
operator|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Try to determine clock type automatically */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI
operator||
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
operator|==
name|USB_CLOCK_TYPE_CRYSTAL_12
condition|)
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI
expr_stmt|;
comment|/* Only 12 MHZ crystals are supported */
else|else
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* Check for auto ref clock frequency */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
operator|)
condition|)
switch|switch
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
condition|)
block|{
case|case
name|USB_CLOCK_TYPE_REF_12
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_24
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_48
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ
expr_stmt|;
break|break;
default|default:
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|memset
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|usb
argument_list|)
argument_list|)
expr_stmt|;
name|usb
operator|->
name|init_flags
operator|=
name|flags
expr_stmt|;
comment|/* Initialize the USB state structure */
block|{
name|int
name|i
decl_stmt|;
name|usb
operator|->
name|index
operator|=
name|usb_port_number
expr_stmt|;
comment|/* Initialize the transaction double linked list */
name|usb
operator|->
name|free_transaction_head
operator|=
name|NULL
expr_stmt|;
name|usb
operator|->
name|free_transaction_tail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TRANSACTIONS
condition|;
name|i
operator|++
control|)
name|__cvmx_usb_free_transaction
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|transaction
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PIPES
condition|;
name|i
operator|++
control|)
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|usb
operator|->
name|pipe
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Power On Reset and PHY Initialization */
comment|/* 1. Wait for DCOK to assert (nothing to do) */
comment|/* 2a. Write USBN0/1_CLK_CTL[POR] = 1 and         USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0 */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* 2b. Select the USB reference clock/crystal parameters by writing         appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON] */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* The USB port uses 12/24/48MHz 2.5V board clock             source at USB_XO. USB_XI should be tied to GND.             Most Octeon evaluation boards require this setting */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|2
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|1
expr_stmt|;
comment|/* From CN52XX manual */
switch|switch
condition|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
condition|)
block|{
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* The USB port uses a 12MHz crystal as clock source             at USB_XO and USB_XI */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN52XX manual */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and         setting USBN0/1_CLK_CTL[ENABLE] = 1.  Divide the core clock down such         that USB is as close as possible to 125Mhz */
block|{
name|int
name|divisor
init|=
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|+
literal|125000000
operator|-
literal|1
operator|)
operator|/
literal|125000000
decl_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|4
condition|)
comment|/* Lower than 4 doesn't seem to work properly */
name|divisor
operator|=
literal|4
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide
operator|=
name|divisor
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide2
operator|=
literal|0
expr_stmt|;
block|}
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
name|cvmx_wait
argument_list|(
literal|64
argument_list|)
expr_stmt|;
comment|/* 3. Program the power-on reset field in the USBN clock-control register:         USBN_CLK_CTL[POR] = 0 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 4. Wait 1 ms for PHY clock to start */
name|cvmx_wait_usec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 5. Program the Reset input from automatic test equipment field in the         USBP control and status register: USBN_USBP_CTL_STATUS[ATE_RESET] = 1 */
name|usbn_usbp_ctl_status
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 6. Wait 10 cycles */
name|cvmx_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 7. Clear ATE_RESET field in the USBN clock-control register:         USBN_USBP_CTL_STATUS[ATE_RESET] = 0 */
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 8. Program the PHY reset field in the USBN clock-control register:         USBN_CLK_CTL[PRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 9. Program the USBP control and status register to select host or         device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for         device */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
condition|)
block|{
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|hst_mode
operator|=
literal|1
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|dm_pulld
operator|=
literal|0
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|dp_pulld
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|hst_mode
operator|=
literal|0
expr_stmt|;
block|}
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 10. Wait 1 µs */
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 11. Program the hreset_n field in the USBN clock-control register:         USBN_CLK_CTL[HRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 12. Proceed to USB core initialization */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* USB Core Initialization */
comment|/* 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to         determine USB core configuration parameters. */
comment|/* Nothing needed */
comment|/* 2. Program the following fields in the global AHB configuration         register (USBC_GAHBCFG)         DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode         Burst length, USBC_GAHBCFG[HBSTLEN] = 0         Nonperiodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[NPTXFEMPLVL]         Periodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[PTXFEMPLVL]         Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1 */
block|{
name|cvmx_usbcx_gahbcfg_t
name|usbcx_gahbcfg
decl_stmt|;
name|usbcx_gahbcfg
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|dmaen
operator|=
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
expr_stmt|;
comment|/* If we are using DMA, start off with 8 idle channels. Without             DMA we emulate a single channel */
if|if
condition|(
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|dmaen
condition|)
name|usb
operator|->
name|idle_hardware_channels
operator|=
literal|0xff
expr_stmt|;
else|else
name|usb
operator|->
name|idle_hardware_channels
operator|=
literal|0x1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|hbstlen
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|nptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|ptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|glblintrmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GAHBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gahbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Program the following fields in USBC_GUSBCFG register.         HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0         ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0         USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5         PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0 */
block|{
name|cvmx_usbcx_gusbcfg_t
name|usbcx_gusbcfg
decl_stmt|;
name|usbcx_gusbcfg
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|toutcal
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|ddrsel
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|usbtrdtim
operator|=
literal|0x5
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|phylpwrclksel
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gusbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 4. The software must unmask the following bits in the USBC_GINTMSK         register.         OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1         Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1 */
block|{
name|cvmx_usbcx_gintmsk_t
name|usbcx_gintmsk
decl_stmt|;
name|cvmx_usbcx_hcintmskx_t
name|usbc_hcintmsk
decl_stmt|;
name|cvmx_usbcx_haintmsk_t
name|usbc_haintmsk
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|usbcx_gintmsk
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|otgintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|modemismsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|hchintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|sofmsk
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Enable the channel halt interrupt */
name|usbc_hcintmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|chhltdmsk
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
literal|8
condition|;
name|channel
operator|++
control|)
if|if
condition|(
name|usb
operator|->
name|idle_hardware_channels
operator|&
operator|(
literal|1
operator|<<
name|channel
operator|)
condition|)
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTMSKX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Enable the channel interrupt to propagate */
name|usbc_haintmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_haintmsk
operator|.
name|s
operator|.
name|haintmsk
operator|=
name|usb
operator|->
name|idle_hardware_channels
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_haintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Host Port Initialization */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d is in host mode\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* 1. Program the host-port interrupt-mask field to unmask,             USBC_GINTMSK[PRTINT] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|prtintmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|disconnintmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 2. Program the USBC_HCFG register to select full-speed host or             high-speed host. */
block|{
name|cvmx_usbcx_hcfg_t
name|usbcx_hcfg
decl_stmt|;
name|usbcx_hcfg
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_hcfg
operator|.
name|s
operator|.
name|fslssupp
operator|=
literal|0
expr_stmt|;
name|usbcx_hcfg
operator|.
name|s
operator|.
name|fslspclksel
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_hcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Program the port power bit to drive VBUS on the USB,             USBC_HPRT[PRTPWR] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtpwr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps 4-15 from the manual are done later in the port enable */
block|}
else|else
block|{
comment|/* Device Port Initialization */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d is in device mode\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* 1. Program the following fields in the USBC0/1_DCFG register:             Device speed, USBC0/1_DCFG[DEVSPD] = 0 (high speed)             Non-zero-length status OUT handshake, USBC0/1_DCFG[NZSTSOUTHSHK]=0             Periodic frame interval (if periodic endpoints are supported),             USBC0/1_DCFG[PERFRINT] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_dcfg_t
argument_list|,
name|devspd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_dcfg_t
argument_list|,
name|nzstsouthshk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_dcfg_t
argument_list|,
name|perfrint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 2. Program the USBC0/1_GINTMSK register to unmask the following             interrupts:             USB Reset, USBC0/1_GINTMSK[USBRSTMSK] = 1             Enumeration done, USBC0/1_GINTMSK[ENUMDONEMSK] = 1             SOF, USBC0/1_GINTMSK[SOFMSK] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|usbrstmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|enumdonemsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|sofmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 3. Wait for the USBC0/1_GINTSTS[USBRESET] interrupt, which             indicates a reset has been detected on the USB and lasts for             about 10 ms. On receiving this interrupt, the application must             perform the steps listed in Section 22.6.1.1, "Initialization on             USB Reset". */
comment|/* Handled in cvmx_poll() usbc_gintsts.s.usbrst processing */
comment|/* 4. Wait for the USBC0/1_GINTSTS[ENUMERATIONDONE] interrupt, which             indicates the end of reset on the USB. On receiving this interrupt,             the application must read the USBC0/1_DSTS register to determine             the enumeration speed and perform the steps listed in Section             22.6.1.2, "Initialization on Enumeration Completion". */
comment|/* Handled in cvmx_poll() usbc_gintsts.s.enumdone processing */
block|}
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Shutdown a USB port after a call to cvmx_usb_initialize().  * The port should be disabled with all pipes closed when this  * function is called.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_shutdown
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Make sure all pipes are closed */
if|if
condition|(
name|usb
operator|->
name|idle_pipes
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_ISOCHRONOUS
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_INTERRUPT
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_CONTROL
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_BULK
index|]
operator|.
name|head
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_BUSY
argument_list|)
expr_stmt|;
comment|/* Disable the clocks and put them in power on reset */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable a USB port. After this call succeeds, the USB port is  * online and servicing requests.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_enable
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_ghwcfg3_t
name|usbcx_ghwcfg3
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
name|usb
operator|->
name|usbcx_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the port is already enabled the just return. We don't need to do         anything */
if|if
condition|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtena
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
comment|/* If there is nothing plugged into the port then fail immediately */
if|if
condition|(
operator|!
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtconnsts
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d Nothing plugged into the port\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Program the port reset bit to start the reset process */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtrst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait at least 50ms (high speed), or 10ms (full speed) for the reset         process to complete. */
name|cvmx_wait_usec
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtrst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the USBC_HPRT[PRTENA]. */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtena
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|100000
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Timeout waiting for the port to finish reset\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Read the port speed field to get the enumerated speed, USBC_HPRT[PRTSPD]. */
name|usb
operator|->
name|usbcx_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d is in %s speed mode\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|,
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
condition|?
literal|"high"
else|:
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_FULL
operator|)
condition|?
literal|"full"
else|:
literal|"low"
argument_list|)
expr_stmt|;
name|usbcx_ghwcfg3
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GHWCFG3
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 13. Program the USBC_GRXFSIZ register to select the size of the receive         FIFO (25%). */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grxfsiz_t
argument_list|,
name|rxfdep
argument_list|,
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* 14. Program the USBC_GNPTXFSIZ register to select the size and the         start address of the non- periodic transmit FIFO for nonperiodic         transactions (50%). */
block|{
name|cvmx_usbcx_gnptxfsiz_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|nptxfdep
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|2
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|nptxfstaddr
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 15. Program the USBC_HPTXFSIZ register to select the size and start         address of the periodic transmit FIFO for periodic transactions (25%). */
block|{
name|cvmx_usbcx_hptxfsiz_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|ptxfsize
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|ptxfstaddr
operator|=
literal|3
operator|*
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Flush all FIFOs */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfnum
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfflsh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfflsh
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|rxfflsh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|rxfflsh
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Disable a USB port. After this call the USB port will not  * generate data transfers and will not generate events.  * Transactions in process will fail and call their  * associated callbacks.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_disable
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
comment|/* Disable the port */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtena
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the current state of the USB port. Use this call to  * determine if the usb port has anything connected, is enabled,  * or has some sort of error condition. The return value of this  * call has "changed" bits to signal of the value of some fields  * have changed between calls. These "changed" fields are based  * on the last call to cvmx_usb_set_status(). In order to clear  * them, you must update the status through cvmx_usb_set_status().  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return Port status information  */
end_comment

begin_function
name|cvmx_usb_port_status_t
name|cvmx_usb_get_status
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_hprt_t
name|usbc_hprt
decl_stmt|;
name|cvmx_usb_port_status_t
name|result
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usbc_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|port_enabled
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtena
expr_stmt|;
name|result
operator|.
name|port_over_current
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtovrcurract
expr_stmt|;
name|result
operator|.
name|port_powered
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtpwr
expr_stmt|;
name|result
operator|.
name|port_speed
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtspd
expr_stmt|;
name|result
operator|.
name|connected
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtconnsts
expr_stmt|;
name|result
operator|.
name|connect_change
operator|=
operator|(
name|result
operator|.
name|connected
operator|!=
name|usb
operator|->
name|port_status
operator|.
name|connected
operator|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: returned port enabled=%d, over_current=%d, powered=%d, speed=%d, connected=%d, connect_change=%d\n"
argument_list|,
literal|2
operator|*
operator|(
operator|--
name|usb
operator|->
name|indent
operator|)
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|result
operator|.
name|port_enabled
argument_list|,
name|result
operator|.
name|port_over_current
argument_list|,
name|result
operator|.
name|port_powered
argument_list|,
name|result
operator|.
name|port_speed
argument_list|,
name|result
operator|.
name|connected
argument_list|,
name|result
operator|.
name|connect_change
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Set the current state of the USB port. The status is used as  * a reference for the "changed" bits returned by  * cvmx_usb_get_status(). Other than serving as a reference, the  * status passed to this function is not used. No fields can be  * changed through this call.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param port_status  *               Port status to set, most like returned by cvmx_usb_get_status()  */
end_comment

begin_function
name|void
name|cvmx_usb_set_status
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_port_status_t
name|port_status
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usb
operator|->
name|port_status
operator|=
name|port_status
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Convert a USB transaction into a handle  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param transaction  *               Transaction to get handle for  *  * @return Handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_submit_handle
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|transaction
operator|-
operator|(
name|unsigned
name|long
operator|)
name|usb
operator|->
name|transaction
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|transaction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Convert a USB pipe into a handle  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe to get handle for  *  * @return Handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_pipe_handle
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pipe
operator|-
operator|(
name|unsigned
name|long
operator|)
name|usb
operator|->
name|pipe
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pipe
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Open a virtual pipe between the host and a USB device. A pipe  * must be opened before data can be transferred between a device  * and Octeon.  *  * @param state      USB device state populated by  *                   cvmx_usb_initialize().  * @param flags      Optional pipe flags defined in  *                   cvmx_usb_pipe_flags_t.  * @param device_addr  *                   USB device address to open the pipe to  *                   (0-127).  * @param endpoint_num  *                   USB endpoint number to open the pipe to  *                   (0-15).  * @param device_speed  *                   The speed of the device the pipe is going  *                   to. This must match the device's speed,  *                   which may be different than the port speed.  * @param max_packet The maximum packet length the device can  *                   transmit/receive (low speed=0-8, full  *                   speed=0-1023, high speed=0-1024). This value  *                   comes from the stadnard endpoint descriptor  *                   field wMaxPacketSize bits<10:0>.  * @param transfer_type  *                   The type of transfer this pipe is for.  * @param transfer_dir  *                   The direction the pipe is in. This is not  *                   used for control pipes.  * @param interval   For ISOCHRONOUS and INTERRUPT transfers,  *                   this is how often the transfer is scheduled  *                   for. All other transfers should specify  *                   zero. The units are in frames (8000/sec at  *                   high speed, 1000/sec for full speed).  * @param multi_count  *                   For high speed devices, this is the maximum  *                   allowed number of packet per microframe.  *                   Specify zero for non high speed devices. This  *                   value comes from the stadnard endpoint descriptor  *                   field wMaxPacketSize bits<12:11>.  * @param hub_device_addr  *                   Hub device address this device is connected  *                   to. Devices connected directly to Octeon  *                   use zero. This is only used when the device  *                   is full/low speed behind a high speed hub.  *                   The address will be of the high speed hub,  *                   not and full speed hubs after it.  * @param hub_port   Which port on the hub the device is  *                   connected. Use zero for devices connected  *                   directly to Octeon. Like hub_device_addr,  *                   this is only used for full/low speed  *                   devices behind a high speed hub.  *  * @return A non negative value is a pipe handle. Negative  *         values are failure codes from cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_open_pipe
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_pipe_flags_t
name|flags
parameter_list|,
name|int
name|device_addr
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|cvmx_usb_speed_t
name|device_speed
parameter_list|,
name|int
name|max_packet
parameter_list|,
name|cvmx_usb_transfer_t
name|transfer_type
parameter_list|,
name|cvmx_usb_direction_t
name|transfer_dir
parameter_list|,
name|int
name|interval
parameter_list|,
name|int
name|multi_count
parameter_list|,
name|int
name|hub_device_addr
parameter_list|,
name|int
name|hub_port
parameter_list|)
block|{
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|device_addr
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|device_speed
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|max_packet
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_type
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_dir
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|multi_count
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|hub_device_addr
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|hub_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|device_addr
operator|<
literal|0
operator|)
operator|||
operator|(
name|device_addr
operator|>
name|MAX_USB_ADDRESS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|endpoint_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|endpoint_num
operator|>
name|MAX_USB_ENDPOINT
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|device_speed
operator|>
name|CVMX_USB_SPEED_LOW
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|max_packet
operator|<=
literal|0
operator|)
operator|||
operator|(
name|max_packet
operator|>
literal|1024
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|transfer_type
operator|>
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|interval
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_CONTROL
operator|)
operator|&&
name|interval
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|multi_count
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|device_speed
operator|!=
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|multi_count
operator|!=
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|hub_device_addr
operator|<
literal|0
operator|)
operator|||
operator|(
name|hub_device_addr
operator|>
name|MAX_USB_ADDRESS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|hub_port
operator|<
literal|0
operator|)
operator|||
operator|(
name|hub_port
operator|>
name|MAX_USB_HUB_PORT
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
comment|/* Find a free pipe */
name|pipe
operator|=
name|usb
operator|->
name|free_pipes
operator|.
name|head
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_NO_MEMORY
argument_list|)
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|flags
operator|=
name|flags
operator||
name|__CVMX_USB_PIPE_FLAGS_OPEN
expr_stmt|;
if|if
condition|(
operator|(
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
name|pipe
operator|->
name|device_addr
operator|=
name|device_addr
expr_stmt|;
name|pipe
operator|->
name|endpoint_num
operator|=
name|endpoint_num
expr_stmt|;
name|pipe
operator|->
name|device_speed
operator|=
name|device_speed
expr_stmt|;
name|pipe
operator|->
name|max_packet
operator|=
name|max_packet
expr_stmt|;
name|pipe
operator|->
name|transfer_type
operator|=
name|transfer_type
expr_stmt|;
name|pipe
operator|->
name|transfer_dir
operator|=
name|transfer_dir
expr_stmt|;
comment|/* All pipes use interval to rate limit NAK processing. Force an interval         if one wasn't supplied */
if|if
condition|(
operator|!
name|interval
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
condition|)
name|pipe
operator|->
name|interval
operator|=
operator|(
name|uint64_t
operator|)
name|interval
operator|*
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|8000
expr_stmt|;
else|else
name|pipe
operator|->
name|interval
operator|=
operator|(
name|uint64_t
operator|)
name|interval
operator|*
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000
expr_stmt|;
name|pipe
operator|->
name|multi_count
operator|=
name|multi_count
expr_stmt|;
name|pipe
operator|->
name|hub_device_addr
operator|=
name|hub_device_addr
expr_stmt|;
name|pipe
operator|->
name|hub_port
operator|=
name|hub_port
expr_stmt|;
name|pipe
operator|->
name|pid_toggle
operator|=
literal|0
expr_stmt|;
name|pipe
operator|->
name|next_tx_cycle
operator|=
name|cvmx_read64_uint64
argument_list|(
name|CVMX_IPD_CLK_COUNT
argument_list|)
operator|+
name|pipe
operator|->
name|interval
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* We don't need to tell the hardware about this pipe yet since         it doesn't have any submitted requests */
name|CVMX_USB_RETURN
argument_list|(
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Perform channel specific setup for Control transactions. All  * the generic stuff will already have been done in  * __cvmx_usb_start_channel()  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  * @param channel Channel to setup  * @param pipe    Pipe for control transaction  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_start_channel_control
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
name|int
name|bytes_to_transfer
init|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transaction
operator|->
name|stage
condition|)
block|{
case|case
name|CVMX_USB_STAGE_NON_CONTROL
case|:
case|case
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
case|:
name|cvmx_dprintf
argument_list|(
literal|"%s: ERROR - Non control stage\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
literal|3
expr_stmt|;
comment|/* Setup */
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
comment|/* All Control operations start with a setup going OUT */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
name|CVMX_USB_DIRECTION_OUT
argument_list|)
expr_stmt|;
comment|/* Setup send the control header instead of the buffer data. The                 buffer data will be used in the next stage */
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|transaction
operator|->
name|control_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
literal|3
expr_stmt|;
comment|/* Setup */
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
literal|0
expr_stmt|;
comment|/* All Control operations start with a setup going OUT */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
name|CVMX_USB_DIRECTION_OUT
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_DATA
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
literal|0
else|:
name|bytes_to_transfer
expr_stmt|;
if|if
condition|(
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|>
name|pipe
operator|->
name|max_packet
condition|)
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
else|else
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|bytes_to_transfer
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_IN
else|:
name|CVMX_USB_DIRECTION_OUT
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|bytes_to_transfer
else|:
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_IN
else|:
name|CVMX_USB_DIRECTION_OUT
operator|)
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_OUT
else|:
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_OUT
else|:
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Set the number of packets needed for this transfer */
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|+
name|pipe
operator|->
name|max_packet
operator|-
literal|1
operator|)
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
if|if
condition|(
operator|!
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
condition|)
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hctsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Start a channel to perform the pipe's head transaction  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  * @param channel Channel to setup  * @param pipe    Pipe to start  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_start_channel
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Channel %d started. Pipe %d transaction %d stage %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|channel
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|transaction
operator|->
name|stage
argument_list|)
expr_stmt|;
comment|/* Make sure all writes to the DMA region get flushed */
name|CVMX_SYNCW
expr_stmt|;
comment|/* Read the current frame number for use with split, INTERRUPT,  and ISO         transactions */
name|usbc_hfnum
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HFNUM
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attach the channel to the pipe */
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
operator|=
name|pipe
expr_stmt|;
name|pipe
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
comment|/* Mark this channel as in use */
name|usb
operator|->
name|idle_hardware_channels
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
comment|/* Enable the channel interrupt bits */
block|{
name|cvmx_usbcx_hcintx_t
name|usbc_hcint
decl_stmt|;
comment|/* Clear all channel status bits */
name|usbc_hcint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcint
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the locations the DMA engines use  */
block|{
name|uint64_t
name|dma_address
init|=
name|transaction
operator|->
name|buffer
operator|+
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|dma_address
operator|=
name|transaction
operator|->
name|buffer
operator|+
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|offset
operator|+
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|dma_address
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|dma_address
argument_list|)
expr_stmt|;
block|}
comment|/* Setup both the size of the transfer and the SPLIT characteristics */
block|{
name|cvmx_usbcx_hcspltx_t
name|usbc_hcsplt
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
name|int
name|bytes_to_transfer
init|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
comment|/* ISOCHRONOUS transactions store each individual transfer size in the             packet structure, not the global buffer_length */
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|bytes_to_transfer
operator|=
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* We need to do split transactions when we are talking to non high             speed devices that are behind a high speed hub */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* On the start split phase (stage is even) record the frame number we                 will need to send the split complete. We only store the lower two bits                 since the time ahead can only be two frames */
if|if
condition|(
operator|(
name|transaction
operator|->
name|stage
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_BULK
condition|)
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|(
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
operator|+
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
else|else
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|(
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
operator|+
literal|2
operator|)
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|spltena
operator|=
literal|1
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|hubaddr
operator|=
name|pipe
operator|->
name|hub_device_addr
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|prtaddr
operator|=
name|pipe
operator|->
name|hub_port
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|compsplt
operator|=
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
operator|)
expr_stmt|;
comment|/* SPLIT transactions can only ever transmit one data packet so                 limit the transfer size to the max packet size */
if|if
condition|(
name|bytes_to_transfer
operator|>
name|pipe
operator|->
name|max_packet
condition|)
name|bytes_to_transfer
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
comment|/* ISOCHRONOUS OUT splits are unique in that they limit                 data transfers to 188 byte chunks representing the                 begin/middle/end of the data or all */
if|if
condition|(
operator|!
name|usbc_hcsplt
operator|.
name|s
operator|.
name|compsplt
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
operator|)
condition|)
block|{
comment|/* See if we've started this tranfer and sent data */
if|if
condition|(
name|transaction
operator|->
name|actual_bytes
operator|==
literal|0
condition|)
block|{
comment|/* Nothing sent yet, this is either a begin or the                         entire payload */
if|if
condition|(
name|bytes_to_transfer
operator|<=
literal|188
condition|)
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|3
expr_stmt|;
comment|/* Entire payload in one go */
else|else
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|2
expr_stmt|;
comment|/* First part of payload */
block|}
else|else
block|{
comment|/* Continuing the previous data, we must either be                         in the middle or at the end */
if|if
condition|(
name|bytes_to_transfer
operator|<=
literal|188
condition|)
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|1
expr_stmt|;
comment|/* End of payload */
else|else
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|0
expr_stmt|;
comment|/* Middle of payload */
block|}
comment|/* Again, the transfer size is limited to 188 bytes */
if|if
condition|(
name|bytes_to_transfer
operator|>
literal|188
condition|)
name|bytes_to_transfer
operator|=
literal|188
expr_stmt|;
block|}
block|}
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|bytes_to_transfer
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|bytes_to_transfer
operator|+
name|pipe
operator|->
name|max_packet
operator|-
literal|1
operator|)
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
if|if
condition|(
operator|!
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
condition|)
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
comment|/* Update the DATA0/DATA1 toggle */
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
comment|/* High speed pipes may need a hardware ping before they start */
if|if
condition|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
condition|)
name|usbc_hctsiz
operator|.
name|s
operator|.
name|dopng
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcsplt
operator|.
name|u32
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hctsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the Host Channel Characteristics Register */
block|{
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
comment|/* Make all transfers start on the next frame and not this one. This             way the time we spend processing doesn't affect USB timing */
name|usbc_hcchar
operator|.
name|s
operator|.
name|oddfrm
operator|=
operator|!
operator|(
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Set the number of back to back packets allowed by this endpoint.             Split transactions interpret "ec" as the number of immediate             retries of failure. These retries happen too quickly, so we             disable these entirely for splits */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|<
literal|1
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|>
literal|3
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|3
expr_stmt|;
else|else
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
name|pipe
operator|->
name|multi_count
expr_stmt|;
comment|/* Set the rest of the endpoint specific settings */
name|usbc_hcchar
operator|.
name|s
operator|.
name|devaddr
operator|=
name|pipe
operator|->
name|device_addr
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|eptype
operator|=
name|transaction
operator|->
name|type
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|lspddev
operator|=
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_LOW
operator|)
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|epdir
operator|=
name|pipe
operator|->
name|transfer_dir
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|epnum
operator|=
name|pipe
operator|->
name|endpoint_num
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Do transaction type specific fixups as needed */
switch|switch
condition|(
name|transaction
operator|->
name|type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
name|__cvmx_usb_start_channel_control
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
case|case
name|CVMX_USB_TRANSFER_INTERRUPT
case|:
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
if|if
condition|(
operator|!
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* ISO transactions require differnet PIDs depending on direction                     and how many packets are needed */
if|if
condition|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
condition|)
block|{
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|<
literal|2
condition|)
comment|/* Need DATA0 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hctsizx_t
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Need MDATA */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hctsizx_t
argument_list|,
name|pid
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|{
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
init|=
block|{
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
argument|usb
argument_list|,
argument|CVMX_USBCX_HCTSIZX(channel, usb->index)
argument_list|)
block|}
decl_stmt|;
name|transaction
operator|->
name|xfersize
operator|=
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
name|transaction
operator|->
name|pktcnt
operator|=
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
expr_stmt|;
block|}
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|chena
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Find a pipe that is ready to be scheduled to hardware.  *  * @param list       Pipe list to search  * @param usbc_hfnum Current USB frame number  * @param current_cycle  *                   Cycle counter to use as a time reference.  *  * @return Pipe or NULL if none are ready  */
end_comment

begin_function
specifier|static
name|cvmx_usb_pipe_t
modifier|*
name|__cvmx_usb_find_ready_pipe
parameter_list|(
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
parameter_list|,
name|uint64_t
name|current_cycle
parameter_list|)
block|{
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|list
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|pipe
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
operator|)
operator|&&
name|pipe
operator|->
name|head
operator|&&
operator|(
name|pipe
operator|->
name|next_tx_cycle
operator|<=
name|current_cycle
operator|)
operator|&&
operator|(
operator|(
name|pipe
operator|->
name|split_sc_frame
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
operator|-
operator|(
name|int
operator|)
name|pipe
operator|->
name|split_sc_frame
operator|)
operator|&
literal|0x7f
operator|)
operator|<
literal|0x40
operator|)
operator|)
condition|)
block|{
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
operator|->
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pipe
return|;
block|}
name|pipe
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Called whenever a pipe might need to be scheduled to the  * hardware.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param is_sof True if this schedule was called on a SOF interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_schedule
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|is_sof
parameter_list|)
block|{
name|int
name|channel
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
decl_stmt|;
name|uint64_t
name|current_cycle
init|=
name|cvmx_read64_uint64
argument_list|(
name|CVMX_IPD_CLK_COUNT
argument_list|)
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|usbc_hfnum
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HFNUM
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|usb
operator|->
name|idle_hardware_channels
condition|)
block|{
comment|/* Find an idle channel */
name|CVMX_CLZ
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|idle_hardware_channels
argument_list|)
expr_stmt|;
name|channel
operator|=
literal|31
operator|-
name|channel
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|channel
operator|>
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Idle hardware channels has a channel higher than 7. This is wrong\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Find a pipe needing service */
name|pipe
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_sof
condition|)
block|{
comment|/* Only process periodic pipes on SOF interrupts. This way we are                 sure that the periodic data is sent in the beginning of the                 frame */
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|,
name|usbc_hfnum
argument_list|,
name|current_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|,
name|usbc_hfnum
argument_list|,
name|current_cycle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
block|{
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_CONTROL
argument_list|,
name|usbc_hfnum
argument_list|,
name|current_cycle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_BULK
argument_list|,
name|usbc_hfnum
argument_list|,
name|current_cycle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipe
condition|)
break|break;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
specifier|const
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
operator|(
name|transaction
operator|->
name|control_header
operator|)
condition|?
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_IN
operator|)
condition|?
literal|"IN"
else|:
literal|"OUT"
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|pipe
operator|->
name|transfer_type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
name|type
operator|=
literal|"SETUP"
expr_stmt|;
name|dir
operator|=
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
literal|"IN"
else|:
literal|"OUT"
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
name|type
operator|=
literal|"ISOCHRONOUS"
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
name|type
operator|=
literal|"BULK"
expr_stmt|;
break|break;
default|default:
comment|/* CVMX_USB_TRANSFER_INTERRUPT */
name|type
operator|=
literal|"INTERRUPT"
expr_stmt|;
break|break;
block|}
name|cvmx_dprintf
argument_list|(
literal|"%s: Starting pipe %d, transaction %d on channel %d. %s %s len=%d header=0x%llx\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|channel
argument_list|,
name|type
argument_list|,
name|dir
argument_list|,
name|transaction
operator|->
name|buffer_length
argument_list|,
operator|(
name|header
operator|)
condition|?
operator|(
name|unsigned
name|long
name|long
operator|)
name|header
operator|->
name|u64
else|:
literal|0ull
argument_list|)
expr_stmt|;
block|}
name|__cvmx_usb_start_channel
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Call a user's callback for a specific reason.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe the callback is for or NULL  * @param transaction  *               Transaction the callback is for or NULL  * @param reason Reason this callback is being called  * @param complete_code  *               Completion code for the transaction, if any  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_perform_callback
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|,
name|cvmx_usb_callback_t
name|reason
parameter_list|,
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
name|cvmx_usb_callback_func_t
name|callback
init|=
name|usb
operator|->
name|callback
index|[
name|reason
index|]
decl_stmt|;
name|void
modifier|*
name|user_data
init|=
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
decl_stmt|;
name|int
name|submit_handle
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pipe_handle
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bytes_transferred
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pipe
condition|)
name|pipe_handle
operator|=
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
condition|)
block|{
name|submit_handle
operator|=
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
name|bytes_transferred
operator|=
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* Transactions are allowed to override the default callback */
if|if
condition|(
operator|(
name|reason
operator|==
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
operator|)
operator|&&
name|transaction
operator|->
name|callback
condition|)
block|{
name|callback
operator|=
name|transaction
operator|->
name|callback
expr_stmt|;
name|user_data
operator|=
name|transaction
operator|->
name|callback_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|callback
condition|)
return|return;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: calling callback %p(usb=%p, complete_code=%s, "
literal|"pipe_handle=%d, submit_handle=%d, bytes_transferred=%d, user_data=%p);\n"
argument_list|,
literal|2
operator|*
name|usb
operator|->
name|indent
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|callback
argument_list|,
name|usb
argument_list|,
name|__cvmx_usb_complete_to_string
argument_list|(
name|complete_code
argument_list|)
argument_list|,
name|pipe_handle
argument_list|,
name|submit_handle
argument_list|,
name|bytes_transferred
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|callback
argument_list|(
operator|(
name|cvmx_usb_state_t
operator|*
operator|)
name|usb
argument_list|,
name|reason
argument_list|,
name|complete_code
argument_list|,
name|pipe_handle
argument_list|,
name|submit_handle
argument_list|,
name|bytes_transferred
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: callback %p complete\n"
argument_list|,
literal|2
operator|*
name|usb
operator|->
name|indent
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Signal the completion of a transaction and free it. The  * transaction will be removed from the pipe transaction list.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe the transaction is on  * @param transaction  *               Transaction that completed  * @param complete_code  *               Completion code  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_perform_complete
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|,
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|complete_code
argument_list|)
expr_stmt|;
comment|/* Isochronous transactions need extra processing as they might not be done         after a single data transfer */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|)
condition|)
block|{
comment|/* Update the number of bytes transfered in this ISO packet */
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|complete_code
expr_stmt|;
comment|/* If there are more ISOs pending and we suceeded, schedule the next             one */
if|if
condition|(
operator|(
name|transaction
operator|->
name|iso_number_packets
operator|>
literal|1
operator|)
operator|&&
operator|(
name|complete_code
operator|==
name|CVMX_USB_COMPLETE_SUCCESS
operator|)
condition|)
block|{
name|transaction
operator|->
name|actual_bytes
operator|=
literal|0
expr_stmt|;
comment|/* No bytes transfered for this packet as of yet */
name|transaction
operator|->
name|iso_number_packets
operator|--
expr_stmt|;
comment|/* One less ISO waiting to transfer */
name|transaction
operator|->
name|iso_packets
operator|++
expr_stmt|;
comment|/* Increment to the next location in our packet array */
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Remove the transaction from the pipe list */
if|if
condition|(
name|transaction
operator|->
name|next
condition|)
name|transaction
operator|->
name|next
operator|->
name|prev
operator|=
name|transaction
operator|->
name|prev
expr_stmt|;
else|else
name|pipe
operator|->
name|tail
operator|=
name|transaction
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|prev
condition|)
name|transaction
operator|->
name|prev
operator|->
name|next
operator|=
name|transaction
operator|->
name|next
expr_stmt|;
else|else
name|pipe
operator|->
name|head
operator|=
name|transaction
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
operator|->
name|head
condition|)
block|{
name|__cvmx_usb_remove_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|pipe
operator|->
name|transfer_type
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
argument_list|,
name|complete_code
argument_list|)
expr_stmt|;
name|__cvmx_usb_free_transaction
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
comment|/* Disable SOF interrupts if we don't have any pending transactions */
name|usb
operator|->
name|active_transactions
operator|--
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|active_transactions
operator|==
literal|0
condition|)
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|sofmsk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Submit a usb transaction to a pipe. Called for all types  * of transactions.  *  * @param usb  * @param pipe_handle  *                  Which pipe to submit to. Will be validated in this function.  * @param type      Transaction type  * @param flags     Flags for the transaction  * @param buffer    User buffer for the transaction  * @param buffer_length  *                  User buffer's length in bytes  * @param control_header  *                  For control transactions, the 8 byte standard header  * @param iso_start_frame  *                  For ISO transactiosn, the start frame  * @param iso_number_packets  *                  For ISO, the number of packet in the transaction.  * @param iso_packets  *                  A description of each ISO packet  * @param callback  User callback to call when the transaction completes  * @param user_data User's data for the callback  *  * @return Submit handle or negative on failure. Matches the result  *         in the external API.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_submit_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|cvmx_usb_transfer_t
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|uint64_t
name|control_header
parameter_list|,
name|int
name|iso_start_frame
parameter_list|,
name|int
name|iso_number_packets
parameter_list|,
name|cvmx_usb_iso_packet_t
modifier|*
name|iso_packets
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|pipe
operator|->
name|transfer_type
operator|!=
name|type
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|__cvmx_usb_alloc_transaction
argument_list|(
name|usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|transaction
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Enable SOF interrupts now that we have pending transactions */
if|if
condition|(
name|usb
operator|->
name|active_transactions
operator|==
literal|0
condition|)
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|sofmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usb
operator|->
name|active_transactions
operator|++
expr_stmt|;
name|transaction
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|transaction
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|transaction
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|transaction
operator|->
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|transaction
operator|->
name|control_header
operator|=
name|control_header
expr_stmt|;
name|transaction
operator|->
name|iso_start_frame
operator|=
name|iso_start_frame
expr_stmt|;
comment|// FIXME: This is not used, implement it
name|transaction
operator|->
name|iso_number_packets
operator|=
name|iso_number_packets
expr_stmt|;
name|transaction
operator|->
name|iso_packets
operator|=
name|iso_packets
expr_stmt|;
name|transaction
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|transaction
operator|->
name|callback_data
operator|=
name|user_data
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_CONTROL
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_SETUP
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
name|transaction
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|tail
condition|)
block|{
name|transaction
operator|->
name|prev
operator|=
name|pipe
operator|->
name|tail
expr_stmt|;
name|transaction
operator|->
name|prev
operator|->
name|next
operator|=
name|transaction
expr_stmt|;
block|}
else|else
block|{
name|transaction
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|head
operator|=
name|transaction
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|pipe
operator|->
name|transfer_type
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|pipe
operator|->
name|tail
operator|=
name|transaction
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
comment|/* We may need to schedule the pipe if this was the head of the pipe */
if|if
condition|(
operator|!
name|transaction
operator|->
name|prev
condition|)
name|__cvmx_usb_schedule
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call to submit a USB Bulk transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_bulk
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_BULK
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call to submit a USB Interrupt transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_interrupt
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call to submit a USB Control transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param control_header  *                  USB 8 byte control header physical address.  *                  Note that this is NOT A POINTER, but the  *                  full 64bit physical address of the buffer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_control
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|control_header
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|control_header
argument_list|)
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|control_header
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|control_header
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Some drivers send a buffer with a zero length. God only knows why */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer
operator|&&
operator|(
name|buffer_length
operator|<
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
operator|&&
operator|(
name|buffer_length
operator|!=
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|buffer_length
operator|=
name|cvmx_le16_to_cpu
argument_list|(
name|header
operator|->
name|s
operator|.
name|length
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_CONTROL
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|control_header
argument_list|,
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call to submit a USB Isochronous transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param start_frame  *                  Number of frames into the future to schedule  *                  this transaction.  * @param flags     Flags to control the transfer. See  *                  cvmx_usb_isochronous_flags_t for the flag  *                  definitions.  * @param number_packets  *                  Number of sequential packets to transfer.  *                  "packets" is a pointer to an array of this  *                  many packet structures.  * @param packets   Description of each transfer packet as  *                  defined by cvmx_usb_iso_packet_t. The array  *                  pointed to here must stay valid until the  *                  complete callback is called.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_isochronous
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|int
name|start_frame
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|number_packets
parameter_list|,
name|cvmx_usb_iso_packet_t
name|packets
index|[]
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|start_frame
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|number_packets
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|packets
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|start_frame
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|flags
operator|&
operator|~
operator|(
name|CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT
operator||
name|CVMX_USB_ISOCHRONOUS_FLAGS_ASAP
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|number_packets
operator|<
literal|1
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|packets
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|,
name|flags
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
name|start_frame
argument_list|,
name|number_packets
argument_list|,
name|packets
argument_list|,
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Cancel one outstanding request in a pipe. Canceling a request  * can fail if the transaction has already completed before cancel  * is called. Even after a successful cancel call, it may take  * a frame or two for the cvmx_usb_poll() function to call the  * associated callback.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to cancel requests in.  * @param submit_handle  *               Handle to transaction to cancel, returned by the submit function.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_cancel
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|int
name|submit_handle
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|submit_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|submit_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|submit_handle
operator|>=
name|MAX_TRANSACTIONS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|usb
operator|->
name|transaction
operator|+
name|submit_handle
expr_stmt|;
comment|/* Fail if this transaction already completed */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transaction
operator|->
name|flags
operator|&
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* If the transaction is the HEAD of the queue and scheduled. We need to         treat it special */
if|if
condition|(
operator|(
name|pipe
operator|->
name|head
operator|==
name|transaction
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
operator|)
condition|)
block|{
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
decl_stmt|;
name|usb
operator|->
name|pipe_for_channel
index|[
name|pipe
operator|->
name|channel
index|]
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
name|usbc_hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|pipe
operator|->
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the channel isn't enabled then the transaction already completed */
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|chena
condition|)
block|{
name|usbc_hcchar
operator|.
name|s
operator|.
name|chdis
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|pipe
operator|->
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
block|}
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_CANCEL
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Cancel all outstanding requests in a pipe. Logically all this  * does is call cvmx_usb_cancel() in a loop.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to cancel requests in.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_cancel_all
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Simply loop through and attempt to cancel each transaction */
while|while
condition|(
name|pipe
operator|->
name|head
condition|)
block|{
name|cvmx_usb_status_t
name|result
init|=
name|cvmx_usb_cancel
argument_list|(
name|state
argument_list|,
name|pipe_handle
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|pipe
operator|->
name|head
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|result
operator|!=
name|CVMX_USB_SUCCESS
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Close a pipe created with cvmx_usb_open_pipe().  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to close.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t. CVMX_USB_BUSY is returned if the  *         pipe has outstanding transfers.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_close_pipe
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe has pending transactions */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|pipe
operator|->
name|head
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_BUSY
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Register a function to be called when various USB events occur.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param reason    Which event to register for.  * @param callback  Function to call when the event occurs.  * @param user_data User data parameter to the function.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_register_callback
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_callback_t
name|reason
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|callback
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|reason
operator|>=
name|__CVMX_USB_CALLBACK_END
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|callback
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|usb
operator|->
name|callback
index|[
name|reason
index|]
operator|=
name|callback
expr_stmt|;
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
operator|=
name|user_data
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the current USB protocol level frame number. The frame  * number is always in the range of 0-0x7ff.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return USB frame number  */
end_comment

begin_function
name|int
name|cvmx_usb_get_frame_number
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|frame_number
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
argument_list|)
condition|)
block|{
name|cvmx_usbcx_dsts_t
name|usbc_dsts
decl_stmt|;
name|usbc_dsts
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|frame_number
operator|=
name|usbc_dsts
operator|.
name|s
operator|.
name|soffn
expr_stmt|;
block|}
else|else
block|{
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
decl_stmt|;
name|usbc_hfnum
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HFNUM
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|frame_number
operator|=
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
name|frame_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Poll a channel for status  *  * @param usb     USB device  * @param channel Channel to poll  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_poll_channel
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|cvmx_usbcx_hcintx_t
name|usbc_hcint
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
decl_stmt|;
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|int
name|bytes_this_transfer
decl_stmt|;
name|int
name|bytes_in_last_packet
decl_stmt|;
name|int
name|packets_processed
decl_stmt|;
name|int
name|buffer_space_left
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Read the interrupt status bits for the channel */
name|usbc_hcint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We ignore any interrupts where the channel hasn't halted yet. These         should be impossible since we don't enable any interrupts except for         channel halted */
if|if
condition|(
operator|!
name|usbc_hcint
operator|.
name|s
operator|.
name|chhltd
condition|)
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the channel has halted, clear all status bits before         processing. This way we don't have any race conditions caused by the         channel starting up and finishing before we clear the bits */
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcint
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|//cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_USBCX_HCINTX(channel, usb->index), usbc_hcint.u32);
name|usb
operator|->
name|idle_hardware_channels
operator||=
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
comment|/* Make sure this channel is tied to a valid pipe */
name|pipe
operator|=
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
condition|)
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|pipe
operator|->
name|head
expr_stmt|;
name|CVMX_PREFETCH0
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
comment|/* Disconnect this pipe from the HW channel. Later the schedule function will         figure out which pipe needs to go */
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
comment|/* Read the channel config info so we can figure out how much data         transfered */
name|usbc_hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculating the number of bytes successfully transfered is dependent on         the transfer direction */
name|packets_processed
operator|=
name|transaction
operator|->
name|pktcnt
operator|-
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
expr_stmt|;
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|epdir
condition|)
block|{
comment|/* IN transactions are easy. For every byte received the hardware             decrements xfersize. All we need to do is subtract the current             value of xfersize from its starting value and we know how many             bytes were written to the buffer */
name|bytes_this_transfer
operator|=
name|transaction
operator|->
name|xfersize
operator|-
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
block|}
else|else
block|{
comment|/* OUT transaction don't decrement xfersize. Instead pktcnt is             decremented on every successful packet send. The hardware does             this when it receives an ACK, or NYET. If it doesn't             receive one of these responses pktcnt doesn't change */
name|bytes_this_transfer
operator|=
name|packets_processed
operator|*
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
expr_stmt|;
comment|/* The last packet may not be a full transfer if we didn't have             enough data */
if|if
condition|(
name|bytes_this_transfer
operator|>
name|transaction
operator|->
name|xfersize
condition|)
name|bytes_this_transfer
operator|=
name|transaction
operator|->
name|xfersize
expr_stmt|;
block|}
comment|/* Figure out how many bytes were in the last packet of the transfer */
if|if
condition|(
name|packets_processed
condition|)
name|bytes_in_last_packet
operator|=
name|bytes_this_transfer
operator|-
operator|(
name|packets_processed
operator|-
literal|1
operator|)
operator|*
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
expr_stmt|;
else|else
name|bytes_in_last_packet
operator|=
name|bytes_this_transfer
expr_stmt|;
comment|/* As a special case, setup transactions output the setup header, not         the user's data. For this reason we don't count setup data as bytes         transfered */
if|if
condition|(
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_SETUP
operator|)
operator|||
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
operator|)
condition|)
name|bytes_this_transfer
operator|=
literal|0
expr_stmt|;
comment|/* Optional debug output */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Channel %d halted. Pipe %d transaction %d stage %d bytes=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|channel
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|transaction
operator|->
name|stage
argument_list|,
name|bytes_this_transfer
argument_list|)
expr_stmt|;
comment|/* Add the bytes transfered to the running total. It is important that         bytes_this_transfer doesn't count any data that needs to be         retransmitted */
name|transaction
operator|->
name|actual_bytes
operator|+=
name|bytes_this_transfer
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|buffer_space_left
operator|=
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
else|else
name|buffer_space_left
operator|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* We need to remember the PID toggle state for the next transaction. The         hardware already updated it for the next transaction */
name|pipe
operator|->
name|pid_toggle
operator|=
operator|!
operator|(
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* For high speed bulk out, assume the next transaction will need to do a         ping before proceeding. If this isn't true the ACK processing below         will clear this flag */
if|if
condition|(
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|stall
condition|)
block|{
comment|/* STALL as a response means this transaction cannot be completed             because the device can't process transactions. Tell the user. Any             data that was transfered will be counted on the actual bytes             transfered */
name|pipe
operator|->
name|pid_toggle
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_STALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|usbc_hcint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
comment|/* XferCompl is only useful in non DMA mode */
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|xacterr
condition|)
block|{
comment|/* We know at least one packet worked if we get a ACK or NAK. Reset the retry counter */
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
operator|||
name|usbc_hcint
operator|.
name|s
operator|.
name|ack
condition|)
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|retries
operator|>
name|MAX_RETRIES
condition|)
block|{
comment|/* XactErr as a response means the device signaled something wrong with                 the transfer. For example, PID toggle errors cause these */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_XACTERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Rewind to the beginning of the transaction by anding off the                 split complete bit */
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|pipe
operator|->
name|next_tx_cycle
operator|=
name|cvmx_read64_uint64
argument_list|(
name|CVMX_IPD_CLK_COUNT
argument_list|)
operator|+
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|usbc_hcint
operator|.
name|s
operator|.
name|datatglerr
condition|)
block|{
comment|/* The hardware automatically handles Data Toggle Errors for us */
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|bblerr
condition|)
block|{
comment|/* Babble Error (BblErr) */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_BABBLEERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|frmovrun
condition|)
block|{
comment|/* Frame Overrun (FrmOvrun) */
comment|/* Rewind to the beginning of the transaction by anding off the             split complete bit */
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nyet
condition|)
block|{
comment|/* NYET as a response is only allowed in three cases: as a response to             a ping, as a response to a split transaction, and as a response to             a bulk out. The ping case is handled by hardware, so we only have             splits and bulk out */
if|if
condition|(
operator|!
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* If there is more data to go then we need to try again. Otherwise                 this transaction is complete */
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Split transactions retry the split complete 4 times then rewind                 to the start split and do the entire transactions again */
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|transaction
operator|->
name|retries
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Rewind to the beginning of the transaction by anding off the                     split complete bit */
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|ack
condition|)
block|{
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* The ACK bit can only be checked after the other error bits. This is             because a multi packet transfer may succeed in a number of packets             and then get a different response on the last packet. In this case             both ACK and the last response bit will be set. If none of the             other response bits is set, then the last packet must have been an             ACK */
comment|/* Since we got an ACK, we know we don't need to do a ping on this             pipe */
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
switch|switch
condition|(
name|transaction
operator|->
name|type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
switch|switch
condition|(
name|transaction
operator|->
name|stage
condition|)
block|{
case|case
name|CVMX_USB_STAGE_NON_CONTROL
case|:
case|case
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
case|:
comment|/* This should be impossible */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP
case|:
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
expr_stmt|;
else|else
block|{
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|s
operator|.
name|length
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
case|:
block|{
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|s
operator|.
name|length
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_DATA
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
case|:
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
else|else
block|{
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_STATUS
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
expr_stmt|;
else|else
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
case|:
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
case|case
name|CVMX_USB_TRANSFER_INTERRUPT
case|:
comment|/* The only time a bulk transfer isn't complete when                     it finishes with an ACK is during a split transaction. For                     splits we need to continue the transfer if more data is                     needed */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|buffer_space_left
operator|&&
operator|(
name|bytes_in_last_packet
operator|==
name|pipe
operator|->
name|max_packet
operator|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
condition|)
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_space_left
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
condition|)
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* ISOCHRONOUS OUT splits don't require a complete split stage.                         Instead they use a sequence of begin OUT splits to transfer                         the data 188 bytes at a time. Once the transfer is complete,                         the pipe sleeps until the next schedule interval */
if|if
condition|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
condition|)
block|{
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
comment|/* If no space left or this wasn't a max size packet then                             this transfer is complete. Otherwise start it again                             to send the next 188 bytes */
if|if
condition|(
operator|!
name|buffer_space_left
operator|||
operator|(
name|bytes_this_transfer
operator|<
literal|188
operator|)
condition|)
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
condition|)
block|{
comment|/* We are in the incomming data phase. Keep getting                                 data until we run out of space or get a small                                 packet */
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
expr_stmt|;
block|}
block|}
else|else
block|{
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
condition|)
block|{
name|uint64_t
name|ipd_clk_count
decl_stmt|;
comment|/* NAK as a response means the device couldn't accept the transaction,             but it should be retried in the future. Rewind to the beginning of             the transaction by anding off the split complete bit. Retry in the             next interval */
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|next_tx_cycle
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|ipd_clk_count
operator|=
name|cvmx_read64_uint64
argument_list|(
name|CVMX_IPD_CLK_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|next_tx_cycle
operator|<
name|ipd_clk_count
condition|)
name|pipe
operator|->
name|next_tx_cycle
operator|=
name|ipd_clk_count
operator|+
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
else|else
block|{
comment|/* We get channel halted interrupts with no result bits sets when the             cable is unplugged */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_ERROR
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Poll a device mode endpoint for status  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param endpoint_num  *               Endpoint to poll  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_poll_endpoint
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usbcx_diepintx_t
name|usbc_diepint
decl_stmt|;
name|cvmx_usbcx_doepintx_t
name|usbc_doepint
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|usbc_diepint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_diepint
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|//cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_USBCX_DIEPINTX(endpoint_num, usb->index), usbc_diepint.u32);
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|inepnakeff
condition|)
block|{
comment|/* IN Endpoint NAK Effective (INEPNakEff)             Applies to periodic IN endpoints only.             Indicates that the IN endpoint NAK bit set by the application has             taken effect in the core. This bit can be cleared when the             application clears the IN endpoint NAK by writing to             DIEPCTLn.CNAK.             This interrupt indicates that the core has sampled the NAK bit             set (either by the application or by the core).             This interrupt does not necessarily mean that a NAK handshake             is sent on the USB. A STALL bit takes priority over a NAK bit. */
comment|/* Nothing to do */
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|intknepmis
condition|)
block|{
comment|/* IN Token Received with EP Mismatch (INTknEPMis)             Applies to non-periodic IN endpoints only.             Indicates that the data in the top of the non-periodic TxFIFO             belongs to an endpoint other than the one for which the IN             token was received. This interrupt is asserted on the endpoint             for which the IN token was received. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Endpoint %d mismatch\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|intkntxfemp
condition|)
block|{
comment|/* IN Token Received When TxFIFO is Empty (INTknTXFEmp)             Applies only to non-periodic IN endpoints.             Indicates that an IN token was received when the associated             TxFIFO (periodic/non-periodic) was empty. This interrupt is             asserted on the endpoint for which the IN token was received. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Received IN token on endpoint %d without data\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|timeout
condition|)
block|{
comment|/* Timeout Condition (TimeOUT)             Applies to non-isochronous IN endpoints only.             Indicates that the core has detected a timeout condition on the             USB for the last IN token on this endpoint. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Received timeout on endpoint %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|ahberr
condition|)
block|{
comment|/* AHB Error (AHBErr)             This is generated only in Internal DMA mode when there is an             AHB error during an AHB read/write. The application can read             the corresponding endpoint DMA address register to get the             error address. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: AHB error on endpoint %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|epdisbld
condition|)
block|{
comment|/* Endpoint Disabled Interrupt (EPDisbld)             This bit indicates that the endpoint is disabled per the             application's request. */
comment|/* Nothing to do */
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
comment|/* Transfer Completed Interrupt (XferCompl)             Indicates that the programmed transfer is complete on the AHB             as well as on the USB, for this endpoint. */
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
argument_list|,
name|NULL
argument_list|,
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|usbc_doepint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepint
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|//cvmx_csr_db_decode(cvmx_get_proc_id(), CVMX_USBCX_DOEPINTX(endpoint_num, usb->index), usbc_doepint.u32);
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|outtknepdis
condition|)
block|{
comment|/* OUT Token Received When Endpoint Disabled (OUTTknEPdis)             Applies only to control OUT endpoints.             Indicates that an OUT token was received when the endpoint             was not yet enabled. This interrupt is asserted on the endpoint             for which the OUT token was received. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Received OUT token on disabled endpoint %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|setup
condition|)
block|{
comment|/* SETUP Phase Done (SetUp)             Applies to control OUT endpoints only.             Indicates that the SETUP phase for the control endpoint is             complete and no more back-to-back SETUP packets were             received for the current control transfer. On this interrupt, the             application can decode the received SETUP data packet. */
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
argument_list|,
name|NULL
argument_list|,
name|CVMX_USB_CALLBACK_DEVICE_SETUP
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|ahberr
condition|)
block|{
comment|/* AHB Error (AHBErr)             This is generated only in Internal DMA mode when there is an             AHB error during an AHB read/write. The application can read             the corresponding endpoint DMA address register to get the             error address. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: AHB error on endpoint %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|epdisbld
condition|)
block|{
comment|/* Endpoint Disabled Interrupt (EPDisbld)             This bit indicates that the endpoint is disabled per the             application's request. */
comment|/* Nothing to do */
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
comment|/* Transfer Completed Interrupt (XferCompl)             Indicates that the programmed transfer is complete on the AHB             as well as on the USB, for this endpoint. */
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
argument_list|,
name|NULL
argument_list|,
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Poll the device mode endpoints for status  *  * @param usb  USB device state populated by  *               cvmx_usb_initialize().  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_poll_endpoints
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_daint_t
name|usbc_daint
decl_stmt|;
name|int
name|active_endpoints
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|usbc_daint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DAINT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|active_endpoints
operator|=
name|usbc_daint
operator|.
name|s
operator|.
name|inepint
operator||
name|usbc_daint
operator|.
name|s
operator|.
name|outepint
expr_stmt|;
while|while
condition|(
name|active_endpoints
condition|)
block|{
name|int
name|endpoint
decl_stmt|;
name|CVMX_CLZ
argument_list|(
name|endpoint
argument_list|,
name|active_endpoints
argument_list|)
expr_stmt|;
name|endpoint
operator|=
literal|31
operator|-
name|endpoint
expr_stmt|;
name|__cvmx_usb_poll_endpoint
argument_list|(
name|usb
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
name|active_endpoints
operator|^=
literal|1
operator|<<
name|endpoint
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Poll the USB block for status and call all needed callback  * handlers. This function is meant to be called in the interrupt  * handler for the USB controller. It can also be called  * periodically in a loop for non-interrupt based operation.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_poll
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_gintsts_t
name|usbc_gintsts
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|1
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|2
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|3
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|4
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Read the pending interrupts */
name|usbc_gintsts
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|wkupint
condition|)
block|{
comment|/* Resume/Remote Wakeup Detected Interrupt (WkUpInt)             In Device mode, this interrupt is asserted when a resume is             detected on the USB. In Host mode, this interrupt is asserted             when a remote wakeup is detected on the USB. */
comment|/* Octeon doesn't support suspend / resume */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|sessreqint
condition|)
block|{
comment|/* Session Request/New Session Detected Interrupt (SessReqInt)             In Host mode, this interrupt is asserted when a session request             is detected from the device. In Device mode, this interrupt is             asserted when the utmiotg_bvalid signal goes high. */
comment|/* Octeon doesn't support OTG */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|disconnint
operator|||
name|usbc_gintsts
operator|.
name|s
operator|.
name|prtint
condition|)
block|{
name|cvmx_usbcx_hprt_t
name|usbc_hprt
decl_stmt|;
comment|/* Disconnect Detected Interrupt (DisconnInt)             Asserted when a device disconnect is detected. */
comment|/* Host Port Interrupt (PrtInt)             The core sets this bit to indicate a change in port status of one             of the O2P USB core ports in Host mode. The application must             read the Host Port Control and Status (HPRT) register to             determine the exact event that caused this interrupt. The             application must clear the appropriate status bit in the Host Port             Control and Status register to clear this bit. */
comment|/* Call the user's port callback */
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|CVMX_USB_CALLBACK_PORT_CHANGED
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Clear the port change bits */
name|usbc_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_hprt
operator|.
name|s
operator|.
name|prtena
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hprt
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|conidstschng
condition|)
block|{
comment|/* Connector ID Status Change (ConIDStsChng)             The core sets this bit when there is a change in connector ID             status. */
comment|/* The USB core currently doesn't support dynamically changing from             host to device mode */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|ptxfemp
condition|)
block|{
comment|/* Periodic TxFIFO Empty (PTxFEmp)             Asserted when the Periodic Transmit FIFO is either half or             completely empty and there is space for at least one entry to be             written in the Periodic Request Queue. The half or completely             empty status is determined by the Periodic TxFIFO Empty Level             bit in the Core AHB Configuration register             (GAHBCFG.PTxFEmpLvl). */
comment|/* In DMA mode we don't care */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|hchint
condition|)
block|{
comment|/* Host Channels Interrupt (HChInt)             The core sets this bit to indicate that an interrupt is pending on             one of the channels of the core (in Host mode). The application             must read the Host All Channels Interrupt (HAINT) register to             determine the exact number of the channel on which the             interrupt occurred, and then read the corresponding Host             Channel-n Interrupt (HCINTn) register to determine the exact             cause of the interrupt. The application must clear the             appropriate status bit in the HCINTn register to clear this bit. */
name|cvmx_usbcx_haint_t
name|usbc_haint
decl_stmt|;
name|usbc_haint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HAINT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|usbc_haint
operator|.
name|u32
condition|)
block|{
name|int
name|channel
decl_stmt|;
name|CVMX_CLZ
argument_list|(
name|channel
argument_list|,
name|usbc_haint
operator|.
name|u32
argument_list|)
expr_stmt|;
name|channel
operator|=
literal|31
operator|-
name|channel
expr_stmt|;
name|__cvmx_usb_poll_channel
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|usbc_haint
operator|.
name|u32
operator|^=
literal|1
operator|<<
name|channel
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|fetsusp
condition|)
block|{
comment|/* Data Fetch Suspended (FetSusp)             This interrupt is valid only in DMA mode. This interrupt indicates             that the core has stopped fetching data for IN endpoints due to             the unavailability of TxFIFO space or Request Queue space.             This interrupt is used by the application for an endpoint             mismatch algorithm. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|incomplp
condition|)
block|{
comment|/* Incomplete Periodic Transfer (incomplP)             In Host mode, the core sets this interrupt bit when there are             incomplete periodic transactions still pending which are             scheduled for the current microframe.             Incomplete Isochronous OUT Transfer (incompISOOUT)             The Device mode, the core sets this interrupt to indicate that             there is at least one isochronous OUT endpoint on which the             transfer is not completed in the current microframe. This             interrupt is asserted along with the End of Periodic Frame             Interrupt (EOPF) bit in this register. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|incompisoin
condition|)
block|{
comment|/* Incomplete Isochronous IN Transfer (incompISOIN)             The core sets this interrupt to indicate that there is at least one             isochronous IN endpoint on which the transfer is not completed             in the current microframe. This interrupt is asserted along with             the End of Periodic Frame Interrupt (EOPF) bit in this register. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|oepint
condition|)
block|{
comment|/* OUT Endpoints Interrupt (OEPInt)             The core sets this bit to indicate that an interrupt is pending on             one of the OUT endpoints of the core (in Device mode). The             application must read the Device All Endpoints Interrupt             (DAINT) register to determine the exact number of the OUT             endpoint on which the interrupt occurred, and then read the             corresponding Device OUT Endpoint-n Interrupt (DOEPINTn)             register to determine the exact cause of the interrupt. The             application must clear the appropriate status bit in the             corresponding DOEPINTn register to clear this bit. */
name|__cvmx_usb_poll_endpoints
argument_list|(
name|usb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|iepint
condition|)
block|{
comment|/* IN Endpoints Interrupt (IEPInt)             The core sets this bit to indicate that an interrupt is pending on             one of the IN endpoints of the core (in Device mode). The             application must read the Device All Endpoints Interrupt             (DAINT) register to determine the exact number of the IN             endpoint on which the interrupt occurred, and then read the             corresponding Device IN Endpoint-n Interrupt (DIEPINTn)             register to determine the exact cause of the interrupt. The             application must clear the appropriate status bit in the             corresponding DIEPINTn register to clear this bit. */
name|__cvmx_usb_poll_endpoints
argument_list|(
name|usb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|epmis
condition|)
block|{
comment|/* Endpoint Mismatch Interrupt (EPMis)             Indicates that an IN token has been received for a non-periodic             endpoint, but the data for another endpoint is present in the top             of the Non-Periodic Transmit FIFO and the IN endpoint             mismatch count programmed by the application has expired. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|eopf
condition|)
block|{
comment|/* End of Periodic Frame Interrupt (EOPF)             Indicates that the period specified in the Periodic Frame Interval             field of the Device Configuration register (DCFG.PerFrInt) has             been reached in the current microframe. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|isooutdrop
condition|)
block|{
comment|/* Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)             The core sets this bit when it fails to write an isochronous OUT             packet into the RxFIFO because the RxFIFO doesn't have             enough space to accommodate a maximum packet size packet             for the isochronous OUT endpoint. */
comment|// FIXME
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|enumdone
condition|)
block|{
comment|/* Enumeration Done (EnumDone)             The core sets this bit to indicate that speed enumeration is             complete. The application must read the Device Status (DSTS)             register to obtain the enumerated speed. */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
condition|)
block|{
name|cvmx_usbcx_dsts_t
name|usbc_dsts
decl_stmt|;
name|usbc_dsts
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d Enumeration complete with %s speed\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|,
operator|(
name|usbc_dsts
operator|.
name|s
operator|.
name|enumspd
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
condition|?
literal|"high"
else|:
operator|(
name|usbc_dsts
operator|.
name|s
operator|.
name|enumspd
operator|==
name|CVMX_USB_SPEED_FULL
operator|)
condition|?
literal|"full"
else|:
literal|"low"
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DIEPCTLX
argument_list|(
literal|0
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_diepctlx_t
argument_list|,
name|mps
argument_list|,
operator|(
name|usbc_dsts
operator|.
name|s
operator|.
name|enumspd
operator|==
name|CVMX_USB_SPEED_LOW
operator|)
condition|?
literal|3
else|:
literal|0
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPCTLX
argument_list|(
literal|0
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doepctlx_t
argument_list|,
name|epena
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|usbrst
condition|)
block|{
comment|/* USB Reset (USBRst)             The core sets this bit to indicate that a reset is             detected on the USB. */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d Reset complete\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
name|__cvmx_usb_device_reset_complete
argument_list|(
name|usb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|nptxfemp
condition|)
block|{
comment|/* Non-Periodic TxFIFO Empty (NPTxFEmp)             This interrupt is asserted when the Non-Periodic TxFIFO is             either half or completely empty, and there is space for at least             one entry to be written to the Non-Periodic Transmit Request             Queue. The half or completely empty status is determined by             the Non-Periodic TxFIFO Empty Level bit in the Core AHB             Configuration register (GAHBCFG.NPTxFEmpLvl). */
comment|/* In DMA mode this is handled by hardware */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|rxflvl
condition|)
block|{
comment|/* RxFIFO Non-Empty (RxFLvl)             Indicates that there is at least one packet pending to be read             from the RxFIFO. */
comment|/* In DMA mode this is handled by hardware */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|sof
condition|)
block|{
comment|/* Start of (micro)Frame (Sof)             In Host mode, the core sets this bit to indicate that an SOF             (FS), micro-SOF (HS), or Keep-Alive (LS) is transmitted on the             USB. The application must write a 1 to this bit to clear the             interrupt.             In Device mode, in the core sets this bit to indicate that an SOF             token has been received on the USB. The application can read             the Device Status register to get the current (micro)frame             number. This interrupt is seen only when the core is operating             at either HS or FS. */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|otgint
condition|)
block|{
comment|/* OTG Interrupt (OTGInt)             The core sets this bit to indicate an OTG protocol event. The             application must read the OTG Interrupt Status (GOTGINT)             register to determine the exact event that caused this interrupt.             The application must clear the appropriate status bit in the             GOTGINT register to clear this bit. */
comment|/* Octeon doesn't support OTG, so ignore */
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|modemis
condition|)
block|{
comment|/* Mode Mismatch Interrupt (ModeMis)             The core sets this bit when the application is trying to access:             * A Host mode register, when the core is operating in Device             mode             * A Device mode register, when the core is operating in Host             mode             The register access is completed on the AHB with an OKAY             response, but is ignored by the core internally and doesn't             affect the operation of the core. */
comment|/* Ignored for now */
block|}
name|__cvmx_usb_schedule
argument_list|(
name|usb
argument_list|,
name|usbc_gintsts
operator|.
name|s
operator|.
name|sof
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts now that we know about them */
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_gintsts
operator|.
name|u32
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable an endpoint for use in device mode. After this call  * transactions will be allowed over the endpoint. This must be  * called after every usb reset.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param endpoint_num  *               The endpoint number to enable (0-4)  * @param transfer_type  *               USB transfer type of this endpoint  * @param transfer_dir  *               Direction of transfer relative to Octeon  * @param max_packet_size  *               Maximum packet size support by this endpoint  * @param buffer Buffer to send/receive  * @param buffer_length  *               Length of the buffer in bytes  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_device_enable_endpoint
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|cvmx_usb_transfer_t
name|transfer_type
parameter_list|,
name|cvmx_usb_direction_t
name|transfer_dir
parameter_list|,
name|int
name|max_packet_size
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_type
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_dir
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|max_packet_size
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|endpoint_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|endpoint_num
operator|>
literal|4
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|transfer_type
operator|>
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|max_packet_size
operator|<
literal|0
operator|)
operator|||
operator|(
name|max_packet_size
operator|>
literal|512
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_IN
condition|)
block|{
name|cvmx_usbcx_doepctlx_t
name|usbc_doepctl
decl_stmt|;
name|cvmx_usbcx_doeptsizx_t
name|usbc_doeptsiz
decl_stmt|;
comment|/* Setup the locations the DMA engines use  */
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|endpoint_num
operator|*
literal|8
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|mc
operator|=
literal|1
expr_stmt|;
comment|// FIXME
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|buffer_length
operator|+
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|==
literal|0
condition|)
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|buffer_length
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doeptsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_doepctl
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|epena
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|setd1pid
operator|=
literal|0
expr_stmt|;
comment|// FIXME
name|usbc_doepctl
operator|.
name|s
operator|.
name|setd0pid
operator|=
literal|0
expr_stmt|;
comment|// FIXME
name|usbc_doepctl
operator|.
name|s
operator|.
name|cnak
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|eptype
operator|=
name|transfer_type
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|usbactep
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
name|max_packet_size
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_usbcx_diepctlx_t
name|usbc_diepctl
decl_stmt|;
name|cvmx_usbcx_dieptsizx_t
name|usbc_dieptsiz
decl_stmt|;
comment|/* Setup the locations the DMA engines use  */
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|endpoint_num
operator|*
literal|8
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|mc
operator|=
literal|1
expr_stmt|;
comment|// FIXME
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|buffer_length
operator|+
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|==
literal|0
condition|)
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|buffer_length
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_dieptsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_diepctl
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|epena
operator|=
literal|1
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|setd1pid
operator|=
literal|0
expr_stmt|;
comment|// FIXME
name|usbc_diepctl
operator|.
name|s
operator|.
name|setd0pid
operator|=
literal|0
expr_stmt|;
comment|// FIXME
name|usbc_diepctl
operator|.
name|s
operator|.
name|cnak
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
operator|)
operator|||
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
operator|)
condition|)
name|usbc_diepctl
operator|.
name|s
operator|.
name|txfnum
operator|=
name|endpoint_num
expr_stmt|;
comment|// FIXME
else|else
name|usbc_diepctl
operator|.
name|s
operator|.
name|txfnum
operator|=
literal|0
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|eptype
operator|=
name|transfer_type
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|usbactep
operator|=
literal|1
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|nextep
operator|=
name|endpoint_num
operator|-
literal|1
expr_stmt|;
comment|// FIXME
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
name|max_packet_size
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_diepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Disable an endpoint in device mode.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param endpoint_num  *               The endpoint number to disable (0-4)  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_device_disable_endpoint
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|endpoint_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|endpoint_num
operator|>
literal|4
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEVICE_MODE
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INCORRECT_MODE
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_doepctlx_t
argument_list|,
name|epdis
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_DIEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_diepctlx_t
argument_list|,
name|epdis
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|cvmx_usb_set_toggle
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|int
name|toggle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
decl_stmt|;
name|pipe
operator|->
name|pid_toggle
operator|=
operator|!
operator|!
name|toggle
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|int
name|cvmx_usb_get_toggle
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
decl_stmt|;
if|if
condition|(
name|pipe
operator|->
name|pid_toggle
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

