begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * "cvmx-usb.c" defines a set of low level USB functions to help  * developers create Octeon USB drivers for various operating  * systems. These functions provide a generic API to the Octeon  * USB blocks, hiding the internal hardware specific  * operations.  *  *<hr>$Revision: 32636 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sysinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usbnx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usbcx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usb.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-swap.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Do not use cvmx-error.h for now. When the cvmx-error.h is properly     * ported, remove the above #if 0, and all #ifdef __CVMX_ERROR_H__ within     * this file */
end_comment

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-usb.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-csr-db.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_RETRIES
value|3
end_define

begin_comment
comment|/* Maximum number of times to retry failed transactions */
end_comment

begin_define
define|#
directive|define
name|MAX_PIPES
value|32
end_define

begin_comment
comment|/* Maximum number of pipes that can be open at once */
end_comment

begin_define
define|#
directive|define
name|MAX_TRANSACTIONS
value|256
end_define

begin_comment
comment|/* Maximum number of outstanding transactions across all pipes */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANNELS
value|8
end_define

begin_comment
comment|/* Maximum number of hardware channels supported by the USB block */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_ADDRESS
value|127
end_define

begin_comment
comment|/* The highest valid USB device address */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_ENDPOINT
value|15
end_define

begin_comment
comment|/* The highest valid USB endpoint number */
end_comment

begin_define
define|#
directive|define
name|MAX_USB_HUB_PORT
value|15
end_define

begin_comment
comment|/* The highest valid port number on a hub */
end_comment

begin_define
define|#
directive|define
name|MAX_TRANSFER_BYTES
value|((1<<19)-1)
end_define

begin_comment
comment|/* The low level hardware can transfer a maximum of this number of bytes in each transfer. The field is 19 bits wide */
end_comment

begin_define
define|#
directive|define
name|MAX_TRANSFER_PACKETS
value|((1<<10)-1)
end_define

begin_comment
comment|/* The low level hardware can transfer a maximum of this number of packets in each transfer. The field is 10 bits wide */
end_comment

begin_define
define|#
directive|define
name|ALLOW_CSR_DECODES
value|0
end_define

begin_comment
comment|/* CSR decoding when CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS is set                                     enlarges the code a lot. This define overrides the ability to do CSR                                     decoding since it isn't necessary 99% of the time. Change this to a                                     one if you need CSR decoding */
end_comment

begin_comment
comment|/* These defines disable the normal read and write csr. This is so I can add     extra debug stuff to the usb specific version and I won't use the normal     version by mistake */
end_comment

begin_define
define|#
directive|define
name|cvmx_read_csr
value|use_cvmx_usb_read_csr64_instead_of_cvmx_read_csr
end_define

begin_define
define|#
directive|define
name|cvmx_write_csr
value|use_cvmx_usb_write_csr64_instead_of_cvmx_write_csr
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
init|=
literal|1
operator|<<
literal|16
block|, }
name|cvmx_usb_transaction_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * Logical transactions may take numerous low level  * transactions, especially when splits are concerned. This  * enum represents all of the possible stages a transaction can  * be in. Note that split completes are always even. This is so  * the NAK handler can backup to the previous low level  * transaction with a simple clearing of bit 0.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|CVMX_USB_STAGE_NON_CONTROL
block|,
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_SETUP
block|,
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_DATA
block|,
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
block|,
name|CVMX_USB_STAGE_STATUS
block|,
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
block|, }
name|cvmx_usb_stage_t
typedef|;
end_typedef

begin_comment
comment|/**  * This structure describes each pending USB transaction  * regardless of type. These are linked together to form a list  * of pending requests for a pipe.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cvmx_usb_transaction
block|{
name|struct
name|cvmx_usb_transaction
modifier|*
name|prev
decl_stmt|;
comment|/**< Transaction before this one in the pipe */
name|struct
name|cvmx_usb_transaction
modifier|*
name|next
decl_stmt|;
comment|/**< Transaction after this one in the pipe */
name|cvmx_usb_transfer_t
name|type
decl_stmt|;
comment|/**< Type of transaction, duplicated of the pipe */
name|cvmx_usb_transaction_flags_t
name|flags
decl_stmt|;
comment|/**< State flags for this transaction */
name|uint64_t
name|buffer
decl_stmt|;
comment|/**< User's physical buffer address to read/write */
name|int
name|buffer_length
decl_stmt|;
comment|/**< Size of the user's buffer in bytes */
name|uint64_t
name|control_header
decl_stmt|;
comment|/**< For control transactions, physical address of the 8 byte standard header */
name|int
name|iso_start_frame
decl_stmt|;
comment|/**< For ISO transactions, the starting frame number */
name|int
name|iso_number_packets
decl_stmt|;
comment|/**< For ISO transactions, the number of packets in the request */
name|cvmx_usb_iso_packet_t
modifier|*
name|iso_packets
decl_stmt|;
comment|/**< For ISO transactions, the sub packets in the request */
name|int
name|xfersize
decl_stmt|;
name|int
name|pktcnt
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|actual_bytes
decl_stmt|;
comment|/**< Actual bytes transfer for this transaction */
name|cvmx_usb_stage_t
name|stage
decl_stmt|;
comment|/**< For control transactions, the current stage */
name|cvmx_usb_callback_func_t
name|callback
decl_stmt|;
comment|/**< User's callback function when complete */
name|void
modifier|*
name|callback_data
decl_stmt|;
comment|/**< User's data */
block|}
name|cvmx_usb_transaction_t
typedef|;
end_typedef

begin_comment
comment|/**  * A pipe represents a virtual connection between Octeon and some  * USB device. It contains a list of pending request to the device.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cvmx_usb_pipe
block|{
name|struct
name|cvmx_usb_pipe
modifier|*
name|prev
decl_stmt|;
comment|/**< Pipe before this one in the list */
name|struct
name|cvmx_usb_pipe
modifier|*
name|next
decl_stmt|;
comment|/**< Pipe after this one in the list */
name|cvmx_usb_transaction_t
modifier|*
name|head
decl_stmt|;
comment|/**< The first pending transaction */
name|cvmx_usb_transaction_t
modifier|*
name|tail
decl_stmt|;
comment|/**< The last pending transaction */
name|uint64_t
name|interval
decl_stmt|;
comment|/**< For periodic pipes, the interval between packets in frames */
name|uint64_t
name|next_tx_frame
decl_stmt|;
comment|/**< The next frame this pipe is allowed to transmit on */
name|cvmx_usb_pipe_flags_t
name|flags
decl_stmt|;
comment|/**< State flags for this pipe */
name|cvmx_usb_speed_t
name|device_speed
decl_stmt|;
comment|/**< Speed of device connected to this pipe */
name|cvmx_usb_transfer_t
name|transfer_type
decl_stmt|;
comment|/**< Type of transaction supported by this pipe */
name|cvmx_usb_direction_t
name|transfer_dir
decl_stmt|;
comment|/**< IN or OUT. Ignored for Control */
name|int
name|multi_count
decl_stmt|;
comment|/**< Max packet in a row for the device */
name|uint16_t
name|max_packet
decl_stmt|;
comment|/**< The device's maximum packet size in bytes */
name|uint8_t
name|device_addr
decl_stmt|;
comment|/**< USB device address at other end of pipe */
name|uint8_t
name|endpoint_num
decl_stmt|;
comment|/**< USB endpoint number at other end of pipe */
name|uint8_t
name|hub_device_addr
decl_stmt|;
comment|/**< Hub address this device is connected to */
name|uint8_t
name|hub_port
decl_stmt|;
comment|/**< Hub port this device is connected to */
name|uint8_t
name|pid_toggle
decl_stmt|;
comment|/**< This toggles between 0/1 on every packet send to track the data pid needed */
name|uint8_t
name|channel
decl_stmt|;
comment|/**< Hardware DMA channel for this pipe */
name|int8_t
name|split_sc_frame
decl_stmt|;
comment|/**< The low order bits of the frame number the split complete should be sent on */
block|}
name|cvmx_usb_pipe_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_usb_pipe_t
modifier|*
name|head
decl_stmt|;
comment|/**< Head of the list, or NULL if empty */
name|cvmx_usb_pipe_t
modifier|*
name|tail
decl_stmt|;
comment|/**< Tail if the list, or NULL if empty */
block|}
name|cvmx_usb_pipe_list_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
struct|struct
block|{
name|int
name|channel
decl_stmt|;
name|int
name|size
decl_stmt|;
name|uint64_t
name|address
decl_stmt|;
block|}
name|entry
index|[
name|MAX_CHANNELS
operator|+
literal|1
index|]
struct|;
name|int
name|head
decl_stmt|;
name|int
name|tail
decl_stmt|;
block|}
name|cvmx_usb_tx_fifo_t
typedef|;
end_typedef

begin_comment
comment|/**  * The state of the USB block is stored in this structure  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|init_flags
decl_stmt|;
comment|/**< Flags passed to initialize */
name|int
name|index
decl_stmt|;
comment|/**< Which USB block this is for */
name|int
name|idle_hardware_channels
decl_stmt|;
comment|/**< Bit set for every idle hardware channel */
name|cvmx_usbcx_hprt_t
name|usbcx_hprt
decl_stmt|;
comment|/**< Stored port status so we don't need to read a CSR to determine splits */
name|cvmx_usb_pipe_t
modifier|*
name|pipe_for_channel
index|[
name|MAX_CHANNELS
index|]
decl_stmt|;
comment|/**< Map channels to pipes */
name|cvmx_usb_transaction_t
modifier|*
name|free_transaction_head
decl_stmt|;
comment|/**< List of free transactions head */
name|cvmx_usb_transaction_t
modifier|*
name|free_transaction_tail
decl_stmt|;
comment|/**< List of free transactions tail */
name|cvmx_usb_pipe_t
name|pipe
index|[
name|MAX_PIPES
index|]
decl_stmt|;
comment|/**< Storage for pipes */
name|cvmx_usb_transaction_t
name|transaction
index|[
name|MAX_TRANSACTIONS
index|]
decl_stmt|;
comment|/**< Storage for transactions */
name|cvmx_usb_callback_func_t
name|callback
index|[
name|__CVMX_USB_CALLBACK_END
index|]
decl_stmt|;
comment|/**< User global callbacks */
name|void
modifier|*
name|callback_data
index|[
name|__CVMX_USB_CALLBACK_END
index|]
decl_stmt|;
comment|/**< User data for each callback */
name|int
name|indent
decl_stmt|;
comment|/**< Used by debug output to indent functions */
name|cvmx_usb_port_status_t
name|port_status
decl_stmt|;
comment|/**< Last port status used for change notification */
name|cvmx_usb_pipe_list_t
name|free_pipes
decl_stmt|;
comment|/**< List of all pipes that are currently closed */
name|cvmx_usb_pipe_list_t
name|idle_pipes
decl_stmt|;
comment|/**< List of open pipes that have no transactions */
name|cvmx_usb_pipe_list_t
name|active_pipes
index|[
literal|4
index|]
decl_stmt|;
comment|/**< Active pipes indexed by transfer type */
name|uint64_t
name|frame_number
decl_stmt|;
comment|/**< Increments every SOF interrupt for time keeping */
name|cvmx_usb_transaction_t
modifier|*
name|active_split
decl_stmt|;
comment|/**< Points to the current active split, or NULL */
name|cvmx_usb_tx_fifo_t
name|periodic
decl_stmt|;
name|cvmx_usb_tx_fifo_t
name|nonperiodic
decl_stmt|;
block|}
name|cvmx_usb_internal_state_t
typedef|;
end_typedef

begin_comment
comment|/* This macro logs out whenever a function is called if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_LOG_CALLED
parameter_list|()
define|\
value|if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \         cvmx_dprintf("%*s%s: called\n", 2*usb->indent++, "", __FUNCTION__);
end_define

begin_comment
comment|/* This macro logs out each function parameter if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_LOG_PARAM
parameter_list|(
name|format
parameter_list|,
name|param
parameter_list|)
define|\
value|if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS)) \         cvmx_dprintf("%*s%s: param %s = " format "\n", 2*usb->indent, "", __FUNCTION__, #param, param);
end_define

begin_comment
comment|/* This macro logs out when a function returns a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_RETURN
parameter_list|(
name|v
parameter_list|)
define|\
value|do {                                                                \         __typeof(v) r = v;                                              \         if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \             cvmx_dprintf("%*s%s: returned %s(%d)\n", 2*--usb->indent, "", __FUNCTION__, #v, r); \         return r;                                                       \     } while (0);
end_define

begin_comment
comment|/* This macro logs out when a function doesn't return a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_USB_RETURN_NOTHING
parameter_list|()
define|\
value|do {                                                                \         if (cvmx_unlikely(usb->init_flags& CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS))    \             cvmx_dprintf("%*s%s: returned\n", 2*--usb->indent, "", __FUNCTION__); \         return;                                                         \     } while (0);
end_define

begin_comment
comment|/* This macro spins on a field waiting for it to reach a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_WAIT_FOR_FIELD32
parameter_list|(
name|address
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|op
parameter_list|,
name|value
parameter_list|,
name|timeout_usec
parameter_list|)
define|\
value|({int result;                                                       \     do {                                                                \         uint64_t done = cvmx_get_cycle() + (uint64_t)timeout_usec *     \                            cvmx_clock_get_rate(CVMX_CLOCK_CORE) / 1000000;  \         type c;                                                         \         while (1)                                                       \         {                                                               \             c.u32 = __cvmx_usb_read_csr32(usb, address);                \             if (c.s.field op (value)) {                                 \                 result = 0;                                             \                 break;                                                  \             } else if (cvmx_get_cycle()> done) {                       \                 result = -1;                                            \                 break;                                                  \             } else                                                      \                 cvmx_wait(100);                                         \         }                                                               \     } while (0);                                                        \     result;})
end_define

begin_comment
comment|/* This macro logically sets a single field in a CSR. It does the sequence     read, modify, and write */
end_comment

begin_define
define|#
directive|define
name|USB_SET_FIELD32
parameter_list|(
name|address
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|do {                                            \         type c;                                     \         c.u32 = __cvmx_usb_read_csr32(usb, address);\         c.s.field = value;                          \         __cvmx_usb_write_csr32(usb, address, c.u32);\     } while (0)
end_define

begin_comment
comment|/* Returns the IO address to push/pop stuff data from the FIFOs */
end_comment

begin_define
define|#
directive|define
name|USB_FIFO_ADDRESS
parameter_list|(
name|channel
parameter_list|,
name|usb_index
parameter_list|)
value|(CVMX_USBCX_GOTGCTL(usb_index) + ((channel)+1)*0x1000)
end_define

begin_comment
comment|/**  * @INTERNAL  * Read a USB 32bit CSR. It performs the necessary address swizzle  * for 32bit CSRs and logs the value in a readable format if  * debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|__cvmx_usb_read_csr32
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|)
block|{
name|uint32_t
name|result
init|=
name|cvmx_read64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|)
decl_stmt|;
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Read: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a USB 32bit CSR. It performs the necessary address  * swizzle for 32bit CSRs and logs the value in a readable format  * if debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to write  * @param value   Value to write  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_write_csr32
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Write: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cvmx_write64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cvmx_read64_uint64
argument_list|(
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Read a USB 64bit CSR. It logs the value in a readable format if  * debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_usb_read_csr64
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|)
block|{
name|uint64_t
name|result
init|=
name|cvmx_read64_uint64
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Read: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a USB 64bit CSR. It logs the value in a readable format  * if debugging is on.  *  * @param usb     USB block this access is for  * @param address 64bit address to write  * @param value   Value to write  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_write_csr64
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
if|#
directive|if
name|ALLOW_CSR_DECODES
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CSRS
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Write: "
argument_list|)
expr_stmt|;
name|cvmx_csr_db_decode
argument_list|(
name|cvmx_get_proc_id
argument_list|()
argument_list|,
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cvmx_write64_uint64
argument_list|(
name|address
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Utility function to convert complete codes into strings  *  * @param complete_code  *               Code to convert  *  * @return Human readable string  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|__cvmx_usb_complete_to_string
parameter_list|(
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
switch|switch
condition|(
name|complete_code
condition|)
block|{
case|case
name|CVMX_USB_COMPLETE_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|CVMX_USB_COMPLETE_SHORT
case|:
return|return
literal|"SHORT"
return|;
case|case
name|CVMX_USB_COMPLETE_CANCEL
case|:
return|return
literal|"CANCEL"
return|;
case|case
name|CVMX_USB_COMPLETE_ERROR
case|:
return|return
literal|"ERROR"
return|;
case|case
name|CVMX_USB_COMPLETE_STALL
case|:
return|return
literal|"STALL"
return|;
case|case
name|CVMX_USB_COMPLETE_XACTERR
case|:
return|return
literal|"XACTERR"
return|;
case|case
name|CVMX_USB_COMPLETE_DATATGLERR
case|:
return|return
literal|"DATATGLERR"
return|;
case|case
name|CVMX_USB_COMPLETE_BABBLEERR
case|:
return|return
literal|"BABBLEERR"
return|;
case|case
name|CVMX_USB_COMPLETE_FRAMEERR
case|:
return|return
literal|"FRAMEERR"
return|;
block|}
return|return
literal|"Update __cvmx_usb_complete_to_string"
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return non zero if this pipe connects to a non HIGH speed  * device through a high speed hub.  *  * @param usb    USB block this access is for  * @param pipe   Pipe to check  *  * @return Non zero if we need to do split transactions  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_pipe_needs_split
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pipe
operator|->
name|device_speed
operator|!=
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Trivial utility function to return the correct PID for a pipe  *  * @param pipe   pipe to check  *  * @return PID for pipe  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_data_pid
parameter_list|(
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|pipe
operator|->
name|pid_toggle
condition|)
return|return
literal|2
return|;
comment|/* Data1 */
else|else
return|return
literal|0
return|;
comment|/* Data0 */
block|}
end_function

begin_comment
comment|/**  * Return the number of USB ports supported by this Octeon  * chip. If the chip doesn't support USB, or is not supported  * by this API, a zero will be returned. Most Octeon chips  * support one usb port, but some support two ports.  * cvmx_usb_initialize() must be called on independent  * cvmx_usb_state_t structures.  *  * This utilizes cvmx_helper_board_usb_get_num_ports()  * to get any board specific variations.  *  * @return Number of port, zero if usb isn't supported  */
end_comment

begin_function
name|int
name|cvmx_usb_get_num_ports
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|arch_ports
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|arch_ports
operator|=
literal|1
expr_stmt|;
else|else
name|arch_ports
operator|=
literal|0
expr_stmt|;
return|return
name|__cvmx_helper_board_usb_get_num_ports
argument_list|(
name|arch_ports
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_get_num_ports
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Allocate a usb transaction for use  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  *  * @return Transaction or NULL  */
end_comment

begin_function
specifier|static
specifier|inline
name|cvmx_usb_transaction_t
modifier|*
name|__cvmx_usb_alloc_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|usb
operator|->
name|free_transaction_head
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|usb
operator|->
name|free_transaction_head
operator|=
name|t
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|usb
operator|->
name|free_transaction_head
condition|)
name|usb
operator|->
name|free_transaction_tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Failed to allocate a transaction\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a usb transaction  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param transaction  *               Transaction to free  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_free_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|)
block|{
name|transaction
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|transaction
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|free_transaction_tail
condition|)
name|usb
operator|->
name|free_transaction_tail
operator|->
name|next
operator|=
name|transaction
expr_stmt|;
else|else
name|usb
operator|->
name|free_transaction_head
operator|=
name|transaction
expr_stmt|;
name|usb
operator|->
name|free_transaction_tail
operator|=
name|transaction
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Add a pipe to the tail of a list  * @param list   List to add pipe to  * @param pipe   Pipe to add  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_append_pipe
parameter_list|(
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|list
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|tail
condition|)
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|pipe
expr_stmt|;
else|else
name|list
operator|->
name|head
operator|=
name|pipe
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|pipe
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Remove a pipe from a list  * @param list   List to remove pipe from  * @param pipe   Pipe to remove  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usb_remove_pipe
parameter_list|(
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
if|if
condition|(
name|list
operator|->
name|head
operator|==
name|pipe
condition|)
block|{
name|list
operator|->
name|head
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|head
condition|)
name|list
operator|->
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
else|else
name|list
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list
operator|->
name|tail
operator|==
name|pipe
condition|)
block|{
name|list
operator|->
name|tail
operator|=
name|pipe
operator|->
name|prev
expr_stmt|;
name|list
operator|->
name|tail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pipe
operator|->
name|prev
operator|->
name|next
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
name|pipe
operator|->
name|next
operator|->
name|prev
operator|=
name|pipe
operator|->
name|prev
expr_stmt|;
name|pipe
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Initialize a USB port for use. This must be called before any  * other access to the Octeon USB port is made. The port starts  * off in the disabled state.  *  * @param state  Pointer to an empty cvmx_usb_state_t structure  *               that will be populated by the initialize call.  *               This structure is then passed to all other USB  *               functions.  * @param usb_port_number  *               Which Octeon USB port to initialize.  * @param flags  Flags to control hardware initialization. See  *               cvmx_usb_initialize_flags_t for the flag  *               definitions. Some flags are mandatory.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_initialize
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|usb_port_number
parameter_list|,
name|cvmx_usb_initialize_flags_t
name|flags
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
name|cvmx_usbnx_usbp_ctl_status_t
name|usbn_usbp_ctl_status
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|usb
operator|->
name|init_flags
operator|=
name|flags
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|usb_port_number
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Make sure that state is large enough to store the internal state */
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|state
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|usb
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* At first allow 0-1 for the usb port number */
if|if
condition|(
operator|(
name|usb_port_number
operator|<
literal|0
operator|)
operator|||
operator|(
name|usb_port_number
operator|>
literal|1
operator|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* For all chips except 52XX there is only one port */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
name|usb_port_number
operator|>
literal|0
operator|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Try to determine clock type automatically */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI
operator||
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
operator|==
name|USB_CLOCK_TYPE_CRYSTAL_12
condition|)
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI
expr_stmt|;
comment|/* Only 12 MHZ crystals are supported */
else|else
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* Check for auto ref clock frequency */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
operator|)
condition|)
switch|switch
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
condition|)
block|{
case|case
name|USB_CLOCK_TYPE_REF_12
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_24
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_48
case|:
name|flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ
expr_stmt|;
break|break;
default|default:
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|memset
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|usb
argument_list|)
argument_list|)
expr_stmt|;
name|usb
operator|->
name|init_flags
operator|=
name|flags
expr_stmt|;
comment|/* Initialize the USB state structure */
block|{
name|int
name|i
decl_stmt|;
name|usb
operator|->
name|index
operator|=
name|usb_port_number
expr_stmt|;
comment|/* Initialize the transaction double linked list */
name|usb
operator|->
name|free_transaction_head
operator|=
name|NULL
expr_stmt|;
name|usb
operator|->
name|free_transaction_tail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TRANSACTIONS
condition|;
name|i
operator|++
control|)
name|__cvmx_usb_free_transaction
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|transaction
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PIPES
condition|;
name|i
operator|++
control|)
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|usb
operator|->
name|pipe
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Power On Reset and PHY Initialization */
comment|/* 1. Wait for DCOK to assert (nothing to do) */
comment|/* 2a. Write USBN0/1_CLK_CTL[POR] = 1 and         USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0 */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* 2b. Select the USB reference clock/crystal parameters by writing         appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON] */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* The USB port uses 12/24/48MHz 2.5V board clock             source at USB_XO. USB_XI should be tied to GND.             Most Octeon evaluation boards require this setting */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|2
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|1
expr_stmt|;
comment|/* From CN52XX manual */
switch|switch
condition|(
name|flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
condition|)
block|{
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* The USB port uses a 12MHz crystal as clock source             at USB_XO and USB_XI */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN52XX manual */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and         setting USBN0/1_CLK_CTL[ENABLE] = 1.  Divide the core clock down such         that USB is as close as possible to 125Mhz */
block|{
name|int
name|divisor
init|=
operator|(
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|+
literal|125000000
operator|-
literal|1
operator|)
operator|/
literal|125000000
decl_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|4
condition|)
comment|/* Lower than 4 doesn't seem to work properly */
name|divisor
operator|=
literal|4
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide
operator|=
name|divisor
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide2
operator|=
literal|0
expr_stmt|;
block|}
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
name|cvmx_wait
argument_list|(
literal|64
argument_list|)
expr_stmt|;
comment|/* 3. Program the power-on reset field in the USBN clock-control register:         USBN_CLK_CTL[POR] = 0 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 4. Wait 1 ms for PHY clock to start */
name|cvmx_wait_usec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 5. Program the Reset input from automatic test equipment field in the         USBP control and status register: USBN_USBP_CTL_STATUS[ATE_RESET] = 1 */
name|usbn_usbp_ctl_status
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 6. Wait 10 cycles */
name|cvmx_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 7. Clear ATE_RESET field in the USBN clock-control register:         USBN_USBP_CTL_STATUS[ATE_RESET] = 0 */
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 8. Program the PHY reset field in the USBN clock-control register:         USBN_CLK_CTL[PRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 9. Program the USBP control and status register to select host or         device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for         device */
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|hst_mode
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 10. Wait 1 Âµs */
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 11. Program the hreset_n field in the USBN clock-control register:         USBN_CLK_CTL[HRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 12. Proceed to USB core initialization */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* USB Core Initialization */
comment|/* 1. Read USBC_GHWCFG1, USBC_GHWCFG2, USBC_GHWCFG3, USBC_GHWCFG4 to         determine USB core configuration parameters. */
comment|/* Nothing needed */
comment|/* 2. Program the following fields in the global AHB configuration         register (USBC_GAHBCFG)         DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode         Burst length, USBC_GAHBCFG[HBSTLEN] = 0         Nonperiodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[NPTXFEMPLVL]         Periodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[PTXFEMPLVL]         Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1 */
block|{
name|cvmx_usbcx_gahbcfg_t
name|usbcx_gahbcfg
decl_stmt|;
comment|/* Due to an errata, CN31XX doesn't support DMA */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|dmaen
operator|=
operator|!
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
operator|)
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
name|usb
operator|->
name|idle_hardware_channels
operator|=
literal|0x1
expr_stmt|;
comment|/* Only use one channel with non DMA */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
name|usb
operator|->
name|idle_hardware_channels
operator|=
literal|0xf7
expr_stmt|;
comment|/* CN5XXX have an errata with channel 3 */
else|else
name|usb
operator|->
name|idle_hardware_channels
operator|=
literal|0xff
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|hbstlen
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|nptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|ptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|glblintrmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GAHBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gahbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Program the following fields in USBC_GUSBCFG register.         HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0         ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0         USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5         PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0 */
block|{
name|cvmx_usbcx_gusbcfg_t
name|usbcx_gusbcfg
decl_stmt|;
name|usbcx_gusbcfg
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|toutcal
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|ddrsel
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|usbtrdtim
operator|=
literal|0x5
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|phylpwrclksel
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gusbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 4. The software must unmask the following bits in the USBC_GINTMSK         register.         OTG interrupt mask, USBC_GINTMSK[OTGINTMSK] = 1         Mode mismatch interrupt mask, USBC_GINTMSK[MODEMISMSK] = 1 */
block|{
name|cvmx_usbcx_gintmsk_t
name|usbcx_gintmsk
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|usbcx_gintmsk
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|otgintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|modemismsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|hchintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|sofmsk
operator|=
literal|0
expr_stmt|;
comment|/* We need RX FIFO interrupts if we don't have DMA */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|rxflvlmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Disable all channel interrupts. We'll enable them per channel later */
for|for
control|(
name|channel
operator|=
literal|0
init|;
name|channel
operator|<
literal|8
condition|;
name|channel
operator|++
control|)
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTMSKX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* Host Port Initialization */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d is in host mode\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* 1. Program the host-port interrupt-mask field to unmask,             USBC_GINTMSK[PRTINT] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|prtintmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|disconnintmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 2. Program the USBC_HCFG register to select full-speed host or             high-speed host. */
block|{
name|cvmx_usbcx_hcfg_t
name|usbcx_hcfg
decl_stmt|;
name|usbcx_hcfg
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_hcfg
operator|.
name|s
operator|.
name|fslssupp
operator|=
literal|0
expr_stmt|;
name|usbcx_hcfg
operator|.
name|s
operator|.
name|fslspclksel
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_hcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Program the port power bit to drive VBUS on the USB,             USBC_HPRT[PRTPWR] = 1 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtpwr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Steps 4-15 from the manual are done later in the port enable */
block|}
ifdef|#
directive|ifdef
name|__CVMX_ERROR_H__
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_USB
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_initialize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Shutdown a USB port after a call to cvmx_usb_initialize().  * The port should be disabled with all pipes closed when this  * function is called.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_shutdown
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Make sure all pipes are closed */
if|if
condition|(
name|usb
operator|->
name|idle_pipes
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_ISOCHRONOUS
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_INTERRUPT
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_CONTROL
index|]
operator|.
name|head
operator|||
name|usb
operator|->
name|active_pipes
index|[
name|CVMX_USB_TRANSFER_BULK
index|]
operator|.
name|head
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_BUSY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__CVMX_ERROR_H__
name|cvmx_error_disable_group
argument_list|(
name|CVMX_ERROR_GROUP_USB
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Disable the clocks and put them in power on reset */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_shutdown
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Enable a USB port. After this call succeeds, the USB port is  * online and servicing requests.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_enable
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_ghwcfg3_t
name|usbcx_ghwcfg3
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usb
operator|->
name|usbcx_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the port is already enabled the just return. We don't need to do         anything */
if|if
condition|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtena
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
comment|/* If there is nothing plugged into the port then fail immediately */
if|if
condition|(
operator|!
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtconnsts
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d Nothing plugged into the port\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Program the port reset bit to start the reset process */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtrst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait at least 50ms (high speed), or 10ms (full speed) for the reset         process to complete. */
name|cvmx_wait_usec
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* Program the port reset bit to 0, USBC_HPRT[PRTRST] = 0 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtrst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the USBC_HPRT[PRTENA]. */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtena
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|100000
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Timeout waiting for the port to finish reset\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Read the port speed field to get the enumerated speed, USBC_HPRT[PRTSPD]. */
name|usb
operator|->
name|usbcx_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: USB%d is in %s speed mode\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|usb
operator|->
name|index
argument_list|,
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
condition|?
literal|"high"
else|:
operator|(
name|usb
operator|->
name|usbcx_hprt
operator|.
name|s
operator|.
name|prtspd
operator|==
name|CVMX_USB_SPEED_FULL
operator|)
condition|?
literal|"full"
else|:
literal|"low"
argument_list|)
expr_stmt|;
name|usbcx_ghwcfg3
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GHWCFG3
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 13. Program the USBC_GRXFSIZ register to select the size of the receive         FIFO (25%). */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grxfsiz_t
argument_list|,
name|rxfdep
argument_list|,
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* 14. Program the USBC_GNPTXFSIZ register to select the size and the         start address of the non- periodic transmit FIFO for nonperiodic         transactions (50%). */
block|{
name|cvmx_usbcx_gnptxfsiz_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|nptxfdep
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|2
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|nptxfstaddr
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* 15. Program the USBC_HPTXFSIZ register to select the size and start         address of the periodic transmit FIFO for periodic transactions (25%). */
block|{
name|cvmx_usbcx_hptxfsiz_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|ptxfsize
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|ptxfstaddr
operator|=
literal|3
operator|*
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
operator|/
literal|4
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Flush all FIFOs */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfnum
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfflsh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|txfflsh
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|rxfflsh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD32
argument_list|(
name|CVMX_USBCX_GRSTCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_grstctl_t
argument_list|,
name|rxfflsh
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Disable a USB port. After this call the USB port will not  * generate data transfers and will not generate events.  * Transactions in process will fail and call their  * associated callbacks.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_disable
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Disable the port */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hprt_t
argument_list|,
name|prtena
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the current state of the USB port. Use this call to  * determine if the usb port has anything connected, is enabled,  * or has some sort of error condition. The return value of this  * call has "changed" bits to signal of the value of some fields  * have changed between calls. These "changed" fields are based  * on the last call to cvmx_usb_set_status(). In order to clear  * them, you must update the status through cvmx_usb_set_status().  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return Port status information  */
end_comment

begin_function
name|cvmx_usb_port_status_t
name|cvmx_usb_get_status
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_hprt_t
name|usbc_hprt
decl_stmt|;
name|cvmx_usb_port_status_t
name|result
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usbc_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|port_enabled
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtena
expr_stmt|;
name|result
operator|.
name|port_over_current
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtovrcurract
expr_stmt|;
name|result
operator|.
name|port_powered
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtpwr
expr_stmt|;
name|result
operator|.
name|port_speed
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtspd
expr_stmt|;
name|result
operator|.
name|connected
operator|=
name|usbc_hprt
operator|.
name|s
operator|.
name|prtconnsts
expr_stmt|;
name|result
operator|.
name|connect_change
operator|=
operator|(
name|result
operator|.
name|connected
operator|!=
name|usb
operator|->
name|port_status
operator|.
name|connected
operator|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: returned port enabled=%d, over_current=%d, powered=%d, speed=%d, connected=%d, connect_change=%d\n"
argument_list|,
literal|2
operator|*
operator|(
operator|--
name|usb
operator|->
name|indent
operator|)
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|result
operator|.
name|port_enabled
argument_list|,
name|result
operator|.
name|port_over_current
argument_list|,
name|result
operator|.
name|port_powered
argument_list|,
name|result
operator|.
name|port_speed
argument_list|,
name|result
operator|.
name|connected
argument_list|,
name|result
operator|.
name|connect_change
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_get_status
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Set the current state of the USB port. The status is used as  * a reference for the "changed" bits returned by  * cvmx_usb_get_status(). Other than serving as a reference, the  * status passed to this function is not used. No fields can be  * changed through this call.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param port_status  *               Port status to set, most like returned by cvmx_usb_get_status()  */
end_comment

begin_function
name|void
name|cvmx_usb_set_status
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_port_status_t
name|port_status
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usb
operator|->
name|port_status
operator|=
name|port_status
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_set_status
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Convert a USB transaction into a handle  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param transaction  *               Transaction to get handle for  *  * @return Handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_submit_handle
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|transaction
operator|-
operator|(
name|unsigned
name|long
operator|)
name|usb
operator|->
name|transaction
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|transaction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Convert a USB pipe into a handle  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe to get handle for  *  * @return Handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_usb_get_pipe_handle
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
return|return
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pipe
operator|-
operator|(
name|unsigned
name|long
operator|)
name|usb
operator|->
name|pipe
operator|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pipe
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Open a virtual pipe between the host and a USB device. A pipe  * must be opened before data can be transferred between a device  * and Octeon.  *  * @param state      USB device state populated by  *                   cvmx_usb_initialize().  * @param flags      Optional pipe flags defined in  *                   cvmx_usb_pipe_flags_t.  * @param device_addr  *                   USB device address to open the pipe to  *                   (0-127).  * @param endpoint_num  *                   USB endpoint number to open the pipe to  *                   (0-15).  * @param device_speed  *                   The speed of the device the pipe is going  *                   to. This must match the device's speed,  *                   which may be different than the port speed.  * @param max_packet The maximum packet length the device can  *                   transmit/receive (low speed=0-8, full  *                   speed=0-1023, high speed=0-1024). This value  *                   comes from the standard endpoint descriptor  *                   field wMaxPacketSize bits<10:0>.  * @param transfer_type  *                   The type of transfer this pipe is for.  * @param transfer_dir  *                   The direction the pipe is in. This is not  *                   used for control pipes.  * @param interval   For ISOCHRONOUS and INTERRUPT transfers,  *                   this is how often the transfer is scheduled  *                   for. All other transfers should specify  *                   zero. The units are in frames (8000/sec at  *                   high speed, 1000/sec for full speed).  * @param multi_count  *                   For high speed devices, this is the maximum  *                   allowed number of packet per microframe.  *                   Specify zero for non high speed devices. This  *                   value comes from the standard endpoint descriptor  *                   field wMaxPacketSize bits<12:11>.  * @param hub_device_addr  *                   Hub device address this device is connected  *                   to. Devices connected directly to Octeon  *                   use zero. This is only used when the device  *                   is full/low speed behind a high speed hub.  *                   The address will be of the high speed hub,  *                   not and full speed hubs after it.  * @param hub_port   Which port on the hub the device is  *                   connected. Use zero for devices connected  *                   directly to Octeon. Like hub_device_addr,  *                   this is only used for full/low speed  *                   devices behind a high speed hub.  *  * @return A non negative value is a pipe handle. Negative  *         values are failure codes from cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_open_pipe
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_pipe_flags_t
name|flags
parameter_list|,
name|int
name|device_addr
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|cvmx_usb_speed_t
name|device_speed
parameter_list|,
name|int
name|max_packet
parameter_list|,
name|cvmx_usb_transfer_t
name|transfer_type
parameter_list|,
name|cvmx_usb_direction_t
name|transfer_dir
parameter_list|,
name|int
name|interval
parameter_list|,
name|int
name|multi_count
parameter_list|,
name|int
name|hub_device_addr
parameter_list|,
name|int
name|hub_port
parameter_list|)
block|{
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|device_addr
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|device_speed
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|max_packet
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_type
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|transfer_dir
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|multi_count
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|hub_device_addr
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|hub_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|device_addr
operator|<
literal|0
operator|)
operator|||
operator|(
name|device_addr
operator|>
name|MAX_USB_ADDRESS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|endpoint_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|endpoint_num
operator|>
name|MAX_USB_ENDPOINT
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|device_speed
operator|>
name|CVMX_USB_SPEED_LOW
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|max_packet
operator|<=
literal|0
operator|)
operator|||
operator|(
name|max_packet
operator|>
literal|1024
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|transfer_type
operator|>
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|transfer_dir
operator|!=
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|interval
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_CONTROL
operator|)
operator|&&
name|interval
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|multi_count
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|device_speed
operator|!=
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|multi_count
operator|!=
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|hub_device_addr
operator|<
literal|0
operator|)
operator|||
operator|(
name|hub_device_addr
operator|>
name|MAX_USB_ADDRESS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|hub_port
operator|<
literal|0
operator|)
operator|||
operator|(
name|hub_port
operator|>
name|MAX_USB_HUB_PORT
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Find a free pipe */
name|pipe
operator|=
name|usb
operator|->
name|free_pipes
operator|.
name|head
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_NO_MEMORY
argument_list|)
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|flags
operator|=
name|flags
operator||
name|__CVMX_USB_PIPE_FLAGS_OPEN
expr_stmt|;
if|if
condition|(
operator|(
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
name|pipe
operator|->
name|device_addr
operator|=
name|device_addr
expr_stmt|;
name|pipe
operator|->
name|endpoint_num
operator|=
name|endpoint_num
expr_stmt|;
name|pipe
operator|->
name|device_speed
operator|=
name|device_speed
expr_stmt|;
name|pipe
operator|->
name|max_packet
operator|=
name|max_packet
expr_stmt|;
name|pipe
operator|->
name|transfer_type
operator|=
name|transfer_type
expr_stmt|;
name|pipe
operator|->
name|transfer_dir
operator|=
name|transfer_dir
expr_stmt|;
comment|/* All pipes use interval to rate limit NAK processing. Force an interval         if one wasn't supplied */
if|if
condition|(
operator|!
name|interval
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|pipe
operator|->
name|interval
operator|=
name|interval
operator|*
literal|8
expr_stmt|;
comment|/* Force start splits to be schedule on uFrame 0 */
name|pipe
operator|->
name|next_tx_frame
operator|=
operator|(
operator|(
name|usb
operator|->
name|frame_number
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
else|else
block|{
name|pipe
operator|->
name|interval
operator|=
name|interval
expr_stmt|;
name|pipe
operator|->
name|next_tx_frame
operator|=
name|usb
operator|->
name|frame_number
operator|+
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
name|pipe
operator|->
name|multi_count
operator|=
name|multi_count
expr_stmt|;
name|pipe
operator|->
name|hub_device_addr
operator|=
name|hub_device_addr
expr_stmt|;
name|pipe
operator|->
name|hub_port
operator|=
name|hub_port
expr_stmt|;
name|pipe
operator|->
name|pid_toggle
operator|=
literal|0
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
comment|/* We don't need to tell the hardware about this pipe yet since         it doesn't have any submitted requests */
name|CVMX_USB_RETURN
argument_list|(
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_open_pipe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Poll the RX FIFOs and remove data as needed. This function is only used  * in non DMA mode. It is very important that this function be called quickly  * enough to prevent FIFO overflow.  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_poll_rx_fifo
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_grxstsph_t
name|rx_status
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|uint64_t
name|address
decl_stmt|;
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|rx_status
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GRXSTSPH
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only read data if IN data is there */
if|if
condition|(
name|rx_status
operator|.
name|s
operator|.
name|pktsts
operator|!=
literal|2
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
comment|/* Check if no data is available */
if|if
condition|(
operator|!
name|rx_status
operator|.
name|s
operator|.
name|bcnt
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
name|channel
operator|=
name|rx_status
operator|.
name|s
operator|.
name|chnum
expr_stmt|;
name|bytes
operator|=
name|rx_status
operator|.
name|s
operator|.
name|bcnt
expr_stmt|;
if|if
condition|(
operator|!
name|bytes
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
comment|/* Get where the DMA engine would have written this data */
name|address
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|address
operator|+
name|bytes
argument_list|)
expr_stmt|;
comment|/* Loop writing the FIFO data for this packet into memory */
while|while
condition|(
name|bytes
operator|>
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|USB_FIFO_ADDRESS
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|-=
literal|4
expr_stmt|;
block|}
name|CVMX_SYNCW
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Fill the TX hardware fifo with data out of the software  * fifos  *  * @param usb       USB device state populated by  *                  cvmx_usb_initialize().  * @param fifo      Software fifo to use  * @param available Amount of space in the hardware fifo  *  * @return Non zero if the hardware fifo was too small and needs  *         to be serviced again.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_fill_tx_hw
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_tx_fifo_t
modifier|*
name|fifo
parameter_list|,
name|int
name|available
parameter_list|)
block|{
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|available
argument_list|)
expr_stmt|;
comment|/* We're done either when there isn't anymore space or the software FIFO         is empty */
while|while
condition|(
name|available
operator|&&
operator|(
name|fifo
operator|->
name|head
operator|!=
name|fifo
operator|->
name|tail
operator|)
condition|)
block|{
name|int
name|i
init|=
name|fifo
operator|->
name|tail
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ptr
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|address
argument_list|)
decl_stmt|;
name|uint64_t
name|csr_address
init|=
name|USB_FIFO_ADDRESS
argument_list|(
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
operator|^
literal|4
decl_stmt|;
name|int
name|words
init|=
name|available
decl_stmt|;
comment|/* Limit the amount of data to waht the SW fifo has */
if|if
condition|(
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
operator|<=
name|available
condition|)
block|{
name|words
operator|=
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|fifo
operator|->
name|tail
operator|++
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|tail
operator|>
name|MAX_CHANNELS
condition|)
name|fifo
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Update the next locations and counts */
name|available
operator|-=
name|words
expr_stmt|;
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|address
operator|+=
name|words
operator|*
literal|4
expr_stmt|;
name|fifo
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
operator|-=
name|words
expr_stmt|;
comment|/* Write the HW fifo data. The read every three writes is due             to an errata on CN3XXX chips */
while|while
condition|(
name|words
operator|>
literal|3
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|cvmx_read64_uint64
argument_list|(
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|words
operator|-=
literal|3
expr_stmt|;
block|}
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|words
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|words
condition|)
name|cvmx_write64_uint32
argument_list|(
name|csr_address
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|cvmx_read64_uint64
argument_list|(
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
name|fifo
operator|->
name|head
operator|!=
name|fifo
operator|->
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Check the hardware FIFOs and fill them as needed  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_poll_tx_fifo
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|periodic
operator|.
name|head
operator|!=
name|usb
operator|->
name|periodic
operator|.
name|tail
condition|)
block|{
name|cvmx_usbcx_hptxsts_t
name|tx_status
decl_stmt|;
name|tx_status
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPTXSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_fill_tx_hw
argument_list|(
name|usb
argument_list|,
operator|&
name|usb
operator|->
name|periodic
argument_list|,
name|tx_status
operator|.
name|s
operator|.
name|ptxfspcavail
argument_list|)
condition|)
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|ptxfempmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|ptxfempmsk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usb
operator|->
name|nonperiodic
operator|.
name|head
operator|!=
name|usb
operator|->
name|nonperiodic
operator|.
name|tail
condition|)
block|{
name|cvmx_usbcx_gnptxsts_t
name|tx_status
decl_stmt|;
name|tx_status
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_fill_tx_hw
argument_list|(
name|usb
argument_list|,
operator|&
name|usb
operator|->
name|nonperiodic
argument_list|,
name|tx_status
operator|.
name|s
operator|.
name|nptxfspcavail
argument_list|)
condition|)
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|nptxfempmsk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|nptxfempmsk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Fill the TX FIFO with an outgoing packet  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  * @param channel Channel number to get packet from  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_fill_tx_fifo
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|cvmx_usbcx_hccharx_t
name|hcchar
decl_stmt|;
name|cvmx_usbcx_hcspltx_t
name|usbc_hcsplt
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
decl_stmt|;
name|cvmx_usb_tx_fifo_t
modifier|*
name|fifo
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* We only need to fill data on outbound channels */
name|hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcchar
operator|.
name|s
operator|.
name|epdir
operator|!=
name|CVMX_USB_DIRECTION_OUT
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
comment|/* OUT Splits only have data on the start and not the complete */
name|usbc_hcsplt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_hcsplt
operator|.
name|s
operator|.
name|spltena
operator|&&
name|usbc_hcsplt
operator|.
name|s
operator|.
name|compsplt
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
comment|/* Find out how many bytes we need to fill and convert it into 32bit words */
name|usbc_hctsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
condition|)
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|hcchar
operator|.
name|s
operator|.
name|eptype
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
operator|)
operator|||
operator|(
name|hcchar
operator|.
name|s
operator|.
name|eptype
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
operator|)
condition|)
name|fifo
operator|=
operator|&
name|usb
operator|->
name|periodic
expr_stmt|;
else|else
name|fifo
operator|=
operator|&
name|usb
operator|->
name|nonperiodic
expr_stmt|;
name|fifo
operator|->
name|entry
index|[
name|fifo
operator|->
name|head
index|]
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
name|fifo
operator|->
name|entry
index|[
name|fifo
operator|->
name|head
index|]
operator|.
name|address
operator|=
name|__cvmx_usb_read_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|)
expr_stmt|;
name|fifo
operator|->
name|entry
index|[
name|fifo
operator|->
name|head
index|]
operator|.
name|size
operator|=
operator|(
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|fifo
operator|->
name|head
operator|++
expr_stmt|;
if|if
condition|(
name|fifo
operator|->
name|head
operator|>
name|MAX_CHANNELS
condition|)
name|fifo
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_poll_tx_fifo
argument_list|(
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Perform channel specific setup for Control transactions. All  * the generic stuff will already have been done in  * __cvmx_usb_start_channel()  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  * @param channel Channel to setup  * @param pipe    Pipe for control transaction  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_start_channel_control
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
name|int
name|bytes_to_transfer
init|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
name|int
name|packets_to_transfer
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transaction
operator|->
name|stage
condition|)
block|{
case|case
name|CVMX_USB_STAGE_NON_CONTROL
case|:
case|case
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
case|:
name|cvmx_dprintf
argument_list|(
literal|"%s: ERROR - Non control stage\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
literal|3
expr_stmt|;
comment|/* Setup */
name|bytes_to_transfer
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
comment|/* All Control operations start with a setup going OUT */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
name|CVMX_USB_DIRECTION_OUT
argument_list|)
expr_stmt|;
comment|/* Setup send the control header instead of the buffer data. The                 buffer data will be used in the next stage */
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|transaction
operator|->
name|control_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
literal|3
expr_stmt|;
comment|/* Setup */
name|bytes_to_transfer
operator|=
literal|0
expr_stmt|;
comment|/* All Control operations start with a setup going OUT */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
name|CVMX_USB_DIRECTION_OUT
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_DATA
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
condition|)
name|bytes_to_transfer
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes_to_transfer
operator|>
name|pipe
operator|->
name|max_packet
condition|)
name|bytes_to_transfer
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_IN
else|:
name|CVMX_USB_DIRECTION_OUT
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|)
name|bytes_to_transfer
operator|=
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_IN
else|:
name|CVMX_USB_DIRECTION_OUT
operator|)
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|bytes_to_transfer
operator|=
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_OUT
else|:
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
case|:
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|bytes_to_transfer
operator|=
literal|0
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|epdir
argument_list|,
operator|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
name|CVMX_USB_DIRECTION_OUT
else|:
name|CVMX_USB_DIRECTION_IN
operator|)
argument_list|)
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hcspltx_t
argument_list|,
name|compsplt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Make sure the transfer never exceeds the byte limit of the hardware.         Further bytes will be sent as continued transactions */
if|if
condition|(
name|bytes_to_transfer
operator|>
name|MAX_TRANSFER_BYTES
condition|)
block|{
comment|/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
name|bytes_to_transfer
operator|=
name|MAX_TRANSFER_BYTES
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
name|bytes_to_transfer
operator|*=
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
comment|/* Calculate the number of packets to transfer. If the length is zero         we still need to transfer one packet */
name|packets_to_transfer
operator|=
operator|(
name|bytes_to_transfer
operator|+
name|pipe
operator|->
name|max_packet
operator|-
literal|1
operator|)
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
if|if
condition|(
name|packets_to_transfer
operator|==
literal|0
condition|)
name|packets_to_transfer
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|packets_to_transfer
operator|>
literal|1
operator|)
operator|&&
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
operator|)
condition|)
block|{
comment|/* Limit to one packet when not using DMA. Channels must be restarted             between every packet for IN transactions, so there is no reason to             do multiple packets in a row */
name|packets_to_transfer
operator|=
literal|1
expr_stmt|;
name|bytes_to_transfer
operator|=
name|packets_to_transfer
operator|*
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|packets_to_transfer
operator|>
name|MAX_TRANSFER_PACKETS
condition|)
block|{
comment|/* Limit the number of packet and data transferred to what the             hardware can handle */
name|packets_to_transfer
operator|=
name|MAX_TRANSFER_PACKETS
expr_stmt|;
name|bytes_to_transfer
operator|=
name|packets_to_transfer
operator|*
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|bytes_to_transfer
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
name|packets_to_transfer
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hctsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Start a channel to perform the pipe's head transaction  *  * @param usb     USB device state populated by  *                cvmx_usb_initialize().  * @param channel Channel to setup  * @param pipe    Pipe to start  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_start_channel
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Channel %d started. Pipe %d transaction %d stage %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|channel
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|transaction
operator|->
name|stage
argument_list|)
expr_stmt|;
comment|/* Make sure all writes to the DMA region get flushed */
name|CVMX_SYNCW
expr_stmt|;
comment|/* Attach the channel to the pipe */
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
operator|=
name|pipe
expr_stmt|;
name|pipe
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
comment|/* Mark this channel as in use */
name|usb
operator|->
name|idle_hardware_channels
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
comment|/* Enable the channel interrupt bits */
block|{
name|cvmx_usbcx_hcintx_t
name|usbc_hcint
decl_stmt|;
name|cvmx_usbcx_hcintmskx_t
name|usbc_hcintmsk
decl_stmt|;
name|cvmx_usbcx_haintmsk_t
name|usbc_haintmsk
decl_stmt|;
comment|/* Clear all channel status bits */
name|usbc_hcint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcint
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|chhltdmsk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
block|{
comment|/* Channels need these extra interrupts when we aren't in DMA mode */
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|datatglerrmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|frmovrunmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|bblerrmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|xacterrmsk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* Splits don't generate xfercompl, so we need ACK and NYET */
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|nyetmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|ackmsk
operator|=
literal|1
expr_stmt|;
block|}
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|nakmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|stallmsk
operator|=
literal|1
expr_stmt|;
name|usbc_hcintmsk
operator|.
name|s
operator|.
name|xfercomplmsk
operator|=
literal|1
expr_stmt|;
block|}
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTMSKX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Enable the channel interrupt to propagate */
name|usbc_haintmsk
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_haintmsk
operator|.
name|s
operator|.
name|haintmsk
operator||=
literal|1
operator|<<
name|channel
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_haintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the locations the DMA engines use  */
block|{
name|uint64_t
name|dma_address
init|=
name|transaction
operator|->
name|buffer
operator|+
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|dma_address
operator|=
name|transaction
operator|->
name|buffer
operator|+
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|offset
operator|+
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|dma_address
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr64
argument_list|(
name|usb
argument_list|,
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|channel
operator|*
literal|8
argument_list|,
name|dma_address
argument_list|)
expr_stmt|;
block|}
comment|/* Setup both the size of the transfer and the SPLIT characteristics */
block|{
name|cvmx_usbcx_hcspltx_t
name|usbc_hcsplt
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
name|int
name|packets_to_transfer
decl_stmt|;
name|int
name|bytes_to_transfer
init|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
decl_stmt|;
comment|/* ISOCHRONOUS transactions store each individual transfer size in the             packet structure, not the global buffer_length */
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|bytes_to_transfer
operator|=
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* We need to do split transactions when we are talking to non high             speed devices that are behind a high speed hub */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* On the start split phase (stage is even) record the frame number we                 will need to send the split complete. We only store the lower two bits                 since the time ahead can only be two frames */
if|if
condition|(
operator|(
name|transaction
operator|->
name|stage
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_BULK
condition|)
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|(
name|usb
operator|->
name|frame_number
operator|+
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
else|else
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|(
name|usb
operator|->
name|frame_number
operator|+
literal|2
operator|)
operator|&
literal|0x7f
expr_stmt|;
block|}
else|else
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|spltena
operator|=
literal|1
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|hubaddr
operator|=
name|pipe
operator|->
name|hub_device_addr
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|prtaddr
operator|=
name|pipe
operator|->
name|hub_port
expr_stmt|;
name|usbc_hcsplt
operator|.
name|s
operator|.
name|compsplt
operator|=
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
operator|)
expr_stmt|;
comment|/* SPLIT transactions can only ever transmit one data packet so                 limit the transfer size to the max packet size */
if|if
condition|(
name|bytes_to_transfer
operator|>
name|pipe
operator|->
name|max_packet
condition|)
name|bytes_to_transfer
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
comment|/* ISOCHRONOUS OUT splits are unique in that they limit                 data transfers to 188 byte chunks representing the                 begin/middle/end of the data or all */
if|if
condition|(
operator|!
name|usbc_hcsplt
operator|.
name|s
operator|.
name|compsplt
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
operator|)
condition|)
block|{
comment|/* Clear the split complete frame number as there isn't going                     to be a split complete */
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* See if we've started this transfer and sent data */
if|if
condition|(
name|transaction
operator|->
name|actual_bytes
operator|==
literal|0
condition|)
block|{
comment|/* Nothing sent yet, this is either a begin or the                         entire payload */
if|if
condition|(
name|bytes_to_transfer
operator|<=
literal|188
condition|)
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|3
expr_stmt|;
comment|/* Entire payload in one go */
else|else
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|2
expr_stmt|;
comment|/* First part of payload */
block|}
else|else
block|{
comment|/* Continuing the previous data, we must either be                         in the middle or at the end */
if|if
condition|(
name|bytes_to_transfer
operator|<=
literal|188
condition|)
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|1
expr_stmt|;
comment|/* End of payload */
else|else
name|usbc_hcsplt
operator|.
name|s
operator|.
name|xactpos
operator|=
literal|0
expr_stmt|;
comment|/* Middle of payload */
block|}
comment|/* Again, the transfer size is limited to 188 bytes */
if|if
condition|(
name|bytes_to_transfer
operator|>
literal|188
condition|)
name|bytes_to_transfer
operator|=
literal|188
expr_stmt|;
block|}
block|}
comment|/* Make sure the transfer never exceeds the byte limit of the hardware.             Further bytes will be sent as continued transactions */
if|if
condition|(
name|bytes_to_transfer
operator|>
name|MAX_TRANSFER_BYTES
condition|)
block|{
comment|/* Round MAX_TRANSFER_BYTES to a multiple of out packet size */
name|bytes_to_transfer
operator|=
name|MAX_TRANSFER_BYTES
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
name|bytes_to_transfer
operator|*=
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
comment|/* Calculate the number of packets to transfer. If the length is zero             we still need to transfer one packet */
name|packets_to_transfer
operator|=
operator|(
name|bytes_to_transfer
operator|+
name|pipe
operator|->
name|max_packet
operator|-
literal|1
operator|)
operator|/
name|pipe
operator|->
name|max_packet
expr_stmt|;
if|if
condition|(
name|packets_to_transfer
operator|==
literal|0
condition|)
name|packets_to_transfer
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|packets_to_transfer
operator|>
literal|1
operator|)
operator|&&
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
operator|)
condition|)
block|{
comment|/* Limit to one packet when not using DMA. Channels must be restarted                 between every packet for IN transactions, so there is no reason to                 do multiple packets in a row */
name|packets_to_transfer
operator|=
literal|1
expr_stmt|;
name|bytes_to_transfer
operator|=
name|packets_to_transfer
operator|*
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|packets_to_transfer
operator|>
name|MAX_TRANSFER_PACKETS
condition|)
block|{
comment|/* Limit the number of packet and data transferred to what the                 hardware can handle */
name|packets_to_transfer
operator|=
name|MAX_TRANSFER_PACKETS
expr_stmt|;
name|bytes_to_transfer
operator|=
name|packets_to_transfer
operator|*
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|bytes_to_transfer
expr_stmt|;
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
name|packets_to_transfer
expr_stmt|;
comment|/* Update the DATA0/DATA1 toggle */
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|=
name|__cvmx_usb_get_data_pid
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
comment|/* High speed pipes may need a hardware ping before they start */
if|if
condition|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
condition|)
name|usbc_hctsiz
operator|.
name|s
operator|.
name|dopng
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCSPLTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcsplt
operator|.
name|u32
argument_list|)
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hctsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the Host Channel Characteristics Register */
block|{
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
init|=
block|{
operator|.
name|u32
operator|=
literal|0
block|}
decl_stmt|;
comment|/* Set the startframe odd/even properly. This is only used for periodic */
name|usbc_hcchar
operator|.
name|s
operator|.
name|oddfrm
operator|=
name|usb
operator|->
name|frame_number
operator|&
literal|1
expr_stmt|;
comment|/* Set the number of back to back packets allowed by this endpoint.             Split transactions interpret "ec" as the number of immediate             retries of failure. These retries happen too quickly, so we             disable these entirely for splits */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|<
literal|1
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|>
literal|3
condition|)
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
literal|3
expr_stmt|;
else|else
name|usbc_hcchar
operator|.
name|s
operator|.
name|ec
operator|=
name|pipe
operator|->
name|multi_count
expr_stmt|;
comment|/* Set the rest of the endpoint specific settings */
name|usbc_hcchar
operator|.
name|s
operator|.
name|devaddr
operator|=
name|pipe
operator|->
name|device_addr
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|eptype
operator|=
name|transaction
operator|->
name|type
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|lspddev
operator|=
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_LOW
operator|)
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|epdir
operator|=
name|pipe
operator|->
name|transfer_dir
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|epnum
operator|=
name|pipe
operator|->
name|endpoint_num
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
operator|=
name|pipe
operator|->
name|max_packet
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Do transaction type specific fixups as needed */
switch|switch
condition|(
name|transaction
operator|->
name|type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
name|__cvmx_usb_start_channel_control
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
case|case
name|CVMX_USB_TRANSFER_INTERRUPT
case|:
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
if|if
condition|(
operator|!
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* ISO transactions require different PIDs depending on direction                     and how many packets are needed */
if|if
condition|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
condition|)
block|{
if|if
condition|(
name|pipe
operator|->
name|multi_count
operator|<
literal|2
condition|)
comment|/* Need DATA0 */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hctsizx_t
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Need MDATA */
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hctsizx_t
argument_list|,
name|pid
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|{
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
init|=
block|{
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
argument|usb
argument_list|,
argument|CVMX_USBCX_HCTSIZX(channel, usb->index)
argument_list|)
block|}
decl_stmt|;
name|transaction
operator|->
name|xfersize
operator|=
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
name|transaction
operator|->
name|pktcnt
operator|=
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
expr_stmt|;
block|}
comment|/* Remeber when we start a split transaction */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|usb
operator|->
name|active_split
operator|=
name|transaction
expr_stmt|;
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_hccharx_t
argument_list|,
name|chena
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
name|__cvmx_usb_fill_tx_fifo
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Find a pipe that is ready to be scheduled to hardware.  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param list   Pipe list to search  * @param current_frame  *               Frame counter to use as a time reference.  *  * @return Pipe or NULL if none are ready  */
end_comment

begin_function
specifier|static
name|cvmx_usb_pipe_t
modifier|*
name|__cvmx_usb_find_ready_pipe
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_list_t
modifier|*
name|list
parameter_list|,
name|uint64_t
name|current_frame
parameter_list|)
block|{
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|list
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|pipe
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
operator|)
operator|&&
name|pipe
operator|->
name|head
operator|&&
operator|(
name|pipe
operator|->
name|next_tx_frame
operator|<=
name|current_frame
operator|)
operator|&&
operator|(
operator|(
name|pipe
operator|->
name|split_sc_frame
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
name|current_frame
operator|-
operator|(
name|int
operator|)
name|pipe
operator|->
name|split_sc_frame
operator|)
operator|&
literal|0x7f
operator|)
operator|<
literal|0x40
operator|)
operator|)
operator|&&
operator|(
operator|!
name|usb
operator|->
name|active_split
operator|||
operator|(
name|usb
operator|->
name|active_split
operator|==
name|pipe
operator|->
name|head
operator|)
operator|)
condition|)
block|{
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
operator|->
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|pipe
return|;
block|}
name|pipe
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Called whenever a pipe might need to be scheduled to the  * hardware.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param is_sof True if this schedule was called on a SOF interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_schedule
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|is_sof
parameter_list|)
block|{
name|int
name|channel
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|int
name|need_sof
decl_stmt|;
name|cvmx_usb_transfer_t
name|ttype
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
block|{
comment|/* Without DMA we need to be careful to not schedule something at the end of a frame and cause an overrun */
name|cvmx_usbcx_hfnum_t
name|hfnum
init|=
block|{
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
argument|usb
argument_list|,
argument|CVMX_USBCX_HFNUM(usb->index)
argument_list|)
block|}
decl_stmt|;
name|cvmx_usbcx_hfir_t
name|hfir
init|=
block|{
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
argument|usb
argument_list|,
argument|CVMX_USBCX_HFIR(usb->index)
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|hfnum
operator|.
name|s
operator|.
name|frrem
operator|<
name|hfir
operator|.
name|s
operator|.
name|frint
operator|/
literal|4
condition|)
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|usb
operator|->
name|idle_hardware_channels
condition|)
block|{
comment|/* Find an idle channel */
name|CVMX_CLZ
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|idle_hardware_channels
argument_list|)
expr_stmt|;
name|channel
operator|=
literal|31
operator|-
name|channel
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|channel
operator|>
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_INFO
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Idle hardware channels has a channel higher than 7. This is wrong\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Find a pipe needing service */
name|pipe
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_sof
condition|)
block|{
comment|/* Only process periodic pipes on SOF interrupts. This way we are                 sure that the periodic data is sent in the beginning of the                 frame */
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|,
name|usb
operator|->
name|frame_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|,
name|usb
operator|->
name|frame_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
block|{
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_CONTROL
argument_list|,
name|usb
operator|->
name|frame_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|pipe
argument_list|)
condition|)
name|pipe
operator|=
name|__cvmx_usb_find_ready_pipe
argument_list|(
name|usb
argument_list|,
name|usb
operator|->
name|active_pipes
operator|+
name|CVMX_USB_TRANSFER_BULK
argument_list|,
name|usb
operator|->
name|frame_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipe
condition|)
break|break;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
init|=
name|pipe
operator|->
name|head
decl_stmt|;
specifier|const
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
operator|(
name|transaction
operator|->
name|control_header
operator|)
condition|?
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_IN
operator|)
condition|?
literal|"IN"
else|:
literal|"OUT"
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|pipe
operator|->
name|transfer_type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
name|type
operator|=
literal|"SETUP"
expr_stmt|;
name|dir
operator|=
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
condition|?
literal|"IN"
else|:
literal|"OUT"
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
name|type
operator|=
literal|"ISOCHRONOUS"
expr_stmt|;
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
name|type
operator|=
literal|"BULK"
expr_stmt|;
break|break;
default|default:
comment|/* CVMX_USB_TRANSFER_INTERRUPT */
name|type
operator|=
literal|"INTERRUPT"
expr_stmt|;
break|break;
block|}
name|cvmx_dprintf
argument_list|(
literal|"%s: Starting pipe %d, transaction %d on channel %d. %s %s len=%d header=0x%llx\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|channel
argument_list|,
name|type
argument_list|,
name|dir
argument_list|,
name|transaction
operator|->
name|buffer_length
argument_list|,
operator|(
name|header
operator|)
condition|?
operator|(
name|unsigned
name|long
name|long
operator|)
name|header
operator|->
name|u64
else|:
literal|0ull
argument_list|)
expr_stmt|;
block|}
name|__cvmx_usb_start_channel
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* Only enable SOF interrupts when we have transactions pending in the         future that might need to be scheduled */
name|need_sof
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ttype
operator|=
name|CVMX_USB_TRANSFER_CONTROL
init|;
name|ttype
operator|<=
name|CVMX_USB_TRANSFER_INTERRUPT
condition|;
name|ttype
operator|++
control|)
block|{
name|pipe
operator|=
name|usb
operator|->
name|active_pipes
index|[
name|ttype
index|]
operator|.
name|head
expr_stmt|;
while|while
condition|(
name|pipe
condition|)
block|{
if|if
condition|(
name|pipe
operator|->
name|next_tx_frame
operator|>
name|usb
operator|->
name|frame_number
condition|)
block|{
name|need_sof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|pipe
operator|=
name|pipe
operator|->
name|next
expr_stmt|;
block|}
block|}
name|USB_SET_FIELD32
argument_list|(
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|cvmx_usbcx_gintmsk_t
argument_list|,
name|sofmsk
argument_list|,
name|need_sof
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Call a user's callback for a specific reason.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe the callback is for or NULL  * @param transaction  *               Transaction the callback is for or NULL  * @param reason Reason this callback is being called  * @param complete_code  *               Completion code for the transaction, if any  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_perform_callback
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|,
name|cvmx_usb_callback_t
name|reason
parameter_list|,
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
name|cvmx_usb_callback_func_t
name|callback
init|=
name|usb
operator|->
name|callback
index|[
name|reason
index|]
decl_stmt|;
name|void
modifier|*
name|user_data
init|=
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
decl_stmt|;
name|int
name|submit_handle
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pipe_handle
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bytes_transferred
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pipe
condition|)
name|pipe_handle
operator|=
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
condition|)
block|{
name|submit_handle
operator|=
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
name|bytes_transferred
operator|=
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* Transactions are allowed to override the default callback */
if|if
condition|(
operator|(
name|reason
operator|==
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
operator|)
operator|&&
name|transaction
operator|->
name|callback
condition|)
block|{
name|callback
operator|=
name|transaction
operator|->
name|callback
expr_stmt|;
name|user_data
operator|=
name|transaction
operator|->
name|callback_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|callback
condition|)
return|return;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: calling callback %p(usb=%p, complete_code=%s, "
literal|"pipe_handle=%d, submit_handle=%d, bytes_transferred=%d, user_data=%p);\n"
argument_list|,
literal|2
operator|*
name|usb
operator|->
name|indent
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|callback
argument_list|,
name|usb
argument_list|,
name|__cvmx_usb_complete_to_string
argument_list|(
name|complete_code
argument_list|)
argument_list|,
name|pipe_handle
argument_list|,
name|submit_handle
argument_list|,
name|bytes_transferred
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|callback
argument_list|(
operator|(
name|cvmx_usb_state_t
operator|*
operator|)
name|usb
argument_list|,
name|reason
argument_list|,
name|complete_code
argument_list|,
name|pipe_handle
argument_list|,
name|submit_handle
argument_list|,
name|bytes_transferred
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_CALLBACKS
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%*s%s: callback %p complete\n"
argument_list|,
literal|2
operator|*
name|usb
operator|->
name|indent
argument_list|,
literal|""
argument_list|,
name|__FUNCTION__
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Signal the completion of a transaction and free it. The  * transaction will be removed from the pipe transaction list.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  * @param pipe   Pipe the transaction is on  * @param transaction  *               Transaction that completed  * @param complete_code  *               Completion code  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usb_perform_complete
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usb_pipe_t
modifier|*
name|pipe
parameter_list|,
name|cvmx_usb_transaction_t
modifier|*
name|transaction
parameter_list|,
name|cvmx_usb_complete_t
name|complete_code
parameter_list|)
block|{
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|complete_code
argument_list|)
expr_stmt|;
comment|/* If this was a split then clear our split in progress marker */
if|if
condition|(
name|usb
operator|->
name|active_split
operator|==
name|transaction
condition|)
name|usb
operator|->
name|active_split
operator|=
name|NULL
expr_stmt|;
comment|/* Isochronous transactions need extra processing as they might not be done         after a single data transfer */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|)
condition|)
block|{
comment|/* Update the number of bytes transferred in this ISO packet */
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|status
operator|=
name|complete_code
expr_stmt|;
comment|/* If there are more ISOs pending and we succeeded, schedule the next             one */
if|if
condition|(
operator|(
name|transaction
operator|->
name|iso_number_packets
operator|>
literal|1
operator|)
operator|&&
operator|(
name|complete_code
operator|==
name|CVMX_USB_COMPLETE_SUCCESS
operator|)
condition|)
block|{
name|transaction
operator|->
name|actual_bytes
operator|=
literal|0
expr_stmt|;
comment|/* No bytes transferred for this packet as of yet */
name|transaction
operator|->
name|iso_number_packets
operator|--
expr_stmt|;
comment|/* One less ISO waiting to transfer */
name|transaction
operator|->
name|iso_packets
operator|++
expr_stmt|;
comment|/* Increment to the next location in our packet array */
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Remove the transaction from the pipe list */
if|if
condition|(
name|transaction
operator|->
name|next
condition|)
name|transaction
operator|->
name|next
operator|->
name|prev
operator|=
name|transaction
operator|->
name|prev
expr_stmt|;
else|else
name|pipe
operator|->
name|tail
operator|=
name|transaction
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|prev
condition|)
name|transaction
operator|->
name|prev
operator|->
name|next
operator|=
name|transaction
operator|->
name|next
expr_stmt|;
else|else
name|pipe
operator|->
name|head
operator|=
name|transaction
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
operator|->
name|head
condition|)
block|{
name|__cvmx_usb_remove_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|pipe
operator|->
name|transfer_type
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_CALLBACK_TRANSFER_COMPLETE
argument_list|,
name|complete_code
argument_list|)
expr_stmt|;
name|__cvmx_usb_free_transaction
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
name|done
label|:
name|CVMX_USB_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Submit a usb transaction to a pipe. Called for all types  * of transactions.  *  * @param usb  * @param pipe_handle  *                  Which pipe to submit to. Will be validated in this function.  * @param type      Transaction type  * @param flags     Flags for the transaction  * @param buffer    User buffer for the transaction  * @param buffer_length  *                  User buffer's length in bytes  * @param control_header  *                  For control transactions, the 8 byte standard header  * @param iso_start_frame  *                  For ISO transactions, the start frame  * @param iso_number_packets  *                  For ISO, the number of packet in the transaction.  * @param iso_packets  *                  A description of each ISO packet  * @param callback  User callback to call when the transaction completes  * @param user_data User's data for the callback  *  * @return Submit handle or negative on failure. Matches the result  *         in the external API.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_submit_transaction
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|cvmx_usb_transfer_t
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|uint64_t
name|control_header
parameter_list|,
name|int
name|iso_start_frame
parameter_list|,
name|int
name|iso_number_packets
parameter_list|,
name|cvmx_usb_iso_packet_t
modifier|*
name|iso_packets
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|pipe
operator|->
name|transfer_type
operator|!=
name|type
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|__cvmx_usb_alloc_transaction
argument_list|(
name|usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|transaction
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_NO_MEMORY
argument_list|)
expr_stmt|;
name|transaction
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|transaction
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|transaction
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|transaction
operator|->
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|transaction
operator|->
name|control_header
operator|=
name|control_header
expr_stmt|;
name|transaction
operator|->
name|iso_start_frame
operator|=
name|iso_start_frame
expr_stmt|;
comment|// FIXME: This is not used, implement it
name|transaction
operator|->
name|iso_number_packets
operator|=
name|iso_number_packets
expr_stmt|;
name|transaction
operator|->
name|iso_packets
operator|=
name|iso_packets
expr_stmt|;
name|transaction
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|transaction
operator|->
name|callback_data
operator|=
name|user_data
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_CONTROL
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_SETUP
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
name|transaction
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|tail
condition|)
block|{
name|transaction
operator|->
name|prev
operator|=
name|pipe
operator|->
name|tail
expr_stmt|;
name|transaction
operator|->
name|prev
operator|->
name|next
operator|=
name|transaction
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pipe
operator|->
name|next_tx_frame
operator|<
name|usb
operator|->
name|frame_number
condition|)
name|pipe
operator|->
name|next_tx_frame
operator|=
name|usb
operator|->
name|frame_number
operator|+
name|pipe
operator|->
name|interval
operator|-
operator|(
name|usb
operator|->
name|frame_number
operator|-
name|pipe
operator|->
name|next_tx_frame
operator|)
operator|%
name|pipe
operator|->
name|interval
expr_stmt|;
name|transaction
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|head
operator|=
name|transaction
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
name|usb
operator|->
name|active_pipes
operator|+
name|pipe
operator|->
name|transfer_type
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
block|}
name|pipe
operator|->
name|tail
operator|=
name|transaction
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
expr_stmt|;
comment|/* We may need to schedule the pipe if this was the head of the pipe */
if|if
condition|(
operator|!
name|transaction
operator|->
name|prev
condition|)
name|__cvmx_usb_schedule
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call to submit a USB Bulk transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_bulk
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_BULK
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_submit_bulk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Call to submit a USB Interrupt transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_interrupt
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_INTERRUPT
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_submit_interrupt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Call to submit a USB Control transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param control_header  *                  USB 8 byte control header physical address.  *                  Note that this is NOT A POINTER, but the  *                  full 64bit physical address of the buffer.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_control
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|uint64_t
name|control_header
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|control_header
argument_list|)
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|control_header
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|control_header
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Some drivers send a buffer with a zero length. God only knows why */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer
operator|&&
operator|(
name|buffer_length
operator|<
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
operator|&&
operator|(
name|buffer_length
operator|!=
literal|0
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|header
operator|->
name|s
operator|.
name|request_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|buffer_length
operator|=
name|cvmx_le16_to_cpu
argument_list|(
name|header
operator|->
name|s
operator|.
name|length
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_CONTROL
argument_list|,
literal|0
argument_list|,
comment|/* flags */
name|buffer
argument_list|,
name|buffer_length
argument_list|,
name|control_header
argument_list|,
literal|0
argument_list|,
comment|/* iso_start_frame */
literal|0
argument_list|,
comment|/* iso_number_packets */
name|NULL
argument_list|,
comment|/* iso_packets */
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_submit_control
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Call to submit a USB Isochronous transfer to a pipe.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param pipe_handle  *                  Handle to the pipe for the transfer.  * @param start_frame  *                  Number of frames into the future to schedule  *                  this transaction.  * @param flags     Flags to control the transfer. See  *                  cvmx_usb_isochronous_flags_t for the flag  *                  definitions.  * @param number_packets  *                  Number of sequential packets to transfer.  *                  "packets" is a pointer to an array of this  *                  many packet structures.  * @param packets   Description of each transfer packet as  *                  defined by cvmx_usb_iso_packet_t. The array  *                  pointed to here must stay valid until the  *                  complete callback is called.  * @param buffer    Physical address of the data buffer in  *                  memory. Note that this is NOT A POINTER, but  *                  the full 64bit physical address of the  *                  buffer. This may be zero if buffer_length is  *                  zero.  * @param buffer_length  *                  Length of buffer in bytes.  * @param callback  Function to call when this transaction  *                  completes. If the return value of this  *                  function isn't an error, then this function  *                  is guaranteed to be called when the  *                  transaction completes. If this parameter is  *                  NULL, then the generic callback registered  *                  through cvmx_usb_register_callback is  *                  called. If both are NULL, then there is no  *                  way to know when a transaction completes.  * @param user_data User supplied data returned when the  *                  callback is called. This is only used if  *                  callback in not NULL.  *  * @return A submitted transaction handle or negative on  *         failure. Negative values are failure codes from  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|int
name|cvmx_usb_submit_isochronous
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|int
name|start_frame
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|number_packets
parameter_list|,
name|cvmx_usb_iso_packet_t
name|packets
index|[]
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|int
name|submit_handle
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|start_frame
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|number_packets
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|packets
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* Pipe handle checking is done later in a common place */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|start_frame
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|flags
operator|&
operator|~
operator|(
name|CVMX_USB_ISOCHRONOUS_FLAGS_ALLOW_SHORT
operator||
name|CVMX_USB_ISOCHRONOUS_FLAGS_ASAP
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|number_packets
operator|<
literal|1
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|packets
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|buffer
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|buffer_length
operator|<
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|submit_handle
operator|=
name|__cvmx_usb_submit_transaction
argument_list|(
name|usb
argument_list|,
name|pipe_handle
argument_list|,
name|CVMX_USB_TRANSFER_ISOCHRONOUS
argument_list|,
name|flags
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
literal|0
argument_list|,
comment|/* control_header */
name|start_frame
argument_list|,
name|number_packets
argument_list|,
name|packets
argument_list|,
name|callback
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|submit_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_submit_isochronous
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Cancel one outstanding request in a pipe. Canceling a request  * can fail if the transaction has already completed before cancel  * is called. Even after a successful cancel call, it may take  * a frame or two for the cvmx_usb_poll() function to call the  * associated callback.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to cancel requests in.  * @param submit_handle  *               Handle to transaction to cancel, returned by the submit function.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_cancel
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|,
name|int
name|submit_handle
parameter_list|)
block|{
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|submit_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|submit_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|submit_handle
operator|>=
name|MAX_TRANSACTIONS
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|usb
operator|->
name|transaction
operator|+
name|submit_handle
expr_stmt|;
comment|/* Fail if this transaction already completed */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|transaction
operator|->
name|flags
operator|&
name|__CVMX_USB_TRANSACTION_FLAGS_IN_USE
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* If the transaction is the HEAD of the queue and scheduled. We need to         treat it special */
if|if
condition|(
operator|(
name|pipe
operator|->
name|head
operator|==
name|transaction
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
operator|)
condition|)
block|{
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
decl_stmt|;
name|usb
operator|->
name|pipe_for_channel
index|[
name|pipe
operator|->
name|channel
index|]
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
name|usbc_hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|pipe
operator|->
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the channel isn't enabled then the transaction already completed */
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|chena
condition|)
block|{
name|usbc_hcchar
operator|.
name|s
operator|.
name|chdis
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|pipe
operator|->
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
block|}
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_CANCEL
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_cancel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Cancel all outstanding requests in a pipe. Logically all this  * does is call cvmx_usb_cancel() in a loop.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to cancel requests in.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_cancel_all
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Simply loop through and attempt to cancel each transaction */
while|while
condition|(
name|pipe
operator|->
name|head
condition|)
block|{
name|cvmx_usb_status_t
name|result
init|=
name|cvmx_usb_cancel
argument_list|(
name|state
argument_list|,
name|pipe_handle
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|pipe
operator|->
name|head
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|result
operator|!=
name|CVMX_USB_SUCCESS
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_cancel_all
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Close a pipe created with cvmx_usb_open_pipe().  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  * @param pipe_handle  *               Pipe handle to close.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t. CVMX_USB_BUSY is returned if the  *         pipe has outstanding transfers.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_close_pipe
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|pipe_handle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|pipe_handle
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|pipe_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe_handle
operator|<
literal|0
operator|)
operator|||
operator|(
name|pipe_handle
operator|>=
name|MAX_PIPES
operator|)
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe isn't open */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|pipe
operator|->
name|flags
operator|&
name|__CVMX_USB_PIPE_FLAGS_OPEN
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Fail if the pipe has pending transactions */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|pipe
operator|->
name|head
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_BUSY
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_remove_pipe
argument_list|(
operator|&
name|usb
operator|->
name|idle_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|__cvmx_usb_append_pipe
argument_list|(
operator|&
name|usb
operator|->
name|free_pipes
argument_list|,
name|pipe
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_close_pipe
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Register a function to be called when various USB events occur.  *  * @param state     USB device state populated by  *                  cvmx_usb_initialize().  * @param reason    Which event to register for.  * @param callback  Function to call when the event occurs.  * @param user_data User data parameter to the function.  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_register_callback
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|cvmx_usb_callback_t
name|reason
parameter_list|,
name|cvmx_usb_callback_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|callback
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|reason
operator|>=
name|__CVMX_USB_CALLBACK_END
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|callback
argument_list|)
condition|)
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_INVALID_PARAM
argument_list|)
expr_stmt|;
name|usb
operator|->
name|callback
index|[
name|reason
index|]
operator|=
name|callback
expr_stmt|;
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
operator|=
name|user_data
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_register_callback
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the current USB protocol level frame number. The frame  * number is always in the range of 0-0x7ff.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return USB frame number  */
end_comment

begin_function
name|int
name|cvmx_usb_get_frame_number
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|frame_number
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|usbc_hfnum
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HFNUM
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|frame_number
operator|=
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|frame_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_get_frame_number
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Poll a channel for status  *  * @param usb     USB device  * @param channel Channel to poll  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usb_poll_channel
parameter_list|(
name|cvmx_usb_internal_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|cvmx_usbcx_hcintx_t
name|usbc_hcint
decl_stmt|;
name|cvmx_usbcx_hctsizx_t
name|usbc_hctsiz
decl_stmt|;
name|cvmx_usbcx_hccharx_t
name|usbc_hcchar
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
decl_stmt|;
name|cvmx_usb_transaction_t
modifier|*
name|transaction
decl_stmt|;
name|int
name|bytes_this_transfer
decl_stmt|;
name|int
name|bytes_in_last_packet
decl_stmt|;
name|int
name|packets_processed
decl_stmt|;
name|int
name|buffer_space_left
decl_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|usb
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* Read the interrupt status bits for the channel */
name|usbc_hcint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cvmx_dprintf("Channel %d%s%s%s%s%s%s%s%s%s%s%s\n", channel,         (usbc_hcint.s.datatglerr) ? " DATATGLERR" : "",         (usbc_hcint.s.frmovrun) ? " FRMOVRUN" : "",         (usbc_hcint.s.bblerr) ? " BBLERR" : "",         (usbc_hcint.s.xacterr) ? " XACTERR" : "",         (usbc_hcint.s.nyet) ? " NYET" : "",         (usbc_hcint.s.ack) ? " ACK" : "",         (usbc_hcint.s.nak) ? " NAK" : "",         (usbc_hcint.s.stall) ? " STALL" : "",         (usbc_hcint.s.ahberr) ? " AHBERR" : "",         (usbc_hcint.s.chhltd) ? " CHHLTD" : "",         (usbc_hcint.s.xfercompl) ? " XFERCOMPL" : "");
endif|#
directive|endif
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
block|{
name|usbc_hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|chena
operator|&&
name|usbc_hcchar
operator|.
name|s
operator|.
name|chdis
condition|)
block|{
comment|/* There seems to be a bug in CN31XX which can cause interrupt                 IN transfers to get stuck until we do a write of HCCHARX                 without changing things */
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* In non DMA mode the channels don't halt themselves. We need to             manually disable channels that are left running */
if|if
condition|(
operator|!
name|usbc_hcint
operator|.
name|s
operator|.
name|chhltd
condition|)
block|{
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|chena
condition|)
block|{
name|cvmx_usbcx_hcintmskx_t
name|hcintmsk
decl_stmt|;
comment|/* Disable all interrupts except CHHLTD */
name|hcintmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|hcintmsk
operator|.
name|s
operator|.
name|chhltdmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTMSKX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|hcintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_hcchar
operator|.
name|s
operator|.
name|chdis
operator|=
literal|1
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hcchar
operator|.
name|u32
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
comment|/* Successful IN/OUT with transfer complete. Channel halt isn't needed */
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"USB%d: Channel %d interrupt without halt\n"
argument_list|,
name|usb
operator|->
name|index
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* There is are no interrupts that we need to process when the channel is             still running */
if|if
condition|(
operator|!
name|usbc_hcint
operator|.
name|s
operator|.
name|chhltd
condition|)
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the channel interrupts now that it is done */
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCINTMSKX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usb
operator|->
name|idle_hardware_channels
operator||=
operator|(
literal|1
operator|<<
name|channel
operator|)
expr_stmt|;
comment|/* Make sure this channel is tied to a valid pipe */
name|pipe
operator|=
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|pipe
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pipe
condition|)
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|transaction
operator|=
name|pipe
operator|->
name|head
expr_stmt|;
name|CVMX_PREFETCH0
argument_list|(
name|transaction
argument_list|)
expr_stmt|;
comment|/* Disconnect this pipe from the HW channel. Later the schedule function will         figure out which pipe needs to go */
name|usb
operator|->
name|pipe_for_channel
index|[
name|channel
index|]
operator|=
name|NULL
expr_stmt|;
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_SCHEDULED
expr_stmt|;
comment|/* Read the channel config info so we can figure out how much data         transfered */
name|usbc_hcchar
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCCHARX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_hctsiz
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HCTSIZX
argument_list|(
name|channel
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculating the number of bytes successfully transferred is dependent on         the transfer direction */
name|packets_processed
operator|=
name|transaction
operator|->
name|pktcnt
operator|-
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pktcnt
expr_stmt|;
if|if
condition|(
name|usbc_hcchar
operator|.
name|s
operator|.
name|epdir
condition|)
block|{
comment|/* IN transactions are easy. For every byte received the hardware             decrements xfersize. All we need to do is subtract the current             value of xfersize from its starting value and we know how many             bytes were written to the buffer */
name|bytes_this_transfer
operator|=
name|transaction
operator|->
name|xfersize
operator|-
name|usbc_hctsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
block|}
else|else
block|{
comment|/* OUT transaction don't decrement xfersize. Instead pktcnt is             decremented on every successful packet send. The hardware does             this when it receives an ACK, or NYET. If it doesn't             receive one of these responses pktcnt doesn't change */
name|bytes_this_transfer
operator|=
name|packets_processed
operator|*
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
expr_stmt|;
comment|/* The last packet may not be a full transfer if we didn't have             enough data */
if|if
condition|(
name|bytes_this_transfer
operator|>
name|transaction
operator|->
name|xfersize
condition|)
name|bytes_this_transfer
operator|=
name|transaction
operator|->
name|xfersize
expr_stmt|;
block|}
comment|/* Figure out how many bytes were in the last packet of the transfer */
if|if
condition|(
name|packets_processed
condition|)
name|bytes_in_last_packet
operator|=
name|bytes_this_transfer
operator|-
operator|(
name|packets_processed
operator|-
literal|1
operator|)
operator|*
name|usbc_hcchar
operator|.
name|s
operator|.
name|mps
expr_stmt|;
else|else
name|bytes_in_last_packet
operator|=
name|bytes_this_transfer
expr_stmt|;
comment|/* As a special case, setup transactions output the setup header, not         the user's data. For this reason we don't count setup data as bytes         transferred */
if|if
condition|(
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_SETUP
operator|)
operator|||
operator|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
operator|)
condition|)
name|bytes_this_transfer
operator|=
literal|0
expr_stmt|;
comment|/* Optional debug output */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_DEBUG_TRANSFERS
operator|)
operator|||
operator|(
name|pipe
operator|->
name|flags
operator|&
name|CVMX_USB_PIPE_FLAGS_DEBUG_TRANSFERS
operator|)
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Channel %d halted. Pipe %d transaction %d stage %d bytes=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|channel
argument_list|,
name|__cvmx_usb_get_pipe_handle
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
argument_list|,
name|__cvmx_usb_get_submit_handle
argument_list|(
name|usb
argument_list|,
name|transaction
argument_list|)
argument_list|,
name|transaction
operator|->
name|stage
argument_list|,
name|bytes_this_transfer
argument_list|)
expr_stmt|;
comment|/* Add the bytes transferred to the running total. It is important that         bytes_this_transfer doesn't count any data that needs to be         retransmitted */
name|transaction
operator|->
name|actual_bytes
operator|+=
name|bytes_this_transfer
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_ISOCHRONOUS
condition|)
name|buffer_space_left
operator|=
name|transaction
operator|->
name|iso_packets
index|[
literal|0
index|]
operator|.
name|length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
else|else
name|buffer_space_left
operator|=
name|transaction
operator|->
name|buffer_length
operator|-
name|transaction
operator|->
name|actual_bytes
expr_stmt|;
comment|/* We need to remember the PID toggle state for the next transaction. The         hardware already updated it for the next transaction */
name|pipe
operator|->
name|pid_toggle
operator|=
operator|!
operator|(
name|usbc_hctsiz
operator|.
name|s
operator|.
name|pid
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* For high speed bulk out, assume the next transaction will need to do a         ping before proceeding. If this isn't true the ACK processing below         will clear this flag */
if|if
condition|(
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|stall
condition|)
block|{
comment|/* STALL as a response means this transaction cannot be completed             because the device can't process transactions. Tell the user. Any             data that was transferred will be counted on the actual bytes             transferred */
name|pipe
operator|->
name|pid_toggle
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_STALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|xacterr
condition|)
block|{
comment|/* We know at least one packet worked if we get a ACK or NAK. Reset the retry counter */
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
operator|||
name|usbc_hcint
operator|.
name|s
operator|.
name|ack
condition|)
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|retries
operator|>
name|MAX_RETRIES
condition|)
block|{
comment|/* XactErr as a response means the device signaled something wrong with                 the transfer. For example, PID toggle errors cause these */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_XACTERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If this was a split then clear our split in progress marker */
if|if
condition|(
name|usb
operator|->
name|active_split
operator|==
name|transaction
condition|)
name|usb
operator|->
name|active_split
operator|=
name|NULL
expr_stmt|;
comment|/* Rewind to the beginning of the transaction by anding off the                 split complete bit */
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|next_tx_frame
operator|<
name|usb
operator|->
name|frame_number
condition|)
name|pipe
operator|->
name|next_tx_frame
operator|=
name|usb
operator|->
name|frame_number
operator|+
name|pipe
operator|->
name|interval
operator|-
operator|(
name|usb
operator|->
name|frame_number
operator|-
name|pipe
operator|->
name|next_tx_frame
operator|)
operator|%
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|bblerr
condition|)
block|{
comment|/* Babble Error (BblErr) */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_BABBLEERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|datatglerr
condition|)
block|{
comment|/* We'll retry the exact same transaction again */
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nyet
condition|)
block|{
comment|/* NYET as a response is only allowed in three cases: as a response to             a ping, as a response to a split transaction, and as a response to             a bulk out. The ping case is handled by hardware, so we only have             splits and bulk out */
if|if
condition|(
operator|!
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* If there is more data to go then we need to try again. Otherwise                 this transaction is complete */
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Split transactions retry the split complete 4 times then rewind                 to the start split and do the entire transactions again */
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|transaction
operator|->
name|retries
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Rewind to the beginning of the transaction by anding off the                     split complete bit */
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|split_sc_frame
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|ack
condition|)
block|{
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* The ACK bit can only be checked after the other error bits. This is             because a multi packet transfer may succeed in a number of packets             and then get a different response on the last packet. In this case             both ACK and the last response bit will be set. If none of the             other response bits is set, then the last packet must have been an             ACK */
comment|/* Since we got an ACK, we know we don't need to do a ping on this             pipe */
name|pipe
operator|->
name|flags
operator|&=
operator|~
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
switch|switch
condition|(
name|transaction
operator|->
name|type
condition|)
block|{
case|case
name|CVMX_USB_TRANSFER_CONTROL
case|:
switch|switch
condition|(
name|transaction
operator|->
name|stage
condition|)
block|{
case|case
name|CVMX_USB_STAGE_NON_CONTROL
case|:
case|case
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
case|:
comment|/* This should be impossible */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_SETUP
case|:
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
expr_stmt|;
else|else
block|{
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|s
operator|.
name|length
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE
case|:
block|{
name|cvmx_usb_control_header_t
modifier|*
name|header
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|transaction
operator|->
name|control_header
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|->
name|s
operator|.
name|length
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_DATA
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
expr_stmt|;
comment|/* For setup OUT data that are splits, the hardware                                 doesn't appear to count transferred data. Here                                 we manually update the data transferred */
if|if
condition|(
operator|!
name|usbc_hcchar
operator|.
name|s
operator|.
name|epdir
condition|)
block|{
if|if
condition|(
name|buffer_space_left
operator|<
name|pipe
operator|->
name|max_packet
condition|)
name|transaction
operator|->
name|actual_bytes
operator|+=
name|buffer_space_left
expr_stmt|;
else|else
name|transaction
operator|->
name|actual_bytes
operator|+=
name|pipe
operator|->
name|max_packet
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_DATA_SPLIT_COMPLETE
case|:
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|pid_toggle
operator|=
literal|1
expr_stmt|;
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS
expr_stmt|;
block|}
else|else
block|{
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_DATA
expr_stmt|;
block|}
break|break;
case|case
name|CVMX_USB_STAGE_STATUS
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
expr_stmt|;
else|else
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE
case|:
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CVMX_USB_TRANSFER_BULK
case|:
case|case
name|CVMX_USB_TRANSFER_INTERRUPT
case|:
comment|/* The only time a bulk transfer isn't complete when                     it finishes with an ACK is during a split transaction. For                     splits we need to continue the transfer if more data is                     needed */
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|buffer_space_left
operator|&&
operator|(
name|bytes_in_last_packet
operator|==
name|pipe
operator|->
name|max_packet
operator|)
condition|)
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
condition|)
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pipe
operator|->
name|device_speed
operator|==
name|CVMX_USB_SPEED_HIGH
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_type
operator|==
name|CVMX_USB_TRANSFER_BULK
operator|)
operator|&&
operator|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
operator|)
operator|&&
operator|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
operator|)
condition|)
name|pipe
operator|->
name|flags
operator||=
name|__CVMX_USB_PIPE_FLAGS_NEED_PING
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_space_left
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
if|if
condition|(
name|transaction
operator|->
name|type
operator|==
name|CVMX_USB_TRANSFER_INTERRUPT
condition|)
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CVMX_USB_TRANSFER_ISOCHRONOUS
case|:
if|if
condition|(
name|__cvmx_usb_pipe_needs_split
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|)
condition|)
block|{
comment|/* ISOCHRONOUS OUT splits don't require a complete split stage.                         Instead they use a sequence of begin OUT splits to transfer                         the data 188 bytes at a time. Once the transfer is complete,                         the pipe sleeps until the next schedule interval */
if|if
condition|(
name|pipe
operator|->
name|transfer_dir
operator|==
name|CVMX_USB_DIRECTION_OUT
condition|)
block|{
comment|/* If no space left or this wasn't a max size packet then                             this transfer is complete. Otherwise start it again                             to send the next 188 bytes */
if|if
condition|(
operator|!
name|buffer_space_left
operator|||
operator|(
name|bytes_this_transfer
operator|<
literal|188
operator|)
condition|)
block|{
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|transaction
operator|->
name|stage
operator|==
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
condition|)
block|{
comment|/* We are in the incoming data phase. Keep getting                                 data until we run out of space or get a small                                 packet */
if|if
condition|(
operator|(
name|buffer_space_left
operator|==
literal|0
operator|)
operator|||
operator|(
name|bytes_in_last_packet
operator|<
name|pipe
operator|->
name|max_packet
operator|)
condition|)
block|{
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|transaction
operator|->
name|stage
operator|=
name|CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE
expr_stmt|;
block|}
block|}
else|else
block|{
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|usbc_hcint
operator|.
name|s
operator|.
name|nak
condition|)
block|{
comment|/* If this was a split then clear our split in progress marker */
if|if
condition|(
name|usb
operator|->
name|active_split
operator|==
name|transaction
condition|)
name|usb
operator|->
name|active_split
operator|=
name|NULL
expr_stmt|;
comment|/* NAK as a response means the device couldn't accept the transaction,             but it should be retried in the future. Rewind to the beginning of             the transaction by anding off the split complete bit. Retry in the             next interval */
name|transaction
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|transaction
operator|->
name|stage
operator|&=
operator|~
literal|1
expr_stmt|;
name|pipe
operator|->
name|next_tx_frame
operator|+=
name|pipe
operator|->
name|interval
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|next_tx_frame
operator|<
name|usb
operator|->
name|frame_number
condition|)
name|pipe
operator|->
name|next_tx_frame
operator|=
name|usb
operator|->
name|frame_number
operator|+
name|pipe
operator|->
name|interval
operator|-
operator|(
name|usb
operator|->
name|frame_number
operator|-
name|pipe
operator|->
name|next_tx_frame
operator|)
operator|%
name|pipe
operator|->
name|interval
expr_stmt|;
block|}
else|else
block|{
name|cvmx_usb_port_status_t
name|port
decl_stmt|;
name|port
operator|=
name|cvmx_usb_get_status
argument_list|(
operator|(
name|cvmx_usb_state_t
operator|*
operator|)
name|usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|.
name|port_enabled
condition|)
block|{
comment|/* We'll retry the exact same transaction again */
name|transaction
operator|->
name|retries
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* We get channel halted interrupts with no result bits sets when the                 cable is unplugged */
name|__cvmx_usb_perform_complete
argument_list|(
name|usb
argument_list|,
name|pipe
argument_list|,
name|transaction
argument_list|,
name|CVMX_USB_COMPLETE_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|CVMX_USB_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Poll the USB block for status and call all needed callback  * handlers. This function is meant to be called in the interrupt  * handler for the USB controller. It can also be called  * periodically in a loop for non-interrupt based operation.  *  * @param state  USB device state populated by  *               cvmx_usb_initialize().  *  * @return CVMX_USB_SUCCESS or a negative error code defined in  *         cvmx_usb_status_t.  */
end_comment

begin_function
name|cvmx_usb_status_t
name|cvmx_usb_poll
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cvmx_usbcx_hfnum_t
name|usbc_hfnum
decl_stmt|;
name|cvmx_usbcx_gintsts_t
name|usbc_gintsts
decl_stmt|;
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|1
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|2
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|3
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|usb
argument_list|,
literal|4
operator|*
literal|128
argument_list|)
expr_stmt|;
name|CVMX_USB_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_USB_LOG_PARAM
argument_list|(
literal|"%p"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Update the frame counter */
name|usbc_hfnum
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HFNUM
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|usb
operator|->
name|frame_number
operator|&
literal|0x3fff
operator|)
operator|>
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
condition|)
name|usb
operator|->
name|frame_number
operator|+=
literal|0x4000
expr_stmt|;
name|usb
operator|->
name|frame_number
operator|&=
operator|~
literal|0x3fffull
expr_stmt|;
name|usb
operator|->
name|frame_number
operator||=
name|usbc_hfnum
operator|.
name|s
operator|.
name|frnum
expr_stmt|;
comment|/* Read the pending interrupts */
name|usbc_gintsts
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts now that we know about them */
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_gintsts
operator|.
name|u32
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|rxflvl
condition|)
block|{
comment|/* RxFIFO Non-Empty (RxFLvl)             Indicates that there is at least one packet pending to be read             from the RxFIFO. */
comment|/* In DMA mode this is handled by hardware */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
name|__cvmx_usb_poll_rx_fifo
argument_list|(
name|usb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|ptxfemp
operator|||
name|usbc_gintsts
operator|.
name|s
operator|.
name|nptxfemp
condition|)
block|{
comment|/* Fill the Tx FIFOs when not in DMA mode */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USB_INITIALIZE_FLAGS_NO_DMA
condition|)
name|__cvmx_usb_poll_tx_fifo
argument_list|(
name|usb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|disconnint
operator|||
name|usbc_gintsts
operator|.
name|s
operator|.
name|prtint
condition|)
block|{
name|cvmx_usbcx_hprt_t
name|usbc_hprt
decl_stmt|;
comment|/* Disconnect Detected Interrupt (DisconnInt)             Asserted when a device disconnect is detected. */
comment|/* Host Port Interrupt (PrtInt)             The core sets this bit to indicate a change in port status of one             of the O2P USB core ports in Host mode. The application must             read the Host Port Control and Status (HPRT) register to             determine the exact event that caused this interrupt. The             application must clear the appropriate status bit in the Host Port             Control and Status register to clear this bit. */
comment|/* Call the user's port callback */
name|__cvmx_usb_perform_callback
argument_list|(
name|usb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|CVMX_USB_CALLBACK_PORT_CHANGED
argument_list|,
name|CVMX_USB_COMPLETE_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Clear the port change bits */
name|usbc_hprt
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_hprt
operator|.
name|s
operator|.
name|prtena
operator|=
literal|0
expr_stmt|;
name|__cvmx_usb_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HPRT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_hprt
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|hchint
condition|)
block|{
comment|/* Host Channels Interrupt (HChInt)             The core sets this bit to indicate that an interrupt is pending on             one of the channels of the core (in Host mode). The application             must read the Host All Channels Interrupt (HAINT) register to             determine the exact number of the channel on which the             interrupt occurred, and then read the corresponding Host             Channel-n Interrupt (HCINTn) register to determine the exact             cause of the interrupt. The application must clear the             appropriate status bit in the HCINTn register to clear this bit. */
name|cvmx_usbcx_haint_t
name|usbc_haint
decl_stmt|;
name|usbc_haint
operator|.
name|u32
operator|=
name|__cvmx_usb_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_HAINT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|usbc_haint
operator|.
name|u32
condition|)
block|{
name|int
name|channel
decl_stmt|;
name|CVMX_CLZ
argument_list|(
name|channel
argument_list|,
name|usbc_haint
operator|.
name|u32
argument_list|)
expr_stmt|;
name|channel
operator|=
literal|31
operator|-
name|channel
expr_stmt|;
name|__cvmx_usb_poll_channel
argument_list|(
name|usb
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|usbc_haint
operator|.
name|u32
operator|^=
literal|1
operator|<<
name|channel
expr_stmt|;
block|}
block|}
name|__cvmx_usb_schedule
argument_list|(
name|usb
argument_list|,
name|usbc_gintsts
operator|.
name|s
operator|.
name|sof
argument_list|)
expr_stmt|;
name|CVMX_USB_RETURN
argument_list|(
name|CVMX_USB_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usb_poll
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|extern
name|void
name|cvmx_usb_set_toggle
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|int
name|toggle
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
decl_stmt|;
name|pipe
operator|->
name|pid_toggle
operator|=
operator|!
operator|!
name|toggle
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|int
name|cvmx_usb_get_toggle
parameter_list|(
name|cvmx_usb_state_t
modifier|*
name|state
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usb_internal_state_t
modifier|*
name|usb
init|=
operator|(
name|cvmx_usb_internal_state_t
operator|*
operator|)
name|state
decl_stmt|;
name|cvmx_usb_pipe_t
modifier|*
name|pipe
init|=
name|usb
operator|->
name|pipe
operator|+
name|endpoint_num
decl_stmt|;
if|if
condition|(
name|pipe
operator|->
name|pid_toggle
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

