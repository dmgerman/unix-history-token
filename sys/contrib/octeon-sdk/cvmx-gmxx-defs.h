begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-gmxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon gmxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_GMXX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_GMXX_DEFS_H__
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_BAD_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000518ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000518ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000518ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_BAD_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000518ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_BIST
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_BIST (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_BPID_MAPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_BPID_MAPX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000680ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x200000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_BPID_MAPX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset)& 15) + ((block_id)& 7) * 0x200000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_BPID_MSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_BPID_MSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000700ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_BPID_MSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000700ull) + ((block_id)& 7) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_CLK_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_CLK_EN (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_EBP_DIS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_EBP_DIS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000608ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_EBP_DIS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000608ull) + ((block_id)& 7) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_EBP_MSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_EBP_MSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000600ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_EBP_MSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000600ull) + ((block_id)& 7) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_HG2_CONTROL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000550ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000550ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000550ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_HG2_CONTROL (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000550ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_INF_MODE
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_INF_MODE (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_NXA_ADR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000510ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000510ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000510ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_NXA_ADR (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000510ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_PIPE_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_PIPE_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000760ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_PIPE_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000760ull) + ((block_id)& 7) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_PRTX_CBFC_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000580ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000580ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000580ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_PRTX_CBFC_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000580ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_PRTX_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_PRTX_CFG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXAUI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXAUI_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000740ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RXAUI_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000740ull) + ((block_id)& 7) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM0 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000180ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM1 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000188ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM2 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000190ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM3 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000198ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM4 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM5 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080001A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM_ALL_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000110ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000110ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000110ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM_ALL_EN (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000110ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CAM_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CAM_EN (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000108ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_ADR_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_ADR_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_DECISION
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_DECISION (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_FRM_CHK
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_FRM_CHK (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_FRM_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_FRM_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_FRM_MAX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_FRM_MAX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000030ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RXX_FRM_MAX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000030ull) + (((offset)& 3) + ((block_id)& 1) * 0x10000ull) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_FRM_MIN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_FRM_MIN(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RXX_FRM_MIN
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000028ull) + (((offset)& 3) + ((block_id)& 1) * 0x10000ull) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_IFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_IFG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_INT_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_INT_EN (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_INT_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_JABBER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_JABBER (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000038ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_PAUSE_DROP_TIME
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_PAUSE_DROP_TIME (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_RX_INBND
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_RX_INBND(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RXX_RX_INBND
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000060ull) + (((offset)& 3) + ((block_id)& 1) * 0x10000ull) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_OCTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_OCTS (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_OCTS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_OCTS_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000098ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_OCTS_DMAC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_OCTS_DMAC (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_OCTS_DRP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_OCTS_DRP (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_PKTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_PKTS (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_PKTS_BAD
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_PKTS_BAD (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_PKTS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_PKTS_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_PKTS_DMAC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_PKTS_DMAC (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_STATS_PKTS_DRP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_STATS_PKTS_DRP (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080000B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RXX_UDD_SKP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RXX_UDD_SKP (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_BP_DROPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x200000ull
operator|)
operator|*
literal|8
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_BP_DROPX (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000420ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_BP_OFFX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x200000ull
operator|)
operator|*
literal|8
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_BP_OFFX (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000460ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_BP_ONX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x200000ull
operator|)
operator|*
literal|8
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_BP_ONX (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000440ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_HG2_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000548ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000548ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000548ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_HG2_STATUS (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000548ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_PASS_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_PASS_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RX_PASS_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080005F8ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_PASS_MAPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_PASS_MAPX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000600ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RX_PASS_MAPX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000600ull) + (((offset)& 15) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_PRTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_PRTS (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_PRT_INFO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_PRT_INFO (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_TX_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_TX_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_RX_TX_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080007E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_XAUI_BAD_COL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000538ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000538ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000538ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_XAUI_BAD_COL (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000538ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_RX_XAUI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000530ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000530ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000530ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_RX_XAUI_CTL (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000530ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_SMACX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_SMACX (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000230ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_SOFT_BIST
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_SOFT_BIST (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_STAT_BP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000520ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000520ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000520ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_STAT_BP (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000520ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TB_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TB_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080007E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_APPEND
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_APPEND (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000218ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_BURST
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_BURST (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000228ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_CBFC_XOFF
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_CBFC_XOFF (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_CBFC_XON
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_CBFC_XON (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080005C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_CLK
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_CLK(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000208ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TXX_CLK
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000208ull) + (((offset)& 3) + ((block_id)& 1) * 0x10000ull) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000270ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_MIN_PKT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_MIN_PKT (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000240ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000248ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_PAUSE_PKT_TIME
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_PAUSE_PKT_TIME (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000238ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_PAUSE_TOGO
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_PAUSE_TOGO (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000258ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_PAUSE_ZERO
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_PAUSE_ZERO (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000260ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_PIPE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_PIPE(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000310ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TXX_PIPE
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000310ull) + (((offset)& 3) + ((block_id)& 7) * 0x2000ull) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_SGMII_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000300ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000300ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000300ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000300ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_SGMII_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000300ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_SLOT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_SLOT (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000220ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_SOFT_PAUSE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_SOFT_PAUSE (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000250ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT0 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000280ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT1 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000288ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT2 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000290ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT3 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000298ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT4 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT5 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT6 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT7 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002B8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT8
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT8 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C0ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STAT9
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STAT9 (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080002C8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_STATS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_STATS_CTL (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000268ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TXX_THRESH
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|2048
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x2000ull
operator|)
operator|*
literal|2048
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TXX_THRESH (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000210ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x10000ull
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_BP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_BP (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_CLK_MSKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_CLK_MSKX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000780ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_CLK_MSKX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000780ull) + (((offset)& 1) + ((block_id)& 0) * 0x0ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_COL_ATTEMPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000498ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000498ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000498ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_COL_ATTEMPT (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000498ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_CORRUPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_CORRUPT (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004D8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_HG2_REG1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000558ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000558ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000558ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_HG2_REG1 (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000558ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_HG2_REG2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000560ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000560ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000560ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_HG2_REG2 (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000560ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_IFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000488ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000488ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000488ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_IFG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000488ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_INT_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000508ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000508ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000508ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_INT_EN (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000508ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000500ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000500ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000500ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_INT_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000500ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_JAM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000490ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000490ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000490ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_JAM (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000490ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_LFSR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_LFSR (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_OVR_BP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004C8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004C8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004C8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_OVR_BP (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004C8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_PAUSE_PKT_DMAC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_PAUSE_PKT_DMAC (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_PAUSE_PKT_TYPE
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_PAUSE_PKT_TYPE (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_PRTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN30XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN50XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN31XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000480ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN38XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN58XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000480ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000480ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_PRTS (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000480ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_SPI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_SPI_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004C0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_SPI_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080004C0ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_SPI_DRAIN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_SPI_DRAIN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_SPI_DRAIN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080004E0ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_SPI_MAX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_SPI_MAX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004B0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_SPI_MAX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080004B0ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_SPI_ROUNDX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_SPI_ROUNDX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000680ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_SPI_ROUNDX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180008000680ull) + (((offset)& 31) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_SPI_THRESH
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_SPI_THRESH(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800080004B8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_GMXX_TX_SPI_THRESH
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800080004B8ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_TX_XAUI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000528ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000528ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000528ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_TX_XAUI_CTL (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000528ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_GMXX_XAUI_EXT_LOOPBACK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000540ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000540ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000540ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_GMXX_XAUI_EXT_LOOPBACK (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180008000540ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_comment
comment|/**  * cvmx_gmx#_bad_reg  *  * GMX_BAD_REG = A collection of things that have gone very, very wrong  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of INB_NXA, LOSTSTAT, OUT_OVR, are used.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_bad_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_bad_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
comment|/**< Inbound port> GMX_RX_PRTS */
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow                                                          The common FIFO to SGMII and XAUI had an overflow                                                          TX Stats are corrupted */
name|uint64_t
name|loststat
range|:
literal|4
decl_stmt|;
comment|/**< TX Statistics data was over-written                                                          In SGMII, one bit per port                                                          In XAUI, only port0 is used                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_18_21
range|:
literal|4
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|16
decl_stmt|;
comment|/**< Outbound data FIFO overflow (per port) */
name|uint64_t
name|ncb_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Outbound NCB FIFO Overflow */
name|uint64_t
name|out_col
range|:
literal|1
decl_stmt|;
comment|/**< Outbound collision occured between PKO and NCB */
else|#
directive|else
name|uint64_t
name|out_col
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_18_21
range|:
literal|4
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_bad_reg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
comment|/**< Inbound port> GMX_RX_PRTS */
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow */
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|3
decl_stmt|;
comment|/**< TX Statistics data was over-written (per RGM port)                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_5_21
range|:
literal|17
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|3
decl_stmt|;
comment|/**< Outbound data FIFO overflow (per port) */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_21
range|:
literal|17
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_bad_reg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_bad_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
comment|/**< Inbound port> GMX_RX_PRTS */
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow                                                          The common FIFO to SGMII and XAUI had an overflow                                                          TX Stats are corrupted */
name|uint64_t
name|loststat
range|:
literal|4
decl_stmt|;
comment|/**< TX Statistics data was over-written                                                          In SGMII, one bit per port                                                          In XAUI, only port0 is used                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_6_21
range|:
literal|16
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|4
decl_stmt|;
comment|/**< Outbound data FIFO overflow (per port) */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_21
range|:
literal|16
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inb_nxa
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bad_reg_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_bad_reg
name|cvmx_gmxx_bad_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_bist  *  * GMX_BIST = GMX BIST Results  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_bist
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_bist_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|status
range|:
literal|25
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.fif_bnk0                                                          - 1: gmx#.inb.fif_bnk1                                                          - 2: gmx#.inb.fif_bnk2                                                          - 3: gmx#.inb.fif_bnk3                                                          - 4: gmx#.inb.fif_bnk_ext0                                                          - 5: gmx#.inb.fif_bnk_ext1                                                          - 6: gmx#.inb.fif_bnk_ext2                                                          - 7: gmx#.inb.fif_bnk_ext3                                                          - 8: gmx#.outb.fif.fif_bnk0                                                          - 9: gmx#.outb.fif.fif_bnk1                                                          - 10: gmx#.outb.fif.fif_bnk2                                                          - 11: gmx#.outb.fif.fif_bnk3                                                          - 12: gmx#.outb.fif.fif_bnk_ext0                                                          - 13: gmx#.outb.fif.fif_bnk_ext1                                                          - 14: gmx#.outb.fif.fif_bnk_ext2                                                          - 15: gmx#.outb.fif.fif_bnk_ext3                                                          - 16: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 17: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 18: gmx#.csr.gmi2.srf8x64m1_bist                                                          - 19: gmx#.csr.gmi3.srf8x64m1_bist                                                          - 20: gmx#.csr.drf20x32m2_bist                                                          - 21: gmx#.csr.drf20x48m2_bist                                                          - 22: gmx#.outb.stat.drf16x27m1_bist                                                          - 23: gmx#.outb.stat.drf40x64m1_bist                                                          - 24: xgmii.tx.drf16x38m1_async_bist */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_bist_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|status
range|:
literal|10
decl_stmt|;
comment|/**< BIST Results.                                                           HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.dpr512x78m4_bist                                                          - 1: gmx#.outb.fif.dpr512x71m4_bist                                                          - 2: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 3: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 4: gmx#.csr.gmi2.srf8x64m1_bist                                                          - 5: 0                                                          - 6: gmx#.csr.drf20x80m1_bist                                                          - 7: gmx#.outb.stat.drf16x27m1_bist                                                          - 8: gmx#.outb.stat.drf40x64m1_bist                                                          - 9: 0 */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_bist_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_gmxx_bist_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|status
range|:
literal|12
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_gmxx_bist_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.fif_bnk0                                                          - 1: gmx#.inb.fif_bnk1                                                          - 2: gmx#.inb.fif_bnk2                                                          - 3: gmx#.inb.fif_bnk3                                                          - 4: gmx#.outb.fif.fif_bnk0                                                          - 5: gmx#.outb.fif.fif_bnk1                                                          - 6: gmx#.outb.fif.fif_bnk2                                                          - 7: gmx#.outb.fif.fif_bnk3                                                          - 8: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 9: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 10: gmx#.csr.gmi2.srf8x64m1_bist                                                          - 11: gmx#.csr.gmi3.srf8x64m1_bist                                                          - 12: gmx#.csr.drf20x80m1_bist                                                          - 13: gmx#.outb.stat.drf16x27m1_bist                                                          - 14: gmx#.outb.stat.drf40x64m1_bist                                                          - 15: xgmii.tx.drf16x38m1_async_bist */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_bist_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_cn52xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_bist_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|status
range|:
literal|17
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.fif_bnk0                                                          - 1: gmx#.inb.fif_bnk1                                                          - 2: gmx#.inb.fif_bnk2                                                          - 3: gmx#.inb.fif_bnk3                                                          - 4: gmx#.outb.fif.fif_bnk0                                                          - 5: gmx#.outb.fif.fif_bnk1                                                          - 6: gmx#.outb.fif.fif_bnk2                                                          - 7: gmx#.outb.fif.fif_bnk3                                                          - 8: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 9: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 10: gmx#.csr.gmi2.srf8x64m1_bist                                                          - 11: gmx#.csr.gmi3.srf8x64m1_bist                                                          - 12: gmx#.csr.drf20x80m1_bist                                                          - 13: gmx#.outb.stat.drf16x27m1_bist                                                          - 14: gmx#.outb.stat.drf40x64m1_bist                                                          - 15: gmx#.outb.ncb.drf16x76m1_bist                                                          - 16: gmx#.outb.fif.srf32x16m2_bist */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_gmxx_bist_cn58xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_bist_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_bist
name|cvmx_gmxx_bist_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_bpid_map#  *  * Notes:  * GMX will build BPID_VECTOR<15:0> using the 16 GMX_BPID_MAP entries and the BPID  * state from IPD.  In XAUI/RXAUI mode when PFC/CBFC/HiGig2 is used, the  * BPID_VECTOR becomes the logical backpressure.  In XAUI/RXAUI mode when  * PFC/CBFC/HiGig2 is not used or when in 4xSGMII mode, the BPID_VECTOR can be used  * with the GMX_BPID_MSK register to determine the physical backpressure.  *  * In XAUI/RXAUI mode, the entire BPID_VECTOR<15:0> is available determining physical  * backpressure for the single XAUI/RXAUI interface.  *  * In SGMII mode, BPID_VECTOR is broken up as follows:  *    SGMII interface0 uses BPID_VECTOR<3:0>  *    SGMII interface1 uses BPID_VECTOR<7:4>  *    SGMII interface2 uses BPID_VECTOR<11:8>  *    SGMII interface3 uses BPID_VECTOR<15:12>  *  * In all SGMII configurations, and in some XAUI/RXAUI configurations, the  * interface protocols only support physical backpressure. In these cases, a single  * BPID will commonly drive the physical backpressure for the physical  * interface. We provide example programmings for these simple cases.  *  * In XAUI/RXAUI mode where PFC/CBFC/HiGig2 is not used, an example programming  * would be as follows:  *  *    @verbatim  *    GMX_BPID_MAP0[VAL]    = 1;  *    GMX_BPID_MAP0[BPID]   = xaui_bpid;  *    GMX_BPID_MSK[MSK_OR]  = 1;  *    GMX_BPID_MSK[MSK_AND] = 0;  *    @endverbatim  *  * In SGMII mode, an example programming would be as follows:  *  *    @verbatim  *    for (i=0; i<4; i++) [  *       if (GMX_PRTi_CFG[EN]) [  *          GMX_BPID_MAP(i*4)[VAL]    = 1;  *          GMX_BPID_MAP(i*4)[BPID]   = sgmii_bpid(i);  *          GMX_BPID_MSK[MSK_OR]      = (1<< (i*4)) | GMX_BPID_MSK[MSK_OR];  *       ]  *    ]  *    GMX_BPID_MSK[MSK_AND] = 0;  *    @endverbatim  */
end_comment

begin_union
union|union
name|cvmx_gmxx_bpid_mapx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_bpid_mapx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
comment|/**< Current received BP from IPD */
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Table entry is valid */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid
range|:
literal|6
decl_stmt|;
comment|/**< Backpressure ID the entry maps to */
else|#
directive|else
name|uint64_t
name|bpid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_bpid_mapx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bpid_mapx_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_bpid_mapx
name|cvmx_gmxx_bpid_mapx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_bpid_msk  */
end_comment

begin_union
union|union
name|cvmx_gmxx_bpid_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_bpid_msk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|msk_or
range|:
literal|16
decl_stmt|;
comment|/**< Assert physical BP when the backpressure ID vector                                                          combined with MSK_OR indicates BP as follows.                                                          phys_bp_msk_or =                                                           (BPID_VECTOR<x:y>& MSK_OR<x:y>) != 0                                                          phys_bp = phys_bp_msk_or || phys_bp_msk_and                                                          In XAUI/RXAUI mode, x=15, y=0                                                          In SGMII mode, x/y are set depending on the SGMII                                                          interface.                                                          SGMII interface0, x=3,  y=0                                                          SGMII interface1, x=7,  y=4                                                          SGMII interface2, x=11, y=8                                                          SGMII interface3, x=15, y=12 */
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|msk_and
range|:
literal|16
decl_stmt|;
comment|/**< Assert physical BP when the backpressure ID vector                                                          combined with MSK_AND indicates BP as follows.                                                          phys_bp_msk_and =                                                           (BPID_VECTOR<x:y>& MSK_AND<x:y>) == MSK_AND<x:y>                                                          phys_bp = phys_bp_msk_or || phys_bp_msk_and                                                          In XAUI/RXAUI mode, x=15, y=0                                                          In SGMII mode, x/y are set depending on the SGMII                                                          interface.                                                          SGMII interface0, x=3,  y=0                                                          SGMII interface1, x=7,  y=4                                                          SGMII interface2, x=11, y=8                                                          SGMII interface3, x=15, y=12 */
else|#
directive|else
name|uint64_t
name|msk_and
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|msk_or
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_bpid_msk_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_bpid_msk_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_bpid_msk
name|cvmx_gmxx_bpid_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_clk_en  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_clk_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_clk_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|clk_en
range|:
literal|1
decl_stmt|;
comment|/**< Force the clock enables on */
else|#
directive|else
name|uint64_t
name|clk_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_clk_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_clk_en
name|cvmx_gmxx_clk_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_ebp_dis  */
end_comment

begin_union
union|union
name|cvmx_gmxx_ebp_dis
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_ebp_dis_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dis
range|:
literal|16
decl_stmt|;
comment|/**< BP channel disable                                                          GMX has the ability to remap unused channels                                                          in order to get down to GMX_TX_PIPE[NUMP]                                                          channels. */
else|#
directive|else
name|uint64_t
name|dis
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_ebp_dis_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_ebp_dis_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_ebp_dis
name|cvmx_gmxx_ebp_dis_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_ebp_msk  */
end_comment

begin_union
union|union
name|cvmx_gmxx_ebp_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_ebp_msk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|msk
range|:
literal|16
decl_stmt|;
comment|/**< BP channel mask                                                          GMX can completely ignore the channel BP for                                                          channels specified by the MSK field.  Any channel                                                          in which MSK == 1, will never send BP information                                                          to PKO. */
else|#
directive|else
name|uint64_t
name|msk
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_ebp_msk_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_ebp_msk_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_ebp_msk
name|cvmx_gmxx_ebp_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_hg2_control  *  * Notes:  * The HiGig2 TX and RX enable would normally be both set together for HiGig2 messaging. However  * setting just the TX or RX bit will result in only the HG2 message transmit or the receive  * capability.  * PHYS_EN and LOGL_EN bits when 1, allow link pause or back pressure to PKO as per received  * HiGig2 message. When 0, link pause and back pressure to PKO in response to received messages  * are disabled.  *  * GMX*_TX_XAUI_CTL[HG_EN] must be set to one(to enable HiGig) whenever either HG2TX_EN or HG2RX_EN  * are set.  *  * GMX*_RX0_UDD_SKP[LEN] must be set to 16 (to select HiGig2) whenever either HG2TX_EN or HG2RX_EN  * are set.  *  * GMX*_TX_OVR_BP[EN<0>] must be set to one and GMX*_TX_OVR_BP[BP<0>] must be cleared to zero  * (to forcibly disable HW-automatic 802.3 pause packet generation) with the HiGig2 Protocol when  * GMX*_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is indicated by GMX*_TX_XAUI_CTL[HG_EN]=1  * and GMX*_RX0_UDD_SKP[LEN]=16.) The HW can only auto-generate backpressure via HiGig2 messages  * (optionally, when HG2TX_EN=1) with the HiGig2 protocol.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_hg2_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_hg2_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|hg2tx_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable Transmission of HG2 phys and logl messages                                                          When set, also disables HW auto-generated (802.3                                                          and CBFC) pause frames. (OCTEON cannot generate                                                          proper 802.3 or CBFC pause frames in HiGig2 mode.) */
name|uint64_t
name|hg2rx_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable extraction and processing of HG2 message                                                          packet from RX flow. Physical logical pause info                                                          is used to pause physical link, back pressure PKO                                                          HG2RX_EN must be set when HiGig2 messages are                                                          present in the receive stream. */
name|uint64_t
name|phys_en
range|:
literal|1
decl_stmt|;
comment|/**< 1 bit physical link pause enable for recevied                                                          HiGig2 physical pause message */
name|uint64_t
name|logl_en
range|:
literal|16
decl_stmt|;
comment|/**< 16 bit xof enables for recevied HiGig2 messages                                                          or CBFC packets */
else|#
directive|else
name|uint64_t
name|logl_en
range|:
literal|16
decl_stmt|;
name|uint64_t
name|phys_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2rx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2tx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_hg2_control_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_hg2_control
name|cvmx_gmxx_hg2_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_inf_mode  *  * GMX_INF_MODE = Interface Mode  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_inf_mode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_inf_mode_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|4
decl_stmt|;
comment|/**< SERDES speed rate                                                          reset value is based on the QLM speed select                                                          0 = 1.25  Gbaud                                                          1 = 3.125 Gbaud                                                          (only valid for GMX0 instance)                                                          Software must not change RATE from its reset value */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
comment|/**< Interface Speed                                                          QLM speed pins  which select reference clock                                                          period and interface data rate.  If the QLM PLL                                                          inputs are correct, the speed setting correspond                                                          to the following data rates (in Gbaud).                                                          0  = 5                                                          1  = 2.5                                                          2  = 2.5                                                          3  = 1.25                                                          4  = 1.25                                                          5  = 6.25                                                          6  = 5                                                          7  = 2.5                                                          8  = 3.125                                                          9  = 2.5                                                          10 = 1.25                                                          11 = 5                                                          12 = 6.25                                                          13 = 3.75                                                          14 = 3.125                                                          15 = QLM disabled */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|3
decl_stmt|;
comment|/**< Interface Electrical Operating Mode                                                          - 0: SGMII (v1.8)                                                          - 1: XAUI (IEEE 802.3-2005) */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0mii
range|:
literal|1
decl_stmt|;
comment|/**< Port 0 Interface Mode                                                          - 0: Port 0 is RGMII                                                          - 1: Port 0 is MII */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Protocol Type                                                          - 0: SGMII/1000Base-X                                                          - 1: XAUI */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0mii
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_inf_mode_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|p0mii
range|:
literal|1
decl_stmt|;
comment|/**< Port 0 Interface Mode                                                          - 0: Port 0 is RGMII                                                          - 1: Port 0 is MII */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Port 1/2 Interface Mode                                                          - 0: Ports 1 and 2 are RGMII                                                          - 1: Port  1 is GMII/MII, Port 2 is unused                                                              GMII/MII is selected by GMX_PRT1_CFG[SPEED] */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0mii
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_gmxx_inf_mode_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Mode                                                          - 0: All three ports are RGMII ports                                                          - 1: prt0 is RGMII, prt1 is GMII, and prt2 is unused */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_gmxx_inf_mode_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_inf_mode_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
comment|/**< Interface Speed                                                          - 0: 1.250GHz                                                          - 1: 2.500GHz                                                          - 2: 3.125GHz                                                          - 3: 3.750GHz */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Interface Electrical Operating Mode                                                          - 0: Disabled (PCIe)                                                          - 1: XAUI (IEEE 802.3-2005)                                                          - 2: SGMII (v1.8)                                                          - 3: PICMG3.1 */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Protocol Type                                                          - 0: SGMII/1000Base-X                                                          - 1: XAUI */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_inf_mode_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn31xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_inf_mode_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
comment|/**< Interface Speed                                                          QLM speed pins  which select reference clock                                                          period and interface data rate.  If the QLM PLL                                                          inputs are correct, the speed setting correspond                                                          to the following data rates (in Gbaud).                                                          0  = 5                                                          1  = 2.5                                                          2  = 2.5                                                          3  = 1.25                                                          4  = 1.25                                                          5  = 6.25                                                          6  = 5                                                          7  = 2.5                                                          8  = 3.125                                                          9  = 2.5                                                          10 = 1.25                                                          11 = 5                                                          12 = 6.25                                                          13 = 3.75                                                          14 = 3.125                                                          15 = QLM disabled */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< Interface Electrical Operating Mode                                                          - 0: SGMII (v1.8)                                                          - 1: XAUI (IEEE 802.3-2005) */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Protocol Type                                                          - 0: SGMII/1000Base-X                                                          - 1: XAUI */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gmxx_inf_mode_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn61xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_inf_mode_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|4
decl_stmt|;
comment|/**< SERDES speed rate                                                          reset value is based on the QLM speed select                                                          0 = 1.25  Gbaud                                                          1 = 3.125 Gbaud                                                          (only valid for GMX0 instance)                                                          Software must not change RATE from its reset value */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
comment|/**< Interface Speed                                                          QLM speed pins  which select reference clock                                                          period and interface data rate.  If the QLM PLL                                                          inputs are correct, the speed setting correspond                                                          to the following data rates (in Gbaud).                                                          0  = 5                                                          1  = 2.5                                                          2  = 2.5                                                          3  = 1.25                                                          4  = 1.25                                                          5  = 6.25                                                          6  = 5                                                          7  = 2.5                                                          8  = 3.125                                                          9  = 2.5                                                          10 = 1.25                                                          11 = 5                                                          12 = 6.25                                                          13 = 3.75                                                          14 = 3.125                                                          15 = QLM disabled */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< Interface Electrical Operating Mode                                                          - 0: SGMII (v1.8)                                                          - 1: XAUI (IEEE 802.3-2005) */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                          Must be set to enable the packet interface.                                                          Should be enabled before any other requests to                                                          GMX including enabling port back pressure with                                                          IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Protocol Type                                                          - 0: SGMII/1000Base-X                                                          - 1: XAUI */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
struct|struct
name|cvmx_gmxx_inf_mode_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
comment|/**< Interface Speed                                                          QLM speed pins  which select reference clock                                                          period and interface data rate.  If the QLM PLL                                                          inputs are correct, the speed setting correspond                                                          to the following data rates (in Gbaud).                                                          0  = 5                                                          1  = 2.5                                                          2  = 2.5                                                          3  = 1.25                                                          4  = 1.25                                                          5  = 6.25                                                          6  = 5                                                          7  = 2.5                                                          8  = 3.125                                                          9  = 2.5                                                          10 = 1.25                                                          11 = 5                                                          12 = 6.25                                                          13 = 3.75                                                          14 = 3.125                                                          15 = QLM disabled */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|3
decl_stmt|;
comment|/**< Interface Electrical Operating Mode                                                          - 0: Reserved                                                          - 1: Reserved                                                          - 2: SGMII (v1.8)                                                          - 3: XAUI (IEEE 802.3-2005)                                                          - 4: Reserved                                                          - 5: Reserved                                                          - 6: Reserved                                                          - 7: RXAUI */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable                                                                    Must be set to enable the packet interface.                                                                    Should be enabled before any other requests to                                                                    GMX including enabling port back pressure with                                                          b         IPD_CTL_STATUS[PBP_EN] */
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Interface Protocol Type                                                          - 0: SGMII/1000Base-X                                                          - 1: XAUI/RXAUI */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_gmxx_inf_mode_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_inf_mode_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_inf_mode
name|cvmx_gmxx_inf_mode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_nxa_adr  *  * GMX_NXA_ADR = NXA Port Address  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_nxa_adr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_nxa_adr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|pipe
range|:
literal|7
decl_stmt|;
comment|/**< Logged pipe for NXP exceptions */
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|prt
range|:
literal|6
decl_stmt|;
comment|/**< Logged address for NXA exceptions                                                          The logged address will be from the first                                                          exception that caused the problem.  NCB has                                                          higher priority than PKO and will win.                                                          (only PRT[3:0]) */
else|#
directive|else
name|uint64_t
name|prt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pipe
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_nxa_adr_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|prt
range|:
literal|6
decl_stmt|;
comment|/**< Logged address for NXA exceptions                                                          The logged address will be from the first                                                          exception that caused the problem.  NCB has                                                          higher priority than PKO and will win. */
else|#
directive|else
name|uint64_t
name|prt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_nxa_adr_cn30xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_nxa_adr
name|cvmx_gmxx_nxa_adr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_pipe_status  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_pipe_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_pipe_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|ovr
range|:
literal|4
decl_stmt|;
comment|/**< Pipe credit return FIFO has overflowed. */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
comment|/**< Pipe credit return FIFO has filled up and asserted                                                          backpressure to the datapath. */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stop
range|:
literal|4
decl_stmt|;
comment|/**< PKO has asserted backpressure on the pipe credit                                                          return interface. */
else|#
directive|else
name|uint64_t
name|stop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ovr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_pipe_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_pipe_status_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_pipe_status
name|cvmx_gmxx_pipe_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_prt#_cbfc_ctl  *  * ** HG2 message CSRs end  *  *  * Notes:  * XOFF for a specific port is XOFF<prt> = (PHYS_EN<prt>& PHYS_BP) | (LOGL_EN<prt>& LOGL_BP<prt>)  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_prtx_cbfc_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|phys_en
range|:
literal|16
decl_stmt|;
comment|/**< Determines which ports will have physical                                                          backpressure pause packets.                                                          The value pplaced in the Class Enable Vector                                                          field of the CBFC pause packet will be                                                          PHYS_EN | LOGL_EN */
name|uint64_t
name|logl_en
range|:
literal|16
decl_stmt|;
comment|/**< Determines which ports will have logical                                                          backpressure pause packets.                                                          The value pplaced in the Class Enable Vector                                                          field of the CBFC pause packet will be                                                          PHYS_EN | LOGL_EN */
name|uint64_t
name|phys_bp
range|:
literal|16
decl_stmt|;
comment|/**< When RX_EN is set and the HW is backpressuring any                                                          ports (from either CBFC pause packets or the                                                          GMX_TX_OVR_BP[TX_PRT_BP] register) and all ports                                                          indiciated by PHYS_BP are backpressured, simulate                                                          physical backpressure by defering all packets on                                                          the transmitter. */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|bck_en
range|:
literal|1
decl_stmt|;
comment|/**< Forward CBFC Pause information to BP block */
name|uint64_t
name|drp_en
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control CBFC Pause Frames */
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
comment|/**< When set, allow for CBFC Pause Packets                                                          Must be clear in HiGig2 mode i.e. when                                                          GMX_TX_XAUI_CTL[HG_EN]=1 and                                                          GMX_RX_UDD_SKP[SKIP]=16. */
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
comment|/**< When set, allow for CBFC Pause Packets                                                          Must be clear in HiGig2 mode i.e. when                                                          GMX_TX_XAUI_CTL[HG_EN]=1 and                                                          GMX_RX_UDD_SKP[SKIP]=16. */
else|#
directive|else
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bck_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|phys_bp
range|:
literal|16
decl_stmt|;
name|uint64_t
name|logl_en
range|:
literal|16
decl_stmt|;
name|uint64_t
name|phys_en
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cbfc_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_prtx_cbfc_ctl
name|cvmx_gmxx_prtx_cbfc_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_prt#_cfg  *  * GMX_PRT_CFG = Port description  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_prtx_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_prtx_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|pknd
range|:
literal|6
decl_stmt|;
comment|/**< Port Kind used for processing the packet by PKI */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
comment|/**< TX Machine is idle */
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
comment|/**< RX Machine is idle */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed MSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
comment|/**< Slot Time for Half-Duplex operation                                                          0 = 512 bitimes (10/100Mbs operation)                                                          1 = 4096 bitimes (1000Mbs operation)                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< Duplex                                                          0 = Half Duplex (collisions/extentions/bursts)                                                          1 = Full Duplex                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed LSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Link Enable                                                          When EN is clear, packets will not be received                                                          or transmitted (including PAUSE and JAM packets).                                                          If EN is cleared while a packet is currently                                                          being received or transmitted, the packet will                                                          be allowed to complete before the bus is idled.                                                          On the RX side, subsequent packets in a burst                                                          will be ignored. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pknd
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
comment|/**< Slot Time for Half-Duplex operation                                                          0 = 512 bitimes (10/100Mbs operation)                                                          1 = 4096 bitimes (1000Mbs operation) */
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< Duplex                                                          0 = Half Duplex (collisions/extentions/bursts)                                                          1 = Full Duplex */
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed                                                          0 = 10/100Mbs operation                                                              (in RGMII mode, GMX_TX_CLK[CLK_CNT]>  1)                                                              (in MII   mode, GMX_TX_CLK[CLK_CNT] == 1)                                                          1 = 1000Mbs operation */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Link Enable                                                          When EN is clear, packets will not be received                                                          or transmitted (including PAUSE and JAM packets).                                                          If EN is cleared while a packet is currently                                                          being received or transmitted, the packet will                                                          be allowed to complete before the bus is idled.                                                          On the RX side, subsequent packets in a burst                                                          will be ignored. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
comment|/**< TX Machine is idle */
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
comment|/**< RX Machine is idle */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed MSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
comment|/**< Slot Time for Half-Duplex operation                                                          0 = 512 bitimes (10/100Mbs operation)                                                          1 = 4096 bitimes (1000Mbs operation)                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< Duplex                                                          0 = Half Duplex (collisions/extentions/bursts)                                                          1 = Full Duplex                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed LSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Link Enable                                                          When EN is clear, packets will not be received                                                          or transmitted (including PAUSE and JAM packets).                                                          If EN is cleared while a packet is currently                                                          being received or transmitted, the packet will                                                          be allowed to complete before the bus is idled.                                                          On the RX side, subsequent packets in a burst                                                          will be ignored. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_prtx_cfg_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_prtx_cfg
name|cvmx_gmxx_prtx_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam0  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam0
name|cvmx_gmxx_rxx_adr_cam0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam1  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam1
name|cvmx_gmxx_rxx_adr_cam1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam2  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam2
name|cvmx_gmxx_rxx_adr_cam2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam3  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam3
name|cvmx_gmxx_rxx_adr_cam3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam4  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam4_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam4
name|cvmx_gmxx_rxx_adr_cam4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam5  *  * GMX_RX_ADR_CAM = Address Filtering Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                           Each entry contributes 8bits to one of 8 matchers.                                                          The CAM matches against unicst or multicst DMAC                                                          addresses.                                                           ALL GMX_RX[0..3]_ADR_CAM[0..5] CSRs may be used                                                          in either SGMII or XAUI mode such that any GMX                                                          MAC can use any of the 32 common DMAC entries.                                                           GMX_RX[1..3]_ADR_CAM[0..5] are the only non-port0                                                          registers used in XAUI mode. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam5_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam5
name|cvmx_gmxx_rxx_adr_cam5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam_all_en  *  * GMX_RX_ADR_CAM_ALL_EN = Address Filtering Control Enable  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam_all_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam_all_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|en
range|:
literal|32
decl_stmt|;
comment|/**< CAM Entry Enables                                                           GMX has 32 DMAC entries that can be accessed with                                                          the GMX_RX[0..3]_ADR_CAM[0..5] CSRs.                                                          These 32 DMAC entries can be used by any of the                                                          four SGMII MACs or the XAUI MAC.                                                           Each port interface has independent control of                                                          which of the 32 DMAC entries to include in the                                                          CAM lookup.                                                           GMX_RXx_ADR_CAM_ALL_EN was not present in legacy                                                          GMX implemenations which had only eight DMAC CAM                                                          entries. New applications may choose to ignore                                                          GMX_RXx_ADR_CAM_EN using GMX_RX_ADR_CAM_ALL_EN                                                          instead.                                                           EN represents the full 32 indepedent per MAC                                                          enables.                                                           Writes to EN will be reflected in                                                          GMX_RXx_ADR_CAM_EN[EN] and writes to                                                          GMX_RXx_ADR_CAM_EN[EN] will be reflected in EN.                                                          Refer to GMX_RXx_ADR_CAM_EN for the CSR mapping.                                                           In XAUI mode, only GMX_RX0_ADR_CAM_ALL_EN is used                                                          and GMX_RX[1,2,3]_ADR_CAM_ALL_EN should not be                                                          used. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_all_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_all_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_all_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_all_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam_all_en
name|cvmx_gmxx_rxx_adr_cam_all_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_cam_en  *  * GMX_RX_ADR_CAM_EN = Address Filtering Control Enable  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_cam_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
comment|/**< CAM Entry Enables                                                           GMX has 32 DMAC entries that can be accessed with                                                          the GMX_RX[0..3]_ADR_CAM[0..5] CSRs.                                                          These 32 DMAC entries can be used by any of the                                                          four SGMII MACs or the XAUI MAC.                                                           Each port interface has independent control of                                                          which of the 32 DMAC entries to include in the                                                          CAM lookup.                                                           Legacy GMX implementations were able to CAM                                                          against eight DMAC entries while current                                                          implementations use 32 common entries.                                                          This register is intended for legacy applications                                                          that only require eight DMAC CAM entries per MAC.                                                          New applications may choose to ignore                                                          GMX_RXx_ADR_CAM_EN using GMX_RXx_ADR_CAM_ALL_EN                                                          instead.                                                           EN controls the enables for the eight legacy CAM                                                          entries as follows:                                                           port0, EN = GMX_RX0_ADR_CAM_ALL_EN[EN<7:0>]                                                           port1, EN = GMX_RX1_ADR_CAM_ALL_EN[EN<15:8>]                                                           port2, EN = GMX_RX2_ADR_CAM_ALL_EN[EN<23:16>]                                                           port3, EN = GMX_RX3_ADR_CAM_ALL_EN[EN<31:24>]                                                           The full 32 indepedent per MAC enables are in                                                          GMX_RX_ADR_CAM_ALL_EN.                                                           Therefore, writes to GMX_RXX_ADR_CAM_ALL_EN[EN]                                                          will be reflected in EN and writes to EN will be                                                          reflected in GMX_RXX_ADR_CAM_ALL_EN[EN].                                                           In XAUI mode, only GMX_RX0_ADR_CAM_EN is used and                                                          GMX_RX[1,2,3]_ADR_CAM_EN should not be used. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_cam_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_cam_en
name|cvmx_gmxx_rxx_adr_cam_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_adr_ctl  *  * GMX_RX_ADR_CTL = Address Filtering Control  *  *  * Notes:  * * ALGORITHM  *   Here is some pseudo code that represents the address filter behavior.  *  *      @verbatim  *      bool dmac_addr_filter(uint8 prt, uint48 dmac) [  *        ASSERT(prt>= 0&& prt<= 3);  *        if (is_bcst(dmac))                               // broadcast accept  *          return (GMX_RX[prt]_ADR_CTL[BCST] ? ACCEPT : REJECT);  *        if (is_mcst(dmac)& GMX_RX[prt]_ADR_CTL[MCST] == 1)   // multicast reject  *          return REJECT;  *        if (is_mcst(dmac)& GMX_RX[prt]_ADR_CTL[MCST] == 2)   // multicast accept  *          return ACCEPT;  *  *        cam_hit = 0;  *  *        for (i=0; i<32; i++) [  *          if (GMX_RX[prt]_ADR_CAM_ALL_EN[EN<i>] == 0)  *            continue;  *          uint48 unswizzled_mac_adr = 0x0;  *          for (j=5; j>=0; j--) [  *             unswizzled_mac_adr = (unswizzled_mac_adr<< 8) | GMX_RX[i>>3]_ADR_CAM[j][ADR<(i&7)*8+7:(i&7)*8>];  *          ]  *          if (unswizzled_mac_adr == dmac) [  *            cam_hit = 1;  *            break;  *          ]  *        ]  *  *        if (cam_hit)  *          return (GMX_RX[prt]_ADR_CTL[CAM_MODE] ? ACCEPT : REJECT);  *        else  *          return (GMX_RX[prt]_ADR_CTL[CAM_MODE] ? REJECT : ACCEPT);  *      ]  *      @endverbatim  *  * * XAUI Mode  *  *   In XAUI mode, only GMX_RX0_ADR_CTL is used.  GMX_RX[1,2,3]_ADR_CTL should not be used.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_adr_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_adr_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|cam_mode
range|:
literal|1
decl_stmt|;
comment|/**< Allow or deny DMAC address filter                                                          0 = reject the packet on DMAC address match                                                          1 = accept the packet on DMAC address match */
name|uint64_t
name|mcst
range|:
literal|2
decl_stmt|;
comment|/**< Multicast Mode                                                          0 = Use the Address Filter CAM                                                          1 = Force reject all multicast packets                                                          2 = Force accept all multicast packets                                                          3 = Reserved */
name|uint64_t
name|bcst
range|:
literal|1
decl_stmt|;
comment|/**< Accept All Broadcast Packets */
else|#
directive|else
name|uint64_t
name|bcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mcst
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cam_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_adr_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_adr_ctl
name|cvmx_gmxx_rxx_adr_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_decision  *  * GMX_RX_DECISION = The byte count to decide when to accept or filter a packet  *  *  * Notes:  * As each byte in a packet is received by GMX, the L2 byte count is compared  * against the GMX_RX_DECISION[CNT].  The L2 byte count is the number of bytes  * from the beginning of the L2 header (DMAC).  In normal operation, the L2  * header begins after the PREAMBLE+SFD (GMX_RX_FRM_CTL[PRE_CHK]=1) and any  * optional UDD skip data (GMX_RX_UDD_SKP[LEN]).  *  * When GMX_RX_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the  * packet and would require UDD skip length to account for them.  *  *                                                 L2 Size  * Port Mode<GMX_RX_DECISION bytes (default=24)>=GMX_RX_DECISION bytes (default=24)  *  * Full Duplex           accept packet                             apply filters  *                       no filtering is applied                   accept packet based on DMAC and PAUSE packet filters  *  * Half Duplex           drop packet                               apply filters  *                       packet is unconditionally dropped         accept packet based on DMAC  *  * where l2_size = MAX(0, total_packet_size - GMX_RX_UDD_SKP[LEN] - ((GMX_RX_FRM_CTL[PRE_CHK]==1)*8)  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_decision
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_decision_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|5
decl_stmt|;
comment|/**< The byte count to decide when to accept or filter                                                          a packet. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_decision_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_decision
name|cvmx_gmxx_rxx_decision_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_frm_chk  *  * GMX_RX_FRM_CHK = Which frame errors will set the ERR bit of the frame  *  *  * Notes:  * If GMX_RX_UDD_SKP[LEN] != 0, then LENERR will be forced to zero in HW.  *  * In XAUI mode prt0 is used for checking.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_frm_chk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_chk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_chk_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_gmxx_rxx_frm_chk_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_s
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_chk_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_frm_chk
name|cvmx_gmxx_rxx_frm_chk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_frm_ctl  *  * GMX_RX_FRM_CTL = Frame Control  *  *  * Notes:  * * PRE_STRP  *   When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP  *   determines if the PREAMBLE+SFD bytes are thrown away or sent to the Octane  *   core as part of the packet.  *  *   In either mode, the PREAMBLE+SFD bytes are not counted toward the packet  *   size when checking against the MIN and MAX bounds.  Furthermore, the bytes  *   are skipped when locating the start of the L2 header for DMAC and Control  *   frame recognition.  *  * * CTL_BCK/CTL_DRP  *   These bits control how the HW handles incoming PAUSE packets.  Here are  *   the most common modes of operation:  *     CTL_BCK=1,CTL_DRP=1   - HW does it all  *     CTL_BCK=0,CTL_DRP=0   - SW sees all pause frames  *     CTL_BCK=0,CTL_DRP=1   - all pause frames are completely ignored  *  *   These control bits should be set to CTL_BCK=0,CTL_DRP=0 in halfdup mode.  *   Since PAUSE packets only apply to fulldup operation, any PAUSE packet  *   would constitute an exception which should be handled by the processing  *   cores.  PAUSE packets should not be forwarded.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_frm_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
comment|/**< Timestamp mode                                                          When PTP_MODE is set, a 64-bit timestamp will be                                                          prepended to every incoming packet. The timestamp                                                          bytes are added to the packet in such a way as to                                                          not modify the packet's receive byte count.  This                                                          implies that the GMX_RX_JABBER, MINERR,                                                          GMX_RX_DECISION, GMX_RX_UDD_SKP, and the                                                          GMX_RX_STATS_* do not require any adjustment as                                                          they operate on the received packet size.                                                          When the packet reaches PKI, its size will                                                          reflect the additional bytes and is subject to                                                          the restrictions below.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1.                                                          If PTP_MODE=1,                                                           PIP_PRT_CFGx[SKIP] should be increased by 8.                                                           PIP_PRT_CFGx[HIGIG_EN] should be 0.                                                           PIP_FRM_CHKx[MAXLEN] should be increased by 8.                                                           PIP_FRM_CHKx[MINLEN] should be increased by 8.                                                           PIP_TAG_INCx[EN] should be adjusted.                                                           PIP_PRT_CFGBx[ALT_SKP_EN] should be 0. */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, do not modify the MOD bits on NULL ticks                                                          due to PARITAL packets */
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PRE_STRP should be set to                                                          account for the variable nature of the PREAMBLE.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII at 10/100Mbs only) */
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for non-min                                                          sized pkts with padding in the client data                                                          (PASS3 Only) */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is  less strict.                                                          GMX will begin the frame at the first SFD.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1. */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send a valid 802.3                                                          PREAMBLE to begin every frame. GMX checks that a                                                          valid PREAMBLE is received (based on PRE_FREE).                                                          When a problem does occur within the PREAMBLE                                                          seqeunce, the frame is marked as bad and not sent                                                          into the core.  The GMX_GMX_RX_INT_REG[PCTERR]                                                          interrupt is also raised.                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, PRE_CHK                                                          must be zero.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1. */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for non-min                                                          sized pkts with padding in the client data */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< Allows for less strict PREAMBLE checking.                                                          0-7 cycles of PREAMBLE followed by SFD (pass 1.0)                                                          0-254 cycles of PREAMBLE followed by SFD (else) */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< Allows for less strict PREAMBLE checking.                                                          0 - 7 cycles of PREAMBLE followed by SFD (pass1.0)                                                          0 - 254 cycles of PREAMBLE followed by SFD (else) */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn31xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, do not modify the MOD bits on NULL ticks                                                          due to PARITAL packets */
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PREAMBLE can be consumed                                                          by the HW so when PRE_ALIGN is set, PRE_FREE,                                                          PRE_STRP must be set for correct operation.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< Allows for less strict PREAMBLE checking.                                                          0-254 cycles of PREAMBLE followed by SFD */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn50xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PRE_STRP should be set to                                                          account for the variable nature of the PREAMBLE.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII at 10/100Mbs only) */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is  less strict.                                                          0 - 254 cycles of PREAMBLE followed by SFD                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly.                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, PRE_CHK                                                          must be zero. */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, do not modify the MOD bits on NULL ticks                                                          due to PARITAL packets                                                          In spi4 mode, all ports use prt0 for checking. */
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PREAMBLE can be consumed                                                          by the HW so when PRE_ALIGN is set, PRE_FREE,                                                          PRE_STRP must be set for correct operation.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for non-min                                                          sized pkts with padding in the client data                                                          (PASS3 Only) */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is  less strict.                                                          0 - 254 cycles of PREAMBLE followed by SFD */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn30xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
comment|/**< Timestamp mode                                                          When PTP_MODE is set, a 64-bit timestamp will be                                                          prepended to every incoming packet. The timestamp                                                          bytes are added to the packet in such a way as to                                                          not modify the packet's receive byte count.  This                                                          implies that the GMX_RX_JABBER, MINERR,                                                          GMX_RX_DECISION, GMX_RX_UDD_SKP, and the                                                          GMX_RX_STATS_* do not require any adjustment as                                                          they operate on the received packet size.                                                          When the packet reaches PKI, its size will                                                          reflect the additional bytes and is subject to                                                          the restrictions below.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1.                                                          If PTP_MODE=1,                                                           PIP_PRT_CFGx[SKIP] should be increased by 8.                                                           PIP_PRT_CFGx[HIGIG_EN] should be 0.                                                           PIP_FRM_CHKx[MAXLEN] should be increased by 8.                                                           PIP_FRM_CHKx[MINLEN] should be increased by 8.                                                           PIP_TAG_INCx[EN] should be adjusted.                                                           PIP_PRT_CFGBx[ALT_SKP_EN] should be 0. */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, do not modify the MOD bits on NULL ticks                                                          due to PARITAL packets */
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PRE_STRP should be set to                                                          account for the variable nature of the PREAMBLE.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII at 10/100Mbs only) */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is  less strict.                                                          GMX will begin the frame at the first SFD.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1. */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send a valid 802.3                                                          PREAMBLE to begin every frame. GMX checks that a                                                          valid PREAMBLE is received (based on PRE_FREE).                                                          When a problem does occur within the PREAMBLE                                                          seqeunce, the frame is marked as bad and not sent                                                          into the core.  The GMX_GMX_RX_INT_REG[PCTERR]                                                          interrupt is also raised.                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, PRE_CHK                                                          must be zero.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1. */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_ctl_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_frm_ctl
name|cvmx_gmxx_rxx_frm_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_frm_max  *  * GMX_RX_FRM_MAX = Frame Max length  *  *  * Notes:  * In spi4 mode, all spi4 ports use prt0 for checking.  *  * When changing the LEN field, be sure that LEN does not exceed  * GMX_RX_JABBER[CNT]. Failure to meet this constraint will cause packets that  * are within the maximum length parameter to be rejected because they exceed  * the GMX_RX_JABBER[CNT] limit.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_frm_max
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_max_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Max-sized frame check                                                          GMX_RXn_FRM_CHK[MAXERR] enables the check for                                                          port n.                                                          If enabled, failing packets set the MAXERR                                                          interrupt and work-queue entry WORD2[opcode] is                                                          set to OVER_FCS (0x3, if packet has bad FCS) or                                                          OVER_ERR (0x4, if packet has good FCS).                                                          LEN =< GMX_RX_JABBER[CNT] */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_max_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_frm_max
name|cvmx_gmxx_rxx_frm_max_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_frm_min  *  * GMX_RX_FRM_MIN = Frame Min length  *  *  * Notes:  * In spi4 mode, all spi4 ports use prt0 for checking.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_frm_min
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_frm_min_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Min-sized frame check                                                          GMX_RXn_FRM_CHK[MINERR] enables the check for                                                          port n.                                                          If enabled, failing packets set the MINERR                                                          interrupt and work-queue entry WORD2[opcode] is                                                          set to UNDER_FCS (0x6, if packet has bad FCS) or                                                          UNDER_ERR (0x8, if packet has good FCS). */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_frm_min_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_frm_min
name|cvmx_gmxx_rxx_frm_min_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_ifg  *  * GMX_RX_IFG = RX Min IFG  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_ifg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_ifg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ifg
range|:
literal|4
decl_stmt|;
comment|/**< Min IFG (in IFG*8 bits) between packets used to                                                          determine IFGERR. Normally IFG is 96 bits.                                                          Note in some operating modes, IFG cycles can be                                                          inserted or removed in order to achieve clock rate                                                          adaptation. For these reasons, the default value                                                          is slightly conservative and does not check upto                                                          the full 96 bits of IFG.                                                          (SGMII/1000Base-X only) */
else|#
directive|else
name|uint64_t
name|ifg
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_ifg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_ifg
name|cvmx_gmxx_rxx_ifg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_int_en  *  * GMX_RX_INT_EN = Interrupt Enable  *  *  * Notes:  * In XAUI mode prt0 is used for checking.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 CRC8 or Control char error interrupt enable */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 Bad field error interrupt enable */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 CRC8 or Control char error interrupt enable */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 Bad field error interrupt enable */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn52xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn58xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 CRC8 or Control char error interrupt enable */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 Bad field error interrupt enable */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_en_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_int_en
name|cvmx_gmxx_rxx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_int_reg  *  * GMX_RX_INT_REG = Interrupt Register  *  *  * Notes:  * (1) exceptions will only be raised to the control processor if the  *     corresponding bit in the GMX_RX_INT_EN register is set.  *  * (2) exception conditions 10:0 can also set the rcv/opcode in the received  *     packet's workQ entry.  The GMX_RX_FRM_CHK register provides a bit mask  *     for configuring which conditions set the error.  *  * (3) in half duplex operation, the expectation is that collisions will appear  *     as either MINERR o r CAREXT errors.  *  * (4) JABBER - An RX Jabber error indicates that a packet was received which  *              is longer than the maximum allowed packet as defined by the  *              system.  GMX will truncate the packet at the JABBER count.  *              Failure to do so could lead to system instabilty.  *  * (5) NIBERR - This error is illegal at 1000Mbs speeds  *              (GMX_RX_PRT_CFG[SPEED]==0) and will never assert.  *  * (6) MAXERR - for untagged frames, the total frame DA+SA+TL+DATA+PAD+FCS>  *              GMX_RX_FRM_MAX.  For tagged frames, DA+SA+VLAN+TL+DATA+PAD+FCS  *> GMX_RX_FRM_MAX + 4*VLAN_VAL + 4*VLAN_STACKED.  *  * (7) MINERR - total frame DA+SA+TL+DATA+PAD+FCS< 64  *  * (8) ALNERR - Indicates that the packet received was not an integer number of  *              bytes.  If FCS checking is enabled, ALNERR will only assert if  *              the FCS is bad.  If FCS checking is disabled, ALNERR will  *              assert in all non-integer frame cases.  *  * (9) Collisions - Collisions can only occur in half-duplex mode.  A collision  *                  is assumed by the receiver when the slottime  *                  (GMX_PRT_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,  *                  this will result in a frame< SLOTTIME.  In 1000 mode, it  *                  could result either in frame< SLOTTIME or a carrier extend  *                  error with the SLOTTIME.  These conditions are visible by...  *  *                  . transfer ended before slottime - COLDET  *                  . carrier extend error           - CAREXT  *  * (A) LENERR - Length errors occur when the received packet does not match the  *              length field.  LENERR is only checked for packets between 64  *              and 1500 bytes.  For untagged frames, the length must exact  *              match.  For tagged frames the length or length+4 must match.  *  * (B) PCTERR - checks that the frame begins with a valid PREAMBLE sequence.  *              Does not check the number of PREAMBLE cycles.  *  * (C) OVRERR -  *  *              OVRERR is an architectural assertion check internal to GMX to  *              make sure no assumption was violated.  In a correctly operating  *              system, this interrupt can never fire.  *  *              GMX has an internal arbiter which selects which of 4 ports to  *              buffer in the main RX FIFO.  If we normally buffer 8 bytes,  *              then each port will typically push a tick every 8 cycles - if  *              the packet interface is going as fast as possible.  If there  *              are four ports, they push every two cycles.  So that's the  *              assumption.  That the inbound module will always be able to  *              consume the tick before another is produced.  If that doesn't  *              happen - that's when OVRERR will assert.  *  * (D) In XAUI mode prt0 is used for interrupt logging.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message CRC or Control char  error                                                          Set when either CRC8 error detected or when                                                          a Control Character is found in the message                                                          bytes after the K.SOM                                                          NOTE: HG2CC has higher priority than HG2FLD                                                                i.e. a HiGig2 message that results in HG2CC                                                                getting set, will never set HG2FLD. */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message field error, as below                                                          1) MSG_TYPE field not 6'b00_0000                                                             i.e. it is not a FLOW CONTROL message, which                                                             is the only defined type for HiGig2                                                          2) FWD_TYPE field not 2'b00 i.e. Link Level msg                                                             which is the only defined type for HiGig2                                                          3) FC_OBJECT field is neither 4'b0000 for                                                             Physical Link nor 4'b0010 for Logical Link.                                                             Those are the only two defined types in HiGig2 */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol                                                          In XAUI mode, the column of data that was bad                                                          will be logged in GMX_RX_XAUI_BAD_COL */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize                                                          Frame length checks are typically handled in PIP                                                          (PIP_INT_REG[MINERR]), but pause frames are                                                          normally discarded before being inspected by PIP. */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message CRC or Control char  error                                                          Set when either CRC8 error detected or when                                                          a Control Character is found in the message                                                          bytes after the K.SOM                                                          NOTE: HG2CC has higher priority than HG2FLD                                                                i.e. a HiGig2 message that results in HG2CC                                                                getting set, will never set HG2FLD. */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message field error, as below                                                          1) MSG_TYPE field not 6'b00_0000                                                             i.e. it is not a FLOW CONTROL message, which                                                             is the only defined type for HiGig2                                                          2) FWD_TYPE field not 2'b00 i.e. Link Level msg                                                             which is the only defined type for HiGig2                                                          3) FC_OBJECT field is neither 4'b0000 for                                                             Physical Link nor 4'b0010 for Logical Link.                                                             Those are the only two defined types in HiGig2 */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol                                                          In XAUI mode, the column of data that was bad                                                          will be logged in GMX_RX_XAUI_BAD_COL */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn52xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol                                                          In XAUI mode, the column of data that was bad                                                          will be logged in GMX_RX_XAUI_BAD_COL */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< RGMII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble) */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< RGMII carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn58xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message CRC or Control char  error                                                          Set when either CRC8 error detected or when                                                          a Control Character is found in the message                                                          bytes after the K.SOM                                                          NOTE: HG2CC has higher priority than HG2FLD                                                                i.e. a HiGig2 message that results in HG2CC                                                                getting set, will never set HG2FLD. */
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
comment|/**< HiGig2 received message field error, as below                                                          1) MSG_TYPE field not 6'b00_0000                                                             i.e. it is not a FLOW CONTROL message, which                                                             is the only defined type for HiGig2                                                          2) FWD_TYPE field not 2'b00 i.e. Link Level msg                                                             which is the only defined type for HiGig2                                                          3) FC_OBJECT field is neither 4'b0000 for                                                             Physical Link nor 4'b0010 for Logical Link.                                                             Those are the only two defined types in HiGig2 */
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Data                                                          (XAUI Mode only) */
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected EOP                                                          (XAUI Mode only) */
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected SOP                                                          (XAUI Mode only) */
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
comment|/**< Frame is terminated by control character other                                                          than /T/.  The error propagation control                                                          character /E/ will be included as part of the                                                          frame and does not cause a frame termination.                                                          (XAUI Mode only) */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Reserved Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
comment|/**< Remote Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
comment|/**< Local Fault Sequence Deteted                                                          (XAUI Mode only) */
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol                                                          In XAUI mode, the column of data that was bad                                                          will be logged in GMX_RX_XAUI_BAD_COL */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Data reception error */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error                                                          (SGMII/1000Base-X only) */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Pause Frame was received with length<minFrameSize                                                          Frame length checks are typically handled in PIP                                                          (PIP_INT_REG[MINERR]), but pause frames are                                                          normally discarded before being inspected by PIP. */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_fault
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_term
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unsop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uneop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2fld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg2cc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_int_reg_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_int_reg
name|cvmx_gmxx_rxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_jabber  *  * GMX_RX_JABBER = The max size packet after which GMX will truncate  *  *  * Notes:  * CNT must be 8-byte aligned such that CNT[2:0] == 0  *  * The packet that will be sent to the packet input logic will have an  * additionl 8 bytes if GMX_RX_FRM_CTL[PRE_CHK] is set and  * GMX_RX_FRM_CTL[PRE_STRP] is clear.  The max packet that will be sent is  * defined as...  *  *      max_sized_packet = GMX_RX_JABBER[CNT]+((GMX_RX_FRM_CTL[PRE_CHK]& !GMX_RX_FRM_CTL[PRE_STRP])*8)  *  * In XAUI mode prt0 is used for checking.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_jabber
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_jabber_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for jabber check                                                          Failing packets set the JABBER interrupt and are                                                          optionally sent with opcode==JABBER                                                          GMX will truncate the packet to CNT bytes */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_jabber_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_jabber
name|cvmx_gmxx_rxx_jabber_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_pause_drop_time  *  * GMX_RX_PAUSE_DROP_TIME = The TIME field in a PAUSE Packet which was dropped due to GMX RX FIFO full condition  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_pause_drop_time
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
comment|/**< Time extracted from the dropped PAUSE packet */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_pause_drop_time_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_pause_drop_time
name|cvmx_gmxx_rxx_pause_drop_time_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_rx_inbnd  *  * GMX_RX_INBND = RGMII InBand Link Status  *  *  * Notes:  * These fields are only valid if the attached PHY is operating in RGMII mode  * and supports the optional in-band status (see section 3.4.1 of the RGMII  * specification, version 1.3 for more information).  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_rx_inbnd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< RGMII Inbound LinkDuplex                                                          0=half-duplex                                                          1=full-duplex */
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
comment|/**< RGMII Inbound LinkSpeed                                                          00=2.5MHz                                                          01=25MHz                                                          10=125MHz                                                          11=Reserved */
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
comment|/**< RGMII Inbound LinkStatus                                                          0=down                                                          1=up */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_rx_inbnd_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_rx_inbnd
name|cvmx_gmxx_rxx_rx_inbnd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_ctl  *  * GMX_RX_STATS_CTL = RX Stats Control register  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
comment|/**< RX Stats registers will clear on reads */
else|#
directive|else
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_ctl
name|cvmx_gmxx_rxx_stats_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_octs  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_octs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_octs_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of received good packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_octs
name|cvmx_gmxx_rxx_stats_octs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_octs_ctl  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_octs_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of received pause packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_octs_ctl
name|cvmx_gmxx_rxx_stats_octs_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_octs_dmac  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_octs_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of filtered dmac packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_dmac_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_octs_dmac
name|cvmx_gmxx_rxx_stats_octs_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_octs_drp  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_octs_drp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of dropped packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_octs_drp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_octs_drp
name|cvmx_gmxx_rxx_stats_octs_drp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_pkts  *  * GMX_RX_STATS_PKTS  *  * Count of good received packets - packets that are not recognized as PAUSE  * packets, dropped due the DMAC filter, dropped due FIFO full status, or  * have any other OPCODE (FCS, Length, etc).  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_pkts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_pkts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of received good packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_pkts
name|cvmx_gmxx_rxx_stats_pkts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_pkts_bad  *  * GMX_RX_STATS_PKTS_BAD  *  * Count of all packets received with some error that were not dropped  * either due to the dmac filter or lack of room in the receive FIFO.  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_pkts_bad
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of bad packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_bad_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_pkts_bad
name|cvmx_gmxx_rxx_stats_pkts_bad_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_pkts_ctl  *  * GMX_RX_STATS_PKTS_CTL  *  * Count of all packets received that were recognized as Flow Control or  * PAUSE packets.  PAUSE packets with any kind of error are counted in  * GMX_RX_STATS_PKTS_BAD.  Pause packets can be optionally dropped or  * forwarded based on the GMX_RX_FRM_CTL[CTL_DRP] bit.  This count  * increments regardless of whether the packet is dropped.  Pause packets  * will never be counted in GMX_RX_STATS_PKTS.  Packets dropped due the dmac  * filter will be counted in GMX_RX_STATS_PKTS_DMAC and not here.  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_pkts_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of received pause packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_pkts_ctl
name|cvmx_gmxx_rxx_stats_pkts_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_pkts_dmac  *  * GMX_RX_STATS_PKTS_DMAC  *  * Count of all packets received that were dropped by the dmac filter.  * Packets that match the DMAC will be dropped and counted here regardless  * of if they were bad packets.  These packets will never be counted in  * GMX_RX_STATS_PKTS.  *  * Some packets that were not able to satisify the DECISION_CNT may not  * actually be dropped by Octeon, but they will be counted here as if they  * were dropped.  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_pkts_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of filtered dmac packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_dmac_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_pkts_dmac
name|cvmx_gmxx_rxx_stats_pkts_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_stats_pkts_drp  *  * GMX_RX_STATS_PKTS_DRP  *  * Count of all packets received that were dropped due to a full receive FIFO.  * This counts both partial packets in which there was enough space in the RX  * FIFO to begin to buffer and the packet and total drops in which no packet was  * sent to PKI.  This counts good and bad packets received - all packets dropped  * by the FIFO.  It does not count packets dropped by the dmac or pause packet  * filters.  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_stats_pkts_drp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of dropped packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_stats_pkts_drp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_stats_pkts_drp
name|cvmx_gmxx_rxx_stats_pkts_drp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx#_udd_skp  *  * GMX_RX_UDD_SKP = Amount of User-defined data before the start of the L2 data  *  *  * Notes:  * (1) The skip bytes are part of the packet and will be sent down the NCB  *     packet interface and will be handled by PKI.  *  * (2) The system can determine if the UDD bytes are included in the FCS check  *     by using the FCSSEL field - if the FCS check is enabled.  *  * (3) Assume that the preamble/sfd is always at the start of the frame - even  *     before UDD bytes.  In most cases, there will be no preamble in these  *     cases since it will be packet interface in direct communication to  *     another packet interface (MAC to MAC) without a PHY involved.  *  * (4) We can still do address filtering and control packet filtering is the  *     user desires.  *  * (5) UDD_SKP must be 0 in half-duplex operation unless  *     GMX_RX_FRM_CTL[PRE_CHK] is clear.  If GMX_RX_FRM_CTL[PRE_CHK] is clear,  *     then UDD_SKP will normally be 8.  *  * (6) In all cases, the UDD bytes will be sent down the packet interface as  *     part of the packet.  The UDD bytes are never stripped from the actual  *     packet.  *  * (7) If LEN != 0, then GMX_RX_FRM_CHK[LENERR] will be disabled and GMX_RX_INT_REG[LENERR] will be zero  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxx_udd_skp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxx_udd_skp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|fcssel
range|:
literal|1
decl_stmt|;
comment|/**< Include the skip bytes in the FCS calculation                                                          0 = all skip bytes are included in FCS                                                          1 = the skip bytes are not included in FCS                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, FCSSEL must                                                          be zero. */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
comment|/**< Amount of User-defined data before the start of                                                          the L2 data.  Zero means L2 comes first.                                                          Max value is 64.                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, LEN must be                                                          set to 12 or 16 (depending on HiGig header size)                                                          to account for the HiGig header. LEN=12 selects                                                          HiGig/HiGig+, and LEN=16 selects HiGig2. */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcssel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rxx_udd_skp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxx_udd_skp
name|cvmx_gmxx_rxx_udd_skp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_bp_drop#  *  * GMX_RX_BP_DROP = FIFO mark for packet drop  *  *  * Notes:  * The actual watermark is dynamic with respect to the GMX_RX_PRTS  * register.  The GMX_RX_PRTS controls the depth of the port's  * FIFO so as ports are added or removed, the drop point may change.  *  * In XAUI mode prt0 is used for checking.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_bp_dropx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_bp_dropx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
comment|/**< Number of 8B ticks to reserve in the RX FIFO.                                                          When the FIFO exceeds this count, packets will                                                          be dropped and not buffered.                                                          MARK should typically be programmed to ports+1.                                                          Failure to program correctly can lead to system                                                          instability. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_dropx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_bp_dropx
name|cvmx_gmxx_rx_bp_dropx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_bp_off#  *  * GMX_RX_BP_OFF = Lowater mark for packet drop  *  *  * Notes:  * In XAUI mode, prt0 is used for checking.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_bp_offx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_bp_offx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
comment|/**< Water mark (8B ticks) to deassert backpressure */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_offx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_bp_offx
name|cvmx_gmxx_rx_bp_offx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_bp_on#  *  * GMX_RX_BP_ON = Hiwater mark for port/interface backpressure  *  *  * Notes:  * In XAUI mode, prt0 is used for checking.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_bp_onx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_bp_onx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|11
decl_stmt|;
comment|/**< Hiwater mark (8B ticks) for backpressure.                                                          Each register is for an individual port.  In XAUI                                                          mode, prt0 is used for the unified RX FIFO                                                          GMX_RX_BP_ON must satisfy                                                          BP_OFF<= BP_ON< (FIFO_SIZE - BP_DROP)                                                          A value of zero will immediately assert back                                                          pressure. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|9
decl_stmt|;
comment|/**< Hiwater mark (8B ticks) for backpressure.                                                          In RGMII mode, the backpressure is given per                                                          port.  In Spi4 mode, the backpressure is for the                                                          entire interface.  GMX_RX_BP_ON must satisfy                                                          BP_OFF<= BP_ON< (FIFO_SIZE - BP_DROP)                                                          The reset value is half the FIFO.                                                          Reset value RGMII mode = 0x40  (512bytes)                                                          Reset value Spi4 mode  = 0x100 (2048bytes)                                                          A value of zero will immediately assert back                                                          pressure. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_bp_onx_cn30xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_bp_onx
name|cvmx_gmxx_rx_bp_onx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_hg2_status  *  * ** HG2 message CSRs  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_hg2_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_hg2_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|phtim2go
range|:
literal|16
decl_stmt|;
comment|/**< Physical time to go for removal of physical link                                                          pause. Initial value from received HiGig2 msg pkt                                                          Non-zero only when physical back pressure active */
name|uint64_t
name|xof
range|:
literal|16
decl_stmt|;
comment|/**< 16 bit xof back pressure vector from HiGig2 msg pkt                                                          or from CBFC packets.                                                          Non-zero only when logical back pressure is active                                                          All bits will be 0 when LGTIM2GO=0 */
name|uint64_t
name|lgtim2go
range|:
literal|16
decl_stmt|;
comment|/**< Logical packet flow back pressure time remaining                                                          Initial value set from xof time field of HiGig2                                                          message packet received or a function of the                                                          enabled and current timers for CBFC packets.                                                          Non-zero only when logical back pressure is active */
else|#
directive|else
name|uint64_t
name|lgtim2go
range|:
literal|16
decl_stmt|;
name|uint64_t
name|xof
range|:
literal|16
decl_stmt|;
name|uint64_t
name|phtim2go
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_hg2_status_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_hg2_status
name|cvmx_gmxx_rx_hg2_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_pass_en  *  * GMX_RX_PASS_EN = Packet pass through mode enable  *  * When both Octane ports are running in Spi4 mode, packets can be directly  * passed from one SPX interface to the other without being processed by the  * core or PP's.  The register has one bit for each port to enable the pass  * through feature.  *  * Notes:  * (1) Can only be used in dual Spi4 configs  *  * (2) The mapped pass through output port cannot be the destination port for  *     any Octane core traffic.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_pass_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_pass_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|en
range|:
literal|16
decl_stmt|;
comment|/**< Which ports to configure in pass through mode */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_pass_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_en_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_pass_en
name|cvmx_gmxx_rx_pass_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_pass_map#  *  * GMX_RX_PASS_MAP = Packet pass through port map  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_pass_mapx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_pass_mapx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|dprt
range|:
literal|4
decl_stmt|;
comment|/**< Destination port to map Spi pass through traffic */
else|#
directive|else
name|uint64_t
name|dprt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_pass_mapx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_mapx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_mapx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_pass_mapx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_pass_mapx
name|cvmx_gmxx_rx_pass_mapx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_prt_info  *  * GMX_RX_PRT_INFO = Report the RX status for port  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of DROP and COMMIT are used.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_prt_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_prt_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|16
decl_stmt|;
comment|/**< Per port indication that data was dropped */
name|uint64_t
name|commit
range|:
literal|16
decl_stmt|;
comment|/**< Per port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|16
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_rx_prt_info_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|3
decl_stmt|;
comment|/**< Per port indication that data was dropped */
name|uint64_t
name|reserved_3_15
range|:
literal|13
decl_stmt|;
name|uint64_t
name|commit
range|:
literal|3
decl_stmt|;
comment|/**< Per port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_15
range|:
literal|13
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|4
decl_stmt|;
comment|/**< Per port indication that data was dropped */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|commit
range|:
literal|4
decl_stmt|;
comment|/**< Per port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prt_info_cn52xx
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_prt_info_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|2
decl_stmt|;
comment|/**< Per port indication that data was dropped */
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|commit
range|:
literal|2
decl_stmt|;
comment|/**< Per port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_prt_info
name|cvmx_gmxx_rx_prt_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_prts  *  * GMX_RX_PRTS = Number of FIFOs to carve the RX buffer into  *  *  * Notes:  * GMX_RX_PRTS[PRTS] must be set to '1' in XAUI mode.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_prts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_prts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|prts
range|:
literal|3
decl_stmt|;
comment|/**< In SGMII/1000Base-X mode, the RX buffer can be                                                          carved into several logical buffers depending on                                                          the number or implemented ports.                                                          0 or 1 port  = 512ticks / 4096bytes                                                          2 ports      = 256ticks / 2048bytes                                                          3 or 4 ports = 128ticks / 1024bytes */
else|#
directive|else
name|uint64_t
name|prts
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_prts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_prts
name|cvmx_gmxx_rx_prts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_tx_status  *  * GMX_RX_TX_STATUS = GMX RX/TX Status  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_tx_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_tx_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|3
decl_stmt|;
comment|/**< Transmit data since last read */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx
range|:
literal|3
decl_stmt|;
comment|/**< Receive data since last read */
else|#
directive|else
name|uint64_t
name|rx
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_tx_status_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_tx_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_tx_status_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_tx_status
name|cvmx_gmxx_rx_tx_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_xaui_bad_col  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_xaui_bad_col
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Set when GMX_RX_INT_REG[PCTERR] is set.                                                          (XAUI mode only) */
name|uint64_t
name|state
range|:
literal|3
decl_stmt|;
comment|/**< When GMX_RX_INT_REG[PCTERR] is set, STATE will                                                          conatin the receive state at the time of the                                                          error.                                                          (XAUI mode only) */
name|uint64_t
name|lane_rxc
range|:
literal|4
decl_stmt|;
comment|/**< When GMX_RX_INT_REG[PCTERR] is set, LANE_RXC will                                                          conatin the XAUI column at the time of the error.                                                          (XAUI mode only) */
name|uint64_t
name|lane_rxd
range|:
literal|32
decl_stmt|;
comment|/**< When GMX_RX_INT_REG[PCTERR] is set, LANE_RXD will                                                          conatin the XAUI column at the time of the error.                                                          (XAUI mode only) */
else|#
directive|else
name|uint64_t
name|lane_rxd
range|:
literal|32
decl_stmt|;
name|uint64_t
name|lane_rxc
range|:
literal|4
decl_stmt|;
name|uint64_t
name|state
range|:
literal|3
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_bad_col_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_xaui_bad_col
name|cvmx_gmxx_rx_xaui_bad_col_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rx_xaui_ctl  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rx_xaui_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rx_xaui_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Link Status                                                          0=Link OK                                                          1=Local Fault                                                          2=Remote Fault                                                          3=Reserved                                                          (XAUI mode only) */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_rx_xaui_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rx_xaui_ctl
name|cvmx_gmxx_rx_xaui_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_rxaui_ctl  */
end_comment

begin_union
union|union
name|cvmx_gmxx_rxaui_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_rxaui_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|disparity
range|:
literal|1
decl_stmt|;
comment|/**< Selects which disparity calculation to use when                                                          combining or splitting the RXAUI lanes.                                                          0=Interleave lanes before PCS layer                                                            As described in the Dune Networks/Broadcom                                                            RXAUI v2.1 specification.                                                            (obeys 6.25GHz SERDES disparity)                                                          1=Interleave lanes after PCS layer                                                            As described in the Marvell RXAUI Interface                                                            specification.                                                            (does not obey 6.25GHz SERDES disparity)                                                          (RXAUI mode only) */
else|#
directive|else
name|uint64_t
name|disparity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_rxaui_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_rxaui_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_rxaui_ctl
name|cvmx_gmxx_rxaui_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_smac#  *  * GMX_SMAC = Packet SMAC  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_smacx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_smacx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|smac
range|:
literal|48
decl_stmt|;
comment|/**< The SMAC field is used for generating and                                                          accepting Control Pause packets */
else|#
directive|else
name|uint64_t
name|smac
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_smacx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_smacx
name|cvmx_gmxx_smacx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_soft_bist  *  * GMX_SOFT_BIST = Software BIST Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_soft_bist
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_soft_bist_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
comment|/**< Run BIST on all memories in the XAUI/RXAUI                                                          CLK domain */
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
comment|/**< Choose between full BIST and CLEAR bist                                                          0=Run full BIST                                                          1=Only run clear BIST */
else|#
directive|else
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_soft_bist_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_soft_bist_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_soft_bist_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_soft_bist_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_soft_bist_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_soft_bist
name|cvmx_gmxx_soft_bist_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_stat_bp  *  * GMX_STAT_BP = Number of cycles that the TX/Stats block has help up operation  *  *  * Notes:  * It has no relationship with the TX FIFO per se.  The TX engine sends packets  * from PKO and upon completion, sends a command to the TX stats block for an  * update based on the packet size.  The stats operation can take a few cycles -  * normally not enough to be visible considering the 64B min packet size that is  * ethernet convention.  *  * In the rare case in which SW attempted to schedule really, really, small packets  * or the sclk (6xxx) is running ass-slow, then the stats updates may not happen in  * real time and can back up the TX engine.  *  * This counter is the number of cycles in which the TX engine was stalled.  In  * normal operation, it should always be zeros.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_stat_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_stat_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
comment|/**< Current TX stats BP state                                                          When the TX stats machine cannot update the stats                                                          registers quickly enough, the machine has the                                                          ability to BP TX datapath.  This is a rare event                                                          and will not occur in normal operation.                                                          0 = no backpressure is applied                                                          1 = backpressure is applied to TX datapath to                                                              allow stat update operations to complete */
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of cycles that BP has been asserted                                                          Saturating counter */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_stat_bp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_stat_bp
name|cvmx_gmxx_stat_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tb_reg  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tb_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tb_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|wr_magic
range|:
literal|1
decl_stmt|;
comment|/**< Enter stats model magic mode */
else|#
directive|else
name|uint64_t
name|wr_magic
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tb_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tb_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tb_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tb_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tb_reg
name|cvmx_gmxx_tb_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_append  *  * GMX_TX_APPEND = Packet TX Append Control  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_append
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_append_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|force_fcs
range|:
literal|1
decl_stmt|;
comment|/**< Append the Ethernet FCS on each pause packet                                                          when FCS is clear.  Pause packets are normally                                                          padded to 60 bytes.  If GMX_TX_MIN_PKT[MIN_SIZE]                                                          exceeds 59, then FORCE_FCS will not be used. */
name|uint64_t
name|fcs
range|:
literal|1
decl_stmt|;
comment|/**< Append the Ethernet FCS on each packet */
name|uint64_t
name|pad
range|:
literal|1
decl_stmt|;
comment|/**< Append PAD bytes such that min sized */
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
comment|/**< Prepend the Ethernet preamble on each transfer                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, PREAMBLE                                                          must be zero. */
else|#
directive|else
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|force_fcs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_append_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_append
name|cvmx_gmxx_txx_append_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_burst  *  * GMX_TX_BURST = Packet TX Burst Counter  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_burst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_burst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|burst
range|:
literal|16
decl_stmt|;
comment|/**< Burst (refer to 802.3 to set correctly)                                                          Only valid for 1000Mbs half-duplex operation                                                           halfdup / 1000Mbs: 0x2000                                                           all other modes:   0x0                                                          (SGMII/1000Base-X only) */
else|#
directive|else
name|uint64_t
name|burst
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_burst_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_burst
name|cvmx_gmxx_txx_burst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_cbfc_xoff  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_cbfc_xoff
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|xoff
range|:
literal|16
decl_stmt|;
comment|/**< Which ports to backpressure                                                          Do not write in HiGig2 mode i.e. when                                                          GMX_TX_XAUI_CTL[HG_EN]=1 and                                                          GMX_RX_UDD_SKP[SKIP]=16. */
else|#
directive|else
name|uint64_t
name|xoff
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xoff_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_cbfc_xoff
name|cvmx_gmxx_txx_cbfc_xoff_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_cbfc_xon  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_cbfc_xon
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_cbfc_xon_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|xon
range|:
literal|16
decl_stmt|;
comment|/**< Which ports to stop backpressure                                                          Do not write in HiGig2 mode i.e. when                                                          GMX_TX_XAUI_CTL[HG_EN]=1 and                                                          GMX_RX_UDD_SKP[SKIP]=16. */
else|#
directive|else
name|uint64_t
name|xon
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_cbfc_xon_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_cbfc_xon
name|cvmx_gmxx_txx_cbfc_xon_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_clk  *  * Per Port  *  *  * GMX_TX_CLK = RGMII TX Clock Generation Register  *  * Notes:  * Programming Restrictions:  *  (1) In RGMII mode, if GMX_PRT_CFG[SPEED]==0, then CLK_CNT must be> 1.  *  (2) In MII mode, CLK_CNT == 1  *  (3) In RGMII or GMII mode, if CLK_CNT==0, Octeon will not generate a tx clock.  *  * RGMII Example:  *  Given a 125MHz PLL reference clock...  *   CLK_CNT ==  1 ==> 125.0MHz TXC clock period (8ns* 1)  *   CLK_CNT ==  5 ==>  25.0MHz TXC clock period (8ns* 5)  *   CLK_CNT == 50 ==>   2.5MHz TXC clock period (8ns*50)  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_clk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_clk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|clk_cnt
range|:
literal|6
decl_stmt|;
comment|/**< Controls the RGMII TXC frequency                                                          When PLL is used, TXC(phase) =                                                           spi4_tx_pll_ref_clk(period)/2*CLK_CNT                                                          When PLL bypass is used, TXC(phase) =                                                           spi4_tx_pll_ref_clk(period)*2*CLK_CNT                                                          NOTE: CLK_CNT==0 will not generate any clock                                                          if CLK_CNT> 1 if GMX_PRT_CFG[SPEED]==0 */
else|#
directive|else
name|uint64_t
name|clk_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_clk_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_clk
name|cvmx_gmxx_txx_clk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_ctl  *  * GMX_TX_CTL = TX Control register  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|xsdef_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the excessive deferral check for stats                                                          and interrupts                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the excessive collision check for stats                                                          and interrupts                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|xscol_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_ctl
name|cvmx_gmxx_txx_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_min_pkt  *  * GMX_TX_MIN_PKT = Packet TX Min Size Packet (PAD upto min size)  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_min_pkt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_min_pkt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|min_size
range|:
literal|8
decl_stmt|;
comment|/**< Min frame in bytes before the FCS is applied                                                          Padding is only appened when GMX_TX_APPEND[PAD]                                                          for the coresponding port is set.                                                          In SGMII mode, packets will be padded to                                                           MIN_SIZE+1. The reset value will pad to 60 bytes.                                                          In XAUI mode, packets will be padded to                                                           MIN(252,(MIN_SIZE+1& ~0x3))                                                          When GMX_TX_XAUI_CTL[HG_EN] is set, the HiGig                                                           header (12B or 16B) is normally added to the                                                           packet, so MIN_SIZE should be 59+12=71B for                                                           HiGig or 59+16=75B for HiGig2. */
else|#
directive|else
name|uint64_t
name|min_size
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_min_pkt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_min_pkt
name|cvmx_gmxx_txx_min_pkt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_pause_pkt_interval  *  * GMX_TX_PAUSE_PKT_INTERVAL = Packet TX Pause Packet transmission interval - how often PAUSE packets will be sent  *  *  * Notes:  * Choosing proper values of GMX_TX_PAUSE_PKT_TIME[TIME] and  * GMX_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system  * designer.  It is suggested that TIME be much greater than INTERVAL and  * GMX_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE  * count and then when the backpressure condition is lifted, a PAUSE packet  * with TIME==0 will be sent indicating that Octane is ready for additional  * data.  *  * If the system chooses to not set GMX_TX_PAUSE_ZERO[SEND], then it is  * suggested that TIME and INTERVAL are programmed such that they satisify the  * following rule...  *  *    INTERVAL<= TIME - (largest_pkt_size + IFG + pause_pkt_size)  *  * where largest_pkt_size is that largest packet that the system can send  * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size  * of the PAUSE packet (normally 64B).  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_pause_pkt_interval
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|16
decl_stmt|;
comment|/**< Arbitrate for a 802.3 pause packet, HiGig2 message,                                                          or CBFC pause packet every (INTERVAL*512)                                                          bit-times.                                                          Normally, 0< INTERVAL< GMX_TX_PAUSE_PKT_TIME                                                          INTERVAL=0, will only send a single PAUSE packet                                                          for each backpressure event */
else|#
directive|else
name|uint64_t
name|interval
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_interval_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_pause_pkt_interval
name|cvmx_gmxx_txx_pause_pkt_interval_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_pause_pkt_time  *  * GMX_TX_PAUSE_PKT_TIME = Packet TX Pause Packet pause_time field  *  *  * Notes:  * Choosing proper values of GMX_TX_PAUSE_PKT_TIME[TIME] and  * GMX_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system  * designer.  It is suggested that TIME be much greater than INTERVAL and  * GMX_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE  * count and then when the backpressure condition is lifted, a PAUSE packet  * with TIME==0 will be sent indicating that Octane is ready for additional  * data.  *  * If the system chooses to not set GMX_TX_PAUSE_ZERO[SEND], then it is  * suggested that TIME and INTERVAL are programmed such that they satisify the  * following rule...  *  *    INTERVAL<= TIME - (largest_pkt_size + IFG + pause_pkt_size)  *  * where largest_pkt_size is that largest packet that the system can send  * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size  * of the PAUSE packet (normally 64B).  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_pause_pkt_time
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< The pause_time field placed in outbnd 802.3 pause                                                          packets, HiGig2 messages, or CBFC pause packets.                                                          pause_time is in 512 bit-times                                                          Normally, TIME> GMX_TX_PAUSE_PKT_INTERVAL */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_pkt_time_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_pause_pkt_time
name|cvmx_gmxx_txx_pause_pkt_time_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_pause_togo  *  * GMX_TX_PAUSE_TOGO = Packet TX Amount of time remaining to backpressure  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_pause_togo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_pause_togo_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|msg_time
range|:
literal|16
decl_stmt|;
comment|/**< Amount of time remaining to backpressure                                                          From the higig2 physical message pause timer                                                          (only valid on port0) */
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< Amount of time remaining to backpressure                                                          From the standard 802.3 pause timer */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|msg_time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< Amount of time remaining to backpressure */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_togo_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_pause_togo
name|cvmx_gmxx_txx_pause_togo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_pause_zero  *  * GMX_TX_PAUSE_ZERO = Packet TX Amount of time remaining to backpressure  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_pause_zero
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_pause_zero_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|send
range|:
literal|1
decl_stmt|;
comment|/**< When backpressure condition clear, send PAUSE                                                          packet with pause_time of zero to enable the                                                          channel */
else|#
directive|else
name|uint64_t
name|send
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pause_zero_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_pause_zero
name|cvmx_gmxx_txx_pause_zero_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_pipe  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_pipe
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_pipe_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|ign_bp
range|:
literal|1
decl_stmt|;
comment|/**< When set, GMX will not throttle the TX machines                                                          if the PIPE return FIFO fills up.                                                          IGN_BP should be clear in normal operation. */
name|uint64_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|5
decl_stmt|;
comment|/**< Number of pipes this port|channel supports.                                                          In SGMII mode, each port binds to one pipe.                                                          In XAUI/RXAUI mode, the port can bind upto 16                                                          consecutive pipes.                                                          SGMII      mode, NUMP = 0 or 1.                                                          XAUI/RXAUI mode, NUMP = 0 or 1-16.                                                          0 = Disabled */
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
comment|/**< When NUMP is non-zero, indicates the base pipe                                                          number this port|channel will accept.                                                          This port will accept pko packets from pipes in                                                          the range of:                                                            BASE .. (BASE+(NUMP-1))                                                          BASE and NUMP must be constrained such that                                                            1) BASE+(NUMP-1)< 127                                                            2) Each used PKO pipe must map to exactly                                                               one port|channel                                                            3) The pipe ranges must be consistent with                                                               the PKO configuration. */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint64_t
name|ign_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_pipe_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_pipe_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_pipe
name|cvmx_gmxx_txx_pipe_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_sgmii_ctl  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_sgmii_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|align
range|:
literal|1
decl_stmt|;
comment|/**< Align the transmission to even cycles                                                           Recommended value is:                                                             ALIGN = !GMX_TX_APPEND[PREAMBLE]                                                           (See the Transmit Conversion to Code groups                                                           section in the SGMII Interface chapter of the                                                           HRM for a complete discussion)                                                           0 = Data can be sent on any cycle                                                              In this mode, the interface will function at                                                              maximum bandwidth. It is possible to for the                                                              TX PCS machine to drop first byte of the TX                                                              frame.  When GMX_TX_APPEND[PREAMBLE] is set,                                                              the first byte will be a preamble byte which                                                              can be dropped to compensate for an extended                                                              IPG.                                                           1 = Data will only be sent on even cycles.                                                              In this mode, there can be bandwidth                                                              implications when sending odd-byte packets as                                                              the IPG can extend an extra cycle.                                                              There will be no loss of data.                                                           (SGMII/1000Base-X only) */
else|#
directive|else
name|uint64_t
name|align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_sgmii_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_sgmii_ctl
name|cvmx_gmxx_txx_sgmii_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_slot  *  * GMX_TX_SLOT = Packet TX Slottime Counter  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_slot
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_slot_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|slot
range|:
literal|10
decl_stmt|;
comment|/**< Slottime (refer to 802.3 to set correctly)                                                          10/100Mbs: 0x40                                                          1000Mbs:   0x200                                                          (SGMII/1000Base-X only) */
else|#
directive|else
name|uint64_t
name|slot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_slot_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_slot
name|cvmx_gmxx_txx_slot_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_soft_pause  *  * GMX_TX_SOFT_PAUSE = Packet TX Software Pause  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_soft_pause
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_soft_pause_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< Back off the TX bus for (TIME*512) bit-times */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_soft_pause_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_soft_pause
name|cvmx_gmxx_txx_soft_pause_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat0  *  * GMX_TX_STAT0 = GMX_TX_STATS_XSDEF / GMX_TX_STATS_XSCOL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|xsdef
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets dropped (never successfully                                                          sent) due to excessive deferal                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets dropped (never successfully                                                          sent) due to excessive collision.  Defined by                                                          GMX_TX_COL_ATTEMPT[LIMIT].                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|xscol
range|:
literal|32
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat0
name|cvmx_gmxx_txx_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat1  *  * GMX_TX_STAT1 = GMX_TX_STATS_SCOL  / GMX_TX_STATS_MCOL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|scol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with a single collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|mcol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with multiple collisions                                                          but< GMX_TX_COL_ATTEMPT[LIMIT].                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|mcol
range|:
literal|32
decl_stmt|;
name|uint64_t
name|scol
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat1
name|cvmx_gmxx_txx_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat2  *  * GMX_TX_STAT2 = GMX_TX_STATS_OCTS  *  *  * Notes:  * - Octect counts are the sum of all data transmitted on the wire including  *   packet data, pad bytes, fcs bytes, pause bytes, and jam bytes.  The octect  *   counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
comment|/**< Number of total octets sent on the interface.                                                          Does not count octets from frames that were                                                          truncated due to collisions in halfdup mode. */
else|#
directive|else
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat2
name|cvmx_gmxx_txx_stat2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat3  *  * GMX_TX_STAT3 = GMX_TX_STATS_PKTS  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
comment|/**< Number of total frames sent on the interface.                                                          Does not count frames that were truncated due to                                                           collisions in halfdup mode. */
else|#
directive|else
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat3
name|cvmx_gmxx_txx_stat3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat4  *  * GMX_TX_STAT4 = GMX_TX_STATS_HIST1 (64) / GMX_TX_STATS_HIST0 (<64)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|hist1
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of 64. */
name|uint64_t
name|hist0
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count                                                          of< 64. */
else|#
directive|else
name|uint64_t
name|hist0
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist1
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat4_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat4
name|cvmx_gmxx_txx_stat4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat5  *  * GMX_TX_STAT5 = GMX_TX_STATS_HIST3 (128- 255) / GMX_TX_STATS_HIST2 (65- 127)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|hist3
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          128 - 255. */
name|uint64_t
name|hist2
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          65 - 127. */
else|#
directive|else
name|uint64_t
name|hist2
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist3
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat5_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat5
name|cvmx_gmxx_txx_stat5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat6  *  * GMX_TX_STAT6 = GMX_TX_STATS_HIST5 (512-1023) / GMX_TX_STATS_HIST4 (256-511)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat6_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|hist5
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          512 - 1023. */
name|uint64_t
name|hist4
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          256 - 511. */
else|#
directive|else
name|uint64_t
name|hist4
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist5
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat6_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat6
name|cvmx_gmxx_txx_stat6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat7  *  * GMX_TX_STAT7 = GMX_TX_STATS_HIST7 (1024-1518) / GMX_TX_STATS_HIST6 (>1518)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat7_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|hist7
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count                                                          of> 1518. */
name|uint64_t
name|hist6
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          1024 - 1518. */
else|#
directive|else
name|uint64_t
name|hist6
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist7
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat7_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat7
name|cvmx_gmxx_txx_stat7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat8  *  * GMX_TX_STAT8 = GMX_TX_STATS_MCST  / GMX_TX_STATS_BCST  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Note, GMX determines if the packet is MCST or BCST from the DMAC of the  *   packet.  GMX assumes that the DMAC lies in the first 6 bytes of the packet  *   as per the 802.3 frame definition.  If the system requires additional data  *   before the L2 header, then the MCST and BCST counters may not reflect  *   reality and should be ignored by software.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat8
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat8_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent to multicast DMAC.                                                          Does not include BCST packets. */
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent to broadcast DMAC.                                                          Does not include MCST packets. */
else|#
directive|else
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat8_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat8
name|cvmx_gmxx_txx_stat8_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stat9  *  * GMX_TX_STAT9 = GMX_TX_STATS_UNDFLW / GMX_TX_STATS_CTL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stat9
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stat9_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|undflw
range|:
literal|32
decl_stmt|;
comment|/**< Number of underflow packets */
name|uint64_t
name|ctl
range|:
literal|32
decl_stmt|;
comment|/**< Number of Control packets (PAUSE flow control)                                                          generated by GMX.  It does not include control                                                          packets forwarded or generated by the PP's.                                                          CTL will count the number of generated PFC frames.                                                          CTL will not track the number of generated HG2                                                          messages. */
else|#
directive|else
name|uint64_t
name|ctl
range|:
literal|32
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stat9_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stat9
name|cvmx_gmxx_txx_stat9_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_stats_ctl  *  * GMX_TX_STATS_CTL = TX Stats Control register  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_stats_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_stats_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
comment|/**< Stats registers will clear on reads */
else|#
directive|else
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_stats_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_stats_ctl
name|cvmx_gmxx_txx_stats_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx#_thresh  *  * Per Port  *  *  * GMX_TX_THRESH = Packet TX Threshold  *  * Notes:  * In XAUI mode, prt0 is used for checking.  Since XAUI mode uses a single TX FIFO and is higher data rate, recommended value is 0x100.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_txx_thresh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_thresh_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|10
decl_stmt|;
comment|/**< Number of 16B ticks to accumulate in the TX FIFO                                                          before sending on the packet interface                                                          This register should be large enough to prevent                                                          underflow on the packet interface and must never                                                          be set to zero.  This register cannot exceed the                                                          the TX FIFO depth which is...                                                           GMX_TX_PRTS==0,1:  CNT MAX = 0x100                                                           GMX_TX_PRTS==2  :  CNT MAX = 0x080                                                           GMX_TX_PRTS==3,4:  CNT MAX = 0x040 */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_txx_thresh_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of 16B ticks to accumulate in the TX FIFO                                                          before sending on the RGMII interface                                                          This register should be large enough to prevent                                                          underflow on the RGMII interface and must never                                                          be set below 4.  This register cannot exceed the                                                          the TX FIFO depth which is 64 16B entries. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_txx_thresh_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_txx_thresh_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|9
decl_stmt|;
comment|/**< Number of 16B ticks to accumulate in the TX FIFO                                                           before sending on the RGMII interface                                                           This register should be large enough to prevent                                                           underflow on the RGMII interface and must never                                                           be set to zero.  This register cannot exceed the                                                           the TX FIFO depth which is...                                                            GMX_TX_PRTS==0,1:  CNT MAX = 0x100                                                            GMX_TX_PRTS==2  :  CNT MAX = 0x080                                                            GMX_TX_PRTS==3,4:  CNT MAX = 0x040                                                          (PASS2 expands from 6 to 9 bits) */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_txx_thresh_cn38xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_txx_thresh
name|cvmx_gmxx_txx_thresh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_bp  *  * GMX_TX_BP = Packet Interface TX BackPressure Register  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of BP is used.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
comment|/**< Per port BackPressure status                                                          0=Port is available                                                          1=Port should be back pressured */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_bp_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|3
decl_stmt|;
comment|/**< Per port BackPressure status                                                          0=Port is available                                                          1=Port should be back pressured */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_tx_bp_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_bp_s
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_bp_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
comment|/**< Per port BackPressure status                                                          0=Port is available                                                          1=Port should be back pressured */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_bp
name|cvmx_gmxx_tx_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_clk_msk#  *  * GMX_TX_CLK_MSK = GMX Clock Select  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_clk_mskx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_clk_mskx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|msk
range|:
literal|1
decl_stmt|;
comment|/**< Write this bit to a 1 when switching clks */
else|#
directive|else
name|uint64_t
name|msk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_clk_mskx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_clk_mskx_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_clk_mskx
name|cvmx_gmxx_tx_clk_mskx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_col_attempt  *  * GMX_TX_COL_ATTEMPT = Packet TX collision attempts before dropping frame  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_col_attempt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_col_attempt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|limit
range|:
literal|5
decl_stmt|;
comment|/**< Collision Attempts                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|limit
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_col_attempt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_col_attempt
name|cvmx_gmxx_tx_col_attempt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_corrupt  *  * GMX_TX_CORRUPT = TX - Corrupt TX packets with the ERR bit set  *  *  * Notes:  * Packets sent from PKO with the ERR wire asserted will be corrupted by  * the transmitter if CORRUPT[prt] is set (XAUI uses prt==0).  *  * Corruption means that GMX will send a bad FCS value.  If GMX_TX_APPEND[FCS]  * is clear then no FCS is sent and the GMX cannot corrupt it.  The corrupt FCS  * value is 0xeeeeeeee for SGMII/1000Base-X and 4 bytes of the error  * propagation code in XAUI mode.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_corrupt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_corrupt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|corrupt
range|:
literal|4
decl_stmt|;
comment|/**< Per port error propagation                                                          0=Never corrupt packets                                                          1=Corrupt packets with ERR */
else|#
directive|else
name|uint64_t
name|corrupt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_corrupt_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|corrupt
range|:
literal|3
decl_stmt|;
comment|/**< Per port error propagation                                                          0=Never corrupt packets                                                          1=Corrupt packets with ERR */
else|#
directive|else
name|uint64_t
name|corrupt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_tx_corrupt_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_corrupt_s
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_corrupt_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|corrupt
range|:
literal|2
decl_stmt|;
comment|/**< Per port error propagation                                                          0=Never corrupt packets                                                          1=Corrupt packets with ERR */
else|#
directive|else
name|uint64_t
name|corrupt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_corrupt
name|cvmx_gmxx_tx_corrupt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_hg2_reg1  *  * Notes:  * The TX_XOF[15:0] field in GMX(0)_TX_HG2_REG1 and the TX_XON[15:0] field in  * GMX(0)_TX_HG2_REG2 register map to the same 16 physical flops. When written with address of  * GMX(0)_TX_HG2_REG1, it will exhibit write 1 to set behavior and when written with address of  * GMX(0)_TX_HG2_REG2, it will exhibit write 1 to clear behavior.  * For reads, either address will return the $GMX(0)_TX_HG2_REG1 values.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_hg2_reg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_hg2_reg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|tx_xof
range|:
literal|16
decl_stmt|;
comment|/**< TX HiGig2 message for logical link pause when any                                                          bit value changes                                                           Only write in HiGig2 mode i.e. when                                                           GMX_TX_XAUI_CTL[HG_EN]=1 and                                                           GMX_RX_UDD_SKP[SKIP]=16. */
else|#
directive|else
name|uint64_t
name|tx_xof
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_hg2_reg1
name|cvmx_gmxx_tx_hg2_reg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_hg2_reg2  *  * Notes:  * The TX_XOF[15:0] field in GMX(0)_TX_HG2_REG1 and the TX_XON[15:0] field in  * GMX(0)_TX_HG2_REG2 register map to the same 16 physical flops. When written with address  of  * GMX(0)_TX_HG2_REG1, it will exhibit write 1 to set behavior and when written with address of  * GMX(0)_TX_HG2_REG2, it will exhibit write 1 to clear behavior.  * For reads, either address will return the $GMX(0)_TX_HG2_REG1 values.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_hg2_reg2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_hg2_reg2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|tx_xon
range|:
literal|16
decl_stmt|;
comment|/**< TX HiGig2 message for logical link pause when any                                                          bit value changes                                                           Only write in HiGig2 mode i.e. when                                                           GMX_TX_XAUI_CTL[HG_EN]=1 and                                                           GMX_RX_UDD_SKP[SKIP]=16. */
else|#
directive|else
name|uint64_t
name|tx_xon
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_hg2_reg2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_hg2_reg2
name|cvmx_gmxx_tx_hg2_reg2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_ifg  *  * GMX_TX_IFG = Packet TX Interframe Gap  *  *  * Notes:  * * Programming IFG1 and IFG2.  *  * For 10/100/1000Mbs half-duplex systems that require IEEE 802.3  * compatibility, IFG1 must be in the range of 1-8, IFG2 must be in the range  * of 4-12, and the IFG1+IFG2 sum must be 12.  *  * For 10/100/1000Mbs full-duplex systems that require IEEE 802.3  * compatibility, IFG1 must be in the range of 1-11, IFG2 must be in the range  * of 1-11, and the IFG1+IFG2 sum must be 12.  *  * For XAUI/10Gbs systems that require IEEE 802.3 compatibility, the  * IFG1+IFG2 sum must be 12.  IFG1[1:0] and IFG2[1:0] must be zero.  *  * For all other systems, IFG1 and IFG2 can be any value in the range of  * 1-15.  Allowing for a total possible IFG sum of 2-30.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_ifg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_ifg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ifg2
range|:
literal|4
decl_stmt|;
comment|/**< 1/3 of the interframe gap timing (in IFG2*8 bits)                                                          If CRS is detected during IFG2, then the                                                          interFrameSpacing timer is not reset and a frame                                                          is transmited once the timer expires. */
name|uint64_t
name|ifg1
range|:
literal|4
decl_stmt|;
comment|/**< 2/3 of the interframe gap timing (in IFG1*8 bits)                                                          If CRS is detected during IFG1, then the                                                          interFrameSpacing timer is reset and a frame is                                                          not transmited. */
else|#
directive|else
name|uint64_t
name|ifg1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ifg2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ifg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_ifg
name|cvmx_gmxx_tx_ifg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_int_en  *  * GMX_TX_INT_EN = Interrupt Enable  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of UNDFLW is used.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI link status changed - this denotes a change                                                          to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI mode only) */
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|3
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (PASS3 only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from NCB Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from NCB Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_gmxx_tx_int_en_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_en_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_en_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_en_s
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_en_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI/RXAUI link status changed - this denotes a                                                          change to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI/RXAUI mode only) */
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|pko_nxp
range|:
literal|1
decl_stmt|;
comment|/**< Port pipe out-of-range from PKO Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_en_cn68xx
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_en_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI link status changed - this denotes a change                                                          to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI mode only) */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_int_en
name|cvmx_gmxx_tx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_int_reg  *  * GMX_TX_INT_REG = Interrupt Register  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of UNDFLW is used.  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI link status changed - this denotes a change                                                          to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI mode only) */
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|3
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (PASS3 only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from NCB Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral (RGMII/halfdup mode only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions (RGMII/halfdup mode only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow (RGMII mode only) */
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from NCB Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_int_reg_s
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI/RXAUI link status changed - this denotes ae                                                          change to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI/RXAUI mode only) */
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|pko_nxp
range|:
literal|1
decl_stmt|;
comment|/**< Port pipe out-of-range from PKO Interface */
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|4
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_gmxx_tx_int_reg_cn68xx
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_int_reg_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
comment|/**< XAUI link status changed - this denotes a change                                                          to GMX_RX_XAUI_CTL[STATUS]                                                          (XAUI mode only) */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions                                                          (SGMII/1000Base-X half-duplex only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xchange
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_int_reg
name|cvmx_gmxx_tx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_jam  *  * GMX_TX_JAM = Packet TX Jam Pattern  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_jam
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_jam_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|jam
range|:
literal|8
decl_stmt|;
comment|/**< Jam pattern                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|jam
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_jam_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_jam
name|cvmx_gmxx_tx_jam_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_lfsr  *  * GMX_TX_LFSR = LFSR used to implement truncated binary exponential backoff  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_lfsr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_lfsr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|lfsr
range|:
literal|16
decl_stmt|;
comment|/**< The current state of the LFSR used to feed random                                                          numbers to compute truncated binary exponential                                                          backoff.                                                          (SGMII/1000Base-X half-duplex only) */
else|#
directive|else
name|uint64_t
name|lfsr
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_lfsr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_lfsr
name|cvmx_gmxx_tx_lfsr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_ovr_bp  *  * GMX_TX_OVR_BP = Packet Interface TX Override BackPressure  *  *  * Notes:  * In XAUI mode, only the lsb (corresponding to port0) of EN, BP, and IGN_FULL are used.  *  * GMX*_TX_OVR_BP[EN<0>] must be set to one and GMX*_TX_OVR_BP[BP<0>] must be cleared to zero  * (to forcibly disable HW-automatic 802.3 pause packet generation) with the HiGig2 Protocol  * when GMX*_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is indicated by  * GMX*_TX_XAUI_CTL[HG_EN]=1 and GMX*_RX0_UDD_SKP[LEN]=16.) HW can only auto-generate backpressure  * through HiGig2 messages (optionally, when GMX*_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2  * protocol.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_ovr_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_ovr_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|tx_prt_bp
range|:
literal|16
decl_stmt|;
comment|/**< Per port BP sent to PKO                                                          0=Port is available                                                          1=Port should be back pressured                                                          TX_PRT_BP should not be set until                                                          GMX_INF_MODE[EN] has been enabled */
name|uint64_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
name|uint64_t
name|en
range|:
literal|4
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
comment|/**< Per port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|ign_full
range|:
literal|4
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|en
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
name|uint64_t
name|tx_prt_bp
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_ovr_bp_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|en
range|:
literal|3
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|3
decl_stmt|;
comment|/**< Per port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ign_full
range|:
literal|3
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_ovr_bp_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|en
range|:
literal|4
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
comment|/**< Per port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|ign_full
range|:
literal|4
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|en
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_ovr_bp_s
name|cn68xxp1
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_ovr_bp_cnf71xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|tx_prt_bp
range|:
literal|16
decl_stmt|;
comment|/**< Per port BP sent to PKO                                                          0=Port is available                                                          1=Port should be back pressured                                                          TX_PRT_BP should not be set until                                                          GMX_INF_MODE[EN] has been enabled */
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|en
range|:
literal|2
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
comment|/**< Per port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ign_full
range|:
literal|2
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|tx_prt_bp
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cnf71xx
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_ovr_bp
name|cvmx_gmxx_tx_ovr_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_pause_pkt_dmac  *  * GMX_TX_PAUSE_PKT_DMAC = Packet TX Pause Packet DMAC field  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_pause_pkt_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|dmac
range|:
literal|48
decl_stmt|;
comment|/**< The DMAC field placed is outbnd pause pkts */
else|#
directive|else
name|uint64_t
name|dmac
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_dmac_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_pause_pkt_dmac
name|cvmx_gmxx_tx_pause_pkt_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_pause_pkt_type  *  * GMX_TX_PAUSE_PKT_TYPE = Packet Interface TX Pause Packet TYPE field  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_pause_pkt_type
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
comment|/**< The TYPE field placed is outbnd pause pkts */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_pause_pkt_type_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_pause_pkt_type
name|cvmx_gmxx_tx_pause_pkt_type_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_prts  *  * Common  *  *  * GMX_TX_PRTS = TX Ports  *  * Notes:  * * The value programmed for PRTS is the number of the highest architected  * port number on the interface, plus 1.  For example, if port 2 is the  * highest architected port, then the programmed value should be 3 since  * there are 3 ports in the system - 0, 1, and 2.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_prts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_prts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|prts
range|:
literal|5
decl_stmt|;
comment|/**< Number of ports allowed on the interface                                                          (SGMII/1000Base-X only) */
else|#
directive|else
name|uint64_t
name|prts
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_prts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_prts
name|cvmx_gmxx_tx_prts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_spi_ctl  *  * GMX_TX_SPI_CTL = Spi4 TX ModesSpi4  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_spi_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_spi_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|tpa_clr
range|:
literal|1
decl_stmt|;
comment|/**< TPA Clear Mode                                                          Clear credit counter when satisifed status */
name|uint64_t
name|cont_pkt
range|:
literal|1
decl_stmt|;
comment|/**< Contiguous Packet Mode                                                          Finish one packet before switching to another                                                          Cannot be set in Spi4 pass-through mode */
else|#
directive|else
name|uint64_t
name|cont_pkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tpa_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_spi_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_spi_ctl
name|cvmx_gmxx_tx_spi_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_spi_drain  *  * GMX_TX_SPI_DRAIN = Drain out Spi TX FIFO  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_spi_drain
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_spi_drain_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|drain
range|:
literal|16
decl_stmt|;
comment|/**< Per port drain control                                                          0=Normal operation                                                          1=GMX TX will be popped, but no valid data will                                                            be sent to SPX.  Credits are correctly returned                                                            to PKO.  STX_IGN_CAL should be set to ignore                                                            TPA and not stall due to back-pressure.                                                          (PASS3 only) */
else|#
directive|else
name|uint64_t
name|drain
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_spi_drain_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_drain_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_drain_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_spi_drain
name|cvmx_gmxx_tx_spi_drain_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_spi_max  *  * GMX_TX_SPI_MAX = RGMII TX Spi4 MAX  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_spi_max
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_spi_max_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|slice
range|:
literal|7
decl_stmt|;
comment|/**< Number of 16B blocks to transmit in a burst before                                                          switching to the next port. SLICE does not always                                                          limit the burst length transmitted by OCTEON.                                                          Depending on the traffic pattern and                                                          GMX_TX_SPI_ROUND programming, the next port could                                                          be the same as the current port. In this case,                                                          OCTEON may merge multiple sub-SLICE bursts into                                                          one contiguous burst that is longer than SLICE                                                          (as long as the burst does not cross a packet                                                          boundary).                                                          SLICE must be programmed to be>=                                                            GMX_TX_SPI_THRESH[THRESH]                                                          If SLICE==0, then the transmitter will tend to                                                          send the complete packet. The port will only                                                          switch if credits are exhausted or PKO cannot                                                          keep up.                                                          (90nm ONLY) */
name|uint64_t
name|max2
range|:
literal|8
decl_stmt|;
comment|/**< MAX2 (per Spi4.2 spec) */
name|uint64_t
name|max1
range|:
literal|8
decl_stmt|;
comment|/**< MAX1 (per Spi4.2 spec)                                                          MAX1>= GMX_TX_SPI_THRESH[THRESH] */
else|#
directive|else
name|uint64_t
name|max1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|max2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|slice
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_gmxx_tx_spi_max_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|max2
range|:
literal|8
decl_stmt|;
comment|/**< MAX2 (per Spi4.2 spec) */
name|uint64_t
name|max1
range|:
literal|8
decl_stmt|;
comment|/**< MAX1 (per Spi4.2 spec)                                                          MAX1>= GMX_TX_SPI_THRESH[THRESH] */
else|#
directive|else
name|uint64_t
name|max1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|max2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_gmxx_tx_spi_max_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_max_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_max_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_spi_max
name|cvmx_gmxx_tx_spi_max_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_spi_round#  *  * GMX_TX_SPI_ROUND = Controls SPI4 TX Arbitration  *  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_spi_roundx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_spi_roundx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|round
range|:
literal|16
decl_stmt|;
comment|/**< Which Spi ports participate in each arbitration                                                           round.  Each bit corresponds to a spi port                                                          - 0: this port will arb in this round                                                          - 1: this port will not arb in this round                                                           (90nm ONLY) */
else|#
directive|else
name|uint64_t
name|round
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_spi_roundx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_roundx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_spi_roundx
name|cvmx_gmxx_tx_spi_roundx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_spi_thresh  *  * GMX_TX_SPI_THRESH = RGMII TX Spi4 Transmit Threshold  *  *  * Notes:  * Note: zero will map to 0x20  *  * This will normally creates Spi4 traffic bursts at least THRESH in length.  * If dclk> eclk, then this rule may not always hold and Octeon may split  * transfers into smaller bursts - some of which could be as short as 16B.  * Octeon will never violate the Spi4.2 spec and send a non-EOP burst that is  * not a multiple of 16B.  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_spi_thresh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_spi_thresh_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|thresh
range|:
literal|6
decl_stmt|;
comment|/**< Transmit threshold in 16B blocks - cannot be zero                                                          THRESH<= TX_FIFO size   (in non-passthrough mode)                                                          THRESH<= TX_FIFO size-2 (in passthrough mode)                                                          THRESH<= GMX_TX_SPI_MAX[MAX1]                                                          THRESH<= GMX_TX_SPI_MAX[MAX2], if not then is it                                                           possible for Octeon to send a Spi4 data burst of                                                           MAX2<= burst<= THRESH 16B ticks                                                          GMX_TX_SPI_MAX[SLICE] must be programmed to be>=                                                            THRESH */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_spi_thresh_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_thresh_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_thresh_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_spi_thresh_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_spi_thresh
name|cvmx_gmxx_tx_spi_thresh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_tx_xaui_ctl  */
end_comment

begin_union
union|union
name|cvmx_gmxx_tx_xaui_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_tx_xaui_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|hg_pause_hgi
range|:
literal|2
decl_stmt|;
comment|/**< HGI Field for HW generated HiGig pause packets                                                          (XAUI mode only) */
name|uint64_t
name|hg_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable HiGig Mode                                                          When HG_EN is set and GMX_RX_UDD_SKP[SKIP]=12                                                           the interface is in HiGig/HiGig+ mode and the                                                           following must be set:                                                           GMX_RX_FRM_CTL[PRE_CHK] == 0                                                           GMX_RX_UDD_SKP[FCSSEL] == 0                                                           GMX_RX_UDD_SKP[SKIP] == 12                                                           GMX_TX_APPEND[PREAMBLE] == 0                                                          When HG_EN is set and GMX_RX_UDD_SKP[SKIP]=16                                                           the interface is in HiGig2 mode and the                                                           following must be set:                                                           GMX_RX_FRM_CTL[PRE_CHK] == 0                                                           GMX_RX_UDD_SKP[FCSSEL] == 0                                                           GMX_RX_UDD_SKP[SKIP] == 16                                                           GMX_TX_APPEND[PREAMBLE] == 0                                                           GMX_PRT0_CBFC_CTL[RX_EN] == 0                                                           GMX_PRT0_CBFC_CTL[TX_EN] == 0                                                          (XAUI mode only) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ls_byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass the link status as determined by the XGMII                                                          receiver and set the link status of the                                                          transmitter to LS.                                                          (XAUI mode only) */
name|uint64_t
name|ls
range|:
literal|2
decl_stmt|;
comment|/**< Link Status                                                          0 = Link Ok                                                              Link runs normally. RS passes MAC data to PCS                                                          1 = Local Fault                                                              RS layer sends continuous remote fault                                                               sequences.                                                          2 = Remote Fault                                                              RS layer sends continuous idles sequences                                                          3 = Link Drain                                                              RS layer drops full packets to allow GMX and                                                               PKO to drain their FIFOs                                                          (XAUI mode only) */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|uni_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable Unidirectional Mode (IEEE Clause 66)                                                          (XAUI mode only) */
name|uint64_t
name|dic_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable the deficit idle counter for IFG averaging                                                          (XAUI mode only) */
else|#
directive|else
name|uint64_t
name|dic_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uni_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ls
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ls_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hg_pause_hgi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_tx_xaui_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_tx_xaui_ctl
name|cvmx_gmxx_tx_xaui_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_gmx#_xaui_ext_loopback  */
end_comment

begin_union
union|union
name|cvmx_gmxx_xaui_ext_loopback
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_gmxx_xaui_ext_loopback_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Loopback enable                                                          Puts the packet interface in external loopback                                                          mode on the XAUI bus in which the RX lines are                                                          reflected on the TX lines.                                                          (XAUI mode only) */
name|uint64_t
name|thresh
range|:
literal|4
decl_stmt|;
comment|/**< Threshhold on the TX FIFO                                                          SW must only write the typical value.  Any other                                                          value will cause loopback mode not to function                                                          correctly.                                                          (XAUI mode only) */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_gmxx_xaui_ext_loopback_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_gmxx_xaui_ext_loopback
name|cvmx_gmxx_xaui_ext_loopback_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

