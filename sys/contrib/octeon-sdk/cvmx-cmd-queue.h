begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Support functions for managing command queues used for  * various hardware blocks.  *  * The common command queue infrastructure abstracts out the  * software necessary for adding to Octeon's chained queue  * structures. These structures are used for commands to the  * PKO, ZIP, DFA, RAID, and DMA engine blocks. Although each  * hardware unit takes commands and CSRs of different types,  * they all use basic linked command buffers to store the  * pending request. In general, users of the CVMX API don't  * call cvmx-cmd-queue functions directly. Instead the hardware  * unit specific wrapper should be used. The wrappers perform  * unit specific validation and CSR writes to submit the  * commands.  *  * Even though most software will never directly interact with  * cvmx-cmd-queue, knowledge of its internal workings can help  * in diagnosing performance problems and help with debugging.  *  * Command queue pointers are stored in a global named block  * called "cvmx_cmd_queues". Except for the PKO queues, each  * hardware queue is stored in its own cache line to reduce SMP  * contention on spin locks. The PKO queues are stored such that  * every 16th queue is next to each other in memory. This scheme  * allows for queues being in separate cache lines when there  * are low number of queues per port. With 16 queues per port,  * the first queue for each port is in the same cache area. The  * second queues for each port are in another area, etc. This  * allows software to implement very efficient lockless PKO with  * 16 queues per port using a minimum of cache lines per core.  * All queues for a given core will be isolated in the same  * cache area.  *  * In addition to the memory pointer layout, cvmx-cmd-queue  * provides an optimized fair ll/sc locking mechanism for the  * queues. The lock uses a "ticket / now serving" model to  * maintain fair order on contended locks. In addition, it uses  * predicted locking time to limit cache contention. When a core  * know it must wait in line for a lock, it spins on the  * internal cycle counter to completely eliminate any causes of  * bus traffic.  *  *<hr> $Revision: 50049 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_CMD_QUEUE_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_CMD_QUEUE_H__
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * By default we disable the max depth support. Most programs  * don't use it and it slows down the command queue processing  * significantly.  */
ifndef|#
directive|ifndef
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
define|#
directive|define
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
value|0
endif|#
directive|endif
comment|/**  * Enumeration representing all hardware blocks that use command  * queues. Each hardware block has up to 65536 sub identifiers for  * multiple command queues. Not all chips support all hardware  * units.  */
typedef|typedef
enum|enum
block|{
name|CVMX_CMD_QUEUE_PKO_BASE
init|=
literal|0x00000
block|,
define|#
directive|define
name|CVMX_CMD_QUEUE_PKO
parameter_list|(
name|queue
parameter_list|)
value|((cvmx_cmd_queue_id_t)(CVMX_CMD_QUEUE_PKO_BASE + (0xffff&(queue))))
name|CVMX_CMD_QUEUE_ZIP
init|=
literal|0x10000
block|,
name|CVMX_CMD_QUEUE_DFA
init|=
literal|0x20000
block|,
name|CVMX_CMD_QUEUE_RAID
init|=
literal|0x30000
block|,
name|CVMX_CMD_QUEUE_DMA_BASE
init|=
literal|0x40000
block|,
define|#
directive|define
name|CVMX_CMD_QUEUE_DMA
parameter_list|(
name|queue
parameter_list|)
value|((cvmx_cmd_queue_id_t)(CVMX_CMD_QUEUE_DMA_BASE + (0xffff&(queue))))
name|CVMX_CMD_QUEUE_END
init|=
literal|0x50000
block|, }
name|cvmx_cmd_queue_id_t
typedef|;
comment|/**  * Command write operations can fail if the command queue needs  * a new buffer and the associated FPA pool is empty. It can also  * fail if the number of queued command words reaches the maximum  * set at initialization.  */
typedef|typedef
enum|enum
block|{
name|CVMX_CMD_QUEUE_SUCCESS
init|=
literal|0
block|,
name|CVMX_CMD_QUEUE_NO_MEMORY
init|=
operator|-
literal|1
block|,
name|CVMX_CMD_QUEUE_FULL
init|=
operator|-
literal|2
block|,
name|CVMX_CMD_QUEUE_INVALID_PARAM
init|=
operator|-
literal|3
block|,
name|CVMX_CMD_QUEUE_ALREADY_SETUP
init|=
operator|-
literal|4
block|, }
name|cvmx_cmd_queue_result_t
typedef|;
typedef|typedef
struct|struct
block|{
name|uint8_t
name|now_serving
decl_stmt|;
comment|/**< You have lock when this is your ticket */
name|uint64_t
name|unused1
range|:
literal|24
decl_stmt|;
name|uint32_t
name|max_depth
decl_stmt|;
comment|/**< Maximum outstanding command words */
name|uint64_t
name|fpa_pool
range|:
literal|3
decl_stmt|;
comment|/**< FPA pool buffers come from */
name|uint64_t
name|base_ptr_div128
range|:
literal|29
decl_stmt|;
comment|/**< Top of command buffer pointer shifted 7 */
name|uint64_t
name|unused2
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pool_size_m1
range|:
literal|13
decl_stmt|;
comment|/**< FPA buffer size in 64bit words minus 1 */
name|uint64_t
name|index
range|:
literal|13
decl_stmt|;
comment|/**< Number of commands already used in buffer */
block|}
name|__cvmx_cmd_queue_state_t
typedef|;
comment|/**  * This structure contains the global state of all command queues.  * It is stored in a bootmem named block and shared by all  * applications running on Octeon. Tickets are stored in a different  * cache line that queue information to reduce the contention on the  * ll/sc used to get a ticket. If this is not the case, the update  * of queue state causes the ll/sc to fail quite often.  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|ticket
index|[
operator|(
name|CVMX_CMD_QUEUE_END
operator|>>
literal|16
operator|)
operator|*
literal|256
index|]
expr_stmt|;
name|__cvmx_cmd_queue_state_t
name|state
index|[
operator|(
name|CVMX_CMD_QUEUE_END
operator|>>
literal|16
operator|)
operator|*
literal|256
index|]
expr_stmt|;
block|}
name|__cvmx_cmd_queue_all_state_t
typedef|;
specifier|extern
name|CVMX_SHARED
name|__cvmx_cmd_queue_all_state_t
modifier|*
name|__cvmx_cmd_queue_state_ptr
decl_stmt|;
comment|/**  * Initialize a command queue for use. The initial FPA buffer is  * allocated and the hardware unit is configured to point to the  * new command queue.  *  * @param queue_id  Hardware command queue to initialize.  * @param max_depth Maximum outstanding commands that can be queued.  * @param fpa_pool  FPA pool the command queues should come from.  * @param pool_size Size of each buffer in the FPA pool (bytes)  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_initialize
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|int
name|fpa_pool
parameter_list|,
name|int
name|pool_size
parameter_list|)
function_decl|;
comment|/**  * Shutdown a queue a free it's command buffers to the FPA. The  * hardware connected to the queue must be stopped before this  * function is called.  *  * @param queue_id Queue to shutdown  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_shutdown
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
function_decl|;
comment|/**  * Return the number of command words pending in the queue. This  * function may be relatively slow for some hardware units.  *  * @param queue_id Hardware command queue to query  *  * @return Number of outstanding commands  */
name|int
name|cvmx_cmd_queue_length
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
function_decl|;
comment|/**  * Return the command buffer to be written to. The purpose of this  * function is to allow CVMX routine access to the low level buffer  * for initial hardware setup. User applications should not call this  * function directly.  *  * @param queue_id Command queue to query  *  * @return Command buffer or NULL on failure  */
name|void
modifier|*
name|cvmx_cmd_queue_buffer
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
function_decl|;
comment|/**  * @INTERNAL  * Get the index into the state arrays for the supplied queue id.  *  * @param queue_id Queue ID to get an index for  *  * @return Index into the state arrays  */
specifier|static
specifier|inline
name|int
name|__cvmx_cmd_queue_get_index
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
block|{
comment|/* Warning: This code currently only works with devices that have 256 queues         or less. Devices with more than 16 queues are layed out in memory to allow         cores quick access to every 16th queue. This reduces cache thrashing         when you are running 16 queues per port to support lockless operation */
name|int
name|unit
init|=
name|queue_id
operator|>>
literal|16
decl_stmt|;
name|int
name|q
init|=
operator|(
name|queue_id
operator|>>
literal|4
operator|)
operator|&
literal|0xf
decl_stmt|;
name|int
name|core
init|=
name|queue_id
operator|&
literal|0xf
decl_stmt|;
return|return
name|unit
operator|*
literal|256
operator|+
name|core
operator|*
literal|16
operator|+
name|q
return|;
block|}
comment|/**  * @INTERNAL  * Lock the supplied queue so nobody else is updating it at the same  * time as us.  *  * @param queue_id Queue ID to lock  * @param qptr     Pointer to the queue's global state  */
specifier|static
specifier|inline
name|void
name|__cvmx_cmd_queue_lock
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|int
name|my_ticket
decl_stmt|;
name|CVMX_PREFETCH
argument_list|(
name|qptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|(         ".set push\n"         ".set noreorder\n"         "1:\n"         "ll     %[my_ticket], %[ticket_ptr]\n"
comment|/* Atomic add one to ticket_ptr */
asm|"li     %[ticket], 1\n"
comment|/*    and store the original value */
asm|"baddu  %[ticket], %[my_ticket]\n"
comment|/*    in my_ticket */
asm|"sc     %[ticket], %[ticket_ptr]\n"         "beqz   %[ticket], 1b\n"         " nop\n"         "lbu    %[ticket], %[now_serving]\n"
comment|/* Load the current now_serving ticket */
asm|"2:\n"         "beq    %[ticket], %[my_ticket], 4f\n"
comment|/* Jump out if now_serving == my_ticket */
asm|" subu   %[ticket], %[my_ticket], %[ticket]\n"
comment|/* Find out how many tickets are in front of me */
asm|"subu  %[ticket], 1\n"
comment|/* Use tickets in front of me minus one to delay */
asm|"cins   %[ticket], %[ticket], 5, 7\n"
comment|/* Delay will be ((tickets in front)-1)*32 loops */
asm|"3:\n"         "bnez   %[ticket], 3b\n"
comment|/* Loop here until our ticket might be up */
asm|" subu  %[ticket], 1\n"         "b      2b\n"
comment|/* Jump back up to check out ticket again */
asm|" lbu   %[ticket], %[now_serving]\n"
comment|/* Load the current now_serving ticket */
asm|"4:\n"         ".set pop\n"         : [ticket_ptr] "=m" (__cvmx_cmd_queue_state_ptr->ticket[__cvmx_cmd_queue_get_index(queue_id)]),           [now_serving] "=m" (qptr->now_serving),           [ticket] "=r" (tmp),           [my_ticket] "=r" (my_ticket)     );
block|}
comment|/**  * @INTERNAL  * Unlock the queue, flushing all writes.  *  * @param qptr   Queue to unlock  */
specifier|static
specifier|inline
name|void
name|__cvmx_cmd_queue_unlock
parameter_list|(
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
parameter_list|)
block|{
name|uint8_t
name|ns
decl_stmt|;
name|ns
operator|=
name|qptr
operator|->
name|now_serving
operator|+
literal|1
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
comment|/* Order queue manipulation with respect to the unlock.  */
name|qptr
operator|->
name|now_serving
operator|=
name|ns
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
comment|/* nudge out the unlock. */
block|}
comment|/**  * @INTERNAL  * Get the queue state structure for the given queue id  *  * @param queue_id Queue id to get  *  * @return Queue structure or NULL on failure  */
specifier|static
specifier|inline
name|__cvmx_cmd_queue_state_t
modifier|*
name|__cvmx_cmd_queue_get_state
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|queue_id
operator|>=
name|CVMX_CMD_QUEUE_END
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|queue_id
operator|&
literal|0xffff
operator|)
operator|>=
literal|256
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|__cvmx_cmd_queue_state_ptr
operator|->
name|state
index|[
name|__cvmx_cmd_queue_get_index
argument_list|(
name|queue_id
argument_list|)
index|]
return|;
block|}
comment|/**  * Write an arbitrary number of command words to a command queue.  * This is a generic function; the fixed number of command word  * functions yield higher performance.  *  * @param queue_id  Hardware command queue to write to  * @param use_locking  *                  Use internal locking to ensure exclusive access for queue  *                  updates. If you don't use this locking you must ensure  *                  exclusivity some other way. Locking is strongly recommended.  * @param cmd_count Number of command words to write  * @param cmds      Array of commands to write  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
specifier|static
specifier|inline
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_write
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|int
name|use_locking
parameter_list|,
name|int
name|cmd_count
parameter_list|,
name|uint64_t
modifier|*
name|cmds
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
init|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|qptr
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|(
name|cmd_count
operator|<
literal|1
operator|)
operator|||
operator|(
name|cmd_count
operator|>
literal|32
operator|)
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cmds
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
comment|/* Make sure nobody else is updating the same queue */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_lock
argument_list|(
name|queue_id
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
comment|/* If a max queue length was specified then make sure we don't         exceed it. If any part of the command would be below the limit         we allow it */
if|if
condition|(
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
operator|&&
name|cvmx_unlikely
argument_list|(
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_cmd_queue_length
argument_list|(
name|queue_id
argument_list|)
operator|>
operator|(
name|int
operator|)
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_FULL
return|;
block|}
block|}
comment|/* Normally there is plenty of room in the current buffer for the command */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|qptr
operator|->
name|index
operator|+
name|cmd_count
operator|<
name|qptr
operator|->
name|pool_size_m1
argument_list|)
condition|)
block|{
name|uint64_t
modifier|*
name|ptr
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
decl_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
name|qptr
operator|->
name|index
operator|+=
name|cmd_count
expr_stmt|;
while|while
condition|(
name|cmd_count
operator|--
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|cmds
operator|++
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* We need a new command buffer. Fail if there isn't one available */
name|uint64_t
modifier|*
name|new_buffer
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_fpa_alloc
argument_list|(
name|qptr
operator|->
name|fpa_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|new_buffer
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
name|ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
expr_stmt|;
comment|/* Figure out how many command words will fit in this buffer. One             location will be needed for the next buffer pointer */
name|count
operator|=
name|qptr
operator|->
name|pool_size_m1
operator|-
name|qptr
operator|->
name|index
expr_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
name|cmd_count
operator|-=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|cmds
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|new_buffer
argument_list|)
expr_stmt|;
comment|/* The current buffer is full and has a link to the next buffer. Time             to write the rest of the commands into the new buffer */
name|qptr
operator|->
name|base_ptr_div128
operator|=
operator|*
name|ptr
operator|>>
literal|7
expr_stmt|;
name|qptr
operator|->
name|index
operator|=
name|cmd_count
expr_stmt|;
name|ptr
operator|=
name|new_buffer
expr_stmt|;
while|while
condition|(
name|cmd_count
operator|--
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|cmds
operator|++
expr_stmt|;
block|}
comment|/* All updates are complete. Release the lock and return */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
comment|/**  * Simple function to write two command words to a command  * queue.  *  * @param queue_id Hardware command queue to write to  * @param use_locking  *                 Use internal locking to ensure exclusive access for queue  *                 updates. If you don't use this locking you must ensure  *                 exclusivity some other way. Locking is strongly recommended.  * @param cmd1     Command  * @param cmd2     Command  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
specifier|static
specifier|inline
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_write2
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|int
name|use_locking
parameter_list|,
name|uint64_t
name|cmd1
parameter_list|,
name|uint64_t
name|cmd2
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
init|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|qptr
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
comment|/* Make sure nobody else is updating the same queue */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_lock
argument_list|(
name|queue_id
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
comment|/* If a max queue length was specified then make sure we don't         exceed it. If any part of the command would be below the limit         we allow it */
if|if
condition|(
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
operator|&&
name|cvmx_unlikely
argument_list|(
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_cmd_queue_length
argument_list|(
name|queue_id
argument_list|)
operator|>
operator|(
name|int
operator|)
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_FULL
return|;
block|}
block|}
comment|/* Normally there is plenty of room in the current buffer for the command */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|qptr
operator|->
name|index
operator|+
literal|2
operator|<
name|qptr
operator|->
name|pool_size_m1
argument_list|)
condition|)
block|{
name|uint64_t
modifier|*
name|ptr
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
decl_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
name|qptr
operator|->
name|index
operator|+=
literal|2
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|cmd1
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|cmd2
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
modifier|*
name|ptr
decl_stmt|;
comment|/* Figure out how many command words will fit in this buffer. One             location will be needed for the next buffer pointer */
name|int
name|count
init|=
name|qptr
operator|->
name|pool_size_m1
operator|-
name|qptr
operator|->
name|index
decl_stmt|;
comment|/* We need a new command buffer. Fail if there isn't one available */
name|uint64_t
modifier|*
name|new_buffer
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_fpa_alloc
argument_list|(
name|qptr
operator|->
name|fpa_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|new_buffer
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
name|count
operator|--
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|cmd1
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|count
argument_list|)
condition|)
operator|*
name|ptr
operator|++
operator|=
name|cmd2
expr_stmt|;
operator|*
name|ptr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|new_buffer
argument_list|)
expr_stmt|;
comment|/* The current buffer is full and has a link to the next buffer. Time             to write the rest of the commands into the new buffer */
name|qptr
operator|->
name|base_ptr_div128
operator|=
operator|*
name|ptr
operator|>>
literal|7
expr_stmt|;
name|qptr
operator|->
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|count
operator|==
literal|0
argument_list|)
condition|)
block|{
name|qptr
operator|->
name|index
operator|=
literal|1
expr_stmt|;
name|new_buffer
index|[
literal|0
index|]
operator|=
name|cmd2
expr_stmt|;
block|}
block|}
comment|/* All updates are complete. Release the lock and return */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
comment|/**  * Simple function to write three command words to a command  * queue.  *  * @param queue_id Hardware command queue to write to  * @param use_locking  *                 Use internal locking to ensure exclusive access for queue  *                 updates. If you don't use this locking you must ensure  *                 exclusivity some other way. Locking is strongly recommended.  * @param cmd1     Command  * @param cmd2     Command  * @param cmd3     Command  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
specifier|static
specifier|inline
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_write3
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|int
name|use_locking
parameter_list|,
name|uint64_t
name|cmd1
parameter_list|,
name|uint64_t
name|cmd2
parameter_list|,
name|uint64_t
name|cmd3
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
init|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|qptr
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
comment|/* Make sure nobody else is updating the same queue */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_lock
argument_list|(
name|queue_id
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
comment|/* If a max queue length was specified then make sure we don't         exceed it. If any part of the command would be below the limit         we allow it */
if|if
condition|(
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
operator|&&
name|cvmx_unlikely
argument_list|(
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_cmd_queue_length
argument_list|(
name|queue_id
argument_list|)
operator|>
operator|(
name|int
operator|)
name|qptr
operator|->
name|max_depth
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_FULL
return|;
block|}
block|}
comment|/* Normally there is plenty of room in the current buffer for the command */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|qptr
operator|->
name|index
operator|+
literal|3
operator|<
name|qptr
operator|->
name|pool_size_m1
argument_list|)
condition|)
block|{
name|uint64_t
modifier|*
name|ptr
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
decl_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
name|qptr
operator|->
name|index
operator|+=
literal|3
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|cmd1
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|cmd2
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|cmd3
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
modifier|*
name|ptr
decl_stmt|;
comment|/* Figure out how many command words will fit in this buffer. One             location will be needed for the next buffer pointer */
name|int
name|count
init|=
name|qptr
operator|->
name|pool_size_m1
operator|-
name|qptr
operator|->
name|index
decl_stmt|;
comment|/* We need a new command buffer. Fail if there isn't one available */
name|uint64_t
modifier|*
name|new_buffer
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_fpa_alloc
argument_list|(
name|qptr
operator|->
name|fpa_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|new_buffer
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
name|count
operator|--
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|qptr
operator|->
name|index
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|cmd1
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|cmd2
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
operator|*
name|ptr
operator|++
operator|=
name|cmd3
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|new_buffer
argument_list|)
expr_stmt|;
comment|/* The current buffer is full and has a link to the next buffer. Time             to write the rest of the commands into the new buffer */
name|qptr
operator|->
name|base_ptr_div128
operator|=
operator|*
name|ptr
operator|>>
literal|7
expr_stmt|;
name|qptr
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|new_buffer
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|cmd2
expr_stmt|;
name|qptr
operator|->
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|cmd3
expr_stmt|;
name|qptr
operator|->
name|index
operator|++
expr_stmt|;
block|}
block|}
comment|/* All updates are complete. Release the lock and return */
if|if
condition|(
name|cvmx_likely
argument_list|(
name|use_locking
argument_list|)
condition|)
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_CMD_QUEUE_H__ */
end_comment

end_unit

