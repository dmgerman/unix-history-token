begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-fpa-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon fpa.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_FPA_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_FPA_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_ADDR_RANGE_ERROR
value|CVMX_FPA_ADDR_RANGE_ERROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_ADDR_RANGE_ERROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_ADDR_RANGE_ERROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000458ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_ADDR_RANGE_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180028000458ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_FPA_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x00011800280000E8ull))
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_CTL_STATUS
value|(CVMX_ADD_IO_SEG(0x0001180028000050ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_FPF0_MARKS
value|CVMX_FPA_FPF0_MARKS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPF0_MARKS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPF0_MARKS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPF0_MARKS
value|(CVMX_ADD_IO_SEG(0x0001180028000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_FPF0_SIZE
value|CVMX_FPA_FPF0_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPF0_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPF0_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPF0_SIZE
value|(CVMX_ADD_IO_SEG(0x0001180028000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_FPA_FPF1_MARKS
value|CVMX_FPA_FPFX_MARKS(1)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF2_MARKS
value|CVMX_FPA_FPFX_MARKS(2)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF3_MARKS
value|CVMX_FPA_FPFX_MARKS(3)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF4_MARKS
value|CVMX_FPA_FPFX_MARKS(4)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF5_MARKS
value|CVMX_FPA_FPFX_MARKS(5)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF6_MARKS
value|CVMX_FPA_FPFX_MARKS(6)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_FPF7_MARKS
value|CVMX_FPA_FPFX_MARKS(7)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_FPF8_MARKS
value|CVMX_FPA_FPF8_MARKS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPF8_MARKS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPF8_MARKS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000240ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPF8_MARKS
value|(CVMX_ADD_IO_SEG(0x0001180028000240ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_FPF8_SIZE
value|CVMX_FPA_FPF8_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPF8_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPF8_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000248ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPF8_SIZE
value|(CVMX_ADD_IO_SEG(0x0001180028000248ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPFX_MARKS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPFX_MARKS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPFX_MARKS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000008ull) + ((offset)& 7) * 8 - 8*1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_FPFX_SIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_FPFX_SIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_FPFX_SIZE
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000060ull) + ((offset)& 7) * 8 - 8*1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_FPA_INT_ENB
value|(CVMX_ADD_IO_SEG(0x0001180028000048ull))
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_INT_SUM
value|(CVMX_ADD_IO_SEG(0x0001180028000040ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_PACKET_THRESHOLD
value|CVMX_FPA_PACKET_THRESHOLD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_PACKET_THRESHOLD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_PACKET_THRESHOLD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000460ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_PACKET_THRESHOLD
value|(CVMX_ADD_IO_SEG(0x0001180028000460ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_POOLX_END_ADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_POOLX_END_ADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000358ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_POOLX_END_ADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000358ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_POOLX_START_ADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_POOLX_START_ADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000258ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_POOLX_START_ADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000258ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_POOLX_THRESHOLD
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_POOLX_THRESHOLD(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000140ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_POOLX_THRESHOLD
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000140ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_FPA_QUE0_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE1_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE2_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE3_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(3)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE4_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(4)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE5_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(5)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE6_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(6)
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE7_PAGE_INDEX
value|CVMX_FPA_QUEX_PAGE_INDEX(7)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_QUE8_PAGE_INDEX
value|CVMX_FPA_QUE8_PAGE_INDEX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_QUE8_PAGE_INDEX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_QUE8_PAGE_INDEX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000250ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_QUE8_PAGE_INDEX
value|(CVMX_ADD_IO_SEG(0x0001180028000250ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_QUEX_AVAILABLE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_QUEX_AVAILABLE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000098ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_QUEX_AVAILABLE
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180028000098ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_QUEX_PAGE_INDEX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_QUEX_PAGE_INDEX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800280000F0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_QUEX_PAGE_INDEX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800280000F0ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_FPA_QUE_ACT
value|(CVMX_ADD_IO_SEG(0x0001180028000138ull))
end_define

begin_define
define|#
directive|define
name|CVMX_FPA_QUE_EXP
value|(CVMX_ADD_IO_SEG(0x0001180028000130ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_WART_CTL
value|CVMX_FPA_WART_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_WART_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_WART_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800280000D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_WART_CTL
value|(CVMX_ADD_IO_SEG(0x00011800280000D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_WART_STATUS
value|CVMX_FPA_WART_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_WART_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_WART_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800280000E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_WART_STATUS
value|(CVMX_ADD_IO_SEG(0x00011800280000E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_FPA_WQE_THRESHOLD
value|CVMX_FPA_WQE_THRESHOLD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_FPA_WQE_THRESHOLD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_FPA_WQE_THRESHOLD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180028000468ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_FPA_WQE_THRESHOLD
value|(CVMX_ADD_IO_SEG(0x0001180028000468ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_fpa_addr_range_error  *  * Space here reserved  *  *                  FPA_ADDR_RANGE_ERROR = FPA's Pool Address Range Error Information  *  * When an address is sent to a pool that does not fall in the start and end address spcified by  * FPA_POOLX_START_ADDR and FPA_POOLX_END_ADDR the information related to the failure is captured here.  * In addition FPA_INT_SUM[PADDR_E] will be set and this register will not be updated again till  * FPA_INT_SUM[PADDR_E] is cleared.  */
end_comment

begin_union
union|union
name|cvmx_fpa_addr_range_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_addr_range_error_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|5
decl_stmt|;
comment|/**< Pool address sent to. */
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Failing address. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_addr_range_error_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_addr_range_error_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_addr_range_error_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_addr_range_error_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_addr_range_error_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_addr_range_error
name|cvmx_fpa_addr_range_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_bist_status  *  * FPA_BIST_STATUS = BIST Status of FPA Memories  *  * The result of the BIST run on the FPA memories.  */
end_comment

begin_union
union|union
name|cvmx_fpa_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|frd
range|:
literal|1
decl_stmt|;
comment|/**< fpa_frd  memory bist status. */
name|uint64_t
name|fpf0
range|:
literal|1
decl_stmt|;
comment|/**< fpa_fpf0 memory bist status. */
name|uint64_t
name|fpf1
range|:
literal|1
decl_stmt|;
comment|/**< fpa_fpf1 memory bist status. */
name|uint64_t
name|ffr
range|:
literal|1
decl_stmt|;
comment|/**< fpa_ffr  memory bist status. */
name|uint64_t
name|fdr
range|:
literal|1
decl_stmt|;
comment|/**< fpa_fdr  memory bist status. */
else|#
directive|else
name|uint64_t
name|fdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ffr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|frd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_bist_status_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_bist_status
name|cvmx_fpa_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_ctl_status  *  * FPA_CTL_STATUS = FPA's Control/Status Register  *  * The FPA's interrupt enable register.  */
end_comment

begin_union
union|union
name|cvmx_fpa_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_ctl_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|free_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the setting of the INT_SUM_[FREE*] bits. */
name|uint64_t
name|ret_off
range|:
literal|1
decl_stmt|;
comment|/**< When set NCB devices returning pointer will be                                                          stalled. */
name|uint64_t
name|req_off
range|:
literal|1
decl_stmt|;
comment|/**< When set NCB devices requesting pointers will be                                                          stalled. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set causes a reset of the FPA with the */
name|uint64_t
name|use_ldt
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the FPA will use LDT to load                                                          pointers from the L2C. This is a PASS-2 field. */
name|uint64_t
name|use_stt
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the FPA will use STT to store                                                          pointers to the L2C. This is a PASS-2 field. */
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
comment|/**< Must be set to 1 AFTER writing all config registers                                                          and 10 cycles have past. If any of the config                                                          register are written after writing this bit the                                                          FPA may begin to operate incorrectly. */
name|uint64_t
name|mem1_err
range|:
literal|7
decl_stmt|;
comment|/**< Causes a flip of the ECC bit associated 38:32                                                          respective to bit 6:0 of this field, for FPF                                                          FIFO 1. */
name|uint64_t
name|mem0_err
range|:
literal|7
decl_stmt|;
comment|/**< Causes a flip of the ECC bit associated 38:32                                                          respective to bit 6:0 of this field, for FPF                                                          FIFO 0. */
else|#
directive|else
name|uint64_t
name|mem0_err
range|:
literal|7
decl_stmt|;
name|uint64_t
name|mem1_err
range|:
literal|7
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_stt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_ldt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ret_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_fpa_ctl_status_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set causes a reset of the FPA with the                                                          exception of the RSL. */
name|uint64_t
name|use_ldt
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the FPA will use LDT to load                                                          pointers from the L2C. */
name|uint64_t
name|use_stt
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the FPA will use STT to store                                                          pointers to the L2C. */
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
comment|/**< Must be set to 1 AFTER writing all config registers                                                          and 10 cycles have past. If any of the config                                                          register are written after writing this bit the                                                          FPA may begin to operate incorrectly. */
name|uint64_t
name|mem1_err
range|:
literal|7
decl_stmt|;
comment|/**< Causes a flip of the ECC bit associated 38:32                                                          respective to bit 6:0 of this field, for FPF                                                          FIFO 1. */
name|uint64_t
name|mem0_err
range|:
literal|7
decl_stmt|;
comment|/**< Causes a flip of the ECC bit associated 38:32                                                          respective to bit 6:0 of this field, for FPF                                                          FIFO 0. */
else|#
directive|else
name|uint64_t
name|mem0_err
range|:
literal|7
decl_stmt|;
name|uint64_t
name|mem1_err
range|:
literal|7
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_stt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_ldt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_ctl_status_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_ctl_status
name|cvmx_fpa_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf#_marks  *  * FPA_FPF1_MARKS = FPA's Queue 1 Free Page FIFO Read Write Marks  *  * The high and low watermark register that determines when we write and read free pages from L2C  * for Queue 1. The value of FPF_RD and FPF_WR should have at least a 33 difference. Recommend value  * is FPF_RD == (FPA_FPF#_SIZE[FPF_SIZ] * .25) and FPF_WR == (FPA_FPF#_SIZE[FPF_SIZ] * .75)  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpfx_marks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpfx_marks_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|11
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                           queue exceeds this value the FPA will write                                                           32-page-pointers of that queue to DRAM.                                                          The MAX value for this field should be                                                          FPA_FPF1_SIZE[FPF_SIZ]-2. */
name|uint64_t
name|fpf_rd
range|:
literal|11
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                           queue drops below this value and there are                                                           free-page-pointers in DRAM, the FPA will                                                           read one page (32 pointers) from DRAM.                                                          This maximum value for this field should be                                                          FPA_FPF1_SIZE[FPF_SIZ]-34. The min number                                                          for this would be 16. */
else|#
directive|else
name|uint64_t
name|fpf_rd
range|:
literal|11
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_marks_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpfx_marks
name|cvmx_fpa_fpfx_marks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf#_size  *  * FPA_FPFX_SIZE = FPA's Queue 1-7 Free Page FIFO Size  *  * The number of page pointers that will be kept local to the FPA for this Queue. FPA Queues are  * assigned in order from Queue 0 to Queue 7, though only Queue 0 through Queue x can be used.  * The sum of the 8 (0-7) FPA_FPF#_SIZE registers must be limited to 2048.  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpfx_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpfx_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|fpf_siz
range|:
literal|11
decl_stmt|;
comment|/**< The number of entries assigned in the FPA FIFO                                                          (used to hold page-pointers) for this Queue.                                                          The value of this register must divisable by 2,                                                          and the FPA will ignore bit [0] of this register.                                                          The total of the FPF_SIZ field of the 8 (0-7)                                                          FPA_FPF#_SIZE registers must not exceed 2048.                                                          After writing this field the FPA will need 10                                                          core clock cycles to be ready for operation. The                                                          assignment of location in the FPA FIFO must                                                          start with Queue 0, then 1, 2, etc.                                                          The number of useable entries will be FPF_SIZ-2. */
else|#
directive|else
name|uint64_t
name|fpf_siz
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpfx_size_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpfx_size
name|cvmx_fpa_fpfx_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf0_marks  *  * FPA_FPF0_MARKS = FPA's Queue 0 Free Page FIFO Read Write Marks  *  * The high and low watermark register that determines when we write and read free pages from L2C  * for Queue 0. The value of FPF_RD and FPF_WR should have at least a 33 difference. Recommend value  * is FPF_RD == (FPA_FPF#_SIZE[FPF_SIZ] * .25) and FPF_WR == (FPA_FPF#_SIZE[FPF_SIZ] * .75)  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpf0_marks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpf0_marks_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|12
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                           queue exceeds this value the FPA will write                                                           32-page-pointers of that queue to DRAM.                                                          The MAX value for this field should be                                                          FPA_FPF0_SIZE[FPF_SIZ]-2. */
name|uint64_t
name|fpf_rd
range|:
literal|12
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                          queue drops below this value and there are                                                          free-page-pointers in DRAM, the FPA will                                                          read one page (32 pointers) from DRAM.                                                          This maximum value for this field should be                                                          FPA_FPF0_SIZE[FPF_SIZ]-34. The min number                                                          for this would be 16. */
else|#
directive|else
name|uint64_t
name|fpf_rd
range|:
literal|12
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_marks_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpf0_marks
name|cvmx_fpa_fpf0_marks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf0_size  *  * FPA_FPF0_SIZE = FPA's Queue 0 Free Page FIFO Size  *  * The number of page pointers that will be kept local to the FPA for this Queue. FPA Queues are  * assigned in order from Queue 0 to Queue 7, though only Queue 0 through Queue x can be used.  * The sum of the 8 (0-7) FPA_FPF#_SIZE registers must be limited to 2048.  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpf0_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpf0_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|fpf_siz
range|:
literal|12
decl_stmt|;
comment|/**< The number of entries assigned in the FPA FIFO                                                          (used to hold page-pointers) for this Queue.                                                          The value of this register must divisable by 2,                                                          and the FPA will ignore bit [0] of this register.                                                          The total of the FPF_SIZ field of the 8 (0-7)                                                          FPA_FPF#_SIZE registers must not exceed 2048.                                                          After writing this field the FPA will need 10                                                          core clock cycles to be ready for operation. The                                                          assignment of location in the FPA FIFO must                                                          start with Queue 0, then 1, 2, etc.                                                          The number of useable entries will be FPF_SIZ-2. */
else|#
directive|else
name|uint64_t
name|fpf_siz
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_fpf0_size_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpf0_size
name|cvmx_fpa_fpf0_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf8_marks  *  * Reserved through 0x238 for additional thresholds  *  *                  FPA_FPF8_MARKS = FPA's Queue 8 Free Page FIFO Read Write Marks  *  * The high and low watermark register that determines when we write and read free pages from L2C  * for Queue 8. The value of FPF_RD and FPF_WR should have at least a 33 difference. Recommend value  * is FPF_RD == (FPA_FPF#_SIZE[FPF_SIZ] * .25) and FPF_WR == (FPA_FPF#_SIZE[FPF_SIZ] * .75)  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpf8_marks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpf8_marks_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|11
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                          queue exceeds this value the FPA will write                                                          32-page-pointers of that queue to DRAM.                                                          The MAX value for this field should be                                                          FPA_FPF0_SIZE[FPF_SIZ]-2. */
name|uint64_t
name|fpf_rd
range|:
literal|11
decl_stmt|;
comment|/**< When the number of free-page-pointers in a                                                          queue drops below this value and there are                                                          free-page-pointers in DRAM, the FPA will                                                          read one page (32 pointers) from DRAM.                                                          This maximum value for this field should be                                                          FPA_FPF0_SIZE[FPF_SIZ]-34. The min number                                                          for this would be 16. */
else|#
directive|else
name|uint64_t
name|fpf_rd
range|:
literal|11
decl_stmt|;
name|uint64_t
name|fpf_wr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpf8_marks_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf8_marks_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpf8_marks
name|cvmx_fpa_fpf8_marks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_fpf8_size  *  * FPA_FPF8_SIZE = FPA's Queue 8 Free Page FIFO Size  *  * The number of page pointers that will be kept local to the FPA for this Queue. FPA Queues are  * assigned in order from Queue 0 to Queue 7, though only Queue 0 through Queue x can be used.  * The sum of the 9 (0-8) FPA_FPF#_SIZE registers must be limited to 2048.  */
end_comment

begin_union
union|union
name|cvmx_fpa_fpf8_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_fpf8_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|fpf_siz
range|:
literal|12
decl_stmt|;
comment|/**< The number of entries assigned in the FPA FIFO                                                          (used to hold page-pointers) for this Queue.                                                          The value of this register must divisable by 2,                                                          and the FPA will ignore bit [0] of this register.                                                          The total of the FPF_SIZ field of the 8 (0-7)                                                          FPA_FPF#_SIZE registers must not exceed 2048.                                                          After writing this field the FPA will need 10                                                          core clock cycles to be ready for operation. The                                                          assignment of location in the FPA FIFO must                                                          start with Queue 0, then 1, 2, etc.                                                          The number of useable entries will be FPF_SIZ-2. */
else|#
directive|else
name|uint64_t
name|fpf_siz
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_fpf8_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_fpf8_size_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_fpf8_size
name|cvmx_fpa_fpf8_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_int_enb  *  * FPA_INT_ENB = FPA's Interrupt Enable  *  * The FPA's interrupt enable register.  */
end_comment

begin_union
union|union
name|cvmx_fpa_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 49 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|reserved_44_48
range|:
literal|5
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 43 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 42 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 41 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 40 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 39 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 38 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 31 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 30 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 29 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 28 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_48
range|:
literal|5
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_fpa_int_enb_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_fpa_int_enb_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 49 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|res_44
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 43 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 42 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 41 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 40 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 39 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 38 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 31 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 30 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 29 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 28 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|res_44
range|:
literal|5
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_fpa_int_enb_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 43 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 42 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 41 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 40 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 39 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 38 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 31 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 30 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 29 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 28 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_fpa_int_enb_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_fpa_int_enb_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 49 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool8th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 48 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q8_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 47 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q8_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 46 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q8_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 45 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free8
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 44 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 43 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 42 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 41 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 40 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 39 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 38 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 37 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 36 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 35 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 34 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 33 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 32 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 31 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 30 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 29 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 28 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 27 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 26 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 25 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 24 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 23 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 22 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 21 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 20 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 19 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 18 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 17 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 16 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 15 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 14 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 13 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 12 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 11 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 10 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 9 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 8 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 7 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 6 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 5 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 4 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 3 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 2 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 1 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< When set (1) and bit 0 of the FPA_INT_SUM                                                          register is asserted the FPA will assert an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool8th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_fpa_int_enb_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_enb_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_int_enb
name|cvmx_fpa_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_int_sum  *  * FPA_INT_SUM = FPA's Interrupt Summary Register  *  * Contains the different interrupt summary bits of the FPA.  */
end_comment

begin_union
union|union
name|cvmx_fpa_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
comment|/**< Set when a pointer address does not fall in the                                                          address range for a pool specified by                                                          FPA_POOLX_START_ADDR and FPA_POOLX_END_ADDR. */
name|uint64_t
name|pool8th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE8_AVAILABLE is equal to                                                          FPA_POOL8_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|q8_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue8 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q8_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue8 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q8_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue8 page count available goes                                                          negative. */
name|uint64_t
name|free8
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL8 is freed bit is set. */
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL7 is freed bit is set. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL6 is freed bit is set. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL5 is freed bit is set. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL4 is freed bit is set. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL3 is freed bit is set. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL2 is freed bit is set. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL1 is freed bit is set. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL0 is freed bit is set. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE7_AVAILABLE is equal to                                                          FPA_POOL7_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE6_AVAILABLE is equal to                                                          FPA_POOL6_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE5_AVAILABLE is equal to                                                          FPA_POOL5_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE4_AVAILABLE is equal to                                                          FPA_POOL4_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE3_AVAILABLE is equal to                                                          FPA_POOL3_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE2_AVAILABLE is equal to                                                          FPA_POOL2_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE1_AVAILABLE is equal to                                                          FPA_POOL1_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE0_AVAILABLE is equal to                                                          FPA_POOL`_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF1. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF1. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF0. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF0. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q8_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool8th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_fpa_int_sum_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF1. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF1. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF0. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF0. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_fpa_int_sum_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
comment|/**< Set when a pointer address does not fall in the                                                          address range for a pool specified by                                                          FPA_POOLX_START_ADDR and FPA_POOLX_END_ADDR. */
name|uint64_t
name|reserved_44_48
range|:
literal|5
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL7 is freed bit is set. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL6 is freed bit is set. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL5 is freed bit is set. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL4 is freed bit is set. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL3 is freed bit is set. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL2 is freed bit is set. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL1 is freed bit is set. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL0 is freed bit is set. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE7_AVAILABLE is equal to                                                          FPA_POOL7_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE6_AVAILABLE is equal to                                                          FPA_POOL6_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE5_AVAILABLE is equal to                                                          FPA_POOL5_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE4_AVAILABLE is equal to                                                          FPA_POOL4_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE3_AVAILABLE is equal to                                                          FPA_POOL3_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE2_AVAILABLE is equal to                                                          FPA_POOL2_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE1_AVAILABLE is equal to                                                          FPA_POOL1_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE0_AVAILABLE is equal to                                                          FPA_POOL`_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF1. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF1. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF0. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF0. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_48
range|:
literal|5
decl_stmt|;
name|uint64_t
name|paddr_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_fpa_int_sum_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL7 is freed bit is set. */
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL6 is freed bit is set. */
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL5 is freed bit is set. */
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL4 is freed bit is set. */
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL3 is freed bit is set. */
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL2 is freed bit is set. */
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL1 is freed bit is set. */
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
comment|/**< When a pointer for POOL0 is freed bit is set. */
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE7_AVAILABLE is equal to                                                          FPA_POOL7_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE6_AVAILABLE is equal to                                                          FPA_POOL6_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE5_AVAILABLE is equal to                                                          FPA_POOL5_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE4_AVAILABLE is equal to                                                          FPA_POOL4_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE3_AVAILABLE is equal to                                                          FPA_POOL3_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE2_AVAILABLE is equal to                                                          FPA_POOL2_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE1_AVAILABLE is equal to                                                          FPA_POOL1_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
comment|/**< Set when FPA_QUE0_AVAILABLE is equal to                                                          FPA_POOL`_THRESHOLD[THRESH] and a pointer is                                                          allocated or de-allocated. */
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than than pointers                                                          present in the FPA. */
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 pointer read from the stack in                                                          the L2C does not have the FPA owner ship bit set. */
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 stack end tag is present and                                                          the count available is greater than pointers                                                          present in the FPA. */
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Queue0 page count available goes                                                          negative. */
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF1. */
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF1. */
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Double Bit Error is detected in FPF0. */
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
comment|/**< Set when a Single Bit Error is detected in FPF0. */
else|#
directive|else
name|uint64_t
name|fed0_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed0_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fed1_dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q4_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q5_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q6_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_und
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_coff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q7_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool0th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool1th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool2th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool3th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool4th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool5th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool6th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pool7th
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_fpa_int_sum_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_int_sum_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_int_sum
name|cvmx_fpa_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_packet_threshold  *  * FPA_PACKET_THRESHOLD = FPA's Packet Threshold  *  * When the value of FPA_QUE0_AVAILABLE[QUE_SIZ] is Less than the value of this register a low pool count signal is sent to the  * PCIe packet instruction engine (to make it stop reading instructions) and to the Packet-Arbiter informing it to not give grants  * to packets MAC with the exception of the PCIe MAC.  */
end_comment

begin_union
union|union
name|cvmx_fpa_packet_threshold
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_packet_threshold_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
comment|/**< Packet Threshold. */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_packet_threshold_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_packet_threshold
name|cvmx_fpa_packet_threshold_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_pool#_end_addr  *  * Space here reserved  *  *                  FPA_POOLX_END_ADDR = FPA's Pool-X Ending Addres  *  * Pointers sent to this pool must be equal to or less than this address.  */
end_comment

begin_union
union|union
name|cvmx_fpa_poolx_end_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_poolx_end_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Address. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_poolx_end_addr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_end_addr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_end_addr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_end_addr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_end_addr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_poolx_end_addr
name|cvmx_fpa_poolx_end_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_pool#_start_addr  *  * FPA_POOLX_START_ADDR = FPA's Pool-X Starting Addres  *  * Pointers sent to this pool must be equal to or greater than this address.  */
end_comment

begin_union
union|union
name|cvmx_fpa_poolx_start_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_poolx_start_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Address. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_poolx_start_addr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_start_addr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_start_addr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_start_addr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_start_addr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_poolx_start_addr
name|cvmx_fpa_poolx_start_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_pool#_threshold  *  * FPA_POOLX_THRESHOLD = FPA's Pool 0-7 Threshold  *  * When the value of FPA_QUEX_AVAILABLE is equal to FPA_POOLX_THRESHOLD[THRESH] when a pointer is allocated  * or deallocated, set interrupt FPA_INT_SUM[POOLXTH].  */
end_comment

begin_union
union|union
name|cvmx_fpa_poolx_threshold
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_poolx_threshold_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
comment|/**< The Threshold. */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_fpa_poolx_threshold_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|thresh
range|:
literal|29
decl_stmt|;
comment|/**< The Threshold. */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_fpa_poolx_threshold_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_threshold_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_threshold_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_threshold_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_poolx_threshold_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_poolx_threshold
name|cvmx_fpa_poolx_threshold_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_que#_available  *  * FPA_QUEX_PAGES_AVAILABLE = FPA's Queue 0-7 Free Page Available Register  *  * The number of page pointers that are available in the FPA and local DRAM.  */
end_comment

begin_union
union|union
name|cvmx_fpa_quex_available
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_quex_available_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|que_siz
range|:
literal|32
decl_stmt|;
comment|/**< The number of free pages available in this Queue.                                                          In PASS-1 this field was [25:0]. */
else|#
directive|else
name|uint64_t
name|que_siz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_fpa_quex_available_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|que_siz
range|:
literal|29
decl_stmt|;
comment|/**< The number of free pages available in this Queue. */
else|#
directive|else
name|uint64_t
name|que_siz
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_available_cn30xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_quex_available
name|cvmx_fpa_quex_available_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_que#_page_index  *  * FPA_QUE0_PAGE_INDEX = FPA's Queue0 Page Index  *  * The present index page for queue 0 of the FPA, this is a PASS-2 register.  * This number reflects the number of pages of pointers that have been written to memory  * for this queue.  */
end_comment

begin_union
union|union
name|cvmx_fpa_quex_page_index
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_quex_page_index_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|pg_num
range|:
literal|25
decl_stmt|;
comment|/**< Page number. */
else|#
directive|else
name|uint64_t
name|pg_num
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_quex_page_index_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_quex_page_index
name|cvmx_fpa_quex_page_index_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_que8_page_index  *  * FPA_QUE8_PAGE_INDEX = FPA's Queue7 Page Index  *  * The present index page for queue 7 of the FPA.  * This number reflects the number of pages of pointers that have been written to memory  * for this queue.  * Because the address space is 38-bits the number of 128 byte pages could cause this register value to wrap.  */
end_comment

begin_union
union|union
name|cvmx_fpa_que8_page_index
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_que8_page_index_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|pg_num
range|:
literal|25
decl_stmt|;
comment|/**< Page number. */
else|#
directive|else
name|uint64_t
name|pg_num
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_que8_page_index_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_que8_page_index_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_que8_page_index
name|cvmx_fpa_que8_page_index_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_que_act  *  * FPA_QUE_ACT = FPA's Queue# Actual Page Index  *  * When a INT_SUM[PERR#] occurs this will be latched with the value read from L2C. PASS-2 register.  * This is latched on the first error and will not latch again unitl all errors are cleared.  */
end_comment

begin_union
union|union
name|cvmx_fpa_que_act
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_que_act_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|act_que
range|:
literal|3
decl_stmt|;
comment|/**< FPA-queue-number read from memory. */
name|uint64_t
name|act_indx
range|:
literal|26
decl_stmt|;
comment|/**< Page number read from memory. */
else|#
directive|else
name|uint64_t
name|act_indx
range|:
literal|26
decl_stmt|;
name|uint64_t
name|act_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_que_act_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_act_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_que_act
name|cvmx_fpa_que_act_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_que_exp  *  * FPA_QUE_EXP = FPA's Queue# Expected Page Index  *  * When a INT_SUM[PERR#] occurs this will be latched with the expected value. PASS-2 register.  * This is latched on the first error and will not latch again unitl all errors are cleared.  */
end_comment

begin_union
union|union
name|cvmx_fpa_que_exp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_que_exp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|exp_que
range|:
literal|3
decl_stmt|;
comment|/**< Expected fpa-queue-number read from memory. */
name|uint64_t
name|exp_indx
range|:
literal|26
decl_stmt|;
comment|/**< Expected page number read from memory. */
else|#
directive|else
name|uint64_t
name|exp_indx
range|:
literal|26
decl_stmt|;
name|uint64_t
name|exp_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_que_exp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_que_exp
name|cvmx_fpa_que_exp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_wart_ctl  *  * FPA_WART_CTL = FPA's WART Control  *  * Control and status for the WART block.  */
end_comment

begin_union
union|union
name|cvmx_fpa_wart_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_wart_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ctl
range|:
literal|16
decl_stmt|;
comment|/**< Control information. */
else|#
directive|else
name|uint64_t
name|ctl
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_wart_ctl
name|cvmx_fpa_wart_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_wart_status  *  * FPA_WART_STATUS = FPA's WART Status  *  * Control and status for the WART block.  */
end_comment

begin_union
union|union
name|cvmx_fpa_wart_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_wart_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|status
range|:
literal|32
decl_stmt|;
comment|/**< Status information. */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_fpa_wart_status_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_wart_status
name|cvmx_fpa_wart_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_fpa_wqe_threshold  *  * FPA_WQE_THRESHOLD = FPA's WQE Threshold  *  * When the value of FPA_QUE#_AVAILABLE[QUE_SIZ] (\# is determined by the value of IPD_WQE_FPA_QUEUE) is Less than the value of this  * register a low pool count signal is sent to the PCIe packet instruction engine (to make it stop reading instructions) and to the  * Packet-Arbiter informing it to not give grants to packets MAC with the exception of the PCIe MAC.  */
end_comment

begin_union
union|union
name|cvmx_fpa_wqe_threshold
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_fpa_wqe_threshold_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
comment|/**< WQE Threshold. */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_fpa_wqe_threshold_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_fpa_wqe_threshold
name|cvmx_fpa_wqe_threshold_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

