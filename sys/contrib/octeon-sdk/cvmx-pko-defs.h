begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pko-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pko.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PKO_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PKO_TYPEDEFS_H__
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_COUNT0
value|(CVMX_ADD_IO_SEG(0x0001180050001080ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_COUNT1
value|(CVMX_ADD_IO_SEG(0x0001180050001088ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180050001100ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG1
value|(CVMX_ADD_IO_SEG(0x0001180050001108ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG10
value|(CVMX_ADD_IO_SEG(0x0001180050001150ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG11
value|(CVMX_ADD_IO_SEG(0x0001180050001158ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG12
value|(CVMX_ADD_IO_SEG(0x0001180050001160ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG13
value|(CVMX_ADD_IO_SEG(0x0001180050001168ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG14
value|CVMX_PKO_MEM_DEBUG14_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_MEM_DEBUG14_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_MEM_DEBUG14 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050001170ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG14
value|(CVMX_ADD_IO_SEG(0x0001180050001170ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG2
value|(CVMX_ADD_IO_SEG(0x0001180050001110ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG3
value|(CVMX_ADD_IO_SEG(0x0001180050001118ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG4
value|(CVMX_ADD_IO_SEG(0x0001180050001120ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG5
value|(CVMX_ADD_IO_SEG(0x0001180050001128ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG6
value|(CVMX_ADD_IO_SEG(0x0001180050001130ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG7
value|(CVMX_ADD_IO_SEG(0x0001180050001138ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG8
value|(CVMX_ADD_IO_SEG(0x0001180050001140ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_DEBUG9
value|(CVMX_ADD_IO_SEG(0x0001180050001148ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_PTRS
value|CVMX_PKO_MEM_PORT_PTRS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_MEM_PORT_PTRS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_MEM_PORT_PTRS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050001010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_PTRS
value|(CVMX_ADD_IO_SEG(0x0001180050001010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_QOS
value|CVMX_PKO_MEM_PORT_QOS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_MEM_PORT_QOS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_MEM_PORT_QOS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050001018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_QOS
value|(CVMX_ADD_IO_SEG(0x0001180050001018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_RATE0
value|CVMX_PKO_MEM_PORT_RATE0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_MEM_PORT_RATE0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_MEM_PORT_RATE0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050001020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_RATE0
value|(CVMX_ADD_IO_SEG(0x0001180050001020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_RATE1
value|CVMX_PKO_MEM_PORT_RATE1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_MEM_PORT_RATE1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_MEM_PORT_RATE1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050001028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_PORT_RATE1
value|(CVMX_ADD_IO_SEG(0x0001180050001028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_QUEUE_PTRS
value|(CVMX_ADD_IO_SEG(0x0001180050001000ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_MEM_QUEUE_QOS
value|(CVMX_ADD_IO_SEG(0x0001180050001008ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_BIST_RESULT
value|(CVMX_ADD_IO_SEG(0x0001180050000080ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_CMD_BUF
value|(CVMX_ADD_IO_SEG(0x0001180050000010ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_CRC_CTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_CRC_CTLX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_CRC_CTLX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180050000028ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_CRC_ENABLE
value|CVMX_PKO_REG_CRC_ENABLE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_CRC_ENABLE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_CRC_ENABLE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_CRC_ENABLE
value|(CVMX_ADD_IO_SEG(0x0001180050000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_CRC_IVX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_CRC_IVX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_CRC_IVX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180050000038ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180050000098ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG1
value|CVMX_PKO_REG_DEBUG1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_DEBUG1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_DEBUG1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800500000A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG1
value|(CVMX_ADD_IO_SEG(0x00011800500000A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG2
value|CVMX_PKO_REG_DEBUG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_DEBUG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_DEBUG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800500000A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG2
value|(CVMX_ADD_IO_SEG(0x00011800500000A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG3
value|CVMX_PKO_REG_DEBUG3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_DEBUG3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_DEBUG3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800500000B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_DEBUG3
value|(CVMX_ADD_IO_SEG(0x00011800500000B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_ENGINE_INFLIGHT
value|CVMX_PKO_REG_ENGINE_INFLIGHT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_ENGINE_INFLIGHT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_ENGINE_INFLIGHT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_ENGINE_INFLIGHT
value|(CVMX_ADD_IO_SEG(0x0001180050000050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_ENGINE_THRESH
value|CVMX_PKO_REG_ENGINE_THRESH_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_ENGINE_THRESH_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_ENGINE_THRESH not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_ENGINE_THRESH
value|(CVMX_ADD_IO_SEG(0x0001180050000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PKO_REG_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180050000088ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_FLAGS
value|(CVMX_ADD_IO_SEG(0x0001180050000000ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_GMX_PORT_MODE
value|(CVMX_ADD_IO_SEG(0x0001180050000018ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_INT_MASK
value|(CVMX_ADD_IO_SEG(0x0001180050000090ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PKO_REG_QUEUE_MODE
value|(CVMX_ADD_IO_SEG(0x0001180050000048ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_QUEUE_PTRS1
value|CVMX_PKO_REG_QUEUE_PTRS1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_QUEUE_PTRS1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_QUEUE_PTRS1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000100ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_QUEUE_PTRS1
value|(CVMX_ADD_IO_SEG(0x0001180050000100ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PKO_REG_READ_IDX
value|(CVMX_ADD_IO_SEG(0x0001180050000008ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PKO_REG_TIMESTAMP
value|CVMX_PKO_REG_TIMESTAMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PKO_REG_TIMESTAMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PKO_REG_TIMESTAMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180050000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PKO_REG_TIMESTAMP
value|(CVMX_ADD_IO_SEG(0x0001180050000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pko_mem_count0  *  * Notes:  * Total number of packets seen by PKO, per port  * A write to this address will clear the entry whose index is specified as COUNT[5:0].  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_count0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_count0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|count
range|:
literal|32
decl_stmt|;
comment|/**< Total number of packets seen by PKO */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_count0
name|cvmx_pko_mem_count0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_count1  *  * Notes:  * Total number of bytes seen by PKO, per port  * A write to this address will clear the entry whose index is specified as COUNT[5:0].  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_count1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_count1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|count
range|:
literal|48
decl_stmt|;
comment|/**< Total number of bytes seen by PKO */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_count1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_count1
name|cvmx_pko_mem_count1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug0  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.cmnd[63:0]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
comment|/**< Fetch and add command words */
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
comment|/**< Command word */
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
comment|/**< Number of segments/gather size */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Packet length in bytes */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug0
name|cvmx_pko_mem_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug1  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.curr[63:0]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
comment|/**< Data pointer */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug1
name|cvmx_pko_mem_debug1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug10  *  * Notes:  * Internal per-port state intended for debug use only - pko.dat.ptr.ptrs1, pko.dat.ptr.ptrs2  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug10
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug10_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug10_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
comment|/**< Fetch and add command words */
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
comment|/**< Command word */
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
comment|/**< Number of segments/gather size */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Packet length in bytes */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug10_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug10_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs1
range|:
literal|17
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs2
range|:
literal|17
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|ptrs2
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs1
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug10_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug10
name|cvmx_pko_mem_debug10_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug11  *  * Notes:  * Internal per-port state intended for debug use only - pko.out.sta.state[22:0]  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug11
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug11_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|reserved_0_39
range|:
literal|40
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_39
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug11_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
comment|/**< Data pointer */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug11_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug11_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|maj
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|uid
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|sop
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|len
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|chk
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cnt
range|:
literal|13
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|mod
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|mod
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|13
decl_stmt|;
name|uint64_t
name|chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|maj
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug11_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug11
name|cvmx_pko_mem_debug11_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug12  *  * Notes:  * Internal per-port state intended for debug use only - pko.out.ctl.cmnd[63:0]  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug12
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug12_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug12_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< WorkQ data or Store0 pointer */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug12_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug12_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
comment|/**< Fetch and add command words */
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
comment|/**< Command word */
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
comment|/**< Number of segments/gather size */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Packet length in bytes */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|14
decl_stmt|;
name|uint64_t
name|fau
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug12_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug12
name|cvmx_pko_mem_debug12_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug13  *  * Notes:  * Internal per-port state intended for debug use only - pko.out.ctl.head[63:0]  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug13
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug13_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|reserved_0_55
range|:
literal|56
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_55
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug13_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|widx
range|:
literal|17
decl_stmt|;
comment|/**< PDB widx */
name|uint64_t
name|ridx2
range|:
literal|17
decl_stmt|;
comment|/**< PDB ridx2 */
name|uint64_t
name|widx2
range|:
literal|17
decl_stmt|;
comment|/**< PDB widx2 */
else|#
directive|else
name|uint64_t
name|widx2
range|:
literal|17
decl_stmt|;
name|uint64_t
name|ridx2
range|:
literal|17
decl_stmt|;
name|uint64_t
name|widx
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug13_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug13_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
comment|/**< Data pointer */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug13_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug13
name|cvmx_pko_mem_debug13_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug14  *  * Notes:  * Internal per-port state intended for debug use only - pko.prt.psb.save[63:0]  * This CSR is a memory of 132 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug14
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug14_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug14_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|ridx
range|:
literal|17
decl_stmt|;
comment|/**< PDB ridx */
else|#
directive|else
name|uint64_t
name|ridx
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug14_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug14_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Command words */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_mem_debug14_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug14_cn52xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug14
name|cvmx_pko_mem_debug14_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug2  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.head[63:0]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
comment|/**< Data pointer */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug2
name|cvmx_pko_mem_debug2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug3  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.resp[63:0]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug3_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
comment|/**< "I"  value used for free operation */
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Back value used for free operation */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Pool value used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Size in bytes */
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
comment|/**< Data pointer */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|i
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug3_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug3_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< WorkQ data or Store0 pointer */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug3_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug3
name|cvmx_pko_mem_debug3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug4  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.state[63:0]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug4_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< WorkQ data or Store0 pointer */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug4_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug4_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|cmnd_segs
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_off
range|:
literal|6
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|uid
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|dread_sop
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|init_dwrite
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|chk_once
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_off_max
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_off
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_base
range|:
literal|8
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|major
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|major
range|:
literal|3
decl_stmt|;
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qid_base
range|:
literal|8
decl_stmt|;
name|uint64_t
name|qid_off
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qid_off_max
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_once
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_dwrite
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dread_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cmnd_off
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cmnd_segs
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pko_mem_debug4_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_off
range|:
literal|16
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_segs
range|:
literal|6
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_off
range|:
literal|6
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|uid
range|:
literal|2
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|dread_sop
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|init_dwrite
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|chk_once
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|major
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|major
range|:
literal|3
decl_stmt|;
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_once
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_dwrite
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dread_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uid
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cmnd_off
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cmnd_segs
range|:
literal|6
decl_stmt|;
name|uint64_t
name|curr_off
range|:
literal|16
decl_stmt|;
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_mem_debug4_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug4_cn52xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug4
name|cvmx_pko_mem_debug4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug5  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.state[127:64]  * This CSR is a memory of 12 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug5_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug5_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|dwri_mod
range|:
literal|1
decl_stmt|;
comment|/**< Dwrite mod */
name|uint64_t
name|dwri_sop
range|:
literal|1
decl_stmt|;
comment|/**< Dwrite sop needed */
name|uint64_t
name|dwri_len
range|:
literal|1
decl_stmt|;
comment|/**< Dwrite len */
name|uint64_t
name|dwri_cnt
range|:
literal|13
decl_stmt|;
comment|/**< Dwrite count */
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
comment|/**< Copy of cmnd.size */
name|uint64_t
name|uid
range|:
literal|1
decl_stmt|;
comment|/**< UID */
name|uint64_t
name|xfer_wor
range|:
literal|1
decl_stmt|;
comment|/**< Transfer work needed */
name|uint64_t
name|xfer_dwr
range|:
literal|1
decl_stmt|;
comment|/**< Transfer dwrite needed */
name|uint64_t
name|cbuf_fre
range|:
literal|1
decl_stmt|;
comment|/**< Cbuf needs free */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
comment|/**< Checksum mode */
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
comment|/**< Port is active */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Current QOS round */
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
comment|/**< Buffer read  index for QCB */
name|uint64_t
name|qid_off
range|:
literal|3
decl_stmt|;
comment|/**< Offset to be added to QID_BASE for current queue */
name|uint64_t
name|qid_base
range|:
literal|7
decl_stmt|;
comment|/**< Absolute QID of the queue array base =&QUEUES[0] */
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
comment|/**< State wait when set */
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
comment|/**< State minor code */
name|uint64_t
name|major
range|:
literal|4
decl_stmt|;
comment|/**< State major code */
else|#
directive|else
name|uint64_t
name|major
range|:
literal|4
decl_stmt|;
name|uint64_t
name|minor
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qid_base
range|:
literal|7
decl_stmt|;
name|uint64_t
name|qid_off
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chk_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cbuf_fre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xfer_dwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xfer_wor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmnd_siz
range|:
literal|16
decl_stmt|;
name|uint64_t
name|dwri_cnt
range|:
literal|13
decl_stmt|;
name|uint64_t
name|dwri_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dwri_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dwri_mod
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug5_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug5_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|curr_ptr
range|:
literal|29
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_siz
range|:
literal|16
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_off
range|:
literal|16
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|cmnd_segs
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|cmnd_segs
range|:
literal|3
decl_stmt|;
name|uint64_t
name|curr_off
range|:
literal|16
decl_stmt|;
name|uint64_t
name|curr_siz
range|:
literal|16
decl_stmt|;
name|uint64_t
name|curr_ptr
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pko_mem_debug5_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|nxt_inflt
range|:
literal|6
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_ptr
range|:
literal|40
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
name|uint64_t
name|curr_ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|nxt_inflt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_mem_debug5_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug5_cn50xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug5_cn63xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ptp
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|major_3
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|nxt_inflt
range|:
literal|6
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_ptr
range|:
literal|40
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|curr_siz
range|:
literal|8
decl_stmt|;
name|uint64_t
name|curr_ptr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|nxt_inflt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|major_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pko_mem_debug5_cn63xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug5
name|cvmx_pko_mem_debug5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug6  *  * Notes:  * Internal per-port state intended for debug use only - pko_prt_psb.port[63:0]  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug6_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|qid_offres
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_offths
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preempted
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|statc
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_offmax
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|qid_offmax
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|statc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preempted
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qid_offths
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qid_offres
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug6_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|qid_offm
range|:
literal|3
decl_stmt|;
comment|/**< Qid offset max */
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Static port when set */
name|uint64_t
name|work_min
range|:
literal|3
decl_stmt|;
comment|/**< Work minor */
name|uint64_t
name|dwri_chk
range|:
literal|1
decl_stmt|;
comment|/**< Dwrite checksum mode */
name|uint64_t
name|dwri_uid
range|:
literal|1
decl_stmt|;
comment|/**< Dwrite UID */
name|uint64_t
name|dwri_mod
range|:
literal|2
decl_stmt|;
comment|/**< Dwrite mod */
else|#
directive|else
name|uint64_t
name|dwri_mod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dwri_uid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dwri_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|work_min
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qid_offm
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug6_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug6_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|curr_ptr
range|:
literal|11
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|curr_ptr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pko_mem_debug6_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|qid_offres
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_offths
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|preempted
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|statc
range|:
literal|1
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_offmax
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_off
range|:
literal|4
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|qid_base
range|:
literal|8
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|qid_base
range|:
literal|8
decl_stmt|;
name|uint64_t
name|qid_off
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qid_offmax
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qcb_ridx
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|statc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|active
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preempted
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qid_offths
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qid_offres
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_mem_debug6_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug6_cn52xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug6
name|cvmx_pko_mem_debug6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug7  *  * Notes:  * Internal per-queue state intended for debug use only - pko_prt_qsb.state[63:0]  * This CSR is a memory of 256 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug7_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< This queue is the last (tail) in the queue array */
name|uint64_t
name|reserved_0_57
range|:
literal|58
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_57
range|:
literal|58
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug7_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
comment|/**< Calculated DWB count used for free operation */
name|uint64_t
name|start
range|:
literal|33
decl_stmt|;
comment|/**< Calculated start address used for free operation */
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
comment|/**< Packet length in bytes */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|16
decl_stmt|;
name|uint64_t
name|start
range|:
literal|33
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug7_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug7_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< This queue is the last (tail) in the queue array */
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
comment|/**< Command buffer remaining size in words */
name|uint64_t
name|buf_ptr
range|:
literal|33
decl_stmt|;
comment|/**< Command word pointer */
name|uint64_t
name|qcb_widx
range|:
literal|6
decl_stmt|;
comment|/**< Buffer write index for QCB */
name|uint64_t
name|qcb_ridx
range|:
literal|6
decl_stmt|;
comment|/**< Buffer read  index for QCB */
else|#
directive|else
name|uint64_t
name|qcb_ridx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qcb_widx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|buf_ptr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug7_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug7
name|cvmx_pko_mem_debug7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug8  *  * Notes:  * Internal per-queue state intended for debug use only - pko_prt_qsb.state[91:64]  * This CSR is a memory of 256 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug8
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug8_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< This queue is the last (tail) in the queue array */
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
comment|/**< Command buffer remaining size in words */
name|uint64_t
name|reserved_0_44
range|:
literal|45
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_44
range|:
literal|45
decl_stmt|;
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug8_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< This queue is the last (tail) in the queue array */
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
comment|/**< Command buffer remaining size in words */
name|uint64_t
name|buf_ptr
range|:
literal|33
decl_stmt|;
comment|/**< Command word pointer */
name|uint64_t
name|qcb_widx
range|:
literal|6
decl_stmt|;
comment|/**< Buffer write index for QCB */
name|uint64_t
name|qcb_ridx
range|:
literal|6
decl_stmt|;
comment|/**< Buffer read  index for QCB */
else|#
directive|else
name|uint64_t
name|qcb_ridx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qcb_widx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|buf_ptr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|buf_siz
range|:
literal|13
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug8_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug8_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
comment|/**< Doorbell count */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Static priority */
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
comment|/**< Static tail */
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
comment|/**< Static priority */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pko_mem_debug8_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
comment|/**< Preempter */
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
comment|/**< Doorbell count */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
comment|/**< Preemptee */
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Static priority */
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
comment|/**< Static tail */
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
comment|/**< Static priority */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|preemptee
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|preempter
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_mem_debug8_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug8_cn52xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug8
name|cvmx_pko_mem_debug8_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_debug9  *  * Notes:  * Internal per-port state intended for debug use only - pko.dat.ptr.ptrs0, pko.dat.ptr.ptrs3  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_debug9
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug9_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs0
range|:
literal|17
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_31
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ptrs0
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_mem_debug9_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
comment|/**< Doorbell count */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
comment|/**< reads as zero (S_TAIL cannot be read) */
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
comment|/**< reads as zero (STATIC_Q cannot be read) */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_mem_debug9_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug9_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
comment|/**< Doorbell count */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Static priority (port) */
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
comment|/**< Static tail */
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
comment|/**< Static priority */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< QOS mask to enable the queue when set */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_pko_mem_debug9_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_mem_debug9_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs0
range|:
literal|17
decl_stmt|;
comment|/**< Internal state */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs3
range|:
literal|17
decl_stmt|;
comment|/**< Internal state */
else|#
directive|else
name|uint64_t
name|ptrs3
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ptrs0
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_debug9_cn50xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_debug9
name|cvmx_pko_mem_debug9_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_port_ptrs  *  * Notes:  * Sets the port to engine mapping, per port.  Ports marked as static priority need not be contiguous,  * but they must be the lowest numbered PIDs mapped to this EID and must have QOS_MASK=0xff.  If EID==8  * or EID==9, then PID[1:0] is used to direct the packet to the correct port on that interface.  * EID==15 can be used for unused PKO-internal ports.  * BP_PORT==63 means that the PKO-internal port is not backpressured.  * BP_PORTs are assumed to belong to an interface as follows:  *   42<= BP_PORT< 44 -> srio       interface 1  *   40<= BP_PORT< 42 -> srio       interface 0  *   36<= BP_PORT< 40 -> loopback   interface  *   32<= BP_PORT< 36 -> PCIe       interface  *   0<= BP_PORT< 16 -> SGMII/Xaui interface 0  *  * Note that the SRIO interfaces do not actually provide backpressure.  Thus, ports that use  * 40<= BP_PORT< 44 for backpressure will never be backpressured.  *  * The reset configuration is the following:  *   PID EID(ext port) BP_PORT QOS_MASK STATIC_P  *   -------------------------------------------  *     0   0( 0)             0     0xff        0  *     1   1( 1)             1     0xff        0  *     2   2( 2)             2     0xff        0  *     3   3( 3)             3     0xff        0  *     4   0( 0)             4     0xff        0  *     5   1( 1)             5     0xff        0  *     6   2( 2)             6     0xff        0  *     7   3( 3)             7     0xff        0  *     8   0( 0)             8     0xff        0  *     9   1( 1)             9     0xff        0  *    10   2( 2)            10     0xff        0  *    11   3( 3)            11     0xff        0  *    12   0( 0)            12     0xff        0  *    13   1( 1)            13     0xff        0  *    14   2( 2)            14     0xff        0  *    15   3( 3)            15     0xff        0  *   -------------------------------------------  *    16   0( 0)             0     0xff        0  *    17   1( 1)             1     0xff        0  *    18   2( 2)             2     0xff        0  *    19   3( 3)             3     0xff        0  *    20   0( 0)             4     0xff        0  *    21   1( 1)             5     0xff        0  *    22   2( 2)             6     0xff        0  *    23   3( 3)             7     0xff        0  *    24   0( 0)             8     0xff        0  *    25   1( 1)             9     0xff        0  *    26   2( 2)            10     0xff        0  *    27   3( 3)            11     0xff        0  *    28   0( 0)            12     0xff        0  *    29   1( 1)            13     0xff        0  *    30   2( 2)            14     0xff        0  *    31   3( 3)            15     0xff        0  *   -------------------------------------------  *    32   8(32)            32     0xff        0  *    33   8(33)            33     0xff        0  *    34   8(34)            34     0xff        0  *    35   8(35)            35     0xff        0  *   -------------------------------------------  *    36   9(36)            36     0xff        0  *    37   9(37)            37     0xff        0  *    38   9(38)            38     0xff        0  *    39   9(39)            39     0xff        0  *   -------------------------------------------  *    40  10(40)            40     0xff        0  *    41  10(41)            41     0xff        0  *   -------------------------------------------  *    42  11(42)            42     0xff        0  *    43  11(43)            43     0xff        0  *  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_port_ptrs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_port_ptrs_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Set if this PID has static priority */
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to control priority across 8 QOS rounds */
name|uint64_t
name|reserved_16_52
range|:
literal|37
decl_stmt|;
name|uint64_t
name|bp_port
range|:
literal|6
decl_stmt|;
comment|/**< PID listens to BP_PORT for per-packet backpressure                                                          Legal BP_PORTs: 0-15, 32-43, 63 (63 means no BP) */
name|uint64_t
name|eid
range|:
literal|4
decl_stmt|;
comment|/**< Engine ID to which this port is mapped                                                          Legal EIDs: 0-3, 8-11, 15 (15 only if port not used) */
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
comment|/**< Port ID[5:0] */
else|#
directive|else
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|eid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp_port
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_16_52
range|:
literal|37
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_ptrs_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_port_ptrs
name|cvmx_pko_mem_port_ptrs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_port_qos  *  * Notes:  * Sets the QOS mask, per port.  These QOS_MASK bits are logically and physically the same QOS_MASK  * bits in PKO_MEM_PORT_PTRS.  This CSR address allows the QOS_MASK bits to be written during PKO  * operation without affecting any other port state.  The engine to which port PID is mapped is engine  * EID.  Note that the port to engine mapping must be the same as was previously programmed via the  * PKO_MEM_PORT_PTRS CSR.  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_port_qos
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_port_qos_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to control priority across 8 QOS rounds */
name|uint64_t
name|reserved_10_52
range|:
literal|43
decl_stmt|;
name|uint64_t
name|eid
range|:
literal|4
decl_stmt|;
comment|/**< Engine ID to which this port is mapped                                                          Legal EIDs: 0-3, 8-11 */
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
comment|/**< Port ID[5:0] */
else|#
directive|else
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|eid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_10_52
range|:
literal|43
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_qos_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_port_qos
name|cvmx_pko_mem_port_qos_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_port_rate0  *  * Notes:  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_port_rate0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_port_rate0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|rate_word
range|:
literal|19
decl_stmt|;
comment|/**< Rate limiting adder per 8 byte */
name|uint64_t
name|rate_pkt
range|:
literal|24
decl_stmt|;
comment|/**< Rate limiting adder per packet */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
comment|/**< Port ID[5:0] */
else|#
directive|else
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rate_pkt
range|:
literal|24
decl_stmt|;
name|uint64_t
name|rate_word
range|:
literal|19
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_port_rate0
name|cvmx_pko_mem_port_rate0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_port_rate1  *  * Notes:  * Writing PKO_MEM_PORT_RATE1[PID,RATE_LIM] has the side effect of setting the corresponding  * accumulator to zero.  * This CSR is a memory of 44 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_port_rate1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_port_rate1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rate_lim
range|:
literal|24
decl_stmt|;
comment|/**< Rate limiting accumulator limit */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
comment|/**< Port ID[5:0] */
else|#
directive|else
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rate_lim
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_port_rate1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_port_rate1
name|cvmx_pko_mem_port_rate1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_queue_ptrs  *  * Notes:  * Sets the queue to port mapping and the initial command buffer pointer, per queue  * Each queue may map to at most one port.  No more than 16 queues may map to a port.  The set of  * queues that is mapped to a port must be a contiguous array of queues.  The port to which queue QID  * is mapped is port PID.  The index of queue QID in port PID's queue list is IDX.  The last queue in  * port PID's queue array must have its TAIL bit set.  Unused queues must be mapped to port 63.  * STATIC_Q marks queue QID as having static priority.  STATIC_P marks the port PID to which QID is  * mapped as having at least one queue with static priority.  If any QID that maps to PID has static  * priority, then all QID that map to PID must have STATIC_P set.  Queues marked as static priority  * must be contiguous and begin at IDX 0.  The last queue that is marked as having static priority  * must have its S_TAIL bit set.  * This CSR is a memory of 256 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_queue_ptrs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_queue_ptrs_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
comment|/**< Set if this QID is the tail of the static queues */
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
comment|/**< Set if any QID in this PID has static priority */
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
comment|/**< Set if this QID has static priority */
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to control priority across 8 QOS rounds */
name|uint64_t
name|buf_ptr
range|:
literal|36
decl_stmt|;
comment|/**< Command buffer pointer,<23:17> MBZ */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set if this QID is the tail of the queue array */
name|uint64_t
name|index
range|:
literal|3
decl_stmt|;
comment|/**< Index[2:0] (distance from head) in the queue array */
name|uint64_t
name|port
range|:
literal|6
decl_stmt|;
comment|/**< Port ID to which this queue is mapped */
name|uint64_t
name|queue
range|:
literal|7
decl_stmt|;
comment|/**< Queue ID[6:0] */
else|#
directive|else
name|uint64_t
name|queue
range|:
literal|7
decl_stmt|;
name|uint64_t
name|port
range|:
literal|6
decl_stmt|;
name|uint64_t
name|index
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|buf_ptr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|static_q
range|:
literal|1
decl_stmt|;
name|uint64_t
name|static_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s_tail
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_ptrs_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_queue_ptrs
name|cvmx_pko_mem_queue_ptrs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_mem_queue_qos  *  * Notes:  * Sets the QOS mask, per queue.  These QOS_MASK bits are logically and physically the same QOS_MASK  * bits in PKO_MEM_QUEUE_PTRS.  This CSR address allows the QOS_MASK bits to be written during PKO  * operation without affecting any other queue state.  The port to which queue QID is mapped is port  * PID.  Note that the queue to port mapping must be the same as was previously programmed via the  * PKO_MEM_QUEUE_PTRS CSR.  * This CSR is a memory of 256 entries, and thus, the PKO_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  A read of any entry that has not been  * previously written is illegal and will result in unpredictable CSR read data.  */
end_comment

begin_union
union|union
name|cvmx_pko_mem_queue_qos
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_mem_queue_qos_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to control priority across 8 QOS rounds */
name|uint64_t
name|reserved_13_52
range|:
literal|40
decl_stmt|;
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
comment|/**< Port ID to which this queue is mapped */
name|uint64_t
name|qid
range|:
literal|7
decl_stmt|;
comment|/**< Queue ID */
else|#
directive|else
name|uint64_t
name|qid
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_13_52
range|:
literal|40
decl_stmt|;
name|uint64_t
name|qos_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_mem_queue_qos_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_mem_queue_qos
name|cvmx_pko_mem_queue_qos_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_bist_result  *  * Notes:  * Access to the internal BiST results  * Each bit is the BiST result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_bist_result_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_bist_result_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|psb2
range|:
literal|5
decl_stmt|;
comment|/**< BiST result of the PSB   memories (0=pass, !0=fail) */
name|uint64_t
name|count
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the COUNT memories (0=pass, !0=fail) */
name|uint64_t
name|rif
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the RIF   memories (0=pass, !0=fail) */
name|uint64_t
name|wif
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the WIF   memories (0=pass, !0=fail) */
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the NCB   memories (0=pass, !0=fail) */
name|uint64_t
name|out
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the OUT   memories (0=pass, !0=fail) */
name|uint64_t
name|crc
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the CRC   memories (0=pass, !0=fail) */
name|uint64_t
name|chk
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the CHK   memories (0=pass, !0=fail) */
name|uint64_t
name|qsb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of the QSB   memories (0=pass, !0=fail) */
name|uint64_t
name|qcb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of the QCB   memories (0=pass, !0=fail) */
name|uint64_t
name|pdb
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of the PDB   memories (0=pass, !0=fail) */
name|uint64_t
name|psb
range|:
literal|7
decl_stmt|;
comment|/**< BiST result of the PSB   memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|psb
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pdb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qcb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qsb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|count
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psb2
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_reg_bist_result_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pko_reg_bist_result_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|csr
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of CSR      memories (0=pass, !0=fail) */
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of IOB      memories (0=pass, !0=fail) */
name|uint64_t
name|out_crc
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_CRC  memories (0=pass, !0=fail) */
name|uint64_t
name|out_ctl
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of OUT_CTL  memories (0=pass, !0=fail) */
name|uint64_t
name|out_sta
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_STA  memories (0=pass, !0=fail) */
name|uint64_t
name|out_wif
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_WIF  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_chk
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of PRT_CHK  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_nxt
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of PRT_NXT  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_psb
range|:
literal|6
decl_stmt|;
comment|/**< BiST result of PRT_PSB  memories (0=pass, !0=fail) */
name|uint64_t
name|ncb_inb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of NCB_INB  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_qcb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of PRT_QCB  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_qsb
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of PRT_QSB  memories (0=pass, !0=fail) */
name|uint64_t
name|dat_dat
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of DAT_DAT  memories (0=pass, !0=fail) */
name|uint64_t
name|dat_ptr
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of DAT_PTR  memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|dat_ptr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dat_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt_qsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|prt_qcb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ncb_inb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prt_psb
range|:
literal|6
decl_stmt|;
name|uint64_t
name|prt_nxt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prt_chk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out_wif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out_sta
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out_crc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pko_reg_bist_result_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|csr
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of CSR      memories (0=pass, !0=fail) */
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of IOB      memories (0=pass, !0=fail) */
name|uint64_t
name|out_dat
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_DAT  memories (0=pass, !0=fail) */
name|uint64_t
name|out_ctl
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of OUT_CTL  memories (0=pass, !0=fail) */
name|uint64_t
name|out_sta
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_STA  memories (0=pass, !0=fail) */
name|uint64_t
name|out_wif
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of OUT_WIF  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_chk
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of PRT_CHK  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_nxt
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of PRT_NXT  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_psb
range|:
literal|8
decl_stmt|;
comment|/**< BiST result of PRT_PSB  memories (0=pass, !0=fail) */
name|uint64_t
name|ncb_inb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of NCB_INB  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_qcb
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of PRT_QCB  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_qsb
range|:
literal|3
decl_stmt|;
comment|/**< BiST result of PRT_QSB  memories (0=pass, !0=fail) */
name|uint64_t
name|prt_ctl
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of PRT_CTL  memories (0=pass, !0=fail) */
name|uint64_t
name|dat_dat
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of DAT_DAT  memories (0=pass, !0=fail) */
name|uint64_t
name|dat_ptr
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of DAT_PTR  memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|dat_ptr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dat_dat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prt_ctl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prt_qsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|prt_qcb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ncb_inb
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prt_psb
range|:
literal|8
decl_stmt|;
name|uint64_t
name|prt_nxt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prt_chk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out_wif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out_sta
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out_ctl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out_dat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_reg_bist_result_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn50xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_bist_result_cn52xx
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_bist_result
name|cvmx_pko_reg_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_cmd_buf  *  * Notes:  * Sets the command buffer parameters  * The size of the command buffer segments is measured in uint64s.  The pool specifies (1 of 8 free  * lists to be used when freeing command buffer segments.  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_cmd_buf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_cmd_buf_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free command buffer segments */
name|uint64_t
name|reserved_13_19
range|:
literal|7
decl_stmt|;
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
comment|/**< Number of uint64s per command buffer segment */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_13_19
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_cmd_buf_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_cmd_buf
name|cvmx_pko_reg_cmd_buf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_crc_ctl#  *  * Notes:  * Controls datapath reflection when calculating CRC  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_crc_ctlx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_crc_ctlx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|invres
range|:
literal|1
decl_stmt|;
comment|/**< Invert the result */
name|uint64_t
name|refin
range|:
literal|1
decl_stmt|;
comment|/**< Reflect the bits in each byte.                                                           Byte order does not change.                                                          - 0: CRC is calculated MSB to LSB                                                          - 1: CRC is calculated MLB to MSB */
else|#
directive|else
name|uint64_t
name|refin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|invres
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_crc_ctlx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ctlx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ctlx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ctlx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_crc_ctlx
name|cvmx_pko_reg_crc_ctlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_crc_enable  *  * Notes:  * Enables CRC for the GMX ports.  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_crc_enable
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_crc_enable_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|32
decl_stmt|;
comment|/**< Mask for ports 31-0 to enable CRC                                                          Mask bit==0 means CRC not enabled                                                          Mask bit==1 means CRC     enabled                                                          Note that CRC should be enabled only when using SPI4.2 */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_crc_enable_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_enable_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_enable_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_enable_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_crc_enable
name|cvmx_pko_reg_crc_enable_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_crc_iv#  *  * Notes:  * Determines the IV used by the CRC algorithm  * * PKO_CRC_IV  *  PKO_CRC_IV controls the initial state of the CRC algorithm.  Octane can  *  support a wide range of CRC algorithms and as such, the IV must be  *  carefully constructed to meet the specific algorithm.  The code below  *  determines the value to program into Octane based on the algorthim's IV  *  and width.  In the case of Octane, the width should always be 32.  *  *  PKO_CRC_IV0 sets the IV for ports 0-15 while PKO_CRC_IV1 sets the IV for  *  ports 16-31.  *  *   @verbatim  *   unsigned octane_crc_iv(unsigned algorithm_iv, unsigned poly, unsigned w)  *   [  *     int i;  *     int doit;  *     unsigned int current_val = algorithm_iv;  *  *     for(i = 0; i< w; i++) [  *       doit = current_val& 0x1;  *  *       if(doit) current_val ^= poly;  *       assert(!(current_val& 0x1));  *  *       current_val = (current_val>> 1) | (doit<< (w-1));  *     ]  *  *     return current_val;  *   ]  *   @endverbatim  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_crc_ivx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_crc_ivx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iv
range|:
literal|32
decl_stmt|;
comment|/**< IV used by the CRC algorithm.  Default is FCS32. */
else|#
directive|else
name|uint64_t
name|iv
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_crc_ivx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ivx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ivx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_crc_ivx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_crc_ivx
name|cvmx_pko_reg_crc_ivx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_debug0  *  * Notes:  * Note that this CSR is present only in chip revisions beginning with pass2.  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_debug0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
comment|/**< Various assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_debug0_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|asserts
range|:
literal|17
decl_stmt|;
comment|/**< Various assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_reg_debug0_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_debug0
name|cvmx_pko_reg_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_debug1  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_debug1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_debug1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
comment|/**< Various assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_debug1
name|cvmx_pko_reg_debug1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_debug2  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_debug2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_debug2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
comment|/**< Various assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_debug2
name|cvmx_pko_reg_debug2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_debug3  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_debug3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_debug3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
comment|/**< Various assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_debug3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_debug3
name|cvmx_pko_reg_debug3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_engine_inflight  *  * Notes:  * Sets the maximum number of inflight packets, per engine.  Values greater than 4 are illegal.  * Setting an engine's value to 0 effectively stops the engine.  * Note that engines 4-7 do not exist  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_engine_inflight
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_engine_inflight_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|engine11
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine11 */
name|uint64_t
name|engine10
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine10 */
name|uint64_t
name|engine9
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine9 */
name|uint64_t
name|engine8
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine8 */
name|uint64_t
name|engine7
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine6
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine5
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine4
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine3
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine3 */
name|uint64_t
name|engine2
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine2 */
name|uint64_t
name|engine1
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine1 */
name|uint64_t
name|engine0
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine0 */
else|#
directive|else
name|uint64_t
name|engine0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine9
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_engine_inflight_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|engine9
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine9 */
name|uint64_t
name|engine8
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine8 */
name|uint64_t
name|engine7
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine6
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine5
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine4
range|:
literal|4
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|engine3
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine3 */
name|uint64_t
name|engine2
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine2 */
name|uint64_t
name|engine1
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine1 */
name|uint64_t
name|engine0
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight packets for engine0 */
else|#
directive|else
name|uint64_t
name|engine0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|engine9
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_reg_engine_inflight_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_inflight_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_inflight_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_inflight_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_inflight_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_engine_inflight
name|cvmx_pko_reg_engine_inflight_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_engine_thresh  *  * Notes:  * When not enabled, packet data may be sent as soon as it is written into PKO's internal buffers.  * When enabled and the packet fits entirely in the PKO's internal buffer, none of the packet data will  * be sent until all of it has been written into the PKO's internal buffer.  Note that a packet is  * considered to fit entirely only if the packet's size is<= BUFFER_SIZE-8.  When enabled and the  * packet does not fit entirely in the PKO's internal buffer, none of the packet data will be sent until  * at least BUFFER_SIZE-256 bytes of the packet have been written into the PKO's internal buffer  * (note that BUFFER_SIZE is a function of PKO_REG_GMX_PORT_MODE above)  * Note that engines 4-7 do not exist, so MASK<7:4> MBZ  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_engine_thresh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_engine_thresh_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|12
decl_stmt|;
comment|/**< Mask[n]=0 disables packet send threshold for engine n                                                          Mask[n]=1 enables  packet send threshold for engine n  $PR       NS                                                          Mask[n] MBZ for n = 4-7, as engines 4-7 dont exist */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_engine_thresh_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|10
decl_stmt|;
comment|/**< Mask[n]=0 disables packet send threshold for eng n                                                          Mask[n]=1 enables  packet send threshold for eng n     $PR       NS                                                          Mask[n] MBZ for n = 4-7, as engines 4-7 dont exist */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pko_reg_engine_thresh_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_thresh_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_thresh_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_thresh_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_engine_thresh_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_engine_thresh
name|cvmx_pko_reg_engine_thresh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_error  *  * Notes:  * Note that this CSR is present only in chip revisions beginning with pass2.  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_error_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|currzero
range|:
literal|1
decl_stmt|;
comment|/**< A packet data pointer has size=0 */
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< A doorbell count has overflowed */
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
comment|/**< Read parity error at port data buffer */
else|#
directive|else
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|currzero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_error_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< A doorbell count has overflowed */
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
comment|/**< Read parity error at port data buffer */
else|#
directive|else
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_reg_error_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_error_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_error
name|cvmx_pko_reg_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_flags  *  * Notes:  * When set, ENA_PKO enables the PKO picker and places the PKO in normal operation.  When set, ENA_DWB  * enables the use of DontWriteBacks during the buffer freeing operations.  When not set, STORE_BE inverts  * bits[2:0] of the STORE0 byte write address.  When set, RESET causes a 4-cycle reset pulse to the  * entire box.  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_flags
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_flags_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse */
name|uint64_t
name|store_be
range|:
literal|1
decl_stmt|;
comment|/**< Force STORE0 byte write address to big endian */
name|uint64_t
name|ena_dwb
range|:
literal|1
decl_stmt|;
comment|/**< Set to enable DontWriteBacks */
name|uint64_t
name|ena_pko
range|:
literal|1
decl_stmt|;
comment|/**< Set to enable the PKO picker */
else|#
directive|else
name|uint64_t
name|ena_pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|store_be
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_flags_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_flags
name|cvmx_pko_reg_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_gmx_port_mode  *  * Notes:  * The system has a total of 4 + 0 + 4 + 4 + 4 ports and 4 + 0 + 1 + 1 + 1 + 1 engines (GM0 + GM1 + PCI + LOOP + SRIO0 + SRIO1).  * This CSR sets the number of GMX0 ports and amount of local storage per engine.  * It has no effect on the number of ports or amount of local storage per engine for PCI, LOOP,  * SRIO0, or SRIO1.  When all GMX ports are used (MODE0=2), each GMX engine has 2.5kB of local  * storage.  Increasing the value of MODEn by 1 decreases the number of GMX ports by a power of 2 and  * increases the local storage per PKO GMX engine by a power of 2.  * Modes 0 and 1 are illegal and, if selected, are treated as mode 2.  *  * MODE[n] GM[0] PCI   LOOP  GM[0]                      PCI            LOOP            SRIO0           SRIO1  *         ports ports ports storage/engine             storage/engine storage/engine  storage/engine  storage/engine  * 0       4     4     4       2.5kB                    2.5kB          2.5kB           2.5kB           2.5kB  * 1       4     4     4       2.5kB                    2.5kB          2.5kB           2.5kB           2.5kB  * 2       4     4     4       2.5kB                    2.5kB          2.5kB           2.5kB           2.5kB  * 3       2     4     4       5.0kB                    2.5kB          2.5kB           2.5kB           2.5kB  * 4       1     4     4      10.0kB                    2.5kB          2.5kB           2.5kB           2.5kB  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_gmx_port_mode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_gmx_port_mode_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mode1
range|:
literal|3
decl_stmt|;
comment|/**< MBZ */
name|uint64_t
name|mode0
range|:
literal|3
decl_stmt|;
comment|/**< # of GM0 ports = 16>> MODE0, 0<= MODE0<= 4 */
else|#
directive|else
name|uint64_t
name|mode0
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mode1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_gmx_port_mode_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_gmx_port_mode
name|cvmx_pko_reg_gmx_port_mode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_int_mask  *  * Notes:  * When a mask bit is set, the corresponding interrupt is enabled.  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_int_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_int_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|currzero
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to PKO_REG_ERROR[2] above */
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to PKO_REG_ERROR[1] above */
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to PKO_REG_ERROR[0] above */
else|#
directive|else
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|currzero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pko_reg_int_mask_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to PKO_REG_ERROR[1] above */
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to PKO_REG_ERROR[0] above */
else|#
directive|else
name|uint64_t
name|parity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pko_reg_int_mask_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_int_mask_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_int_mask
name|cvmx_pko_reg_int_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_queue_mode  *  * Notes:  * Sets the number of queues and amount of local storage per queue  * The system has a total of 256 queues and (256*8) words of local command storage.  This CSR sets the  * number of queues that are used.  Increasing the value of MODE by 1 decreases the number of queues  * by a power of 2 and increases the local storage per queue by a power of 2.  * MODEn queues storage/queue  * 0     256     64B ( 8 words)  * 1     128    128B (16 words)  * 2      64    256B (32 words)  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_queue_mode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_queue_mode_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< # of queues = 256>> MODE, 0<= MODE<=2 */
else|#
directive|else
name|uint64_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_mode_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_queue_mode
name|cvmx_pko_reg_queue_mode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_queue_ptrs1  *  * Notes:  * This CSR is used with PKO_MEM_QUEUE_PTRS and PKO_MEM_QUEUE_QOS to allow access to queues 128-255  * and to allow up mapping of up to 16 queues per port.  When programming queues 128-255, the  * programming sequence must first write PKO_REG_QUEUE_PTRS1 and then write PKO_MEM_QUEUE_PTRS or  * PKO_MEM_QUEUE_QOS for each queue.  * See the descriptions of PKO_MEM_QUEUE_PTRS and PKO_MEM_QUEUE_QOS for further explanation of queue  * programming.  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_queue_ptrs1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_queue_ptrs1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|idx3
range|:
literal|1
decl_stmt|;
comment|/**< [3] of Index (distance from head) in the queue array */
name|uint64_t
name|qid7
range|:
literal|1
decl_stmt|;
comment|/**< [7] of Queue ID */
else|#
directive|else
name|uint64_t
name|qid7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idx3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_queue_ptrs1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_queue_ptrs1
name|cvmx_pko_reg_queue_ptrs1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_read_idx  *  * Notes:  * Provides the read index during a CSR read operation to any of the CSRs that are physically stored  * as memories.  The names of these CSRs begin with the prefix "PKO_MEM_".  * IDX[7:0] is the read index.  INC[7:0] is an increment that is added to IDX[7:0] after any CSR read.  * The intended use is to initially write this CSR such that IDX=0 and INC=1.  Then, the entire  * contents of a CSR memory can be read with consecutive CSR read commands.  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_read_idx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_read_idx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Index to use for next memory CSR read */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_read_idx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_read_idx
name|cvmx_pko_reg_read_idx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pko_reg_timestamp  *  * Notes:  * None.  *  */
end_comment

begin_union
union|union
name|cvmx_pko_reg_timestamp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pko_reg_timestamp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|wqe_word
range|:
literal|4
decl_stmt|;
comment|/**< Specifies the 8-byte word in the WQE to which a PTP                                                          timestamp is written.  Values 0 and 1 are illegal. */
else|#
directive|else
name|uint64_t
name|wqe_word
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pko_reg_timestamp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pko_reg_timestamp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pko_reg_timestamp
name|cvmx_pko_reg_timestamp_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

