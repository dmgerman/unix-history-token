begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware work queue timers.  * `*<hr>$Revision: 49448 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_TIM_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_TIM_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|CVMX_TIM_NUM_TIMERS
value|16
define|#
directive|define
name|CVMX_TIM_NUM_BUCKETS
value|2048
typedef|typedef
enum|enum
block|{
name|CVMX_TIM_STATUS_SUCCESS
init|=
literal|0
block|,
name|CVMX_TIM_STATUS_NO_MEMORY
init|=
operator|-
literal|1
block|,
name|CVMX_TIM_STATUS_TOO_FAR_AWAY
init|=
operator|-
literal|2
block|,
name|CVMX_TIM_STATUS_BUSY
init|=
operator|-
literal|3
block|}
name|cvmx_tim_status_t
typedef|;
comment|/**  * Each timer bucket contains a list of work queue entries to  * schedule when the timer fires. The list is implemented as  * a linked list of blocks. Each block contains an array of  * work queue entries followed by a next block pointer. Since  * these blocks are dynamically allocated off of a hardware  * memory pool, there actual size isn't known compile time.  * The next block pointer is stored in the last 8 bytes of  * the memory block.  */
typedef|typedef
struct|struct
name|cvmx_tim_entry_chunk
block|{
specifier|volatile
name|uint64_t
name|entries
index|[
literal|0
index|]
decl_stmt|;
block|}
name|cvmx_tim_entry_chunk_t
typedef|;
comment|/**  * Each timer contains an array of buckets. Each bucket  * represents the list of work queue entries that should be  * scheduled when the timer fires.  The first 3 entries are used  * byt the hardware.  */
typedef|typedef
struct|struct
block|{
specifier|volatile
name|uint64_t
name|first_chunk_addr
decl_stmt|;
specifier|volatile
name|uint32_t
name|num_entries
decl_stmt|;
comment|/**< Zeroed by HW after traversing list */
specifier|volatile
name|uint32_t
name|chunk_remainder
decl_stmt|;
comment|/**< Zeroed by HW after traversing list */
comment|// the remaining 16 bytes are not touched by hardware
specifier|volatile
name|cvmx_tim_entry_chunk_t
modifier|*
name|last_chunk
decl_stmt|;
name|uint64_t
name|pad
decl_stmt|;
block|}
name|cvmx_tim_bucket_entry_t
typedef|;
comment|/**  * Structure representing an individual timer. Each timer has  * a timer period, a memory management pool, and a list of  * buckets.  */
typedef|typedef
struct|struct
block|{
name|cvmx_tim_bucket_entry_t
modifier|*
name|bucket
decl_stmt|;
comment|/**< The timer buckets. Array of [CVMX_TIM_NUM_TIMERS][CVMX_TIM_NUM_BUCKETS] */
name|uint64_t
name|tick_cycles
decl_stmt|;
comment|/**< How long a bucket represents */
name|uint64_t
name|start_time
decl_stmt|;
comment|/**< Time the timer started in cycles */
name|uint32_t
name|bucket_shift
decl_stmt|;
comment|/**< How long a bucket represents in ms */
name|uint32_t
name|num_buckets
decl_stmt|;
comment|/**< How many buckets per wheel */
name|uint32_t
name|max_ticks
decl_stmt|;
comment|/**< maximum number of ticks allowed for timer */
block|}
name|cvmx_tim_t
typedef|;
comment|/**  * Structure used to store state information needed to delete  * an already scheduled timer entry. An instance of this  * structure must be passed to cvmx_tim_add_entry in order  * to be able to delete an entry later with  * cvmx_tim_delete_entry.  *  * NOTE: This structure should be considered opaque by the application,  * and the application should not access its members  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|commit_cycles
decl_stmt|;
comment|/**< After this time the timer can't be changed */
name|uint64_t
modifier|*
name|timer_entry_ptr
decl_stmt|;
comment|/**< Where the work entry is. Zero this                                             location to delete the entry */
block|}
name|cvmx_tim_delete_t
typedef|;
comment|/**  * Global structure holding the state of all timers.  */
specifier|extern
name|cvmx_tim_t
name|cvmx_tim
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
comment|/**  * Setup a timer for use. Must be called before the timer  * can be used.  *  * @param tick      Time between each bucket in microseconds. This must not be  *                  smaller than 1024/(clock frequency in MHz).  * @param max_ticks The maximum number of ticks the timer must be able  *                  to schedule in the future. There are guaranteed to be enough  *                  timer buckets such that:  *                  number of buckets>= max_ticks.  * @return Zero on success. Negative on error. Failures are possible  *         if the number of buckets needed is too large or memory  *         allocation fails for creating the buckets.  */
name|int
name|cvmx_tim_setup
parameter_list|(
name|uint64_t
name|tick
parameter_list|,
name|uint64_t
name|max_ticks
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/**  * Start the hardware timer processing  */
specifier|extern
name|void
name|cvmx_tim_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Stop the hardware timer processing. Timers stay configured.  */
specifier|extern
name|void
name|cvmx_tim_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Stop the timer. After this the timer must be setup again  * before use.  */
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
specifier|extern
name|void
name|cvmx_tim_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
comment|/**  * Add a work queue entry to the timer.  *  * @param work_entry Work queue entry to add.  * @param ticks_from_now  * @param delete_info  *                   Optional pointer where to store information needed to  *                   delete the timer entry. If non NULL information needed  *                   to delete the timer entry before it fires is stored here.  *                   If you don't need to be able to delete the timer, pass  *                   NULL.  * @return Result return code  */
specifier|static
specifier|inline
name|cvmx_tim_status_t
name|cvmx_tim_add_entry
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work_entry
parameter_list|,
name|uint64_t
name|ticks_from_now
parameter_list|,
name|cvmx_tim_delete_t
modifier|*
name|delete_info
parameter_list|)
block|{
name|cvmx_tim_bucket_entry_t
modifier|*
name|work_bucket_ptr
decl_stmt|;
name|uint64_t
name|current_bucket
decl_stmt|;
name|uint64_t
name|work_bucket
decl_stmt|;
specifier|volatile
name|uint64_t
modifier|*
name|tim_entry_ptr
decl_stmt|;
comment|/* pointer to wqe address in timer chunk */
name|uint64_t
name|entries_per_chunk
decl_stmt|;
specifier|const
name|uint64_t
name|cycles
init|=
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_TIM
argument_list|)
decl_stmt|;
comment|/* Get our reference time early for accuracy */
specifier|const
name|uint64_t
name|core_num
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
comment|/* One timer per processor, so use this to select */
comment|/* Make sure the specified time won't wrap our bucket list */
if|if
condition|(
name|ticks_from_now
operator|>
name|cvmx_tim
operator|.
name|max_ticks
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_tim_add_entry: Tried to schedule work too far away.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_TIM_STATUS_TOO_FAR_AWAY
return|;
block|}
comment|/* Since we have no way to synchronize, we can't update a timer that is         being used by the hardware. Two buckets forward should be safe */
if|if
condition|(
name|ticks_from_now
operator|<
literal|2
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_tim_add_entry: Tried to schedule work too soon. Delaying it.\n"
argument_list|)
expr_stmt|;
name|ticks_from_now
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Get the bucket this work queue entry should be in. Remember the bucket         array is circular */
name|current_bucket
operator|=
operator|(
operator|(
name|cycles
operator|-
name|cvmx_tim
operator|.
name|start_time
operator|)
operator|>>
name|cvmx_tim
operator|.
name|bucket_shift
operator|)
expr_stmt|;
name|work_bucket
operator|=
operator|(
operator|(
operator|(
name|ticks_from_now
operator|*
name|cvmx_tim
operator|.
name|tick_cycles
operator|)
operator|+
name|cycles
operator|-
name|cvmx_tim
operator|.
name|start_time
operator|)
operator|>>
name|cvmx_tim
operator|.
name|bucket_shift
operator|)
expr_stmt|;
name|work_bucket_ptr
operator|=
name|cvmx_tim
operator|.
name|bucket
operator|+
name|core_num
operator|*
name|cvmx_tim
operator|.
name|num_buckets
operator|+
operator|(
name|work_bucket
operator|&
operator|(
name|cvmx_tim
operator|.
name|num_buckets
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|entries_per_chunk
operator|=
operator|(
name|CVMX_FPA_TIMER_POOL_SIZE
operator|/
literal|8
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Check if we have room to add this entry into the existing list */
if|if
condition|(
name|work_bucket_ptr
operator|->
name|chunk_remainder
condition|)
block|{
comment|/* Adding the work entry to the end of the existing list */
name|tim_entry_ptr
operator|=
operator|&
operator|(
name|work_bucket_ptr
operator|->
name|last_chunk
operator|->
name|entries
index|[
name|entries_per_chunk
operator|-
name|work_bucket_ptr
operator|->
name|chunk_remainder
index|]
operator|)
expr_stmt|;
operator|*
name|tim_entry_ptr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|work_entry
argument_list|)
expr_stmt|;
name|work_bucket_ptr
operator|->
name|chunk_remainder
operator|--
expr_stmt|;
name|work_bucket_ptr
operator|->
name|num_entries
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Current list is either completely empty or completely full. We need             to allocate a new chunk for storing this work entry */
name|cvmx_tim_entry_chunk_t
modifier|*
name|new_chunk
init|=
operator|(
name|cvmx_tim_entry_chunk_t
operator|*
operator|)
name|cvmx_fpa_alloc
argument_list|(
name|CVMX_FPA_TIMER_POOL
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_chunk
operator|==
name|NULL
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_tim_add_entry: Failed to allocate memory for new chunk.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_TIM_STATUS_NO_MEMORY
return|;
block|}
comment|/* Does a chunk currently exist? We have to check num_entries since             the hardware doesn't NULL out the chunk pointers on free */
if|if
condition|(
name|work_bucket_ptr
operator|->
name|num_entries
condition|)
block|{
comment|/* This chunk must be appended to an existing list by putting             ** its address in the last spot of the existing chunk. */
name|work_bucket_ptr
operator|->
name|last_chunk
operator|->
name|entries
index|[
name|entries_per_chunk
index|]
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|new_chunk
argument_list|)
expr_stmt|;
name|work_bucket_ptr
operator|->
name|num_entries
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the very first chunk. Add it */
name|work_bucket_ptr
operator|->
name|first_chunk_addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|new_chunk
argument_list|)
expr_stmt|;
name|work_bucket_ptr
operator|->
name|num_entries
operator|=
literal|1
expr_stmt|;
block|}
name|work_bucket_ptr
operator|->
name|last_chunk
operator|=
name|new_chunk
expr_stmt|;
name|work_bucket_ptr
operator|->
name|chunk_remainder
operator|=
name|entries_per_chunk
operator|-
literal|1
expr_stmt|;
name|tim_entry_ptr
operator|=
operator|&
operator|(
name|new_chunk
operator|->
name|entries
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
name|tim_entry_ptr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|work_entry
argument_list|)
expr_stmt|;
block|}
comment|/* If the user supplied a delete info structure then fill it in */
if|if
condition|(
name|delete_info
condition|)
block|{
comment|/* It would be very bad to delete a timer entry after, or during the             timer's processing. During the processing could yield unpredicatable             results, but after would always be bad. Modifying the entry after             processing means we would be changing data in a buffer that has been             freed, and possible allocated again. For this reason we store a             commit cycle count in the delete structure. If we are after this             count we will refuse to delete the timer entry. */
name|delete_info
operator|->
name|commit_cycles
operator|=
name|cycles
operator|+
operator|(
name|ticks_from_now
operator|-
literal|2
operator|)
operator|*
name|cvmx_tim
operator|.
name|tick_cycles
expr_stmt|;
name|delete_info
operator|->
name|timer_entry_ptr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|tim_entry_ptr
expr_stmt|;
comment|/* Cast to non-volatile type */
block|}
name|CVMX_SYNCWS
expr_stmt|;
comment|/* Make sure the hardware timer unit can access valid data from L2 */
return|return
name|CVMX_TIM_STATUS_SUCCESS
return|;
block|}
endif|#
directive|endif
comment|/**  * Delete a timer entry scheduled using cvmx_tim_add_entry.  * Deleting a timer will fail if it has already triggered or  * might be in progress. The actual state of the work queue  * entry isn't changed. You need to dispose of it properly.  *  * @param delete_info  *               Structure passed to cvmx_tim_add_entry to store the  *               information needed to delete a timer entry.  * @return CVMX_TIM_STATUS_BUSY if the timer was not deleted, otherwise  *         CVMX_TIM_STATUS_SUCCESS.  */
specifier|static
specifier|inline
name|cvmx_tim_status_t
name|cvmx_tim_delete_entry
parameter_list|(
name|cvmx_tim_delete_t
modifier|*
name|delete_info
parameter_list|)
block|{
specifier|const
name|uint64_t
name|cycles
init|=
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_TIM
argument_list|)
decl_stmt|;
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|cycles
operator|-
name|delete_info
operator|->
name|commit_cycles
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Timer is far enough away. Safe to delete */
operator|*
name|delete_info
operator|->
name|timer_entry_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|CVMX_TIM_STATUS_SUCCESS
return|;
block|}
else|else
block|{
comment|/* Timer is passed the commit time. It cannot be stopped */
return|return
name|CVMX_TIM_STATUS_BUSY
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// __CVMX_TIM_H__
end_comment

end_unit

