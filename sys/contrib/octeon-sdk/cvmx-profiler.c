begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2011  Cavium Inc. (support@cavium.com). All rights  * reserved.  *   *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *    *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.  *  *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.  *  * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.  *  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ************************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to event profiler.  *  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-atomic.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-asm.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-profiler.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PROFILER_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|cvmx_safe_printf(fmt, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRINTF
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|CVMX_SHARED
specifier|static
name|event_counter_control_block_t
name|eccb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cvmx_config_block_t
modifier|*
name|pcpu_cfg_blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|read_percpu_block
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Set Interrupt IRQ line for Performance Counter  *  */
end_comment

begin_function
name|void
name|cvmx_update_perfcnt_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|cvmctl
decl_stmt|;
comment|/* Clear CvmCtl[IPPCI] bit and move the Performance Counter      * interrupt to IRQ 6      */
name|CVMX_MF_COP0
argument_list|(
name|cvmctl
argument_list|,
name|COP0_CVMCTL
argument_list|)
expr_stmt|;
name|cvmctl
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|7
operator|)
expr_stmt|;
name|cvmctl
operator||=
literal|6
operator|<<
literal|7
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|cvmctl
argument_list|,
name|COP0_CVMCTL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return the baseaddress of the namedblock   * @param buf_name  Name of Namedblock  *  * @return baseaddress of block on Success, NULL on failure.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|cvmx_get_memory_addr
parameter_list|(
specifier|const
name|char
modifier|*
name|buf_name
parameter_list|)
block|{
name|void
modifier|*
name|buffer_ptr
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|block_desc
init|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|buf_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_desc
condition|)
name|buffer_ptr
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|block_desc
operator|->
name|base_addr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buffer_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|buffer_ptr
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize the cpu block metadata.   *   * @param cpu	core no  * @param size	size of per cpu memory in named block  *  */
end_comment

begin_function
specifier|static
name|void
name|cvmx_init_pcpu_block
parameter_list|(
name|int
name|cpu
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|cvmx_get_memory_addr
argument_list|(
name|EVENT_BUFFER_BLOCK
argument_list|)
operator|+
operator|(
name|size
operator|*
name|cpu
operator|)
expr_stmt|;
name|assert
argument_list|(
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_ringbuf_t
modifier|*
name|cpu_buf
init|=
operator|(
name|cvmx_ringbuf_t
operator|*
operator|)
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
decl_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|max_samples
operator|=
operator|(
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
name|cvmx_cpu_event_block_t
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|cvmx_sample_entry_t
argument_list|)
operator|)
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|sample_count
operator|=
literal|0
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|sample_read
operator|=
literal|0
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
operator|=
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
operator|+
sizeof|sizeof
argument_list|(
name|cvmx_cpu_event_block_t
argument_list|)
operator|+
name|PADBYTES
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|head
operator|=
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|tail
operator|=
expr|\
name|cpu_buf
operator|->
name|pcpu_data
operator|=
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|end
operator|=
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
operator|+
name|size
expr_stmt|;
name|cvmx_atomic_set32
argument_list|(
operator|&
name|read_percpu_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Write per cpu mem base address info in to 'event config' named block,      * This info is needed by oct-remote-profile to get Per cpu memory       * base address of each core of the named block.      */
name|pcpu_cfg_blk
operator|=
operator|(
name|cvmx_config_block_t
operator|*
operator|)
name|eccb
operator|.
name|config_blk_base_addr
expr_stmt|;
name|pcpu_cfg_blk
operator|->
name|pcpu_base_addr
index|[
name|cpu
index|]
operator|=
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Retrieve the info from the 'event_config' named block.  *  * Here events value is read(as passed to oct-remote-profile) to reset perf   * counters on every Perf counter overflow.  *  */
end_comment

begin_function
specifier|static
name|void
name|cvmx_read_config_blk
parameter_list|(
name|void
parameter_list|)
block|{
name|eccb
operator|.
name|config_blk_base_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|cvmx_get_memory_addr
argument_list|(
name|EVENT_BUFFER_CONFIG_BLOCK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|eccb
operator|.
name|cfg_blk
operator|.
name|events
operator|)
argument_list|,
name|eccb
operator|.
name|config_blk_base_addr
operator|+
expr|\
name|offsetof
argument_list|(
name|cvmx_config_block_t
argument_list|,
name|events
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_atomic_set32
argument_list|(
operator|&
name|eccb
operator|.
name|read_cfg_blk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"cfg_blk.events=%lu, sample_count=%ld\n"
argument_list|,
name|eccb
operator|.
name|cfg_blk
operator|.
name|events
argument_list|,
name|eccb
operator|.
name|cfg_blk
operator|.
name|sample_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Add new sample to the buffer and increment the head pointer and   * global sample count(i.e sum total of samples collected on all cores)   *  */
end_comment

begin_function
specifier|static
name|void
name|cvmx_add_sample_to_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|epc
decl_stmt|;
name|int
name|cpu
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|epc
argument_list|,
name|COP0_EPC
argument_list|)
expr_stmt|;
name|cvmx_ringbuf_t
modifier|*
name|cpu_buf
init|=
operator|(
name|cvmx_ringbuf_t
operator|*
operator|)
name|eccb
operator|.
name|cfg_blk
operator|.
name|pcpu_base_addr
index|[
name|cpu
index|]
decl_stmt|;
comment|/*       * head/tail pointer can be NULL, and this case arises when oct-remote-profile is      * invoked afresh. To keep memory sane for current instance, we clear namedblock off       * previous data and this is accomplished by octeon_remote_write_mem from host.      */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
operator|!
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|head
operator|&&
operator|!
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|end
argument_list|)
condition|)
block|{
comment|/* Reread the event count as a different threshold val could be          * passed with profiler alongside --events flag */
name|cvmx_read_config_blk
argument_list|()
expr_stmt|;
name|cvmx_init_pcpu_block
argument_list|(
name|cpu
argument_list|,
name|EVENT_PERCPU_BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* In case of hitting end of buffer, reset head,data ptr to start */
if|if
condition|(
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|head
operator|==
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|end
condition|)
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|head
operator|=
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
operator|=
name|cpu_buf
operator|->
name|pcpu_data
expr_stmt|;
comment|/* Store the pc, respective core no.*/
name|cvmx_sample_entry_t
modifier|*
name|sample
init|=
operator|(
name|cvmx_sample_entry_t
operator|*
operator|)
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
decl_stmt|;
name|sample
operator|->
name|pc
operator|=
name|epc
expr_stmt|;
name|sample
operator|->
name|core
operator|=
name|cpu
expr_stmt|;
comment|/* Update Per CPU stats */
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|sample_count
operator|++
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|cvmx_sample_entry_t
argument_list|)
expr_stmt|;
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|head
operator|=
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|data
expr_stmt|;
comment|/* Increment the global sample count i.e sum total of samples on all cores*/
name|cvmx_atomic_add64
argument_list|(
operator|&
operator|(
name|pcpu_cfg_blk
operator|->
name|sample_count
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTF
argument_list|(
literal|"the core%d:pc 0x%016lx, sample_count=%ld\n"
argument_list|,
name|cpu
argument_list|,
name|sample
operator|->
name|pc
argument_list|,
name|cpu_buf
operator|->
name|pcpu_blk_info
operator|.
name|sample_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Reset performance counters  *  * @param pf     The performance counter Number (0, 1)  * @param events The threshold value for which interrupt has to be asserted  */
end_comment

begin_function
specifier|static
name|void
name|cvmx_reset_perf_counter
parameter_list|(
name|int
name|pf
parameter_list|,
name|uint64_t
name|events
parameter_list|)
block|{
name|uint64_t
name|pfc
decl_stmt|;
name|pfc
operator|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator|-
name|events
expr_stmt|;
if|if
condition|(
operator|!
name|pf
condition|)
block|{
name|CVMX_MT_COP0
argument_list|(
name|pfc
argument_list|,
name|COP0_PERFVALUE0
argument_list|)
expr_stmt|;
block|}
else|else
name|CVMX_MT_COP0
argument_list|(
name|pfc
argument_list|,
name|COP0_PERFVALUE1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvmx_collect_sample
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|eccb
operator|.
name|read_cfg_blk
condition|)
name|cvmx_read_config_blk
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_percpu_block
condition|)
name|cvmx_init_pcpu_block
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|,
name|EVENT_PERCPU_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|cvmx_add_sample_to_buffer
argument_list|()
expr_stmt|;
name|cvmx_reset_perf_counter
argument_list|(
literal|0
argument_list|,
name|eccb
operator|.
name|cfg_blk
operator|.
name|events
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

