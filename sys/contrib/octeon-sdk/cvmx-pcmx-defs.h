begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pcmx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pcmx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PCMX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PCMX_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_DMA_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_DMA_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_DMA_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010018ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_INT_ENA
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_INT_ENA(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_INT_ENA
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010020ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_INT_SUM
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_INT_SUM(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_INT_SUM
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010028ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010068ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010068ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXCNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXCNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXCNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010060ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100C0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100C8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100C8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100D0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100D0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100D8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100D8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100E0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100E0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100E8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100E8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK6(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100F0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK6
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100F0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXMSK7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXMSK7(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100F8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXMSK7
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100F8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_RXSTART
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_RXSTART(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_RXSTART
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010058ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TDM_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TDM_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TDM_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010010ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TDM_DBG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TDM_DBG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TDM_DBG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010030ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010050ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXCNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXCNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXCNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010048ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010080ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010088ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010088ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010090ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010090ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010098ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010098ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100A0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100A8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100A8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK6(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK6
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100B0ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXMSK7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXMSK7(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00010700000100B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXMSK7
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00010700000100B8ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCMX_TXSTART
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCMX_TXSTART(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000010040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCMX_TXSTART
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000010040ull) + ((offset)& 3) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pcm#_dma_cfg  */
end_comment

begin_union
union|union
name|cvmx_pcmx_dma_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_dma_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rdpend
range|:
literal|1
decl_stmt|;
comment|/**< If 0, no L2C read responses pending               |          NS                                                             1, L2C read responses are outstanding                                                          NOTE: When restarting after stopping a running TDM                                                          engine, software must wait for RDPEND to read 0                                                          before writing PCMn_TDM_CFG[ENABLE] to a 1 */
name|uint64_t
name|reserved_54_62
range|:
literal|9
decl_stmt|;
name|uint64_t
name|rxslots
range|:
literal|10
decl_stmt|;
comment|/**< Number of 8-bit slots to receive per frame        |          NS                                                          (number of slots in a receive superframe) */
name|uint64_t
name|reserved_42_43
range|:
literal|2
decl_stmt|;
name|uint64_t
name|txslots
range|:
literal|10
decl_stmt|;
comment|/**< Number of 8-bit slots to transmit per frame       |          NS                                                          (number of slots in a transmit superframe) */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rxst
range|:
literal|10
decl_stmt|;
comment|/**< Number of frame writes for interrupt              |          NS */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|useldt
range|:
literal|1
decl_stmt|;
comment|/**< If 0, use LDI command to read from L2C            |          NS                                                          1, use LDT command to read from L2C */
name|uint64_t
name|txrd
range|:
literal|10
decl_stmt|;
comment|/**< Number of frame reads for interrupt               |          NS */
name|uint64_t
name|fetchsiz
range|:
literal|4
decl_stmt|;
comment|/**< FETCHSIZ+1 timeslots are read when threshold is   |          NS                                                          reached. */
name|uint64_t
name|thresh
range|:
literal|4
decl_stmt|;
comment|/**< If number of bytes remaining in the DMA fifo is<=|          NS                                                          THRESH, initiate a fetch of timeslot data from the                                                          transmit memory region.                                                          NOTE: there are only 16B of buffer for each engine                                                          so the seetings for FETCHSIZ and THRESH must be                                                          such that the buffer will not be overrun:                                                           THRESH + min(FETCHSIZ + 1,TXSLOTS) MUST BE<= 16 */
else|#
directive|else
name|uint64_t
name|thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fetchsiz
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txrd
range|:
literal|10
decl_stmt|;
name|uint64_t
name|useldt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxst
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|txslots
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_42_43
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rxslots
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_54_62
range|:
literal|9
decl_stmt|;
name|uint64_t
name|rdpend
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_dma_cfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_dma_cfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_dma_cfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_dma_cfg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_dma_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_dma_cfg
name|cvmx_pcmx_dma_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_int_ena  */
end_comment

begin_union
union|union
name|cvmx_pcmx_int_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_int_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rxovf
range|:
literal|1
decl_stmt|;
comment|/**< Enable interrupt if RX byte overflows           |          NS */
name|uint64_t
name|txempty
range|:
literal|1
decl_stmt|;
comment|/**< Enable interrupt on TX byte empty               |          NS */
name|uint64_t
name|txrd
range|:
literal|1
decl_stmt|;
comment|/**< Enable DMA engine frame read interrupts         |          NS */
name|uint64_t
name|txwrap
range|:
literal|1
decl_stmt|;
comment|/**< Enable TX region wrap interrupts                |          NS */
name|uint64_t
name|rxst
range|:
literal|1
decl_stmt|;
comment|/**< Enable DMA engine frame store interrupts        |          NS */
name|uint64_t
name|rxwrap
range|:
literal|1
decl_stmt|;
comment|/**< Enable RX region wrap interrupts                |          NS */
name|uint64_t
name|fsyncextra
range|:
literal|1
decl_stmt|;
comment|/**< Enable FSYNC extra interrupts                   |          NS                                                          NOTE: FSYNCEXTRA errors are defined as an FSYNC                                                          found in the "wrong" spot of a frame given the                                                          programming of PCMn_CLK_CFG[NUMSLOTS] and                                                          PCMn_CLK_CFG[EXTRABIT]. */
name|uint64_t
name|fsyncmissed
range|:
literal|1
decl_stmt|;
comment|/**< Enable FSYNC missed interrupts                  |          NS                                                          NOTE: FSYNCMISSED errors are defined as an FSYNC                                                          missing from the correct spot in a frame given                                                          the programming of PCMn_CLK_CFG[NUMSLOTS] and                                                          PCMn_CLK_CFG[EXTRABIT]. */
else|#
directive|else
name|uint64_t
name|fsyncmissed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsyncextra
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxwrap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txwrap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_int_ena_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_ena_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_ena_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_ena_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_ena_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_int_ena
name|cvmx_pcmx_int_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_int_sum  */
end_comment

begin_union
union|union
name|cvmx_pcmx_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rxovf
range|:
literal|1
decl_stmt|;
comment|/**< RX byte overflowed                              |           NS */
name|uint64_t
name|txempty
range|:
literal|1
decl_stmt|;
comment|/**< TX byte was empty when sampled                  |           NS */
name|uint64_t
name|txrd
range|:
literal|1
decl_stmt|;
comment|/**< DMA engine frame read interrupt occurred        |           NS */
name|uint64_t
name|txwrap
range|:
literal|1
decl_stmt|;
comment|/**< TX region wrap interrupt occurred               |           NS */
name|uint64_t
name|rxst
range|:
literal|1
decl_stmt|;
comment|/**< DMA engine frame store interrupt occurred       |           NS */
name|uint64_t
name|rxwrap
range|:
literal|1
decl_stmt|;
comment|/**< RX region wrap interrupt occurred               |           NS */
name|uint64_t
name|fsyncextra
range|:
literal|1
decl_stmt|;
comment|/**< FSYNC extra interrupt occurred                  |           NS */
name|uint64_t
name|fsyncmissed
range|:
literal|1
decl_stmt|;
comment|/**< FSYNC missed interrupt occurred                 |           NS */
else|#
directive|else
name|uint64_t
name|fsyncmissed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsyncextra
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxwrap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txwrap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_int_sum_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_sum_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_sum_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_sum_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_int_sum_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_int_sum
name|cvmx_pcmx_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxaddr  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxaddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxaddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Address of the next write to the receive memory    |           NS                                                          region */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxaddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxaddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxaddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxaddr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxaddr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxaddr
name|cvmx_pcmx_rxaddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxcnt  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxcnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxcnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of superframes in receive memory region     |          NS */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxcnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxcnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxcnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxcnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxcnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxcnt
name|cvmx_pcmx_rxcnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk0  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 63 to 0                |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk0
name|cvmx_pcmx_rxmsk0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk1  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 127 to 64              |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk1
name|cvmx_pcmx_rxmsk1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk2  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 191 to 128             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk2
name|cvmx_pcmx_rxmsk2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk3  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 255 to 192             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk3
name|cvmx_pcmx_rxmsk3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk4  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 319 to 256             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk4_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk4_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk4
name|cvmx_pcmx_rxmsk4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk5  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 383 to 320             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk5_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk5_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk5
name|cvmx_pcmx_rxmsk5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk6  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk6_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 447 to 384             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk6_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk6_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk6
name|cvmx_pcmx_rxmsk6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxmsk7  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxmsk7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxmsk7_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Receive mask bits for slots 511 to 448             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxmsk7_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk7_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk7_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk7_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxmsk7_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxmsk7
name|cvmx_pcmx_rxmsk7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_rxstart  */
end_comment

begin_union
union|union
name|cvmx_pcmx_rxstart
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_rxstart_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Starting address for the receive memory region     |          NS */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_rxstart_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxstart_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxstart_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxstart_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_rxstart_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_rxstart
name|cvmx_pcmx_rxstart_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_tdm_cfg  */
end_comment

begin_union
union|union
name|cvmx_pcmx_tdm_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_tdm_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|drvtim
range|:
literal|16
decl_stmt|;
comment|/**< Number of ECLKs from start of bit time to stop    |          NS                                                          driving last bit of timeslot (if not driving next                                                          timeslot) */
name|uint64_t
name|samppt
range|:
literal|16
decl_stmt|;
comment|/**< Number of ECLKs from start of bit time to sample  |          NS                                                          data bit. */
name|uint64_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift/receive MSB first                     |          NS                                                          1, shift/receive LSB first */
name|uint64_t
name|useclk1
range|:
literal|1
decl_stmt|;
comment|/**< If 0, this PCM is based on BCLK/FSYNC0            |          NS                                                          1, this PCM is based on BCLK/FSYNC1 */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 1, PCM is enabled, otherwise pins are GPIOs    |          NS                                                          NOTE: when TDM is disabled by detection of an                                                          FSYNC error all transmission and reception is                                                          halted.  In addition, PCMn_TX/RXADDR are updated                                                          to point to the position at which the error was                                                          detected. */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|useclk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint64_t
name|samppt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|drvtim
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_tdm_cfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_cfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_cfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_cfg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_tdm_cfg
name|cvmx_pcmx_tdm_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_tdm_dbg  */
end_comment

begin_union
union|union
name|cvmx_pcmx_tdm_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_tdm_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|debuginfo
range|:
literal|64
decl_stmt|;
comment|/**< Miscellaneous debug information                   |           NS */
else|#
directive|else
name|uint64_t
name|debuginfo
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_tdm_dbg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_dbg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_dbg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_dbg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_tdm_dbg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_tdm_dbg
name|cvmx_pcmx_tdm_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txaddr  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txaddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txaddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Address of the next read from the transmit memory  |           NS                                                          region */
name|uint64_t
name|fram
range|:
literal|3
decl_stmt|;
comment|/**< Frame offset                                       |           NS                                                          NOTE: this is used to extract the correct byte from                                                          each 64b word read from the transmit memory region */
else|#
directive|else
name|uint64_t
name|fram
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txaddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txaddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txaddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txaddr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txaddr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txaddr
name|cvmx_pcmx_txaddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txcnt  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txcnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txcnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of superframes in transmit memory region    |          NS */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txcnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txcnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txcnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txcnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txcnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txcnt
name|cvmx_pcmx_txcnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk0  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 63 to 0               |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk0
name|cvmx_pcmx_txmsk0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk1  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 127 to 64             |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk1
name|cvmx_pcmx_txmsk1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk2  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 191 to 128            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk2
name|cvmx_pcmx_txmsk2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk3  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 255 to 192            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk3
name|cvmx_pcmx_txmsk3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk4  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 319 to 256            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk4_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk4_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk4
name|cvmx_pcmx_txmsk4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk5  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 383 to 320            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk5_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk5_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk5_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk5_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk5_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk5
name|cvmx_pcmx_txmsk5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk6  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk6_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 447 to 384            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk6_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk6_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk6
name|cvmx_pcmx_txmsk6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txmsk7  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txmsk7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txmsk7_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Transmit mask bits for slots 511 to 448            |          NS                                                          (1 means transmit, 0 means don't transmit) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txmsk7_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk7_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk7_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk7_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txmsk7_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txmsk7
name|cvmx_pcmx_txmsk7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcm#_txstart  */
end_comment

begin_union
union|union
name|cvmx_pcmx_txstart
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcmx_txstart_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
comment|/**< Starting address for the transmit memory region    |          NS */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcmx_txstart_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txstart_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txstart_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txstart_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcmx_txstart_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcmx_txstart
name|cvmx_pcmx_txstart_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

