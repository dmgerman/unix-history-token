begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Utility functions to decode Octeon's RSL_INT_BLOCKS  * interrupts into error messages.  *  *<hr>$Revision: 32636 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PRINT_ERROR
end_ifndef

begin_define
define|#
directive|define
name|PRINT_ERROR
parameter_list|(
name|format
parameter_list|,
modifier|...
parameter_list|)
value|cvmx_safe_printf("ERROR " format, ##__VA_ARGS__)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Change this to a 1 before calling cvmx_interrupt_rsl_enable() to report     single bit ecc errors and other correctable errors */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|int
name|__cvmx_interrupt_ecc_report_single_bit_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|__cvmx_interrupt_agl_gmx_rxx_int_en_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_agl_gmx_rxx_int_reg_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_fpa_int_enb_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_fpa_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_gmxx_rxx_int_en_enable
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_gmxx_rxx_int_reg_decode
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_iob_int_enb_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_iob_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_ipd_int_enb_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_ipd_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_key_int_enb_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_key_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_mio_boot_int_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_mio_boot_err_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_npei_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_npei_int_enb2_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_npi_int_enb_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_npi_int_sum_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pcsx_intx_reg_decode
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pcsxx_int_en_reg_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pcsxx_int_reg_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pescx_dbg_info_en_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pescx_dbg_info_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pip_int_en_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pip_int_reg_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pko_reg_int_mask_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_pko_reg_error_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_rad_reg_int_mask_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_rad_reg_error_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_spxx_int_msk_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_spxx_int_reg_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_stxx_int_msk_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_stxx_int_reg_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_usbnx_int_enb_enable
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_usbnx_int_sum_decode
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_zip_int_mask_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__cvmx_interrupt_zip_error_decode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Enable ASX error interrupts that exist on CN3XXX, CN50XX, and  * CN58XX.  *  * @param block  Interface to enable 0-1  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_asxx_enable
parameter_list|(
name|int
name|block
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|cvmx_asxx_int_en_t
name|csr
decl_stmt|;
comment|/* CN38XX and CN58XX have two interfaces with 4 ports per interface. All         other chips have a max of 3 ports on interface 0 */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|mask
operator|=
literal|0xf
expr_stmt|;
comment|/* Set enables for 4 ports */
else|else
name|mask
operator|=
literal|0x7
expr_stmt|;
comment|/* Set enables for 3 ports */
comment|/* Enable interface interrupts */
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_INT_EN
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|txpsh
operator|=
name|mask
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|txpop
operator|=
name|mask
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|ovrflw
operator|=
name|mask
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_INT_EN
argument_list|(
name|block
argument_list|)
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode ASX error interrupts for CN3XXX, CN50XX, and CN58XX  *  * @param block  Interface to decode 0-1  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_asxx_decode
parameter_list|(
name|int
name|block
parameter_list|)
block|{
name|cvmx_asxx_int_reg_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_INT_REG
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_INT_REG
argument_list|(
name|block
argument_list|)
argument_list|,
name|err
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|u64
condition|)
block|{
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
literal|4
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|ovrflw
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"ASX%d_INT_REG[OVRFLW]: RX FIFO overflow on RMGII port %d\n"
argument_list|,
name|block
argument_list|,
name|port
operator|+
name|block
operator|*
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|txpop
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"ASX%d_INT_REG[TXPOP]: TX FIFO underflow on RMGII port %d\n"
argument_list|,
name|block
argument_list|,
name|port
operator|+
name|block
operator|*
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|txpsh
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"ASX%d_INT_REG[TXPSH]: TX FIFO overflow on RMGII port %d\n"
argument_list|,
name|block
argument_list|,
name|port
operator|+
name|block
operator|*
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Enable DFA errors for CN38XX, CN58XX, and CN31XX  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_dfa_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_dfa_err_t
name|csr
decl_stmt|;
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dblina
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|cp2pina
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|cp2parena
operator|=
literal|0
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dtepina
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dteparena
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dtedbina
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dtesbina
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dteeccena
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|cp2dbina
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|cp2sbina
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|cp2eccena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode DFA errors for CN38XX, CN58XX, and CN31XX  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_dfa_decode
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_dfa_err_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|err
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|u64
condition|)
block|{
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dblovf
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DBLOVF]: Doorbell Overflow detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|cp2perr
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2PERR]: PP-CP2 Parity Error Detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dteperr
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTEPERR]: DTE Parity Error Detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dtedbe
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTEDBE]: DFA DTE 29b Double Bit Error Detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dtesbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTESBE]: DFA DTE 29b Single Bit Error Corrected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dtedbe
operator|||
operator|(
name|err
operator|.
name|s
operator|.
name|dtesbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTESYN]: Failing syndrome %u\n"
argument_list|,
name|err
operator|.
name|s
operator|.
name|dtesyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|cp2dbe
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2DBE]: DFA PP-CP2 Double Bit Error Detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|cp2sbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2SBE]: DFA PP-CP2 Single Bit Error Corrected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|cp2dbe
operator|||
operator|(
name|err
operator|.
name|s
operator|.
name|cp2sbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2SYN]: Failing syndrome %u\n"
argument_list|,
name|err
operator|.
name|s
operator|.
name|cp2syn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Enable L2 error interrupts for all chips  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_l2_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_l2t_err_t
name|csr
decl_stmt|;
name|cvmx_l2d_err_t
name|csr2
decl_stmt|;
comment|/* Enable ECC Interrupts for double bit errors from L2C Tags */
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|lck_intena2
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|lck_intena
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|ded_intena
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|sec_intena
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|ecc_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Enable ECC Interrupts for double bit errors from L2D Errors */
name|csr2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|)
expr_stmt|;
name|csr2
operator|.
name|s
operator|.
name|ded_intena
operator|=
literal|1
expr_stmt|;
name|csr2
operator|.
name|s
operator|.
name|sec_intena
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|csr2
operator|.
name|s
operator|.
name|ecc_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|,
name|csr2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode L2 error interrupts for all chips  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_l2_decode
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_l2t_err_t
name|terr
decl_stmt|;
name|cvmx_l2d_err_t
name|derr
decl_stmt|;
name|uint64_t
name|clr_val
decl_stmt|;
name|terr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|terr
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|terr
operator|.
name|u64
condition|)
block|{
if|if
condition|(
name|terr
operator|.
name|s
operator|.
name|ded_err
condition|)
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[DED_ERR]: double bit:\tfadr: 0x%x, fset: 0x%x, fsyn: 0x%x\n"
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fsyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|terr
operator|.
name|s
operator|.
name|sec_err
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
condition|)
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[SEC_ERR]: single bit:\tfadr: 0x%x, fset: 0x%x, fsyn: 0x%x\n"
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fsyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|terr
operator|.
name|s
operator|.
name|ded_err
operator|||
name|terr
operator|.
name|s
operator|.
name|sec_err
condition|)
block|{
if|if
condition|(
operator|!
name|terr
operator|.
name|s
operator|.
name|fsyn
condition|)
block|{
comment|/* Syndrome is zero, which means error was in non-hit line,                     so flush all associations */
name|int
name|i
decl_stmt|;
name|int
name|l2_assoc
init|=
name|cvmx_l2c_get_num_assoc
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l2_assoc
condition|;
name|i
operator|++
control|)
name|cvmx_l2c_flush_line
argument_list|(
name|i
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_l2c_flush_line
argument_list|(
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|terr
operator|.
name|s
operator|.
name|lckerr2
condition|)
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[LCKERR2]: HW detected a case where a Rd/Wr Miss from PP#n could not find an available/unlocked set (for replacement).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terr
operator|.
name|s
operator|.
name|lckerr
condition|)
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[LCKERR]: SW attempted to LOCK DOWN the last available set of the INDEX (which is ignored by HW - but reported to SW).\n"
argument_list|)
expr_stmt|;
block|}
name|clr_val
operator|=
name|derr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|derr
operator|.
name|u64
condition|)
block|{
name|cvmx_l2d_fadr_t
name|fadr
decl_stmt|;
if|if
condition|(
name|derr
operator|.
name|s
operator|.
name|ded_err
operator|||
operator|(
name|derr
operator|.
name|s
operator|.
name|sec_err
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
operator|)
condition|)
block|{
specifier|const
name|int
name|coreid
init|=
operator|(
name|int
operator|)
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|uint64_t
name|syn0
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN0
argument_list|)
decl_stmt|;
name|uint64_t
name|syn1
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN1
argument_list|)
decl_stmt|;
name|fadr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FADR
argument_list|)
expr_stmt|;
if|if
condition|(
name|derr
operator|.
name|s
operator|.
name|ded_err
condition|)
name|PRINT_ERROR
argument_list|(
literal|"L2D_ERR[DED_ERR] ECC double (core %d): fadr: 0x%llx, syn0:0x%llx, syn1: 0x%llx\n"
argument_list|,
name|coreid
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fadr
operator|.
name|u64
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn0
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn1
argument_list|)
expr_stmt|;
else|else
name|PRINT_ERROR
argument_list|(
literal|"L2D_ERR[SEC_ERR] ECC single (core %d): fadr: 0x%llx, syn0:0x%llx, syn1: 0x%llx\n"
argument_list|,
name|coreid
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fadr
operator|.
name|u64
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn0
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn1
argument_list|)
expr_stmt|;
comment|/* Flush the line that had the error */
if|if
condition|(
name|derr
operator|.
name|s
operator|.
name|ded_err
operator|||
name|derr
operator|.
name|s
operator|.
name|sec_err
condition|)
name|cvmx_l2c_flush_line
argument_list|(
name|fadr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fadr
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|,
name|clr_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable LMC (DDR controller) interrupts for all chips  *  * @param ddr_controller  *               Which controller to enable for 0-1  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_lmcx_enable
parameter_list|(
name|int
name|ddr_controller
parameter_list|)
block|{
name|cvmx_lmc_mem_cfg0_t
name|csr
decl_stmt|;
comment|/* The LMC controllers can be independently enabled/disabled on CN56XX.         If a controller is disabled it can't be accessed at all since it         isn't clocked */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2c_cfg
operator|.
name|s
operator|.
name|dpres0
operator|&&
operator|(
name|ddr_controller
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|l2c_cfg
operator|.
name|s
operator|.
name|dpres1
operator|&&
operator|(
name|ddr_controller
operator|==
literal|1
operator|)
condition|)
return|return;
block|}
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|)
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|intr_ded_ena
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|intr_sec_ena
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode LMC (DDR controller) interrupts for all chips  *  * @param ddr_controller  *               Which controller to decode 0-1  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_lmcx_decode
parameter_list|(
name|int
name|ddr_controller
parameter_list|)
block|{
comment|/* These static counters are used to track ECC error counts */
specifier|static
name|CVMX_SHARED
name|unsigned
name|long
name|single_bit_errors
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|CVMX_SHARED
name|unsigned
name|long
name|double_bit_errors
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|cvmx_lmcx_mem_cfg0_t
name|mem_cfg0
decl_stmt|;
name|cvmx_lmc_fadr_t
name|fadr
decl_stmt|;
name|mem_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|)
expr_stmt|;
name|fadr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_FADR
argument_list|(
name|ddr_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|,
name|mem_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_cfg0
operator|.
name|s
operator|.
name|sec_err
operator|||
name|mem_cfg0
operator|.
name|s
operator|.
name|ded_err
condition|)
block|{
name|int
name|pop_count
decl_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop_count
argument_list|,
name|mem_cfg0
operator|.
name|s
operator|.
name|sec_err
argument_list|)
expr_stmt|;
name|single_bit_errors
index|[
name|ddr_controller
index|]
operator|+=
name|pop_count
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop_count
argument_list|,
name|mem_cfg0
operator|.
name|s
operator|.
name|ded_err
argument_list|)
expr_stmt|;
name|double_bit_errors
index|[
name|ddr_controller
index|]
operator|+=
name|pop_count
expr_stmt|;
if|if
condition|(
name|mem_cfg0
operator|.
name|s
operator|.
name|ded_err
operator|||
operator|(
name|mem_cfg0
operator|.
name|s
operator|.
name|sec_err
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
operator|)
condition|)
block|{
name|PRINT_ERROR
argument_list|(
literal|"DDR%d ECC: %lu Single bit corrections, %lu Double bit errors\n"
literal|"DDR%d ECC:\tFailing dimm:   %u\n"
literal|"DDR%d ECC:\tFailing rank:   %u\n"
literal|"DDR%d ECC:\tFailing bank:   %u\n"
literal|"DDR%d ECC:\tFailing row:    0x%x\n"
literal|"DDR%d ECC:\tFailing column: 0x%x\n"
argument_list|,
name|ddr_controller
argument_list|,
name|single_bit_errors
index|[
name|ddr_controller
index|]
argument_list|,
name|double_bit_errors
index|[
name|ddr_controller
index|]
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fdimm
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fbunk
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fbank
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|frow
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fcol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Decode GMX error interrupts  *  * @param block  GMX interface to decode  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_gmxx_decode
parameter_list|(
name|int
name|block
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|cvmx_gmxx_tx_int_reg_t
name|csr
decl_stmt|;
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_INT_REG
argument_list|(
name|block
argument_list|)
argument_list|)
operator|&
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_REG
argument_list|(
name|block
argument_list|)
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|4
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|late_col
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX%d_INT_REG[LATE_COL]: TX Late Collision\n"
argument_list|,
name|block
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|xsdef
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX%d_INT_REG[XSDEF]: TX Excessive deferral\n"
argument_list|,
name|block
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|xscol
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX%d_INT_REG[XSCOL]: TX Excessive collisions\n"
argument_list|,
name|block
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|undflw
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX%d_INT_REG[UNDFLW]: TX Underflow\n"
argument_list|,
name|block
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|ncb_nxa
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX_INT_REG[NCB_NXA]: Port address out-of-range from NCB Interface\n"
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|.
name|s
operator|.
name|pko_nxa
condition|)
name|PRINT_ERROR
argument_list|(
literal|"GMX%d_TX_INT_REG[PKO_NXA]: Port address out-of-range from PKO Interface\n"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_gmxx_rxx_int_reg_decode
argument_list|(
literal|0
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_gmxx_rxx_int_reg_decode
argument_list|(
literal|1
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_gmxx_rxx_int_reg_decode
argument_list|(
literal|2
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|__cvmx_interrupt_gmxx_rxx_int_reg_decode
argument_list|(
literal|3
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable POW error interrupts for all chips  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_pow_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_pow_ecc_err_t
name|csr
decl_stmt|;
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX_PASS2
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
block|{
comment|/* These doesn't exist for chips CN31XX and CN38XXp2 */
name|csr
operator|.
name|s
operator|.
name|iop_ie
operator|=
literal|0x1fff
expr_stmt|;
block|}
name|csr
operator|.
name|s
operator|.
name|rpe_ie
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|dbe_ie
operator|=
literal|1
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|sbe_ie
operator|=
name|__cvmx_interrupt_ecc_report_single_bit_errors
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode POW error interrupts for all chips  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_pow_decode
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_pow_ecc_err_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|err
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|u64
condition|)
block|{
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|sbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[SBE]: POW single bit error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dbe
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[DBE]: POW double bit error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|dbe
operator|||
operator|(
name|err
operator|.
name|s
operator|.
name|sbe
operator|&&
name|__cvmx_interrupt_ecc_report_single_bit_errors
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[SYN]: Failing syndrome %u\n"
argument_list|,
name|err
operator|.
name|s
operator|.
name|syn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|rpe
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[RPE]: Remote pointer error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP0]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP1]: Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP2]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED or ATOMIC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP3]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP4]: Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP5]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP6]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP7]: Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP8]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with CLR_NSCHED pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP9]: Received illegal opcode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP10]: Received ADD_WORK with tag specified as NULL_NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP11]: Received DBG load from PP with DBG load pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP12]: Received CSR load from PP with CSR load pending\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Enable TIM tiemr wheel interrupts for all chips  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_tim_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_tim_reg_int_mask_t
name|csr
decl_stmt|;
name|csr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_REG_INT_MASK
argument_list|)
expr_stmt|;
name|csr
operator|.
name|s
operator|.
name|mask
operator|=
literal|0xffff
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_REG_INT_MASK
argument_list|,
name|csr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Decode TIM timer wheel interrupts  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_tim_decode
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_tim_reg_error_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_REG_ERROR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_REG_ERROR
argument_list|,
name|err
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|u64
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"TIM_REG_ERROR[MASK]: Timer wheel %d error\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Utility function to decode Octeon's RSL_INT_BLOCKS interrupts  * into error messages.  */
end_comment

begin_function
name|void
name|cvmx_interrupt_rsl_decode
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|rsl_int_blocks
decl_stmt|;
comment|/* Reading the RSL interrupts is different between PCI and PCIe chips */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
name|rsl_int_blocks
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_RSL_INT_BLOCKS
argument_list|)
expr_stmt|;
else|else
name|rsl_int_blocks
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NPI_RSL_INT_BLOCKS
argument_list|)
expr_stmt|;
comment|/* Not all chips support all error interrupts. This code assumes         that unsupported interrupts always are zero */
comment|/* Bits 63-31 are unused on all chips */
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|30
operator|)
condition|)
name|__cvmx_interrupt_iob_int_sum_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|29
operator|)
condition|)
name|__cvmx_interrupt_lmcx_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|28
operator|)
condition|)
block|{
name|__cvmx_interrupt_agl_gmx_rxx_int_reg_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|__cvmx_interrupt_agl_gmx_rxx_int_reg_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Bit 27-24 are unused on all chips */
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|23
operator|)
condition|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsxx_int_reg_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|__cvmx_interrupt_asxx_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|22
operator|)
condition|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_reg_decode
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsxx_int_reg_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|__cvmx_interrupt_asxx_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Bit 21 is unsed on all chips */
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|20
operator|)
condition|)
name|__cvmx_interrupt_pip_int_reg_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|19
operator|)
condition|)
block|{
name|__cvmx_interrupt_spxx_int_reg_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_stxx_int_reg_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|18
operator|)
condition|)
block|{
name|__cvmx_interrupt_spxx_int_reg_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_stxx_int_reg_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|17
operator|)
condition|)
name|__cvmx_interrupt_lmcx_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|16
operator|)
condition|)
name|__cvmx_interrupt_l2_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|15
operator|)
condition|)
name|__cvmx_interrupt_usbnx_int_sum_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|14
operator|)
condition|)
name|__cvmx_interrupt_rad_reg_error_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|13
operator|)
condition|)
name|__cvmx_interrupt_usbnx_int_sum_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|12
operator|)
condition|)
name|__cvmx_interrupt_pow_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|11
operator|)
condition|)
name|__cvmx_interrupt_tim_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|10
operator|)
condition|)
name|__cvmx_interrupt_pko_reg_error_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|9
operator|)
condition|)
name|__cvmx_interrupt_ipd_int_sum_decode
argument_list|()
expr_stmt|;
comment|/* Bit 8 is unused on all chips */
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|7
operator|)
condition|)
name|__cvmx_interrupt_zip_error_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|6
operator|)
condition|)
name|__cvmx_interrupt_dfa_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|5
operator|)
condition|)
name|__cvmx_interrupt_fpa_int_sum_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|4
operator|)
condition|)
name|__cvmx_interrupt_key_int_sum_decode
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
name|__cvmx_interrupt_npei_int_sum_decode
argument_list|()
expr_stmt|;
else|else
name|__cvmx_interrupt_npi_int_sum_decode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|2
operator|)
condition|)
name|__cvmx_interrupt_gmxx_decode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|1
operator|)
condition|)
name|__cvmx_interrupt_gmxx_decode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsl_int_blocks
operator|&
operator|(
literal|1ull
operator|<<
literal|0
operator|)
condition|)
name|__cvmx_interrupt_mio_boot_err_decode
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Enable GMX error reporting for the supplied interface  *  * @param interface Interface to enable  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_gmxx_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
name|cvmx_gmxx_tx_int_en_t
name|gmx_tx_int_en
decl_stmt|;
name|int
name|num_ports
decl_stmt|;
name|int
name|index
decl_stmt|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|en
condition|)
block|{
switch|switch
condition|(
name|mode
operator|.
name|cn56xx
operator|.
name|mode
condition|)
block|{
case|case
literal|1
case|:
comment|/* XAUI */
name|num_ports
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* SGMII */
case|case
literal|3
case|:
comment|/* PICMG */
name|num_ports
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
comment|/* Disabled */
name|num_ports
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|num_ports
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|en
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
comment|/* SPI on CN38XX and CN58XX report all errors through port 0.                     RGMII needs to check all 4 ports */
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|type
condition|)
name|num_ports
operator|=
literal|1
expr_stmt|;
else|else
name|num_ports
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* CN30XX, CN31XX, and CN50XX have two or three ports. GMII                     and MII has 2, RGMII has three */
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|type
condition|)
name|num_ports
operator|=
literal|2
expr_stmt|;
else|else
name|num_ports
operator|=
literal|3
expr_stmt|;
block|}
block|}
else|else
name|num_ports
operator|=
literal|0
expr_stmt|;
block|}
name|gmx_tx_int_en
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_ports
condition|)
block|{
name|gmx_tx_int_en
operator|.
name|s
operator|.
name|ncb_nxa
operator|=
literal|1
expr_stmt|;
name|gmx_tx_int_en
operator|.
name|s
operator|.
name|pko_nxa
operator|=
literal|1
expr_stmt|;
block|}
name|gmx_tx_int_en
operator|.
name|s
operator|.
name|undflw
operator|=
operator|(
literal|1
operator|<<
name|num_ports
operator|)
operator|-
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_tx_int_en
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
name|__cvmx_interrupt_gmxx_rxx_int_en_enable
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Utility function to enable all RSL error interupts  */
end_comment

begin_function
name|void
name|cvmx_interrupt_rsl_enable
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Bits 63-31 are unused on all chips */
name|__cvmx_interrupt_iob_int_enb_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
name|__cvmx_interrupt_lmcx_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_MGMT_PORT
argument_list|)
condition|)
block|{
comment|// FIXME __cvmx_interrupt_agl_gmx_rxx_int_en_enable(0);
comment|//if (OCTEON_IS_MODEL(OCTEON_CN52XX))
comment|//    __cvmx_interrupt_agl_gmx_rxx_int_en_enable(1);
block|}
comment|/* Bit 27-24 are unused on all chips */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|__cvmx_interrupt_asxx_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsxx_int_en_reg_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsx_intx_en_reg_enable
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pcsxx_int_en_reg_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|__cvmx_interrupt_asxx_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Bit 21 is unsed on all chips */
name|__cvmx_interrupt_pip_int_en_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
name|__cvmx_interrupt_spxx_int_msk_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_stxx_int_msk_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_spxx_int_msk_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_stxx_int_msk_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|__cvmx_interrupt_lmcx_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_l2_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|__cvmx_interrupt_usbnx_int_enb_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_RAID
argument_list|)
condition|)
name|__cvmx_interrupt_rad_reg_int_mask_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_USB
argument_list|)
condition|)
name|__cvmx_interrupt_usbnx_int_enb_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_pow_enable
argument_list|()
expr_stmt|;
name|__cvmx_interrupt_tim_enable
argument_list|()
expr_stmt|;
name|__cvmx_interrupt_pko_reg_int_mask_enable
argument_list|()
expr_stmt|;
name|__cvmx_interrupt_ipd_int_enb_enable
argument_list|()
expr_stmt|;
comment|/* Bit 8 is unused on all chips */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_ZIP
argument_list|)
condition|)
name|__cvmx_interrupt_zip_int_mask_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|__cvmx_interrupt_dfa_enable
argument_list|()
expr_stmt|;
name|__cvmx_interrupt_fpa_int_enb_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_KEY_MEMORY
argument_list|)
condition|)
name|__cvmx_interrupt_key_int_enb_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
condition|)
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
name|__cvmx_interrupt_npei_int_enb2_enable
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|bootloader_config_flags
operator|&
name|CVMX_BOOTINFO_CFG_FLAG_PCI_HOST
condition|)
name|__cvmx_interrupt_npi_int_enb_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
name|__cvmx_interrupt_gmxx_enable
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_gmxx_enable
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_mio_boot_int_enable
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

