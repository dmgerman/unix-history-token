begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-stxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon stxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_STXX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_STXX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_ARB_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_ARB_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000608ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_ARB_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000608ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_BCKPRS_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_BCKPRS_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000688ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_BCKPRS_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000688ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_COM_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_COM_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000600ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_COM_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000600ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_DIP_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_DIP_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000690ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_DIP_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000690ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_IGN_CAL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_IGN_CAL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000610ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_IGN_CAL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000610ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_INT_MSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_INT_MSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800900006A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_INT_MSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800900006A0ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_INT_REG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000698ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_INT_REG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000698ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_INT_SYNC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_INT_SYNC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800900006A8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_INT_SYNC
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800900006A8ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_MIN_BST
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_MIN_BST(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000618ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_MIN_BST
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000618ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_SPI4_CALX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_SPI4_CALX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000400ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_SPI4_CALX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000400ull) + (((offset)& 31) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_SPI4_DAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_SPI4_DAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000628ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_SPI4_DAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000628ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_SPI4_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_SPI4_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000630ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_SPI4_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000630ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_STAT_BYTES_HI
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_STAT_BYTES_HI(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000648ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_STAT_BYTES_HI
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000648ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_STAT_BYTES_LO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_STAT_BYTES_LO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000680ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_STAT_BYTES_LO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000680ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_STAT_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_STAT_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000638ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_STAT_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000638ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_STXX_STAT_PKT_XMT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_STXX_STAT_PKT_XMT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000640ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_STXX_STAT_PKT_XMT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000640ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_stx#_arb_ctl  *  * STX_ARB_CTL - Spi transmit arbitration control  *  *  * Notes:  * If STX_ARB_CTL[MINTRN] is set in Spi4 mode, then the data_max_t  * parameter will have to be adjusted.  Please see the  * STX_SPI4_DAT[MAX_T] section for additional information.  In  * addition, the min_burst can only be guaranteed on the initial data  * burst of a given packet (i.e. the first data burst which contains  * the SOP tick).  All subsequent bursts could be truncated by training  * sequences at any point during transmission and could be arbitrarily  * small.  This mode is only for use in Spi4 mode.  */
end_comment

begin_union
union|union
name|cvmx_stxx_arb_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_arb_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mintrn
range|:
literal|1
decl_stmt|;
comment|/**< Hold off training cycles until STX_MIN_BST[MINB]                                                          is satisfied */
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|igntpa
range|:
literal|1
decl_stmt|;
comment|/**< User switch to ignore any TPA information from the                                                          Spi interface. This CSR forces all TPA terms to                                                          be masked out.  It is only intended as backdoor                                                          or debug feature. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|igntpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mintrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_arb_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_arb_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_arb_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_arb_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_arb_ctl
name|cvmx_stxx_arb_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_bckprs_cnt  *  * Notes:  * This register reports the total number of cycles (STX data clks -  * stx_clk) in which the port defined in STX_STAT_CTL[BCKPRS] has lost TPA  * or is otherwise receiving backpressure.  *  * In Spi4 mode, this is defined as a loss of TPA which is indicated when  * the receiving device reports SATISFIED for the given port.  The calendar  * status is brought into N2 on the spi4_tx*_sclk and synchronized into the  * N2 Spi TX clock domain which is 1/2 the frequency of the spi4_tx*_dclk  * clock (internally, this the stx_clk).  The counter will update on the  * rising edge in which backpressure is reported.  *  * This register will be cleared when software writes all '1's to  * the STX_BCKPRS_CNT.  */
end_comment

begin_union
union|union
name|cvmx_stxx_bckprs_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_bckprs_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of cycles when back-pressure is received                                                          for port defined in STX_STAT_CTL[BCKPRS] */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_bckprs_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_bckprs_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_bckprs_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_bckprs_cnt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_bckprs_cnt
name|cvmx_stxx_bckprs_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_com_ctl  *  * STX_COM_CTL - TX Common Control Register  *  *  * Notes:  * Restrictions:  * Both the calendar table and the LEN and M parameters must be  * completely setup before writing the Interface enable (INF_EN) and  * Status channel enabled (ST_EN) asserted.  */
end_comment

begin_union
union|union
name|cvmx_stxx_com_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_com_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
comment|/**< Status channel enabled */
name|uint64_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inf_en
range|:
literal|1
decl_stmt|;
comment|/**< Interface enable */
else|#
directive|else
name|uint64_t
name|inf_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_com_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_com_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_com_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_com_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_com_ctl
name|cvmx_stxx_com_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_dip_cnt  *  * Notes:  * * DIPMAX  *   This counts the number of consecutive DIP2 states in which the the  *   received DIP2 is bad.  The expected range is 1-15 cycles with the  *   value of 0 meaning disabled.  *  * * FRMMAX  *   This counts the number of consecutive unexpected framing patterns (11)  *   states.  The expected range is 1-15 cycles with the value of 0 meaning  *   disabled.  */
end_comment

begin_union
union|union
name|cvmx_stxx_dip_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_dip_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|frmmax
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive unexpected framing patterns                                                          before loss of sync */
name|uint64_t
name|dipmax
range|:
literal|4
decl_stmt|;
comment|/**< Number of consecutive DIP2 error before loss                                                          of sync */
else|#
directive|else
name|uint64_t
name|dipmax
range|:
literal|4
decl_stmt|;
name|uint64_t
name|frmmax
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_dip_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_dip_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_dip_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_dip_cnt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_dip_cnt
name|cvmx_stxx_dip_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_ign_cal  *  * STX_IGN_CAL - Ignore Calendar Status from Spi4 Status Channel  *  */
end_comment

begin_union
union|union
name|cvmx_stxx_ign_cal
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_ign_cal_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|igntpa
range|:
literal|16
decl_stmt|;
comment|/**< Ignore Calendar Status from Spi4 Status Channel                                                           per Spi4 port                                                          - 0: Use the status channel info                                                          - 1: Grant the given port MAX_BURST1 credits */
else|#
directive|else
name|uint64_t
name|igntpa
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_ign_cal_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_ign_cal_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_ign_cal_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_ign_cal_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_ign_cal
name|cvmx_stxx_ign_cal_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_int_msk  *  * Notes:  * If the bit is enabled, then the coresponding exception condition will  * result in an interrupt to the system.  */
end_comment

begin_union
union|union
name|cvmx_stxx_int_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_int_msk_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
comment|/**< FRMCNT has exceeded STX_DIP_CNT[MAXFRM] */
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected framing sequence */
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
comment|/**< ERRCNT has exceeded STX_DIP_CNT[MAXDIP] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< DIP2 error on the Spi4 Status channel */
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 FIFO overflow error */
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
comment|/**< Transmit packet burst too big */
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank1 */
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank0 */
else|#
directive|else
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_int_msk_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_msk_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_int_msk_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_msk_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_int_msk
name|cvmx_stxx_int_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_int_reg  *  * Notes:  * * CALPAR0  *   This bit indicates that the Spi4 calendar table encountered a parity  *   error on bank0 of the calendar table memory.  This error bit is  *   associated with the calendar table on the TX interface - the interface  *   that drives the Spi databus.  The calendar table is used in Spi4 mode  *   when using the status channel.  Parity errors can occur during normal  *   operation when the calendar table is constantly being read for the port  *   information, or during initialization time, when the user has access.  *   This errors will force the the status channel to the reset state and  *   begin driving training sequences.  The status channel will also reset.  *   Software must follow the init sequence to resynch the interface.  This  *   includes toggling INF_EN which will cancel all outstanding accumulated  *   credits.  *  * * CALPAR1  *   Identical to CALPAR0 except that it indicates that the error occured  *   on bank1 (instead of bank0).  *  * * OVRBST  *   STX can track upto a 512KB data burst.  Any packet larger than that is  *   illegal and will cause confusion in the STX state machine.  BMI is  *   responsible for throwing away these out of control packets from the  *   input and the Execs should never generate them on the output.  This is  *   a fatal error and should have STX_INT_SYNC[OVRBST] set.  *  * * DATOVR  *   FIFO where the Spi4 data ramps upto its transmit frequency has  *   overflowed.  This is a fatal error and should have  *   STX_INT_SYNC[DATOVR] set.  *  * * DIPERR  *   This bit will fire if any DIP2 error is caught by the Spi4 status  *   channel.  *  * * NOSYNC  *   This bit indicates that the number of consecutive DIP2 errors exceeds  *   STX_DIP_CNT[MAXDIP] and that the interface should be taken down.  The  *   datapath will be notified and send continuous training sequences until  *   software resynchronizes the interface.  This error condition should  *   have STX_INT_SYNC[NOSYNC] set.  *  * * UNXFRM  *   Unexpected framing data was seen on the status channel.  *  * * FRMERR  *   This bit indicates that the number of consecutive unexpected framing  *   sequences STX_DIP_CNT[MAXFRM] and that the interface should be taken  *   down.  The datapath will be notified and send continuous training  *   sequences until software resynchronizes the interface.  This error  *   condition should have STX_INT_SYNC[FRMERR] set.  *  * * SYNCERR  *   Indicates that an exception marked in STX_INT_SYNC has occured and the  *   TX datapath is disabled.  It is recommended that the OVRBST, DATOVR,  *   NOSYNC, and FRMERR error conditions all have their bits set in the  *   STX_INT_SYNC register.  */
end_comment

begin_union
union|union
name|cvmx_stxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
comment|/**< Interface encountered a fatal error */
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
comment|/**< FRMCNT has exceeded STX_DIP_CNT[MAXFRM] */
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected framing sequence */
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
comment|/**< ERRCNT has exceeded STX_DIP_CNT[MAXDIP] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< DIP2 error on the Spi4 Status channel */
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 FIFO overflow error */
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
comment|/**< Transmit packet burst too big */
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank1 */
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank0 */
else|#
directive|else
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_int_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_int_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_int_reg
name|cvmx_stxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_int_sync  *  * Notes:  * If the bit is enabled, then the coresponding exception condition is flagged  * to be fatal.  In Spi4 mode, the exception condition will result in a loss  * of sync condition on the Spi4 interface and the datapath will send  * continuous traing sequences.  *  * It is recommended that software set the OVRBST, DATOVR, NOSYNC, and  * FRMERR errors as synchronization events.  Software is free to  * synchronize the bus on other conditions, but this is the minimum  * recommended set.  */
end_comment

begin_union
union|union
name|cvmx_stxx_int_sync
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_int_sync_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
comment|/**< FRMCNT has exceeded STX_DIP_CNT[MAXFRM] */
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected framing sequence */
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
comment|/**< ERRCNT has exceeded STX_DIP_CNT[MAXDIP] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< DIP2 error on the Spi4 Status channel */
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 FIFO overflow error */
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
comment|/**< Transmit packet burst too big */
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank1 */
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
comment|/**< STX Calendar Table Parity Error Bank0 */
else|#
directive|else
name|uint64_t
name|calpar0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calpar1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|datovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unxfrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|frmerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_int_sync_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_sync_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_int_sync_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_int_sync_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_int_sync
name|cvmx_stxx_int_sync_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_min_bst  *  * STX_MIN_BST - Min Burst to enforce when inserting training sequence  *  */
end_comment

begin_union
union|union
name|cvmx_stxx_min_bst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_min_bst_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|minb
range|:
literal|9
decl_stmt|;
comment|/**< When STX_ARB_CTL[MINTRN] is set, MINB indicates                                                          the number of 8B blocks to send before inserting                                                          a training sequence.  Normally MINB will be set                                                          to GMX_TX_SPI_THRESH[THRESH].  MINB should always                                                          be set to an even number (ie. multiple of 16B) */
else|#
directive|else
name|uint64_t
name|minb
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_min_bst_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_min_bst_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_min_bst_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_min_bst_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_min_bst
name|cvmx_stxx_min_bst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_spi4_cal#  *  * specify the RSL base addresses for the block  * STX_SPI4_CAL - Spi4 Calender table  * direct_calendar_write / direct_calendar_read  *  * Notes:  * There are 32 calendar table CSR's, each containing 4 entries for a  *     total of 128 entries.  In the above definition...  *  *           n = calendar table offset * 4  *  *        Example, offset 0x00 contains the calendar table entries 0, 1, 2, 3  *        (with n == 0).  Offset 0x10 is the 16th entry in the calendar table  *        and would contain entries (16*4) = 64, 65, 66, and 67.  *  * Restrictions:  *        Calendar table entry accesses (read or write) can only occur  *        if the interface is disabled.  All other accesses will be  *        unpredictable.  *  *     Both the calendar table and the LEN and M parameters must be  *     completely setup before writing the Interface enable (INF_EN) and  *     Status channel enabled (ST_EN) asserted.  */
end_comment

begin_union
union|union
name|cvmx_stxx_spi4_calx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_spi4_calx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|oddpar
range|:
literal|1
decl_stmt|;
comment|/**< Odd parity over STX_SPI4_CAL[15:0]                                                          (^STX_SPI4_CAL[16:0] === 1'b1)                  |   $NS       NS */
name|uint64_t
name|prt3
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+3 */
name|uint64_t
name|prt2
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+2 */
name|uint64_t
name|prt1
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+1 */
name|uint64_t
name|prt0
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+0 */
else|#
directive|else
name|uint64_t
name|prt0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|oddpar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_spi4_calx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_calx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_calx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_calx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_spi4_calx
name|cvmx_stxx_spi4_calx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_spi4_dat  *  * STX_SPI4_DAT - Spi4 datapath channel control register  *  *  * Notes:  * Restrictions:  * * DATA_MAX_T must be in MOD 4 cycles  *  * * DATA_MAX_T must at least 0x20  *  * * DATA_MAX_T == 0 or ALPHA == 0 will disable the training sequnce  *  * * If STX_ARB_CTL[MINTRN] is set, then training cycles will stall  *   waiting for min bursts to complete.  In the worst case, this will  *   add the entire min burst transmission time to the interval between  *   trainging sequence.  The observed MAX_T on the Spi4 bus will be...  *  *                STX_SPI4_DAT[MAX_T] + (STX_MIN_BST[MINB] * 4)  *  *      If STX_ARB_CTL[MINTRN] is set in Spi4 mode, then the data_max_t  *      parameter will have to be adjusted.  Please see the  *      STX_SPI4_DAT[MAX_T] section for additional information.  In  *      addition, the min_burst can only be guaranteed on the initial data  *      burst of a given packet (i.e. the first data burst which contains  *      the SOP tick).  All subsequent bursts could be truncated by training  *      sequences at any point during transmission and could be arbitrarily  *      small.  This mode is only for use in Spi4 mode.  */
end_comment

begin_union
union|union
name|cvmx_stxx_spi4_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_spi4_dat_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|alpha
range|:
literal|16
decl_stmt|;
comment|/**< alpha (from spi4.2 spec) */
name|uint64_t
name|max_t
range|:
literal|16
decl_stmt|;
comment|/**< DATA_MAX_T (from spi4.2 spec) */
else|#
directive|else
name|uint64_t
name|max_t
range|:
literal|16
decl_stmt|;
name|uint64_t
name|alpha
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_spi4_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_dat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_dat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_spi4_dat
name|cvmx_stxx_spi4_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_spi4_stat  *  * STX_SPI4_STAT - Spi4 status channel control register  *  *  * Notes:  * Restrictions:  * Both the calendar table and the LEN and M parameters must be  * completely setup before writing the Interface enable (INF_EN) and  * Status channel enabled (ST_EN) asserted.  *  * The calendar table will only be enabled when LEN> 0.  *  * Current rev will only support LVTTL status IO.  */
end_comment

begin_union
union|union
name|cvmx_stxx_spi4_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_spi4_stat_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|m
range|:
literal|8
decl_stmt|;
comment|/**< CALENDAR_M (from spi4.2 spec) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
comment|/**< CALENDAR_LEN (from spi4.2 spec) */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_spi4_stat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_stat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_stat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_spi4_stat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_spi4_stat
name|cvmx_stxx_spi4_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_stat_bytes_hi  */
end_comment

begin_union
union|union
name|cvmx_stxx_stat_bytes_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_stat_bytes_hi_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of bytes sent (CNT[63:32]) */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_stat_bytes_hi_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_hi_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_hi_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_hi_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_stat_bytes_hi
name|cvmx_stxx_stat_bytes_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_stat_bytes_lo  */
end_comment

begin_union
union|union
name|cvmx_stxx_stat_bytes_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_stat_bytes_lo_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of bytes sent (CNT[31:0]) */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_stat_bytes_lo_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_lo_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_lo_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_bytes_lo_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_stat_bytes_lo
name|cvmx_stxx_stat_bytes_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_stat_ctl  */
end_comment

begin_union
union|union
name|cvmx_stxx_stat_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_stat_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< Clear all statistics counters                                                          - STX_STAT_PKT_XMT                                                          - STX_STAT_BYTES_HI                                                          - STX_STAT_BYTES_LO */
name|uint64_t
name|bckprs
range|:
literal|4
decl_stmt|;
comment|/**< The selected port for STX_BCKPRS_CNT */
else|#
directive|else
name|uint64_t
name|bckprs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_stat_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_stat_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_stat_ctl
name|cvmx_stxx_stat_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_stx#_stat_pkt_xmt  */
end_comment

begin_union
union|union
name|cvmx_stxx_stat_pkt_xmt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_stxx_stat_pkt_xmt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_stxx_stat_pkt_xmt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_pkt_xmt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_stxx_stat_pkt_xmt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_stxx_stat_pkt_xmt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_stxx_stat_pkt_xmt
name|cvmx_stxx_stat_pkt_xmt_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

