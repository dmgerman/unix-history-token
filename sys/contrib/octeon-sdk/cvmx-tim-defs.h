begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-tim-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon tim.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_TIM_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_TIM_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_BIST_RESULT
value|CVMX_TIM_BIST_RESULT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_BIST_RESULT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_BIST_RESULT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_BIST_RESULT
value|(CVMX_ADD_IO_SEG(0x0001180058000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_DBG2
value|CVMX_TIM_DBG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_DBG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_DBG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800580000A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_DBG2
value|(CVMX_ADD_IO_SEG(0x00011800580000A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_DBG3
value|CVMX_TIM_DBG3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_DBG3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_DBG3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800580000A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_DBG3
value|(CVMX_ADD_IO_SEG(0x00011800580000A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_ECC_CFG
value|CVMX_TIM_ECC_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_ECC_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_ECC_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_ECC_CFG
value|(CVMX_ADD_IO_SEG(0x0001180058000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_FR_RN_TT
value|CVMX_TIM_FR_RN_TT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_FR_RN_TT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_FR_RN_TT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_FR_RN_TT
value|(CVMX_ADD_IO_SEG(0x0001180058000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_GPIO_EN
value|CVMX_TIM_GPIO_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_GPIO_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_GPIO_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_GPIO_EN
value|(CVMX_ADD_IO_SEG(0x0001180058000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT0
value|CVMX_TIM_INT0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT0
value|(CVMX_ADD_IO_SEG(0x0001180058000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT0_EN
value|CVMX_TIM_INT0_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT0_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT0_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT0_EN
value|(CVMX_ADD_IO_SEG(0x0001180058000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT0_EVENT
value|CVMX_TIM_INT0_EVENT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT0_EVENT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT0_EVENT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT0_EVENT
value|(CVMX_ADD_IO_SEG(0x0001180058000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR
value|CVMX_TIM_INT_ECCERR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT_ECCERR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT_ECCERR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR
value|(CVMX_ADD_IO_SEG(0x0001180058000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EN
value|CVMX_TIM_INT_ECCERR_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT_ECCERR_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT_ECCERR_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000068ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EN
value|(CVMX_ADD_IO_SEG(0x0001180058000068ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EVENT0
value|CVMX_TIM_INT_ECCERR_EVENT0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT_ECCERR_EVENT0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT_ECCERR_EVENT0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000070ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EVENT0
value|(CVMX_ADD_IO_SEG(0x0001180058000070ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EVENT1
value|CVMX_TIM_INT_ECCERR_EVENT1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_INT_ECCERR_EVENT1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_INT_ECCERR_EVENT1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000078ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_INT_ECCERR_EVENT1
value|(CVMX_ADD_IO_SEG(0x0001180058000078ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG0
value|CVMX_TIM_MEM_DEBUG0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_MEM_DEBUG0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_MEM_DEBUG0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001100ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180058001100ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG1
value|CVMX_TIM_MEM_DEBUG1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_MEM_DEBUG1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_MEM_DEBUG1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001108ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG1
value|(CVMX_ADD_IO_SEG(0x0001180058001108ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG2
value|CVMX_TIM_MEM_DEBUG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_MEM_DEBUG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_MEM_DEBUG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001110ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG2
value|(CVMX_ADD_IO_SEG(0x0001180058001110ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING0
value|CVMX_TIM_MEM_RING0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_MEM_RING0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_MEM_RING0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING0
value|(CVMX_ADD_IO_SEG(0x0001180058001000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING1
value|CVMX_TIM_MEM_RING1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_MEM_RING1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_MEM_RING1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING1
value|(CVMX_ADD_IO_SEG(0x0001180058001008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_REG_BIST_RESULT
value|CVMX_TIM_REG_BIST_RESULT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_REG_BIST_RESULT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_REG_BIST_RESULT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_REG_BIST_RESULT
value|(CVMX_ADD_IO_SEG(0x0001180058000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_REG_ERROR
value|CVMX_TIM_REG_ERROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_REG_ERROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_REG_ERROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_REG_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180058000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_TIM_REG_FLAGS
value|(CVMX_ADD_IO_SEG(0x0001180058000000ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_REG_INT_MASK
value|CVMX_TIM_REG_INT_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_REG_INT_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_REG_INT_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_REG_INT_MASK
value|(CVMX_ADD_IO_SEG(0x0001180058000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_TIM_REG_READ_IDX
value|CVMX_TIM_REG_READ_IDX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_REG_READ_IDX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_REG_READ_IDX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_REG_READ_IDX
value|(CVMX_ADD_IO_SEG(0x0001180058000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_RINGX_CTL0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_RINGX_CTL0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058002000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_RINGX_CTL0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180058002000ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_RINGX_CTL1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_RINGX_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058002400ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_RINGX_CTL1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180058002400ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_RINGX_CTL2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_RINGX_CTL2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058002800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_RINGX_CTL2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180058002800ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_RINGX_DBG0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_RINGX_DBG0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058003000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_RINGX_DBG0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180058003000ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_TIM_RINGX_DBG1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_TIM_RINGX_DBG1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180058001200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_TIM_RINGX_DBG1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180058001200ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_tim_bist_result  *  * Notes:  * Access to the internal BiST results  * Each bit is the BiST result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_tim_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_bist_result_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|wqe_fifo
range|:
literal|1
decl_stmt|;
comment|/**< BIST result of the NCB_WQE FIFO (0=pass, !0=fail) */
name|uint64_t
name|lslr_fifo
range|:
literal|1
decl_stmt|;
comment|/**< BIST result of the NCB_LSLR FIFO (0=pass, !0=fail) */
name|uint64_t
name|rds_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST result of the RDS memory (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|rds_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lslr_fifo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_fifo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_bist_result_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_bist_result_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_bist_result
name|cvmx_tim_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_dbg2  */
end_comment

begin_union
union|union
name|cvmx_tim_dbg2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_dbg2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_alloc_reg
range|:
literal|8
decl_stmt|;
comment|/**< NCB Load Memory Allocation status */
name|uint64_t
name|reserved_51_55
range|:
literal|5
decl_stmt|;
name|uint64_t
name|gnt_fifo_level
range|:
literal|3
decl_stmt|;
comment|/**< NCB GRANT FIFO level */
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rwf_fifo_level
range|:
literal|5
decl_stmt|;
comment|/**< NCB requests FIFO level */
name|uint64_t
name|wqe_fifo_level
range|:
literal|8
decl_stmt|;
comment|/**< NCB WQE LD FIFO level */
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|fsm3_state
range|:
literal|4
decl_stmt|;
comment|/**< FSM 3 current state */
name|uint64_t
name|fsm2_state
range|:
literal|4
decl_stmt|;
comment|/**< FSM 2 current state */
name|uint64_t
name|fsm1_state
range|:
literal|4
decl_stmt|;
comment|/**< FSM 1 current state */
name|uint64_t
name|fsm0_state
range|:
literal|4
decl_stmt|;
comment|/**< FSM 0 current state */
else|#
directive|else
name|uint64_t
name|fsm0_state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fsm1_state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fsm2_state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fsm3_state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|wqe_fifo_level
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rwf_fifo_level
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gnt_fifo_level
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_51_55
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mem_alloc_reg
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_dbg2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_dbg2_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_dbg2
name|cvmx_tim_dbg2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_dbg3  */
end_comment

begin_union
union|union
name|cvmx_tim_dbg3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_dbg3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rings_pending_vec
range|:
literal|64
decl_stmt|;
comment|/**< Pending rings vector. Indicates which ring in TIM are                                                          pending traversal. Bit 0 represents ring 0 while bit 63                                                          represents ring 63. */
else|#
directive|else
name|uint64_t
name|rings_pending_vec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_dbg3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_dbg3_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_dbg3
name|cvmx_tim_dbg3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ecc_cfg  */
end_comment

begin_union
union|union
name|cvmx_tim_ecc_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ecc_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|ecc_flp_syn
range|:
literal|2
decl_stmt|;
comment|/**< ECC Flip Syndrome. Flip the ECC's syndrome for testing                                                          purposes, to test SBE and DBE ECC interrupts. */
name|uint64_t
name|ecc_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable ECC correction of the Ring Data Structre memory.                                                          ECC is enabled by default. */
else|#
directive|else
name|uint64_t
name|ecc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_flp_syn
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ecc_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_ecc_cfg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ecc_cfg
name|cvmx_tim_ecc_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_fr_rn_tt  *  * Notes:  * For every 64 entries in a bucket interval should be at  * least 1us.  * Minimal recommended value for Threshold register is 1us  */
end_comment

begin_union
union|union
name|cvmx_tim_fr_rn_tt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_fr_rn_tt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|thld_gp
range|:
literal|22
decl_stmt|;
comment|/**< Free Running Timer Threshold. Defines the reset value                                                          for the free running timer when it reaches zero during                                                          it's count down. This threshold only applies to the                                                          timer that is driven by GPIO edge as defined at                                                          TIM_REG_FLAGS.GPIO_EDGE                                                          ***NOTE: Added in pass 2.0 */
name|uint64_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fr_rn_tt
range|:
literal|22
decl_stmt|;
comment|/**< Free Running Timer Threshold. Defines the reset value                                                          for the free running timer when it reaches zero during                                                          it's count down.                                                          FR_RN_TT will be used in both cases where free running                                                          clock is driven externally or internally.                                                          Interval programming guidelines:                                                          For every 64 entries in a bucket interval should be at                                                          least 1us.                                                          Minimal recommended value for FR_RN_TT is 1us. */
else|#
directive|else
name|uint64_t
name|fr_rn_tt
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
name|uint64_t
name|thld_gp
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_fr_rn_tt_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_tim_fr_rn_tt_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|fr_rn_tt
range|:
literal|22
decl_stmt|;
comment|/**< Free Running Timer Threshold. Defines the reset value                                                          for the free running timer when it reaches zero during                                                          it's count down.                                                          FR_RN_TT will be used in both cases where free running                                                          clock is driven externally or internally.                                                          Interval programming guidelines:                                                          For every 64 entries in a bucket interval should be at                                                          least 1us.                                                          Minimal recommended value for FR_RN_TT is 1us. */
else|#
directive|else
name|uint64_t
name|fr_rn_tt
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_fr_rn_tt
name|cvmx_tim_fr_rn_tt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_gpio_en  */
end_comment

begin_union
union|union
name|cvmx_tim_gpio_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_gpio_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|gpio_en
range|:
literal|64
decl_stmt|;
comment|/**< Each bit correspond to rings [63:0] respectively.                                                          This register reflects the values written to                                                          TIM_RING63..0_CTL1.ENA_GPIO                                                          ***NOTE: Added in pass 2.0 for debug only. RESERVED */
else|#
directive|else
name|uint64_t
name|gpio_en
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_gpio_en_s
name|cn68xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_gpio_en
name|cvmx_tim_gpio_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int0  *  * Notes:  * A ring is in error if its interval has elapsed more than once without having been serviced. This is  * usually a programming error where number of entries in the bucket is too large for the interval  * specified for the ring.  * Any bit in the INT field should be cleared by writing '1' to it.  */
end_comment

begin_union
union|union
name|cvmx_tim_int0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|int0
range|:
literal|64
decl_stmt|;
comment|/**< Interrupt bit per ring. Each bit indicates the                                                          ring number in error. Each bit in this reg is set                                                          regardless of TIM_INT0_EN value. */
else|#
directive|else
name|uint64_t
name|int0
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int0
name|cvmx_tim_int0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int0_en  *  * Notes:  * When bit at TIM_INT0_EN is set it enables the corresponding TIM_INTO's bit for interrupt generation  * If enable bit is cleared the corresponding bit at TIM_INT0 will still be set.  * Interrupt to the cores is generated by : |(TIM_INT0& TIM_INT0_EN0)  */
end_comment

begin_union
union|union
name|cvmx_tim_int0_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int0_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|int0_en
range|:
literal|64
decl_stmt|;
comment|/**< Bit enable corresponding to TIM_INT0. */
else|#
directive|else
name|uint64_t
name|int0_en
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int0_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int0_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int0_en
name|cvmx_tim_int0_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int0_event  */
end_comment

begin_union
union|union
name|cvmx_tim_int0_event
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int0_event_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|ring_id
range|:
literal|6
decl_stmt|;
comment|/**< The first Ring ID where an interrupt occurred. */
else|#
directive|else
name|uint64_t
name|ring_id
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int0_event_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int0_event_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int0_event
name|cvmx_tim_int0_event_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int_eccerr  *  * Notes:  * Each bit in this reg is set regardless of TIM_INT_ECCERR_EN value.  *  */
end_comment

begin_union
union|union
name|cvmx_tim_int_eccerr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int_eccerr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< TIM RDS memory had a Double Bit Error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< TIM RDS memory had a Single Bit Error */
else|#
directive|else
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int_eccerr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int_eccerr_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int_eccerr
name|cvmx_tim_int_eccerr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int_eccerr_en  *  * Notes:  * When mask bit is set, the corresponding bit in TIM_INT_ECCERR is enabled. If mask bit is cleared the  * corresponding bit in TIM_INT_ECCERR will still be set but interrupt will not be reported.  */
end_comment

begin_union
union|union
name|cvmx_tim_int_eccerr_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int_eccerr_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dbe_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to TIM_REG_ECCERR.DBE */
name|uint64_t
name|sbe_en
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to TIM_REG_ECCERR.SBE */
else|#
directive|else
name|uint64_t
name|sbe_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int_eccerr_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int_eccerr_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int_eccerr_en
name|cvmx_tim_int_eccerr_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int_eccerr_event0  */
end_comment

begin_union
union|union
name|cvmx_tim_int_eccerr_event0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int_eccerr_event0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|synd
range|:
literal|7
decl_stmt|;
comment|/**< ECC Syndrome */
name|uint64_t
name|add
range|:
literal|8
decl_stmt|;
comment|/**< Memory address where the Error occurred. */
else|#
directive|else
name|uint64_t
name|add
range|:
literal|8
decl_stmt|;
name|uint64_t
name|synd
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int_eccerr_event0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int_eccerr_event0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int_eccerr_event0
name|cvmx_tim_int_eccerr_event0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_int_eccerr_event1  */
end_comment

begin_union
union|union
name|cvmx_tim_int_eccerr_event1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_int_eccerr_event1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|org_ecc
range|:
literal|7
decl_stmt|;
comment|/**< Original ECC bits where the error occured. */
name|uint64_t
name|org_rds_dat
range|:
literal|48
decl_stmt|;
comment|/**< Memory original data where the error occured. */
else|#
directive|else
name|uint64_t
name|org_rds_dat
range|:
literal|48
decl_stmt|;
name|uint64_t
name|org_ecc
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_int_eccerr_event1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_int_eccerr_event1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_int_eccerr_event1
name|cvmx_tim_int_eccerr_event1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_debug0  *  * Notes:  * Internal per-ring state intended for debug use only - tim.ctl[47:0]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
comment|/**< Ring timer enable */
name|uint64_t
name|reserved_46_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|count
range|:
literal|22
decl_stmt|;
comment|/**< Time offset for the ring                                                          Set to INTERVAL and counts down by 1 every 1024                                                          cycles when ENA==1. The HW forces a bucket                                                          traversal (and resets COUNT to INTERVAL) whenever                                                          the decrement would cause COUNT to go negative.                                                          COUNT is unpredictable whenever ENA==0.                                                          COUNT is reset to INTERVAL whenever TIM_MEM_RING1                                                          is written for the ring. */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
comment|/**< Timer interval - 1 */
else|#
directive|else
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|count
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_46_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug0
name|cvmx_tim_mem_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_debug1  *  * Notes:  * Internal per-ring state intended for debug use only - tim.sta[63:0]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|bucket
range|:
literal|13
decl_stmt|;
comment|/**< Current bucket[12:0]                                                          Reset to 0 whenever TIM_MEM_RING0 is written for                                                          the ring. Incremented (modulo BSIZE) once per                                                          bucket traversal.                                                          See TIM_MEM_DEBUG2[BUCKET]. */
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
comment|/**< Pointer[35:5] to bucket[0] */
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets - 1 */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug1
name|cvmx_tim_mem_debug1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_debug2  *  * Notes:  * Internal per-ring state intended for debug use only - tim.sta[95:64]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free chunks */
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
comment|/**< Number of words per chunk */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|7
decl_stmt|;
comment|/**< Current bucket[19:13]                                                          See TIM_MEM_DEBUG1[BUCKET]. */
else|#
directive|else
name|uint64_t
name|bucket
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug2
name|cvmx_tim_mem_debug2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_ring0  *  * Notes:  * TIM_MEM_RING0 must not be written for a ring when TIM_MEM_RING1[ENA] is set for the ring.  * Every write to TIM_MEM_RING0 clears the current bucket for the ring. (The current bucket is  * readable via TIM_MEM_DEBUG2[BUCKET],TIM_MEM_DEBUG1[BUCKET].)  * BASE is a 32-byte aligned pointer[35:0].  Only pointer[35:5] are stored because pointer[4:0] = 0.  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_ring0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_ring0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|first_bucket
range|:
literal|31
decl_stmt|;
comment|/**< Pointer[35:5] to bucket[0] */
name|uint64_t
name|num_buckets
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets - 1 */
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
comment|/**< Ring ID */
else|#
directive|else
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
name|uint64_t
name|num_buckets
range|:
literal|20
decl_stmt|;
name|uint64_t
name|first_bucket
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_ring0
name|cvmx_tim_mem_ring0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_ring1  *  * Notes:  * After a 1->0 transition on ENA, the HW will still complete a bucket traversal for the ring  * if it was pending or active prior to the transition. (SW must delay to ensure the completion  * of the traversal before reprogramming the ring.)  * Every write to TIM_MEM_RING1 resets the current time offset for the ring to the INTERVAL value.  * (The current time offset for the ring is readable via TIM_MEM_DEBUG0[COUNT].)  * CSIZE must be at least 16.  It is illegal to program CSIZE to a value that is less than 16.  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_ring1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_ring1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Ring timer enable                                                          When clear, the ring is disabled and TIM                                                          will not traverse any new buckets for the ring. */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free chunks */
name|uint64_t
name|words_per_chunk
range|:
literal|13
decl_stmt|;
comment|/**< Number of words per chunk */
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
comment|/**< Timer interval - 1, measured in 1024 cycle ticks */
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
comment|/**< Ring ID */
else|#
directive|else
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
name|uint64_t
name|words_per_chunk
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_ring1
name|cvmx_tim_mem_ring1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_bist_result  *  * Notes:  * Access to the internal BiST results  * Each bit is the BiST result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_bist_result_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|sta
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of the STA   memories (0=pass, !0=fail) */
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the NCB   memories (0=pass, !0=fail) */
name|uint64_t
name|ctl
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the CTL   memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|ctl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sta
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_bist_result
name|cvmx_tim_reg_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_error  *  * Notes:  * A ring is in error if its interval has elapsed more than once without having been serviced.  * During a CSR write to this register, the write data is used as a mask to clear the selected mask  * bits (mask'[15:0] = mask[15:0]& ~write_data[15:0]).  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_error_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask indicating the rings in error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_error_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_error
name|cvmx_tim_reg_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_flags  *  * 13e20 reserved  *  *  * Notes:  * TIM has a counter that causes a periodic tick every 1024 cycles. This counter is shared by all  * rings. (Each tick causes the HW to decrement the time offset (i.e. COUNT) for all enabled rings.)  * When ENA_TIM==0, the HW stops this shared periodic counter, so there are no more ticks, and there  * are no more new bucket traversals (for any ring).  *  * If ENA_TIM transitions 1->0, TIM will no longer create new bucket traversals, but there may  * have been previous ones. If there are ring bucket traversals that were already pending but  * not currently active (i.e. bucket traversals that need to be done by the HW, but haven't been yet)  * during this ENA_TIM 1->0 transition, then these bucket traversals will remain pending until  * ENA_TIM is later set to one. Bucket traversals that were already in progress will complete  * after the 1->0 ENA_TIM transition, though.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_flags
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_flags_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|gpio_edge
range|:
literal|2
decl_stmt|;
comment|/**< Edge used for GPIO timing                                                          2'b10 - TIM counts high to low transitions                                                          2'b01 - TIM counts low to high transitions                                                          2'b11 - TIM counts Both low to high and high to low                                                          transitions */
name|uint64_t
name|ena_gpio
range|:
literal|1
decl_stmt|;
comment|/**< Enable the external control of GPIO over the free                                                          running timer.                                                          When set, free running timer will be driven by GPIO.                                                          Free running timer will count posedge or negedge of the                                                          GPIO pin based on GPIO_EDGE register. */
name|uint64_t
name|ena_dfb
range|:
literal|1
decl_stmt|;
comment|/**< Enable Don't Free Buffer. When set chunk buffer                                                          would not be released by the TIM back to FPA. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for free-running structures */
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
comment|/**< Enables non-zero DonwWriteBacks when set                                                          When set, enables the use of                                                          DontWriteBacks during the buffer freeing                                                          operations. */
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
comment|/**< Enables the TIM section when set                                                          When set, TIM is in normal operation.                                                          When clear, time is effectively stopped for all                                                          rings in TIM. */
else|#
directive|else
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_dfb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_gpio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gpio_edge
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_tim_reg_flags_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for free-running structures */
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
comment|/**< Enables non-zero DonwWriteBacks when set                                                          When set, enables the use of                                                          DontWriteBacks during the buffer freeing                                                          operations. */
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
comment|/**< Enables the TIM section when set                                                          When set, TIM is in normal operation.                                                          When clear, time is effectively stopped for all                                                          rings in TIM. */
else|#
directive|else
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_cn30xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_flags
name|cvmx_tim_reg_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_int_mask  *  * Notes:  * Note that this CSR is present only in chip revisions beginning with pass2.  * When mask bit is set, the interrupt is enabled.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_int_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_int_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask corresponding to TIM_REG_ERROR.MASK above */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_int_mask
name|cvmx_tim_reg_int_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_read_idx  *  * Notes:  * Provides the read index during a CSR read operation to any of the CSRs that are physically stored  * as memories.  The names of these CSRs begin with the prefix "TIM_MEM_".  * IDX[7:0] is the read index.  INC[7:0] is an increment that is added to IDX[7:0] after any CSR read.  * The intended use is to initially write this CSR such that IDX=0 and INC=1.  Then, the entire  * contents of a CSR memory can be read with consecutive CSR read commands.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_read_idx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_read_idx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Index to use for next memory CSR read */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_read_idx
name|cvmx_tim_reg_read_idx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ring#_ctl0  *  * Notes:  * This CSR is a memory of 64 entries  * After a 1 to 0 transition on ENA, the HW will still complete a bucket traversal for the ring  * if it was pending or active prior to the transition. (SW must delay to ensure the completion  * of the traversal before reprogramming the ring.)  */
end_comment

begin_union
union|union
name|cvmx_tim_ringx_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_ctl0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
comment|/**< Ring timer enable */
name|uint64_t
name|intc
range|:
literal|2
decl_stmt|;
comment|/**< Interval count for Error. Defines how many intervals                                                          could elapse from bucket expiration till actual                                                          bucket traversal before HW asserts an error.                                                          Typical value is 0,1,2. */
name|uint64_t
name|timercount
range|:
literal|22
decl_stmt|;
comment|/**< Timer Count represents the ring offset; how many timer                                                          ticks have left till the interval expiration.                                                          Typical initialization value should be Interval/Constant,                                                          it is recommended that constant should be unique per ring                                                          This will create an offset between the rings.                                                          Once ENA is set,                                                          TIMERCOUNT counts down timer ticks. When TIMERCOUNT                                                          reaches zero, ring's interval expired and the HW forces                                                          a bucket traversal (and resets TIMERCOUNT to INTERVAL)                                                          TIMERCOUNT is unpredictable whenever ENA==0.                                                          It is SW responsibility to set TIMERCOUNT before                                                          TIM_RINGX_CTL0.ENA transitions from 0 to 1.                                                          When the field is set to X it would take X+1 timer tick                                                          for the interval to expire. */
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
comment|/**< Timer interval. Measured in Timer Ticks, where timer                                                          ticks are defined by TIM_FR_RN_TT.FR_RN_TT. */
else|#
directive|else
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
name|uint64_t
name|timercount
range|:
literal|22
decl_stmt|;
name|uint64_t
name|intc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ringx_ctl0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_ringx_ctl0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ringx_ctl0
name|cvmx_tim_ringx_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ring#_ctl1  *  * Notes:  * This CSR is a memory of 64 entries  * ***NOTE: Added fields in pass 2.0  */
end_comment

begin_union
union|union
name|cvmx_tim_ringx_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_ctl1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|ena_gpio
range|:
literal|1
decl_stmt|;
comment|/**< When set, ring's timer tick will be generated by the                                                          GPIO Timer. GPIO edge is defined by                                                          TIM_REG_FLAGS.GPIO_EDGE                                                          Default value zero means that timer ticks will                                                          be genearated from the Internal Timer */
name|uint64_t
name|ena_prd
range|:
literal|1
decl_stmt|;
comment|/**< Enable Periodic Mode which would disable the memory                                                          write of zeros to num_entries and chunk_remainder                                                          when a bucket is traveresed. */
name|uint64_t
name|ena_dwb
range|:
literal|1
decl_stmt|;
comment|/**< When set, enables the use of Dont Write Back during                                                          FPA buffer freeing operations */
name|uint64_t
name|ena_dfb
range|:
literal|1
decl_stmt|;
comment|/**< Enable Don't Free Buffer. When set chunk buffer                                                          would not be released by the TIM back to FPA. */
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
comment|/**< FPA Free list to free chunks to. */
name|uint64_t
name|bucket
range|:
literal|20
decl_stmt|;
comment|/**< Current bucket. Should be set to zero by SW at                                                          enable time.                                                          Incremented once per bucket traversal. */
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets minus one. If BSIZE==0 there is                                                          only one bucket in the ring. */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|20
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ena_dfb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_prd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_gpio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ringx_ctl1_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_ctl1_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
comment|/**< FPA Free list to free chunks to. */
name|uint64_t
name|bucket
range|:
literal|20
decl_stmt|;
comment|/**< Current bucket. Should be set to zero by SW at                                                          enable time.                                                          Incremented once per bucket traversal. */
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets minus one. If BSIZE==0 there is                                                          only one bucket in the ring. */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|20
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ringx_ctl1
name|cvmx_tim_ringx_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ring#_ctl2  *  * Notes:  * BASE is a 32-byte aligned pointer[35:0].  Only pointer[35:5] are stored because pointer[4:0] = 0.  * This CSR is a memory of 64 entries  */
end_comment

begin_union
union|union
name|cvmx_tim_ringx_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_ctl2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
comment|/**< Number of words per chunk. CSIZE mod(16) should be                                                          zero. */
name|uint64_t
name|reserved_31_33
range|:
literal|3
decl_stmt|;
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
comment|/**< Pointer[35:5] to bucket[0] */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reserved_31_33
range|:
literal|3
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ringx_ctl2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_ringx_ctl2_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ringx_ctl2
name|cvmx_tim_ringx_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ring#_dbg0  */
end_comment

begin_union
union|union
name|cvmx_tim_ringx_dbg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_dbg0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|fr_rn_ht
range|:
literal|22
decl_stmt|;
comment|/**< Free Running Hardware Timer. Shared by all rings and is                                                          used to generate the Timer Tick based on                                                          FR_RN_TT. */
name|uint64_t
name|timercount
range|:
literal|22
decl_stmt|;
comment|/**< Timer Count represents the ring's offset.                                                          Refer to TIM_RINGX_CTL0. */
name|uint64_t
name|cur_bucket
range|:
literal|20
decl_stmt|;
comment|/**< Current bucket. Indicates the ring's current bucket.                                                          Refer to TIM_RINGX_CTL1.BUCKET. */
else|#
directive|else
name|uint64_t
name|cur_bucket
range|:
literal|20
decl_stmt|;
name|uint64_t
name|timercount
range|:
literal|22
decl_stmt|;
name|uint64_t
name|fr_rn_ht
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ringx_dbg0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_ringx_dbg0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ringx_dbg0
name|cvmx_tim_ringx_dbg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_ring#_dbg1  */
end_comment

begin_union
union|union
name|cvmx_tim_ringx_dbg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_ringx_dbg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|ring_esr
range|:
literal|2
decl_stmt|;
comment|/**< Ring Expiration Status Register.                                                          This register hold the expiration status of the ring.                                                          2'b00 - Ring was recently traversed.                                                          2'b01 - Interval expired. Ring is queued to be traversed.                                                          2'b10 - 1st interval expiration while ring is queued to be                                                          traversed.                                                          2'b11 - 2nd interval expiration while ring is queued to be                                                          traversed. */
else|#
directive|else
name|uint64_t
name|ring_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_ringx_dbg1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_tim_ringx_dbg1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_ringx_dbg1
name|cvmx_tim_ringx_dbg1_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

