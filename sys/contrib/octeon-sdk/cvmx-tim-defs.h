begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-tim-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon tim.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_TIM_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_TIM_TYPEDEFS_H__
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180058001100ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG1
value|(CVMX_ADD_IO_SEG(0x0001180058001108ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_DEBUG2
value|(CVMX_ADD_IO_SEG(0x0001180058001110ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING0
value|(CVMX_ADD_IO_SEG(0x0001180058001000ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_MEM_RING1
value|(CVMX_ADD_IO_SEG(0x0001180058001008ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_REG_BIST_RESULT
value|(CVMX_ADD_IO_SEG(0x0001180058000080ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_REG_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180058000088ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_REG_FLAGS
value|(CVMX_ADD_IO_SEG(0x0001180058000000ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_REG_INT_MASK
value|(CVMX_ADD_IO_SEG(0x0001180058000090ull))
end_define

begin_define
define|#
directive|define
name|CVMX_TIM_REG_READ_IDX
value|(CVMX_ADD_IO_SEG(0x0001180058000008ull))
end_define

begin_comment
comment|/**  * cvmx_tim_mem_debug0  *  * Notes:  * Internal per-ring state intended for debug use only - tim.ctl[47:0]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
comment|/**< Ring timer enable */
name|uint64_t
name|reserved_46_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|count
range|:
literal|22
decl_stmt|;
comment|/**< Time offset for the ring                                                          Set to INTERVAL and counts down by 1 every 1024                                                          cycles when ENA==1. The HW forces a bucket                                                          traversal (and resets COUNT to INTERVAL) whenever                                                          the decrement would cause COUNT to go negative.                                                          COUNT is unpredictable whenever ENA==0.                                                          COUNT is reset to INTERVAL whenever TIM_MEM_RING1                                                          is written for the ring. */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
comment|/**< Timer interval - 1 */
else|#
directive|else
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|count
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_46_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug0
name|cvmx_tim_mem_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_debug1  *  * Notes:  * Internal per-ring state intended for debug use only - tim.sta[63:0]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|bucket
range|:
literal|13
decl_stmt|;
comment|/**< Current bucket[12:0]                                                          Reset to 0 whenever TIM_MEM_RING0 is written for                                                          the ring. Incremented (modulo BSIZE) once per                                                          bucket traversal.                                                          See TIM_MEM_DEBUG2[BUCKET]. */
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
comment|/**< Pointer[35:5] to bucket[0] */
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets - 1 */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|base
range|:
literal|31
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug1
name|cvmx_tim_mem_debug1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_debug2  *  * Notes:  * Internal per-ring state intended for debug use only - tim.sta[95:64]  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_debug2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_debug2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free chunks */
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
comment|/**< Number of words per chunk */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bucket
range|:
literal|7
decl_stmt|;
comment|/**< Current bucket[19:13]                                                          See TIM_MEM_DEBUG1[BUCKET]. */
else|#
directive|else
name|uint64_t
name|bucket
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|13
decl_stmt|;
name|uint64_t
name|cpool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_debug2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_debug2
name|cvmx_tim_mem_debug2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_ring0  *  * Notes:  * TIM_MEM_RING0 must not be written for a ring when TIM_MEM_RING1[ENA] is set for the ring.  * Every write to TIM_MEM_RING0 clears the current bucket for the ring. (The current bucket is  * readable via TIM_MEM_DEBUG2[BUCKET],TIM_MEM_DEBUG1[BUCKET].)  * BASE is a 32-byte aligned pointer[35:0].  Only pointer[35:5] are stored because pointer[4:0] = 0.  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_ring0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_ring0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|first_bucket
range|:
literal|31
decl_stmt|;
comment|/**< Pointer[35:5] to bucket[0] */
name|uint64_t
name|num_buckets
range|:
literal|20
decl_stmt|;
comment|/**< Number of buckets - 1 */
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
comment|/**< Ring ID */
else|#
directive|else
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
name|uint64_t
name|num_buckets
range|:
literal|20
decl_stmt|;
name|uint64_t
name|first_bucket
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_ring0
name|cvmx_tim_mem_ring0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_mem_ring1  *  * Notes:  * After a 1->0 transition on ENA, the HW will still complete a bucket traversal for the ring  * if it was pending or active prior to the transition. (SW must delay to ensure the completion  * of the traversal before reprogramming the ring.)  * Every write to TIM_MEM_RING1 resets the current time offset for the ring to the INTERVAL value.  * (The current time offset for the ring is readable via TIM_MEM_DEBUG0[COUNT].)  * CSIZE must be at least 16.  It is illegal to program CSIZE to a value that is less than 16.  * This CSR is a memory of 16 entries, and thus, the TIM_REG_READ_IDX CSR must be written before any  * CSR read operations to this address can be performed.  */
end_comment

begin_union
union|union
name|cvmx_tim_mem_ring1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_mem_ring1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Ring timer enable                                                          When clear, the ring is disabled and TIM                                                          will not traverse any new buckets for the ring. */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free chunks */
name|uint64_t
name|words_per_chunk
range|:
literal|13
decl_stmt|;
comment|/**< Number of words per chunk */
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
comment|/**< Timer interval - 1, measured in 1024 cycle ticks */
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
comment|/**< Ring ID */
else|#
directive|else
name|uint64_t
name|ring
range|:
literal|4
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|22
decl_stmt|;
name|uint64_t
name|words_per_chunk
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_mem_ring1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_mem_ring1
name|cvmx_tim_mem_ring1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_bist_result  *  * Notes:  * Access to the internal BiST results  * Each bit is the BiST result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_bist_result_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|sta
range|:
literal|2
decl_stmt|;
comment|/**< BiST result of the STA   memories (0=pass, !0=fail) */
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the NCB   memories (0=pass, !0=fail) */
name|uint64_t
name|ctl
range|:
literal|1
decl_stmt|;
comment|/**< BiST result of the CTL   memories (0=pass, !0=fail) */
else|#
directive|else
name|uint64_t
name|ctl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sta
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_bist_result_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_bist_result
name|cvmx_tim_reg_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_error  *  * Notes:  * A ring is in error if its interval has elapsed more than once without having been serviced.  * During a CSR write to this register, the write data is used as a mask to clear the selected mask  * bits (mask'[15:0] = mask[15:0]& ~write_data[15:0]).  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_error_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask indicating the rings in error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_error_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_error_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_error
name|cvmx_tim_reg_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_flags  *  * Notes:  * TIM has a counter that causes a periodic tick every 1024 cycles. This counter is shared by all  * rings. (Each tick causes the HW to decrement the time offset (i.e. COUNT) for all enabled rings.)  * When ENA_TIM==0, the HW stops this shared periodic counter, so there are no more ticks, and there  * are no more new bucket traversals (for any ring).  *  * If ENA_TIM transitions 1->0, TIM will no longer create new bucket traversals, but there may  * have been previous ones. If there are ring bucket traversals that were already pending but  * not currently active (i.e. bucket traversals that need to be done by the HW, but haven't been yet)  * during this ENA_TIM 1->0 transition, then these bucket traversals will remain pending until  * ENA_TIM is later set to one. Bucket traversals that were already in progress will complete  * after the 1->0 ENA_TIM transition, though.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_flags
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_flags_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for free-running structures */
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
comment|/**< Enables non-zero DonwWriteBacks when set                                                          When set, enables the use of                                                          DontWriteBacks during the buffer freeing                                                          operations. */
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
comment|/**< Enables the TIM section when set                                                          When set, TIM is in normal operation.                                                          When clear, time is effectively stopped for all                                                          rings in TIM. */
else|#
directive|else
name|uint64_t
name|enable_timers
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable_dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_flags_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_flags
name|cvmx_tim_reg_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_int_mask  *  * Notes:  * Note that this CSR is present only in chip revisions beginning with pass2.  * When mask bit is set, the interrupt is enabled.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_int_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_int_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Bit mask corresponding to TIM_REG_ERROR.MASK above */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_int_mask_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_int_mask
name|cvmx_tim_reg_int_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_tim_reg_read_idx  *  * Notes:  * Provides the read index during a CSR read operation to any of the CSRs that are physically stored  * as memories.  The names of these CSRs begin with the prefix "TIM_MEM_".  * IDX[7:0] is the read index.  INC[7:0] is an increment that is added to IDX[7:0] after any CSR read.  * The intended use is to initially write this CSR such that IDX=0 and INC=1.  Then, the entire  * contents of a CSR memory can be read with consecutive CSR read commands.  */
end_comment

begin_union
union|union
name|cvmx_tim_reg_read_idx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_tim_reg_read_idx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Index to use for next memory CSR read */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_tim_reg_read_idx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_tim_reg_read_idx
name|cvmx_tim_reg_read_idx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

