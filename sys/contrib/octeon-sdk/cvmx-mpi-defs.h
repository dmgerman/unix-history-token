begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-mpi-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon mpi.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_MPI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_MPI_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_CFG
value|CVMX_MPI_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_CFG
value|(CVMX_ADD_IO_SEG(0x0001070000001000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_DATX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_DATX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_DATX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000001080ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_STS
value|CVMX_MPI_STS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_STS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_STS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_STS
value|(CVMX_ADD_IO_SEG(0x0001070000001008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_TX
value|CVMX_MPI_TX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_TX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_TX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_TX
value|(CVMX_ADD_IO_SEG(0x0001070000001010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_mpi_cfg  *  * SPI_MPI interface  *  *  * Notes:  * Some of the SPI/MPI pins are muxed with UART pins.  * SPI_CLK         : spi clock, dedicated pin  * SPI_DI          : spi input, shared with UART0_DCD_N/SPI_DI, enabled when MPI_CFG[ENABLE]=1  * SPI_DO          : spi output, mux to UART0_DTR_N/SPI_DO, enabled when MPI_CFG[ENABLE]=1  * SPI_CS0_L       : chips select 0, mux to BOOT_CE_N<6>/SPI_CS0_L pin, enabled when MPI_CFG[CSENA0]=1 and MPI_CFG[ENABLE]=1  * SPI_CS1_L       : chips select 1, mux to BOOT_CE_N<7>/SPI_CS1_L pin, enabled when MPI_CFG[CSENA1]=1 and MPI_CFG[ENABLE]=1  */
end_comment

begin_union
union|union
name|cvmx_mpi_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fspi_clk = Fsclk / (2 * CLKDIV)                    |          NS                                                          CLKDIV = Fsclk / (2 * Fspi_clk) */
name|uint64_t
name|csena3
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART1_RTS_L/SPI_CS3_L pin is UART pin        |          NS                                                          1, UART1_RTS_L/SPI_CS3_L pin is SPI pin                                                             SPI_CS3_L drives UART1_RTS_L/SPI_CS3_L */
name|uint64_t
name|csena2
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_RTS_L/SPI_CS2_L pin is UART pin        |          NS                                                          1, UART0_RTS_L/SPI_CS2_L pin is SPI pin                                                             SPI_CS2_L drives  UART0_RTS_L/SPI_CS2_L */
name|uint64_t
name|csena1
range|:
literal|1
decl_stmt|;
comment|/**< If 0, BOOT_CE_N<7>/SPI_CS1_L pin is BOOT pin       |          NS                                                          1, BOOT_CE_N<7>/SPI_CS1_L pin is SPI pin                                                             SPI_CS1_L drives BOOT_CE_N<7>/SPI_CS1_L */
name|uint64_t
name|csena0
range|:
literal|1
decl_stmt|;
comment|/**< If 0, BOOT_CE_N<6>/SPI_CS0_L pin is BOOT pin       |          NS                                                          1, BOOT_CE_N<6>/SPI_CS0_L pin is SPI pin                                                             SPI_CS0_L drives BOOT_CE_N<6>/SPI_CS0_L */
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CS asserts 1/2 SCLK before transaction   |          NS                                                             1, SPI_CS assert coincident with transaction                                                          NOTE: This control apply for 2 CSs */
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO pin is driven when slave is not       |          NS                                                                expected to be driving                                                             1, SPI_DO pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between        |          NS                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                           |          NS                                                          1, CS is high asserted */
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, the MPI_CS is a GPIO, not used by MPI_TX                                                          1, CS is driven per MPI_TX intruction */
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                          |          NS                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                              |          NS                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO and SPI_DI are separate wires (SPI)   |          NS                                                                SPI_DO pin is always driven                                                             1, SPI_DO/DI is all from SPI_DO pin (MPI)                                                                SPI_DO pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, SPI_DI pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after   |          NS                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CLK idles high, 1st transition is hi->lo |          NS                                                          1, SPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI       |          NS                                                             BOOT_CE_N<7:6>/SPI_CSx_L                                                             pins are UART/BOOT pins                                                          1, UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI                                                             pins are SPI/MPI pins.                                                             BOOT_CE_N<6>/SPI_CS0_L is SPI pin if CSENA0=1                                                             BOOT_CE_N<7>/SPI_CS1_L is SPI pin if CSENA1=1 */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mpi_cfg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fsclk = Feclk / (2 * CLKDIV)                                                          CLKDIV = Feclk / (2 * Fsclk) */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CS asserts 1/2 SCLK before transaction                                                             1, MPI_CS assert coincident with transaction                                                          NOTE: only used if CSENA == 1 */
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX pin is driven when slave is not                                                                expected to be driving                                                             1, MPI_TX pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                                                          1, CS is high asserted */
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, the MPI_CS is a GPIO, not used by MPI_TX                                                          1, CS is driven per MPI_TX intruction */
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX and MPI_RX are separate wires (SPI)                                                                MPI_TX pin is always driven                                                             1, MPI_TX/RX is all from MPI_TX pin (MPI)                                                                MPI_TX pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, MPI_RX pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CLK idles high, 1st transition is hi->lo                                                          1, MPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, all MPI pins are GPIOs                                                          1, MPI_CLK, MPI_CS, and MPI_TX are driven */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_mpi_cfg_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fsclk = Feclk / (2 * CLKDIV)                                                          CLKDIV = Feclk / (2 * Fsclk) */
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX pin is driven when slave is not                                                                expected to be driving                                                             1, MPI_TX pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                                                          1, CS is high asserted */
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, the MPI_CS is a GPIO, not used by MPI_TX                                                          1, CS is driven per MPI_TX intruction */
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX and MPI_RX are separate wires (SPI)                                                                MPI_TX pin is always driven                                                             1, MPI_TX/RX is all from MPI_TX pin (MPI)                                                                MPI_TX pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, MPI_RX pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CLK idles high, 1st transition is hi->lo                                                          1, MPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, all MPI pins are GPIOs                                                          1, MPI_CLK, MPI_CS, and MPI_TX are driven */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_mpi_cfg_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_mpi_cfg_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fspi_clk = Fsclk / (2 * CLKDIV)                    |          NS                                                          CLKDIV = Fsclk / (2 * Fspi_clk) */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|csena1
range|:
literal|1
decl_stmt|;
comment|/**< If 0, BOOT_CE_N<7>/SPI_CS1_L pin is BOOT pin       |          NS                                                          1, BOOT_CE_N<7>/SPI_CS1_L pin is SPI pin                                                             SPI_CS1_L drives BOOT_CE_N<7>/SPI_CS1_L */
name|uint64_t
name|csena0
range|:
literal|1
decl_stmt|;
comment|/**< If 0, BOOT_CE_N<6>/SPI_CS0_L pin is BOOT pin       |          NS                                                          1, BOOT_CE_N<6>/SPI_CS0_L pin is SPI pin                                                             SPI_CS0_L drives BOOT_CE_N<6>/SPI_CS0_L */
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CS asserts 1/2 SCLK before transaction   |          NS                                                             1, SPI_CS assert coincident with transaction                                                          NOTE: This control apply for 2 CSs */
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO pin is driven when slave is not       |          NS                                                                expected to be driving                                                             1, SPI_DO pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between        |          NS                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                           |          NS                                                          1, CS is high asserted */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                          |          NS                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                              |          NS                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO and SPI_DI are separate wires (SPI)   |          NS                                                                SPI_DO pin is always driven                                                             1, SPI_DO/DI is all from SPI_DO pin (MPI)                                                                SPI_DO pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, SPI_DI pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after   |          NS                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CLK idles high, 1st transition is hi->lo |          NS                                                          1, SPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI       |          NS                                                             BOOT_CE_N<7:6>/SPI_CSx_L                                                             pins are UART/BOOT pins                                                          1, UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI                                                             pins are SPI/MPI pins.                                                             BOOT_CE_N<6>/SPI_CS0_L is SPI pin if CSENA0=1                                                             BOOT_CE_N<7>/SPI_CS1_L is SPI pin if CSENA1=1 */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_mpi_cfg_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fspi_clk = Fsclk / (2 * CLKDIV)                    |          NS                                                          CLKDIV = Fsclk / (2 * Fspi_clk) */
name|uint64_t
name|csena3
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART1_RTS_L/SPI_CS3_L pin is UART pin        |          NS                                                          1, UART1_RTS_L/SPI_CS3_L pin is SPI pin                                                             SPI_CS3_L drives UART1_RTS_L/SPI_CS3_L */
name|uint64_t
name|csena2
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_RTS_L/SPI_CS2_L pin is UART pin        |          NS                                                          1, UART0_RTS_L/SPI_CS2_L pin is SPI pin                                                             SPI_CS2_L drives  UART0_RTS_L/SPI_CS2_L */
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CS asserts 1/2 SCLK before transaction   |          NS                                                             1, SPI_CS assert coincident with transaction                                                          NOTE: This control apply for 4 CSs */
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO pin is driven when slave is not       |          NS                                                                expected to be driving                                                             1, SPI_DO pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between        |          NS                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                           |          NS                                                          1, CS is high asserted */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                          |          NS                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                              |          NS                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_DO and SPI_DI are separate wires (SPI)   |          NS                                                                SPI_DO pin is always driven                                                             1, SPI_DO/DI is all from SPI_DO pin (MPI)                                                                SPI_DO pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, SPI_DI pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after   |          NS                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, SPI_CLK idles high, 1st transition is hi->lo |          NS                                                          1, SPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, UART0_DTR_L/SPI_DO, UART0_DCD_L/SPI_DI       |          NS                                                             UART0_RTS_L/SPI_CS2_L, UART1_RTS_L/SPI_CS3_L                                                             pins are UART pins                                                          1, UART0_DTR_L/SPI_DO and UART0_DCD_L/SPI_DI                                                             pins are SPI/MPI pins.                                                             UART0_RTS_L/SPI_CS2_L is SPI pin if CSENA2=1                                                             UART1_RTS_L/SPI_CS3_L is SPI pin if CSENA3=1 */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|csena2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_mpi_cfg_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_cfg
name|cvmx_mpi_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_dat#  */
end_comment

begin_union
union|union
name|cvmx_mpi_datx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_datx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
comment|/**< Data to transmit/received                          |           NS */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_datx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_datx
name|cvmx_mpi_datx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_sts  */
end_comment

begin_union
union|union
name|cvmx_mpi_sts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_sts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|rxnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes written for transaction            |          NS */
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< If 0, no MPI transaction in progress               |          NS                                                          1, MPI engine is processing a transaction */
else|#
directive|else
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rxnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_sts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_sts
name|cvmx_mpi_sts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_tx  */
end_comment

begin_union
union|union
name|cvmx_mpi_tx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_tx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|csid
range|:
literal|2
decl_stmt|;
comment|/**< Which CS to assert for this transaction            |          NS */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
comment|/**< If 0, deassert CS after transaction is done        |          NS                                                          1, leave CS asserted after transactrion is done */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to transmit                        |          NS */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to shift (transmit + receive)      |          NS */
else|#
directive|else
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|csid
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mpi_tx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
comment|/**< If 0, deassert CS after transaction is done                                                          1, leave CS asserted after transactrion is done */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to transmit */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to shift (transmit + receive) */
else|#
directive|else
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mpi_tx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_tx_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_mpi_tx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|csid
range|:
literal|1
decl_stmt|;
comment|/**< Which CS to assert for this transaction            |          NS */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
comment|/**< If 0, deassert CS after transaction is done        |          NS                                                          1, leave CS asserted after transactrion is done */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to transmit                        |          NS */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to shift (transmit + receive)      |          NS */
else|#
directive|else
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|csid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mpi_tx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mpi_tx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_tx
name|cvmx_mpi_tx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

