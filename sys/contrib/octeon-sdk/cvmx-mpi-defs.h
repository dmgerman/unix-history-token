begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-mpi-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon mpi.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_MPI_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_MPI_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_CFG
value|CVMX_MPI_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_CFG
value|(CVMX_ADD_IO_SEG(0x0001070000001000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_DATX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_DATX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_DATX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000001080ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_STS
value|CVMX_MPI_STS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_STS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_STS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_STS
value|(CVMX_ADD_IO_SEG(0x0001070000001008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MPI_TX
value|CVMX_MPI_TX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MPI_TX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MPI_TX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000001010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MPI_TX
value|(CVMX_ADD_IO_SEG(0x0001070000001010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_mpi_cfg  */
end_comment

begin_union
union|union
name|cvmx_mpi_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_cfg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fsclk = Feclk / (2 * CLKDIV)                                                          CLKDIV = Feclk / (2 * Fsclk) */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CS asserts 1/2 SCLK before transaction                                                             1, MPI_CS assert coincident with transaction                                                          NOTE: only used if CSENA == 1 */
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX pin is driven when slave is not                                                                expected to be driving                                                             1, MPI_TX pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                                                          1, CS is high asserted */
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, the MPI_CS is a GPIO, not used by MPI_TX                                                          1, CS is driven per MPI_TX intruction */
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX and MPI_RX are separate wires (SPI)                                                                MPI_TX pin is always driven                                                             1, MPI_TX/RX is all from MPI_TX pin (MPI)                                                                MPI_TX pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, MPI_RX pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CLK idles high, 1st transition is hi->lo                                                          1, MPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, all MPI pins are GPIOs                                                          1, MPI_CLK, MPI_CS, and MPI_TX are driven */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cslate
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_cfg_s
name|cn30xx
decl_stmt|;
struct|struct
name|cvmx_mpi_cfg_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
comment|/**< Fsclk = Feclk / (2 * CLKDIV)                                                          CLKDIV = Feclk / (2 * Fsclk) */
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX pin is driven when slave is not                                                                expected to be driving                                                             1, MPI_TX pin is tristated when not transmitting                                                          NOTE: only used when WIREOR==1 */
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
comment|/**< Guarantee IDLECLKS idle sclk cycles between                                                          commands. */
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
comment|/**< If 0, CS is low asserted                                                          1, CS is high asserted */
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, the MPI_CS is a GPIO, not used by MPI_TX                                                          1, CS is driven per MPI_TX intruction */
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
comment|/**< If 0, polling is required                                                          1, MPI engine interrupts X end of transaction */
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
comment|/**< If 0, shift MSB first                                                          1, shift LSB first */
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_TX and MPI_RX are separate wires (SPI)                                                                MPI_TX pin is always driven                                                             1, MPI_TX/RX is all from MPI_TX pin (MPI)                                                                MPI_TX pin is tristated when not transmitting                                                          NOTE: if WIREOR==1, MPI_RX pin is not used by the                                                                MPI engine */
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
comment|/**< If 0, clock idles to value given by IDLELO after                                                             completion of MPI transaction                                                          1, clock never idles, requires CS deassertion                                                             assertion between commands */
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
comment|/**< If 0, MPI_CLK idles high, 1st transition is hi->lo                                                          1, MPI_CLK idles low, 1st transition is lo->hi */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< If 0, all MPI pins are GPIOs                                                          1, MPI_CLK, MPI_CS, and MPI_TX are driven */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idlelo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_cont
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wireor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbfirst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cshi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idleclks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tritx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_mpi_cfg_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_cfg
name|cvmx_mpi_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_dat#  */
end_comment

begin_union
union|union
name|cvmx_mpi_datx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_datx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
comment|/**< Data to transmit/received */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_datx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_datx_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_datx
name|cvmx_mpi_datx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_sts  */
end_comment

begin_union
union|union
name|cvmx_mpi_sts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_sts_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|rxnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes written for transaction */
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< If 0, no MPI transaction in progress                                                          1, MPI engine is processing a transaction */
else|#
directive|else
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rxnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_sts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_sts_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_sts
name|cvmx_mpi_sts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mpi_tx  */
end_comment

begin_union
union|union
name|cvmx_mpi_tx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mpi_tx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
comment|/**< If 0, deassert CS after transaction is done                                                          1, leave CS asserted after transactrion is done */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to transmit */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
comment|/**< Number of bytes to shift (transmit + receive) */
else|#
directive|else
name|uint64_t
name|totnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|leavecs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mpi_tx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mpi_tx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mpi_tx_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mpi_tx
name|cvmx_mpi_tx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

