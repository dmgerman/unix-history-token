begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pow-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pow.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_POW_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_POW_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_BIST_STAT
value|CVMX_POW_BIST_STAT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_BIST_STAT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_BIST_STAT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016700000003F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_BIST_STAT
value|(CVMX_ADD_IO_SEG(0x00016700000003F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_DS_PC
value|CVMX_POW_DS_PC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_DS_PC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_DS_PC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000398ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_DS_PC
value|(CVMX_ADD_IO_SEG(0x0001670000000398ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_ECC_ERR
value|CVMX_POW_ECC_ERR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_ECC_ERR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_ECC_ERR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000218ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_ECC_ERR
value|(CVMX_ADD_IO_SEG(0x0001670000000218ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_INT_CTL
value|CVMX_POW_INT_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_INT_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_INT_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000220ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_INT_CTL
value|(CVMX_ADD_IO_SEG(0x0001670000000220ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_IQ_CNTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_IQ_CNTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000340ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_IQ_CNTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000340ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_IQ_COM_CNT
value|CVMX_POW_IQ_COM_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_IQ_COM_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_IQ_COM_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000388ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_IQ_COM_CNT
value|(CVMX_ADD_IO_SEG(0x0001670000000388ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_IQ_INT
value|CVMX_POW_IQ_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_IQ_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_IQ_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000238ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_IQ_INT
value|(CVMX_ADD_IO_SEG(0x0001670000000238ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_IQ_INT_EN
value|CVMX_POW_IQ_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_IQ_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_IQ_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000240ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_IQ_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001670000000240ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_IQ_THRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_IQ_THRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016700000003A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_IQ_THRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016700000003A0ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_NOS_CNT
value|CVMX_POW_NOS_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_NOS_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_NOS_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000228ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_NOS_CNT
value|(CVMX_ADD_IO_SEG(0x0001670000000228ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_NW_TIM
value|CVMX_POW_NW_TIM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_NW_TIM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_NW_TIM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000210ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_NW_TIM
value|(CVMX_ADD_IO_SEG(0x0001670000000210ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_PF_RST_MSK
value|CVMX_POW_PF_RST_MSK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_PF_RST_MSK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_PF_RST_MSK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000230ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_PF_RST_MSK
value|(CVMX_ADD_IO_SEG(0x0001670000000230ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_PP_GRP_MSKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|11
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|9
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_PP_GRP_MSKX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_PP_GRP_MSKX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000000ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_QOS_RNDX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_QOS_RNDX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016700000001C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_QOS_RNDX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016700000001C0ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_QOS_THRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_QOS_THRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000180ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_QOS_THRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000180ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_TS_PC
value|CVMX_POW_TS_PC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_TS_PC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_TS_PC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000390ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_TS_PC
value|(CVMX_ADD_IO_SEG(0x0001670000000390ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_WA_COM_PC
value|CVMX_POW_WA_COM_PC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WA_COM_PC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WA_COM_PC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000380ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WA_COM_PC
value|(CVMX_ADD_IO_SEG(0x0001670000000380ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WA_PCX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WA_PCX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000300ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WA_PCX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000300ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT
value|CVMX_POW_WQ_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WQ_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WQ_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000200ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT
value|(CVMX_ADD_IO_SEG(0x0001670000000200ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WQ_INT_CNTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WQ_INT_CNTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT_CNTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000100ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT_PC
value|CVMX_POW_WQ_INT_PC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WQ_INT_PC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WQ_INT_PC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000208ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT_PC
value|(CVMX_ADD_IO_SEG(0x0001670000000208ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WQ_INT_THRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WQ_INT_THRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WQ_INT_THRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000080ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_POW_WS_PCX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_POW_WS_PCX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001670000000280ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_POW_WS_PCX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001670000000280ull) + ((offset)& 15) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pow_bist_stat  *  * POW_BIST_STAT = POW BIST Status Register  *  * Contains the BIST status for the POW memories ('0' = pass, '1' = fail).  *  * Also contains the BIST status for the PP's.  Each bit in the PP field is the OR of all BIST  * results for the corresponding physical PP ('0' = pass, '1' = fail).  */
end_comment

begin_union
union|union
name|cvmx_pow_bist_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_bist_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|16
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_bist_stat_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|1
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 1 BIST status */
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 0 BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 1 BIST status */
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 0 BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pow_bist_stat_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|2
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 1 BIST status */
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 0 BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 1 BIST status */
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 0 BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_pow_bist_stat_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|16
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbt
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 1 BIST status */
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 0 BIST status */
name|uint64_t
name|pend1
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory 1 BIST status */
name|uint64_t
name|pend0
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory 0 BIST status */
name|uint64_t
name|adr1
range|:
literal|1
decl_stmt|;
comment|/**< Address memory 1 BIST status */
name|uint64_t
name|adr0
range|:
literal|1
decl_stmt|;
comment|/**< Address memory 0 BIST status */
else|#
directive|else
name|uint64_t
name|adr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|adr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_pow_bist_stat_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_bist_stat_cn31xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pow_bist_stat_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|4
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 1 BIST status */
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory 0 BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 1 BIST status */
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 0 BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pow_bist_stat_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_pow_bist_stat_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|12
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbt
range|:
literal|1
decl_stmt|;
comment|/**< NCB transmitter memory BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 1 BIST status */
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
comment|/**< NCB receiver memory 0 BIST status */
name|uint64_t
name|pend1
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory 1 BIST status */
name|uint64_t
name|pend0
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory 0 BIST status */
name|uint64_t
name|adr1
range|:
literal|1
decl_stmt|;
comment|/**< Address memory 1 BIST status */
name|uint64_t
name|adr0
range|:
literal|1
decl_stmt|;
comment|/**< Address memory 0 BIST status */
else|#
directive|else
name|uint64_t
name|adr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|adr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_pow_bist_stat_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_bist_stat_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_bist_stat_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_pow_bist_stat_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|4
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
comment|/**< NCB receiver memory BIST status */
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
comment|/**< NCB transmitter memory BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_pow_bist_stat_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|6
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
comment|/**< NCB receiver memory BIST status */
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
comment|/**< NCB transmitter memory BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pow_bist_stat_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_pow_bist_stat_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|10
decl_stmt|;
comment|/**< Physical PP BIST status */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
comment|/**< POW CAM BIST status */
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
comment|/**< NCB receiver memory BIST status */
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
comment|/**< NCB transmitter memory BIST status */
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
comment|/**< Index memory BIST status */
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
comment|/**< Forward index memory BIST status */
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< Pending switch memory BIST status */
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
comment|/**< Address memory BIST status */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fidx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nbt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nbr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pp
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_pow_bist_stat_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_bist_stat
name|cvmx_pow_bist_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_ds_pc  *  * POW_DS_PC = POW De-Schedule Performance Counter  *  * Counts the number of de-schedule requests.  Write to clear.  */
end_comment

begin_union
union|union
name|cvmx_pow_ds_pc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_ds_pc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ds_pc
range|:
literal|32
decl_stmt|;
comment|/**< De-schedule performance counter */
else|#
directive|else
name|uint64_t
name|ds_pc
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_ds_pc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_ds_pc
name|cvmx_pow_ds_pc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_ecc_err  *  * POW_ECC_ERR = POW ECC Error Register  *  * Contains the single and double error bits and the corresponding interrupt enables for the ECC-  * protected POW index memory.  Also contains the syndrome value in the event of an ECC error.  *  * Also contains the remote pointer error bit and interrupt enable.  RPE is set when the POW detected  * corruption on one or more of the input queue lists in L2/DRAM (POW's local copy of the tail pointer  * for the L2/DRAM input queue did not match the last entry on the the list).   This is caused by  * L2/DRAM corruption, and is generally a fatal error because it likely caused POW to load bad work  * queue entries.  *  * This register also contains the illegal operation error bits and the corresponding interrupt  * enables as follows:  *  *<0> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state  *<1> Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state  *<2> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED or ATOMIC  *<3> Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL  *<4> Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL  *<5> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK pending  *<6> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD pending  *<7> Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending  *<8> Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with CLR_NSCHED pending  *<9> Received illegal opcode  *<10> Received ADD_WORK with tag specified as NULL_NULL  *<11> Received DBG load from PP with DBG load pending  *<12> Received CSR load from PP with CSR load pending  */
end_comment

begin_union
union|union
name|cvmx_pow_ecc_err
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_ecc_err_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
name|uint64_t
name|iop_ie
range|:
literal|13
decl_stmt|;
comment|/**< Illegal operation interrupt enables */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iop
range|:
literal|13
decl_stmt|;
comment|/**< Illegal operation errors */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rpe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Remote pointer error interrupt enable */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< Remote pointer error */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|5
decl_stmt|;
comment|/**< Syndrome value (only valid when DBE or SBE is set) */
name|uint64_t
name|dbe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Double bit error interrupt enable */
name|uint64_t
name|sbe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Single bit error interrupt enable */
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< Double bit error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< Single bit error */
else|#
directive|else
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iop
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iop_ie
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn30xx
decl_stmt|;
struct|struct
name|cvmx_pow_ecc_err_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|rpe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Remote pointer error interrupt enable */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< Remote pointer error */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|5
decl_stmt|;
comment|/**< Syndrome value (only valid when DBE or SBE is set) */
name|uint64_t
name|dbe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Double bit error interrupt enable */
name|uint64_t
name|sbe_ie
range|:
literal|1
decl_stmt|;
comment|/**< Single bit error interrupt enable */
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< Double bit error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< Single bit error */
else|#
directive|else
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe_ie
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_ecc_err_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_ecc_err
name|cvmx_pow_ecc_err_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_int_ctl  *  * POW_INT_CTL = POW Internal Control Register  *  * Contains POW internal control values (for internal use, not typically for customer use):  *  * PFR_DIS = Disable high-performance pre-fetch reset mode.  *  * NBR_THR = Assert ncb__busy when the number of remaining coherent bus NBR credits equals is less  * than or equal to this value.  */
end_comment

begin_union
union|union
name|cvmx_pow_int_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_int_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|pfr_dis
range|:
literal|1
decl_stmt|;
comment|/**< High-perf pre-fetch reset mode disable */
name|uint64_t
name|nbr_thr
range|:
literal|5
decl_stmt|;
comment|/**< NBR busy threshold */
else|#
directive|else
name|uint64_t
name|nbr_thr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pfr_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_int_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_int_ctl
name|cvmx_pow_int_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_iq_cnt#  *  * POW_IQ_CNTX = POW Input Queue Count Register (1 per QOS level)  *  * Contains a read-only count of the number of work queue entries for each QOS level.  */
end_comment

begin_union
union|union
name|cvmx_pow_iq_cntx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_iq_cntx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Input queue count for QOS level X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_cntx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_iq_cntx
name|cvmx_pow_iq_cntx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_iq_com_cnt  *  * POW_IQ_COM_CNT = POW Input Queue Combined Count Register  *  * Contains a read-only count of the total number of work queue entries in all QOS levels.  */
end_comment

begin_union
union|union
name|cvmx_pow_iq_com_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_iq_com_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Input queue combined count */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_com_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_iq_com_cnt
name|cvmx_pow_iq_com_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_iq_int  *  * POW_IQ_INT = POW Input Queue Interrupt Register  *  * Contains the bits (1 per QOS level) that can trigger the input queue interrupt.  An IQ_INT bit  * will be set if POW_IQ_CNT#QOS# changes and the resulting value is equal to POW_IQ_THR#QOS#.  */
end_comment

begin_union
union|union
name|cvmx_pow_iq_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_iq_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|iq_int
range|:
literal|8
decl_stmt|;
comment|/**< Input queue interrupt bits */
else|#
directive|else
name|uint64_t
name|iq_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_iq_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_iq_int
name|cvmx_pow_iq_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_iq_int_en  *  * POW_IQ_INT_EN = POW Input Queue Interrupt Enable Register  *  * Contains the bits (1 per QOS level) that enable the input queue interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pow_iq_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_iq_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|int_en
range|:
literal|8
decl_stmt|;
comment|/**< Input queue interrupt enable bits */
else|#
directive|else
name|uint64_t
name|int_en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_int_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_iq_int_en
name|cvmx_pow_iq_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_iq_thr#  *  * POW_IQ_THRX = POW Input Queue Threshold Register (1 per QOS level)  *  * Threshold value for triggering input queue interrupts.  */
end_comment

begin_union
union|union
name|cvmx_pow_iq_thrx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_iq_thrx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|32
decl_stmt|;
comment|/**< Input queue threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_iq_thrx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_iq_thrx
name|cvmx_pow_iq_thrx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_nos_cnt  *  * POW_NOS_CNT = POW No-schedule Count Register  *  * Contains the number of work queue entries on the no-schedule list.  */
end_comment

begin_union
union|union
name|cvmx_pow_nos_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_nos_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|12
decl_stmt|;
comment|/**< # of work queue entries on the no-schedule list */
else|#
directive|else
name|uint64_t
name|nos_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_nos_cnt_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|7
decl_stmt|;
comment|/**< # of work queue entries on the no-schedule list */
else|#
directive|else
name|uint64_t
name|nos_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pow_nos_cnt_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|9
decl_stmt|;
comment|/**< # of work queue entries on the no-schedule list */
else|#
directive|else
name|uint64_t
name|nos_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_cn31xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pow_nos_cnt_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|10
decl_stmt|;
comment|/**< # of work queue entries on the no-schedule list */
else|#
directive|else
name|uint64_t
name|nos_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pow_nos_cnt_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_cn52xx
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_pow_nos_cnt_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|nos_cnt
range|:
literal|11
decl_stmt|;
comment|/**< # of work queue entries on the no-schedule list */
else|#
directive|else
name|uint64_t
name|nos_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pow_nos_cnt_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_nos_cnt_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_nos_cnt
name|cvmx_pow_nos_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_nw_tim  *  * POW_NW_TIM = POW New Work Timer Period Register  *  * Sets the minimum period for a new work request timeout.  Period is specified in n-1 notation  * where the increment value is 1024 clock cycles.  Thus, a value of 0x0 in this register translates  * to 1024 cycles, 0x1 translates to 2048 cycles, 0x2 translates to 3072 cycles, etc...  Note: the  * maximum period for a new work request timeout is 2 times the minimum period.  Note: the new work  * request timeout counter is reset when this register is written.  *  * There are two new work request timeout cases:  *  * - WAIT bit clear.  The new work request can timeout if the timer expires before the pre-fetch  *   engine has reached the end of all work queues.  This can occur if the executable work queue  *   entry is deep in the queue and the pre-fetch engine is subject to many resets (i.e. high switch,  *   de-schedule, or new work load from other PP's).  Thus, it is possible for a PP to receive a work  *   response with the NO_WORK bit set even though there was at least one executable entry in the  *   work queues.  The other (and typical) scenario for receiving a NO_WORK response with the WAIT  *   bit clear is that the pre-fetch engine has reached the end of all work queues without finding  *   executable work.  *  * - WAIT bit set.  The new work request can timeout if the timer expires before the pre-fetch  *   engine has found executable work.  In this case, the only scenario where the PP will receive a  *   work response with the NO_WORK bit set is if the timer expires.  Note: it is still possible for  *   a PP to receive a NO_WORK response even though there was at least one executable entry in the  *   work queues.  *  * In either case, it's important to note that switches and de-schedules are higher priority  * operations that can cause the pre-fetch engine to reset.  Thus in a system with many switches or  * de-schedules occuring, it's possible for the new work timer to expire (resulting in NO_WORK  * responses) before the pre-fetch engine is able to get very deep into the work queues.  */
end_comment

begin_union
union|union
name|cvmx_pow_nw_tim
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_nw_tim_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|nw_tim
range|:
literal|10
decl_stmt|;
comment|/**< New work timer period */
else|#
directive|else
name|uint64_t
name|nw_tim
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_nw_tim_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_nw_tim
name|cvmx_pow_nw_tim_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_pf_rst_msk  *  * POW_PF_RST_MSK = POW Prefetch Reset Mask  *  * Resets the work prefetch engine when work is stored in an internal buffer (either when the add  * work arrives or when the work is reloaded from an external buffer) for an enabled QOS level  * (1 bit per QOS level).  */
end_comment

begin_union
union|union
name|cvmx_pow_pf_rst_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_pf_rst_msk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rst_msk
range|:
literal|8
decl_stmt|;
comment|/**< Prefetch engine reset mask */
else|#
directive|else
name|uint64_t
name|rst_msk
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_pf_rst_msk_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_pf_rst_msk
name|cvmx_pow_pf_rst_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_pp_grp_msk#  *  * POW_PP_GRP_MSKX = POW PP Group Mask Register (1 per PP)  *  * Selects which group(s) a PP belongs to.  A '1' in any bit position sets the PP's membership in  * the corresponding group.  A value of 0x0 will prevent the PP from receiving new work.  Note:  * disabled or non-existent PP's should have this field set to 0xffff (the reset value) in order to  * maximize POW performance.  *  * Also contains the QOS level priorities for each PP.  0x0 is highest priority, and 0x7 the lowest.  * Setting the priority to 0xf will prevent that PP from receiving work from that QOS level.  * Priority values 0x8 through 0xe are reserved and should not be used.  For a given PP, priorities  * should begin at 0x0 and remain contiguous throughout the range.  */
end_comment

begin_union
union|union
name|cvmx_pow_pp_grp_mskx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_pp_grp_mskx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|qos7_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 7 */
name|uint64_t
name|qos6_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 6 */
name|uint64_t
name|qos5_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 5 */
name|uint64_t
name|qos4_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 4 */
name|uint64_t
name|qos3_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 3 */
name|uint64_t
name|qos2_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 2 */
name|uint64_t
name|qos1_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 1 */
name|uint64_t
name|qos0_pri
range|:
literal|4
decl_stmt|;
comment|/**< PPX priority for QOS level 0 */
name|uint64_t
name|grp_msk
range|:
literal|16
decl_stmt|;
comment|/**< PPX group mask */
else|#
directive|else
name|uint64_t
name|grp_msk
range|:
literal|16
decl_stmt|;
name|uint64_t
name|qos0_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos1_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos2_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos3_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos4_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos5_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos6_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos7_pri
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_pp_grp_mskx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|grp_msk
range|:
literal|16
decl_stmt|;
comment|/**< PPX group mask */
else|#
directive|else
name|uint64_t
name|grp_msk
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pow_pp_grp_mskx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_pp_grp_mskx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_pp_grp_mskx
name|cvmx_pow_pp_grp_mskx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_qos_rnd#  *  * POW_QOS_RNDX = POW QOS Issue Round Register (4 rounds per register x 8 registers = 32 rounds)  *  * Contains the round definitions for issuing new work.  Each round consists of 8 bits with each bit  * corresponding to a QOS level.  There are 4 rounds contained in each register for a total of 32  * rounds.  The issue logic traverses through the rounds sequentially (lowest round to highest round)  * in an attempt to find new work for each PP.  Within each round, the issue logic traverses through  * the QOS levels sequentially (highest QOS to lowest QOS) skipping over each QOS level with a clear  * bit in the round mask.  Note: setting a QOS level to all zeroes in all issue round registers will  * prevent work from being issued from that QOS level.  */
end_comment

begin_union
union|union
name|cvmx_pow_qos_rndx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_qos_rndx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rnd_p3
range|:
literal|8
decl_stmt|;
comment|/**< Round mask for round Xx4+3 */
name|uint64_t
name|rnd_p2
range|:
literal|8
decl_stmt|;
comment|/**< Round mask for round Xx4+2 */
name|uint64_t
name|rnd_p1
range|:
literal|8
decl_stmt|;
comment|/**< Round mask for round Xx4+1 */
name|uint64_t
name|rnd
range|:
literal|8
decl_stmt|;
comment|/**< Round mask for round Xx4 */
else|#
directive|else
name|uint64_t
name|rnd
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rnd_p1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rnd_p2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rnd_p3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_rndx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_qos_rndx
name|cvmx_pow_qos_rndx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_qos_thr#  *  * POW_QOS_THRX = POW QOS Threshold Register (1 per QOS level)  *  * Contains the thresholds for allocating POW internal storage buffers.  If the number of remaining  * free buffers drops below the minimum threshold (MIN_THR) or the number of allocated buffers for  * this QOS level rises above the maximum threshold (MAX_THR), future incoming work queue entries  * will be buffered externally rather than internally.  This register also contains a read-only count  * of the current number of free buffers (FREE_CNT), the number of internal buffers currently  * allocated to this QOS level (BUF_CNT), and the total number of buffers on the de-schedule list  * (DES_CNT) (which is not the same as the total number of de-scheduled buffers).  */
end_comment

begin_union
union|union
name|cvmx_pow_qos_thrx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_qos_thrx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|12
decl_stmt|;
comment|/**< # of buffers on de-schedule list */
name|uint64_t
name|buf_cnt
range|:
literal|12
decl_stmt|;
comment|/**< # of internal buffers allocated to QOS level X */
name|uint64_t
name|free_cnt
range|:
literal|12
decl_stmt|;
comment|/**< # of total free buffers */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|11
decl_stmt|;
comment|/**< Max threshold for QOS level X */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|min_thr
range|:
literal|11
decl_stmt|;
comment|/**< Min threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|min_thr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_qos_thrx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|7
decl_stmt|;
comment|/**< # of buffers on de-schedule list */
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|7
decl_stmt|;
comment|/**< # of internal buffers allocated to QOS level X */
name|uint64_t
name|reserved_31_35
range|:
literal|5
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|7
decl_stmt|;
comment|/**< # of total free buffers */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|6
decl_stmt|;
comment|/**< Max threshold for QOS level X */
name|uint64_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint64_t
name|min_thr
range|:
literal|6
decl_stmt|;
comment|/**< Min threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|min_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_31_35
range|:
literal|5
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pow_qos_thrx_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|9
decl_stmt|;
comment|/**< # of buffers on de-schedule list */
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|9
decl_stmt|;
comment|/**< # of internal buffers allocated to QOS level X */
name|uint64_t
name|reserved_33_35
range|:
literal|3
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|9
decl_stmt|;
comment|/**< # of total free buffers */
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|8
decl_stmt|;
comment|/**< Max threshold for QOS level X */
name|uint64_t
name|reserved_8_11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|min_thr
range|:
literal|8
decl_stmt|;
comment|/**< Min threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|min_thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_33_35
range|:
literal|3
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_cn31xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pow_qos_thrx_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|10
decl_stmt|;
comment|/**< # of buffers on de-schedule list */
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|10
decl_stmt|;
comment|/**< # of internal buffers allocated to QOS level X */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|10
decl_stmt|;
comment|/**< # of total free buffers */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|9
decl_stmt|;
comment|/**< Max threshold for QOS level X */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|min_thr
range|:
literal|9
decl_stmt|;
comment|/**< Min threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|min_thr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pow_qos_thrx_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_cn52xx
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_pow_qos_thrx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|11
decl_stmt|;
comment|/**< # of buffers on de-schedule list */
name|uint64_t
name|reserved_47_47
range|:
literal|1
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|11
decl_stmt|;
comment|/**< # of internal buffers allocated to QOS level X */
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|11
decl_stmt|;
comment|/**< # of total free buffers */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|10
decl_stmt|;
comment|/**< Max threshold for QOS level X */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|min_thr
range|:
literal|10
decl_stmt|;
comment|/**< Min threshold for QOS level X */
else|#
directive|else
name|uint64_t
name|min_thr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|max_thr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|free_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|buf_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_47_47
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pow_qos_thrx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_qos_thrx_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_qos_thrx
name|cvmx_pow_qos_thrx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_ts_pc  *  * POW_TS_PC = POW Tag Switch Performance Counter  *  * Counts the number of tag switch requests.  Write to clear.  */
end_comment

begin_union
union|union
name|cvmx_pow_ts_pc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_ts_pc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ts_pc
range|:
literal|32
decl_stmt|;
comment|/**< Tag switch performance counter */
else|#
directive|else
name|uint64_t
name|ts_pc
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_ts_pc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_ts_pc
name|cvmx_pow_ts_pc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wa_com_pc  *  * POW_WA_COM_PC = POW Work Add Combined Performance Counter  *  * Counts the number of add new work requests for all QOS levels.  Write to clear.  */
end_comment

begin_union
union|union
name|cvmx_pow_wa_com_pc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wa_com_pc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wa_pc
range|:
literal|32
decl_stmt|;
comment|/**< Work add combined performance counter */
else|#
directive|else
name|uint64_t
name|wa_pc
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_com_pc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wa_com_pc
name|cvmx_pow_wa_com_pc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wa_pc#  *  * POW_WA_PCX = POW Work Add Performance Counter (1 per QOS level)  *  * Counts the number of add new work requests for each QOS level.  Write to clear.  */
end_comment

begin_union
union|union
name|cvmx_pow_wa_pcx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wa_pcx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wa_pc
range|:
literal|32
decl_stmt|;
comment|/**< Work add performance counter for QOS level X */
else|#
directive|else
name|uint64_t
name|wa_pc
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wa_pcx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wa_pcx
name|cvmx_pow_wa_pcx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wq_int  *  * POW_WQ_INT = POW Work Queue Interrupt Register  *  * Contains the bits (1 per group) that set work queue interrupts and are used to clear these  * interrupts.  Also contains the input queue interrupt temporary disable bits (1 per group).  For  * more information regarding this register, see the interrupt section.  */
end_comment

begin_union
union|union
name|cvmx_pow_wq_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iq_dis
range|:
literal|16
decl_stmt|;
comment|/**< Input queue interrupt temporary disable mask                                                          Corresponding WQ_INT<*> bit cannot be set due to                                                          IQ_CNT/IQ_THR check when this bit is set.                                                          Corresponding IQ_DIS bit is cleared by HW whenever:                                                           - POW_WQ_INT_CNT*[IQ_CNT] is zero, or                                                           - POW_WQ_INT_CNT*[TC_CNT]==1 when periodic                                                             counter POW_WQ_INT_PC[PC]==0 */
name|uint64_t
name|wq_int
range|:
literal|16
decl_stmt|;
comment|/**< Work queue interrupt bits                                                          Corresponding WQ_INT bit is set by HW whenever:                                                           - POW_WQ_INT_CNT*[IQ_CNT]>=                                                             POW_WQ_INT_THR*[IQ_THR] and the threshold                                                             interrupt is not disabled.                                                             IQ_DIS<*>==1 disables the interrupt.                                                             POW_WQ_INT_THR*[IQ_THR]==0 disables the int.                                                           - POW_WQ_INT_CNT*[DS_CNT]>=                                                             POW_WQ_INT_THR*[DS_THR] and the threshold                                                             interrupt is not disabled                                                             POW_WQ_INT_THR*[DS_THR]==0 disables the int.                                                           - POW_WQ_INT_CNT*[TC_CNT]==1 when periodic                                                             counter POW_WQ_INT_PC[PC]==0 and                                                             POW_WQ_INT_THR*[TC_EN]==1 and at least one of:                                                             - POW_WQ_INT_CNT*[IQ_CNT]> 0                                                             - POW_WQ_INT_CNT*[DS_CNT]> 0 */
else|#
directive|else
name|uint64_t
name|wq_int
range|:
literal|16
decl_stmt|;
name|uint64_t
name|iq_dis
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_wq_int_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wq_int
name|cvmx_pow_wq_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wq_int_cnt#  *  * POW_WQ_INT_CNTX = POW Work Queue Interrupt Count Register (1 per group)  *  * Contains a read-only copy of the counts used to trigger work queue interrupts.  For more  * information regarding this register, see the interrupt section.  */
end_comment

begin_union
union|union
name|cvmx_pow_wq_int_cntx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_cntx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Time counter current value for group X                                                          HW sets TC_CNT to POW_WQ_INT_THR*[TC_THR] whenever:                                                           - corresponding POW_WQ_INT_CNT*[IQ_CNT]==0 and                                                             corresponding POW_WQ_INT_CNT*[DS_CNT]==0                                                           - corresponding POW_WQ_INT[WQ_INT<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT[IQ_DIS<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT_THR* is written by SW                                                           - TC_CNT==1 and periodic counter                                                             POW_WQ_INT_PC[PC]==0                                                          Otherwise, HW decrements TC_CNT whenever the                                                          periodic counter POW_WQ_INT_PC[PC]==0.                                                          TC_CNT is 0 whenever POW_WQ_INT_THR*[TC_THR]==0. */
name|uint64_t
name|ds_cnt
range|:
literal|12
decl_stmt|;
comment|/**< De-schedule executable count for group X */
name|uint64_t
name|iq_cnt
range|:
literal|12
decl_stmt|;
comment|/**< Input queue executable count for group X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_wq_int_cntx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Time counter current value for group X                                                          HW sets TC_CNT to POW_WQ_INT_THR*[TC_THR] whenever:                                                           - corresponding POW_WQ_INT_CNT*[IQ_CNT]==0 and                                                             corresponding POW_WQ_INT_CNT*[DS_CNT]==0                                                           - corresponding POW_WQ_INT[WQ_INT<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT[IQ_DIS<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT_THR* is written by SW                                                           - TC_CNT==1 and periodic counter                                                             POW_WQ_INT_PC[PC]==0                                                          Otherwise, HW decrements TC_CNT whenever the                                                          periodic counter POW_WQ_INT_PC[PC]==0.                                                          TC_CNT is 0 whenever POW_WQ_INT_THR*[TC_THR]==0. */
name|uint64_t
name|reserved_19_23
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|7
decl_stmt|;
comment|/**< De-schedule executable count for group X */
name|uint64_t
name|reserved_7_11
range|:
literal|5
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|7
decl_stmt|;
comment|/**< Input queue executable count for group X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_11
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_19_23
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pow_wq_int_cntx_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Time counter current value for group X                                                          HW sets TC_CNT to POW_WQ_INT_THR*[TC_THR] whenever:                                                           - corresponding POW_WQ_INT_CNT*[IQ_CNT]==0 and                                                             corresponding POW_WQ_INT_CNT*[DS_CNT]==0                                                           - corresponding POW_WQ_INT[WQ_INT<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT[IQ_DIS<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT_THR* is written by SW                                                           - TC_CNT==1 and periodic counter                                                             POW_WQ_INT_PC[PC]==0                                                          Otherwise, HW decrements TC_CNT whenever the                                                          periodic counter POW_WQ_INT_PC[PC]==0.                                                          TC_CNT is 0 whenever POW_WQ_INT_THR*[TC_THR]==0. */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|9
decl_stmt|;
comment|/**< De-schedule executable count for group X */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|9
decl_stmt|;
comment|/**< Input queue executable count for group X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_cn31xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_cntx_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Time counter current value for group X                                                          HW sets TC_CNT to POW_WQ_INT_THR*[TC_THR] whenever:                                                           - corresponding POW_WQ_INT_CNT*[IQ_CNT]==0 and                                                             corresponding POW_WQ_INT_CNT*[DS_CNT]==0                                                           - corresponding POW_WQ_INT[WQ_INT<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT[IQ_DIS<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT_THR* is written by SW                                                           - TC_CNT==1 and periodic counter                                                             POW_WQ_INT_PC[PC]==0                                                          Otherwise, HW decrements TC_CNT whenever the                                                          periodic counter POW_WQ_INT_PC[PC]==0.                                                          TC_CNT is 0 whenever POW_WQ_INT_THR*[TC_THR]==0. */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|10
decl_stmt|;
comment|/**< De-schedule executable count for group X */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|10
decl_stmt|;
comment|/**< Input queue executable count for group X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pow_wq_int_cntx_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_cn52xx
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_cntx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Time counter current value for group X                                                          HW sets TC_CNT to POW_WQ_INT_THR*[TC_THR] whenever:                                                           - corresponding POW_WQ_INT_CNT*[IQ_CNT]==0 and                                                             corresponding POW_WQ_INT_CNT*[DS_CNT]==0                                                           - corresponding POW_WQ_INT[WQ_INT<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT[IQ_DIS<*>] is written                                                             with a 1 by SW                                                           - corresponding POW_WQ_INT_THR* is written by SW                                                           - TC_CNT==1 and periodic counter                                                             POW_WQ_INT_PC[PC]==0                                                          Otherwise, HW decrements TC_CNT whenever the                                                          periodic counter POW_WQ_INT_PC[PC]==0.                                                          TC_CNT is 0 whenever POW_WQ_INT_THR*[TC_THR]==0. */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|11
decl_stmt|;
comment|/**< De-schedule executable count for group X */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iq_cnt
range|:
literal|11
decl_stmt|;
comment|/**< Input queue executable count for group X */
else|#
directive|else
name|uint64_t
name|iq_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ds_cnt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tc_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pow_wq_int_cntx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_cntx_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wq_int_cntx
name|cvmx_pow_wq_int_cntx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wq_int_pc  *  * POW_WQ_INT_PC = POW Work Queue Interrupt Periodic Counter Register  *  * Contains the threshold value for the work queue interrupt periodic counter and also a read-only  * copy of the periodic counter.  For more information regarding this register, see the interrupt  * section.  */
end_comment

begin_union
union|union
name|cvmx_pow_wq_int_pc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_pc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pc
range|:
literal|28
decl_stmt|;
comment|/**< Work queue interrupt periodic counter */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pc_thr
range|:
literal|20
decl_stmt|;
comment|/**< Work queue interrupt periodic counter threshold */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pc_thr
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pc
range|:
literal|28
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_pc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wq_int_pc
name|cvmx_pow_wq_int_pc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_wq_int_thr#  *  * POW_WQ_INT_THRX = POW Work Queue Interrupt Threshold Register (1 per group)  *  * Contains the thresholds for enabling and setting work queue interrupts.  For more information  * regarding this register, see the interrupt section.  *  * Note: Up to 4 of the POW's internal storage buffers can be allocated for hardware use and are  * therefore not available for incoming work queue entries.  Additionally, any PP that is not in the  * NULL_NULL state consumes a buffer.  Thus in a 4 PP system, it is not advisable to set either  * IQ_THR or DS_THR to greater than 512 - 4 - 4 = 504.  Doing so may prevent the interrupt from  * ever triggering.  */
end_comment

begin_union
union|union
name|cvmx_pow_wq_int_thrx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_thrx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
comment|/**< Time counter interrupt enable for group X                                                          TC_EN must be zero when TC_THR==0 */
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
comment|/**< Time counter interrupt threshold for group X                                                          When TC_THR==0, POW_WQ_INT_CNT*[TC_CNT] is zero */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|11
decl_stmt|;
comment|/**< De-schedule count threshold for group X                                                          DS_THR==0 disables the threshold interrupt */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|11
decl_stmt|;
comment|/**< Input queue count threshold for group X                                                          IQ_THR==0 disables the threshold interrupt */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pow_wq_int_thrx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
comment|/**< Time counter interrupt enable for group X                                                          TC_EN must be zero when TC_THR==0 */
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
comment|/**< Time counter interrupt threshold for group X                                                          When TC_THR==0, POW_WQ_INT_CNT*[TC_CNT] is zero */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|6
decl_stmt|;
comment|/**< De-schedule count threshold for group X                                                          DS_THR==0 disables the threshold interrupt */
name|uint64_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|6
decl_stmt|;
comment|/**< Input queue count threshold for group X                                                          IQ_THR==0 disables the threshold interrupt */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_11
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pow_wq_int_thrx_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
comment|/**< Time counter interrupt enable for group X                                                          TC_EN must be zero when TC_THR==0 */
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
comment|/**< Time counter interrupt threshold for group X                                                          When TC_THR==0, POW_WQ_INT_CNT*[TC_CNT] is zero */
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|8
decl_stmt|;
comment|/**< De-schedule count threshold for group X                                                          DS_THR==0 disables the threshold interrupt */
name|uint64_t
name|reserved_8_11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|8
decl_stmt|;
comment|/**< Input queue count threshold for group X                                                          IQ_THR==0 disables the threshold interrupt */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_cn31xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_thrx_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
comment|/**< Time counter interrupt enable for group X                                                          TC_EN must be zero when TC_THR==0 */
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
comment|/**< Time counter interrupt threshold for group X                                                          When TC_THR==0, POW_WQ_INT_CNT*[TC_CNT] is zero */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|9
decl_stmt|;
comment|/**< De-schedule count threshold for group X                                                          DS_THR==0 disables the threshold interrupt */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|9
decl_stmt|;
comment|/**< Input queue count threshold for group X                                                          IQ_THR==0 disables the threshold interrupt */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pow_wq_int_thrx_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_cn52xx
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_pow_wq_int_thrx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
comment|/**< Time counter interrupt enable for group X                                                          TC_EN must be zero when TC_THR==0 */
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
comment|/**< Time counter interrupt threshold for group X                                                          When TC_THR==0, POW_WQ_INT_CNT*[TC_CNT] is zero */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|10
decl_stmt|;
comment|/**< De-schedule count threshold for group X                                                          DS_THR==0 disables the threshold interrupt */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iq_thr
range|:
literal|10
decl_stmt|;
comment|/**< Input queue count threshold for group X                                                          IQ_THR==0 disables the threshold interrupt */
else|#
directive|else
name|uint64_t
name|iq_thr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ds_thr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tc_thr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_pow_wq_int_thrx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_wq_int_thrx_cn52xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_wq_int_thrx
name|cvmx_pow_wq_int_thrx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pow_ws_pc#  *  * POW_WS_PCX = POW Work Schedule Performance Counter (1 per group)  *  * Counts the number of work schedules for each group.  Write to clear.  */
end_comment

begin_union
union|union
name|cvmx_pow_ws_pcx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pow_ws_pcx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ws_pc
range|:
literal|32
decl_stmt|;
comment|/**< Work schedule performance counter for group X */
else|#
directive|else
name|uint64_t
name|ws_pc
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pow_ws_pcx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pow_ws_pcx
name|cvmx_pow_ws_pcx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

