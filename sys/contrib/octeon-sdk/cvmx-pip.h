begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware Packet Input Processing unit.  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PIP_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PIP_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_DONT_INCLUDE_CONFIG
end_ifndef

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|CVMX_PIP_NUM_INPUT_PORTS
value|40
define|#
directive|define
name|CVMX_PIP_NUM_WATCHERS
value|4
comment|//
comment|// Encodes the different error and exception codes
comment|//
typedef|typedef
enum|enum
block|{
name|CVMX_PIP_L4_NO_ERR
init|=
literal|0ull
block|,
comment|//        1  = TCP (UDP) packet not long enough to cover TCP (UDP) header
name|CVMX_PIP_L4_MAL_ERR
init|=
literal|1ull
block|,
comment|//        2  = TCP/UDP checksum failure
name|CVMX_PIP_CHK_ERR
init|=
literal|2ull
block|,
comment|//        3  = TCP/UDP length check (TCP/UDP length does not match IP length)
name|CVMX_PIP_L4_LENGTH_ERR
init|=
literal|3ull
block|,
comment|//        4  = illegal TCP/UDP port (either source or dest port is zero)
name|CVMX_PIP_BAD_PRT_ERR
init|=
literal|4ull
block|,
comment|//        8  = TCP flags = FIN only
name|CVMX_PIP_TCP_FLG8_ERR
init|=
literal|8ull
block|,
comment|//        9  = TCP flags = 0
name|CVMX_PIP_TCP_FLG9_ERR
init|=
literal|9ull
block|,
comment|//        10 = TCP flags = FIN+RST+*
name|CVMX_PIP_TCP_FLG10_ERR
init|=
literal|10ull
block|,
comment|//        11 = TCP flags = SYN+URG+*
name|CVMX_PIP_TCP_FLG11_ERR
init|=
literal|11ull
block|,
comment|//        12 = TCP flags = SYN+RST+*
name|CVMX_PIP_TCP_FLG12_ERR
init|=
literal|12ull
block|,
comment|//        13 = TCP flags = SYN+FIN+*
name|CVMX_PIP_TCP_FLG13_ERR
init|=
literal|13ull
block|}
name|cvmx_pip_l4_err_t
typedef|;
typedef|typedef
enum|enum
block|{
name|CVMX_PIP_IP_NO_ERR
init|=
literal|0ull
block|,
comment|//        1 = not IPv4 or IPv6
name|CVMX_PIP_NOT_IP
init|=
literal|1ull
block|,
comment|//        2 = IPv4 header checksum violation
name|CVMX_PIP_IPV4_HDR_CHK
init|=
literal|2ull
block|,
comment|//        3 = malformed (packet not long enough to cover IP hdr)
name|CVMX_PIP_IP_MAL_HDR
init|=
literal|3ull
block|,
comment|//        4 = malformed (packet not long enough to cover len in IP hdr)
name|CVMX_PIP_IP_MAL_PKT
init|=
literal|4ull
block|,
comment|//        5 = TTL / hop count equal zero
name|CVMX_PIP_TTL_HOP
init|=
literal|5ull
block|,
comment|//        6 = IPv4 options / IPv6 early extension headers
name|CVMX_PIP_OPTS
init|=
literal|6ull
block|}
name|cvmx_pip_ip_exc_t
typedef|;
comment|/**  * NOTES  *       late collision (data received before collision)  *            late collisions cannot be detected by the receiver  *            they would appear as JAM bits which would appear as bad FCS  *            or carrier extend error which is CVMX_PIP_EXTEND_ERR  */
typedef|typedef
enum|enum
block|{
comment|/**      * No error      */
name|CVMX_PIP_RX_NO_ERR
init|=
literal|0ull
block|,
name|CVMX_PIP_PARTIAL_ERR
init|=
literal|1ull
block|,
comment|// RGM+SPI            1 = partially received packet (buffering/bandwidth not adequate)
name|CVMX_PIP_JABBER_ERR
init|=
literal|2ull
block|,
comment|// RGM+SPI            2 = receive packet too large and truncated
name|CVMX_PIP_OVER_FCS_ERR
init|=
literal|3ull
block|,
comment|// RGM                3 = max frame error (pkt len> max frame len) (with FCS error)
name|CVMX_PIP_OVER_ERR
init|=
literal|4ull
block|,
comment|// RGM+SPI            4 = max frame error (pkt len> max frame len)
name|CVMX_PIP_ALIGN_ERR
init|=
literal|5ull
block|,
comment|// RGM                5 = nibble error (data not byte multiple - 100M and 10M only)
name|CVMX_PIP_UNDER_FCS_ERR
init|=
literal|6ull
block|,
comment|// RGM                6 = min frame error (pkt len< min frame len) (with FCS error)
name|CVMX_PIP_GMX_FCS_ERR
init|=
literal|7ull
block|,
comment|// RGM                7 = FCS error
name|CVMX_PIP_UNDER_ERR
init|=
literal|8ull
block|,
comment|// RGM+SPI            8 = min frame error (pkt len< min frame len)
name|CVMX_PIP_EXTEND_ERR
init|=
literal|9ull
block|,
comment|// RGM                9 = Frame carrier extend error
name|CVMX_PIP_LENGTH_ERR
init|=
literal|10ull
block|,
comment|// RGM               10 = length mismatch (len did not match len in L2 length/type)
name|CVMX_PIP_DAT_ERR
init|=
literal|11ull
block|,
comment|// RGM               11 = Frame error (some or all data bits marked err)
name|CVMX_PIP_DIP_ERR
init|=
literal|11ull
block|,
comment|//     SPI           11 = DIP4 error
name|CVMX_PIP_SKIP_ERR
init|=
literal|12ull
block|,
comment|// RGM               12 = packet was not large enough to pass the skipper - no inspection could occur
name|CVMX_PIP_NIBBLE_ERR
init|=
literal|13ull
block|,
comment|// RGM               13 = studder error (data not repeated - 100M and 10M only)
name|CVMX_PIP_PIP_FCS
init|=
literal|16L
block|,
comment|// RGM+SPI           16 = FCS error
name|CVMX_PIP_PIP_SKIP_ERR
init|=
literal|17L
block|,
comment|// RGM+SPI+PCI       17 = packet was not large enough to pass the skipper - no inspection could occur
name|CVMX_PIP_PIP_L2_MAL_HDR
init|=
literal|18L
comment|// RGM+SPI+PCI       18 = malformed l2 (packet not long enough to cover L2 hdr)
comment|// NOTES
comment|//       xx = late collision (data received before collision)
comment|//            late collisions cannot be detected by the receiver
comment|//            they would appear as JAM bits which would appear as bad FCS
comment|//            or carrier extend error which is CVMX_PIP_EXTEND_ERR
block|}
name|cvmx_pip_rcv_err_t
typedef|;
comment|/**  * This defines the err_code field errors in the work Q entry  */
typedef|typedef
union|union
block|{
name|cvmx_pip_l4_err_t
name|l4_err
decl_stmt|;
name|cvmx_pip_ip_exc_t
name|ip_exc
decl_stmt|;
name|cvmx_pip_rcv_err_t
name|rcv_err
decl_stmt|;
block|}
name|cvmx_pip_err_t
typedef|;
comment|/**  * Status statistics for a port  */
typedef|typedef
struct|struct
block|{
name|uint32_t
name|dropped_octets
decl_stmt|;
comment|/**< Inbound octets marked to be dropped by the IPD */
name|uint32_t
name|dropped_packets
decl_stmt|;
comment|/**< Inbound packets marked to be dropped by the IPD */
name|uint32_t
name|pci_raw_packets
decl_stmt|;
comment|/**< RAW PCI Packets received by PIP per port */
name|uint32_t
name|octets
decl_stmt|;
comment|/**< Number of octets processed by PIP */
name|uint32_t
name|packets
decl_stmt|;
comment|/**< Number of packets processed by PIP */
name|uint32_t
name|multicast_packets
decl_stmt|;
comment|/**< Number of indentified L2 multicast packets.                                             Does not include broadcast packets.                                             Only includes packets whose parse mode is                                             SKIP_TO_L2 */
name|uint32_t
name|broadcast_packets
decl_stmt|;
comment|/**< Number of indentified L2 broadcast packets.                                             Does not include multicast packets.                                             Only includes packets whose parse mode is                                             SKIP_TO_L2 */
name|uint32_t
name|len_64_packets
decl_stmt|;
comment|/**< Number of 64B packets */
name|uint32_t
name|len_65_127_packets
decl_stmt|;
comment|/**< Number of 65-127B packets */
name|uint32_t
name|len_128_255_packets
decl_stmt|;
comment|/**< Number of 128-255B packets */
name|uint32_t
name|len_256_511_packets
decl_stmt|;
comment|/**< Number of 256-511B packets */
name|uint32_t
name|len_512_1023_packets
decl_stmt|;
comment|/**< Number of 512-1023B packets */
name|uint32_t
name|len_1024_1518_packets
decl_stmt|;
comment|/**< Number of 1024-1518B packets */
name|uint32_t
name|len_1519_max_packets
decl_stmt|;
comment|/**< Number of 1519-max packets */
name|uint32_t
name|fcs_align_err_packets
decl_stmt|;
comment|/**< Number of packets with FCS or Align opcode errors */
name|uint32_t
name|runt_packets
decl_stmt|;
comment|/**< Number of packets with length< min */
name|uint32_t
name|runt_crc_packets
decl_stmt|;
comment|/**< Number of packets with length< min and FCS error */
name|uint32_t
name|oversize_packets
decl_stmt|;
comment|/**< Number of packets with length> max */
name|uint32_t
name|oversize_crc_packets
decl_stmt|;
comment|/**< Number of packets with length> max and FCS error */
name|uint32_t
name|inb_packets
decl_stmt|;
comment|/**< Number of packets without GMX/SPX/PCI errors received by PIP */
name|uint64_t
name|inb_octets
decl_stmt|;
comment|/**< Total number of octets from all packets received by PIP, including CRC */
name|uint16_t
name|inb_errors
decl_stmt|;
comment|/**< Number of packets with GMX/SPX/PCI errors received by PIP */
block|}
name|cvmx_pip_port_status_t
typedef|;
comment|/**  * Definition of the PIP custom header that can be prepended  * to a packet by external hardware.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rawfull
range|:
literal|1
decl_stmt|;
comment|/**< Documented as R - Set if the Packet is RAWFULL. If set,                                                             this header must be the full 8 bytes */
name|uint64_t
name|reserved0
range|:
literal|5
decl_stmt|;
comment|/**< Must be zero */
name|cvmx_pip_port_parse_mode_t
name|parse_mode
range|:
literal|2
decl_stmt|;
comment|/**< PIP parse mode for this packet */
name|uint64_t
name|reserved1
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|skip_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip amount, including this header, to the beginning of the packet */
name|uint64_t
name|reserved2
range|:
literal|6
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< POW input queue for this packet */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< POW input group for this packet */
name|uint64_t
name|rs
range|:
literal|1
decl_stmt|;
comment|/**< Flag to store this packet in the work queue entry, if possible */
name|cvmx_pow_tag_type_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< POW input tag type */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< POW input tag */
block|}
name|s
struct|;
block|}
name|cvmx_pip_pkt_inst_hdr_t
typedef|;
comment|/* CSR typedefs have been moved to cvmx-csr-*.h */
comment|/**  * Configure an ethernet input port  *  * @param port_num Port number to configure  * @param port_cfg Port hardware configuration  * @param port_tag_cfg  *                 Port POW tagging configuration  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_port
parameter_list|(
name|uint64_t
name|port_num
parameter_list|,
name|cvmx_pip_port_cfg_t
name|port_cfg
parameter_list|,
name|cvmx_pip_port_tag_cfg_t
name|port_tag_cfg
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_PRT_CFGX
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|port_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|port_tag_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * @deprecated      This function is a thin wrapper around the Pass1 version  *                  of the CVMX_PIP_QOS_WATCHX CSR; Pass2 has added a field for  *                  setting the group that is incompatible with this function,  *                  the preferred upgrade path is to use the CSR directly.  *  * Configure the global QoS packet watchers. Each watcher is  * capable of matching a field in a packet to determine the  * QoS queue for scheduling.  *  * @param watcher    Watcher number to configure (0 - 3).  * @param match_type Watcher match type  * @param match_value  *                   Value the watcher will match against  * @param qos        QoS queue for packets matching this watcher  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_watcher
parameter_list|(
name|uint64_t
name|watcher
parameter_list|,
name|cvmx_pip_qos_watch_types
name|match_type
parameter_list|,
name|uint64_t
name|match_value
parameter_list|,
name|uint64_t
name|qos
parameter_list|)
block|{
name|cvmx_pip_port_watcher_cfg_t
name|watcher_config
decl_stmt|;
name|watcher_config
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|watcher_config
operator|.
name|s
operator|.
name|match_type
operator|=
name|match_type
expr_stmt|;
name|watcher_config
operator|.
name|s
operator|.
name|match_value
operator|=
name|match_value
expr_stmt|;
name|watcher_config
operator|.
name|s
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_QOS_WATCHX
argument_list|(
name|watcher
argument_list|)
argument_list|,
name|watcher_config
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Configure the VLAN priority to QoS queue mapping.  *  * @param vlan_priority  *               VLAN priority (0-7)  * @param qos    QoS queue for packets matching this watcher  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_vlan_qos
parameter_list|(
name|uint64_t
name|vlan_priority
parameter_list|,
name|uint64_t
name|qos
parameter_list|)
block|{
name|cvmx_pip_qos_vlanx_t
name|pip_qos_vlanx
decl_stmt|;
name|pip_qos_vlanx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_qos_vlanx
operator|.
name|s
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_QOS_VLANX
argument_list|(
name|vlan_priority
argument_list|)
argument_list|,
name|pip_qos_vlanx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Configure the Diffserv to QoS queue mapping.  *  * @param diffserv Diffserv field value (0-63)  * @param qos      QoS queue for packets matching this watcher  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_diffserv_qos
parameter_list|(
name|uint64_t
name|diffserv
parameter_list|,
name|uint64_t
name|qos
parameter_list|)
block|{
name|cvmx_pip_qos_diffx_t
name|pip_qos_diffx
decl_stmt|;
name|pip_qos_diffx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_qos_diffx
operator|.
name|s
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_QOS_DIFFX
argument_list|(
name|diffserv
argument_list|)
argument_list|,
name|pip_qos_diffx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Get the status counters for a port.  *  * @param port_num Port number to get statistics for.  * @param clear    Set to 1 to clear the counters after they are read  * @param status   Where to put the results.  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_get_port_status
parameter_list|(
name|uint64_t
name|port_num
parameter_list|,
name|uint64_t
name|clear
parameter_list|,
name|cvmx_pip_port_status_t
modifier|*
name|status
parameter_list|)
block|{
name|cvmx_pip_stat_ctl_t
name|pip_stat_ctl
decl_stmt|;
name|cvmx_pip_stat0_prtx_t
name|stat0
decl_stmt|;
name|cvmx_pip_stat1_prtx_t
name|stat1
decl_stmt|;
name|cvmx_pip_stat2_prtx_t
name|stat2
decl_stmt|;
name|cvmx_pip_stat3_prtx_t
name|stat3
decl_stmt|;
name|cvmx_pip_stat4_prtx_t
name|stat4
decl_stmt|;
name|cvmx_pip_stat5_prtx_t
name|stat5
decl_stmt|;
name|cvmx_pip_stat6_prtx_t
name|stat6
decl_stmt|;
name|cvmx_pip_stat7_prtx_t
name|stat7
decl_stmt|;
name|cvmx_pip_stat8_prtx_t
name|stat8
decl_stmt|;
name|cvmx_pip_stat9_prtx_t
name|stat9
decl_stmt|;
name|cvmx_pip_stat_inb_pktsx_t
name|pip_stat_inb_pktsx
decl_stmt|;
name|cvmx_pip_stat_inb_octsx_t
name|pip_stat_inb_octsx
decl_stmt|;
name|cvmx_pip_stat_inb_errsx_t
name|pip_stat_inb_errsx
decl_stmt|;
name|pip_stat_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_stat_ctl
operator|.
name|s
operator|.
name|rdclr
operator|=
name|clear
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_STAT_CTL
argument_list|,
name|pip_stat_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT0_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT1_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT2_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT3_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat4
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT4_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat5
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT5_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat6
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT6_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat7
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT7_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT8_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT9_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_pktsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_PKTSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_octsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_OCTSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_errsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_ERRSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|->
name|dropped_octets
operator|=
name|stat0
operator|.
name|s
operator|.
name|drp_octs
expr_stmt|;
name|status
operator|->
name|dropped_packets
operator|=
name|stat0
operator|.
name|s
operator|.
name|drp_pkts
expr_stmt|;
name|status
operator|->
name|octets
operator|=
name|stat1
operator|.
name|s
operator|.
name|octs
expr_stmt|;
name|status
operator|->
name|pci_raw_packets
operator|=
name|stat2
operator|.
name|s
operator|.
name|raw
expr_stmt|;
name|status
operator|->
name|packets
operator|=
name|stat2
operator|.
name|s
operator|.
name|pkts
expr_stmt|;
name|status
operator|->
name|multicast_packets
operator|=
name|stat3
operator|.
name|s
operator|.
name|mcst
expr_stmt|;
name|status
operator|->
name|broadcast_packets
operator|=
name|stat3
operator|.
name|s
operator|.
name|bcst
expr_stmt|;
name|status
operator|->
name|len_64_packets
operator|=
name|stat4
operator|.
name|s
operator|.
name|h64
expr_stmt|;
name|status
operator|->
name|len_65_127_packets
operator|=
name|stat4
operator|.
name|s
operator|.
name|h65to127
expr_stmt|;
name|status
operator|->
name|len_128_255_packets
operator|=
name|stat5
operator|.
name|s
operator|.
name|h128to255
expr_stmt|;
name|status
operator|->
name|len_256_511_packets
operator|=
name|stat5
operator|.
name|s
operator|.
name|h256to511
expr_stmt|;
name|status
operator|->
name|len_512_1023_packets
operator|=
name|stat6
operator|.
name|s
operator|.
name|h512to1023
expr_stmt|;
name|status
operator|->
name|len_1024_1518_packets
operator|=
name|stat6
operator|.
name|s
operator|.
name|h1024to1518
expr_stmt|;
name|status
operator|->
name|len_1519_max_packets
operator|=
name|stat7
operator|.
name|s
operator|.
name|h1519
expr_stmt|;
name|status
operator|->
name|fcs_align_err_packets
operator|=
name|stat7
operator|.
name|s
operator|.
name|fcs
expr_stmt|;
name|status
operator|->
name|runt_packets
operator|=
name|stat8
operator|.
name|s
operator|.
name|undersz
expr_stmt|;
name|status
operator|->
name|runt_crc_packets
operator|=
name|stat8
operator|.
name|s
operator|.
name|frag
expr_stmt|;
name|status
operator|->
name|oversize_packets
operator|=
name|stat9
operator|.
name|s
operator|.
name|oversz
expr_stmt|;
name|status
operator|->
name|oversize_crc_packets
operator|=
name|stat9
operator|.
name|s
operator|.
name|jabber
expr_stmt|;
name|status
operator|->
name|inb_packets
operator|=
name|pip_stat_inb_pktsx
operator|.
name|s
operator|.
name|pkts
expr_stmt|;
name|status
operator|->
name|inb_octets
operator|=
name|pip_stat_inb_octsx
operator|.
name|s
operator|.
name|octs
expr_stmt|;
name|status
operator|->
name|inb_errors
operator|=
name|pip_stat_inb_errsx
operator|.
name|s
operator|.
name|errs
expr_stmt|;
if|if
condition|(
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
block|{
comment|/* Kludge to fix Octeon Pass 1 errata - Drop counts don't work */
if|if
condition|(
name|status
operator|->
name|inb_packets
operator|>
name|status
operator|->
name|packets
condition|)
name|status
operator|->
name|dropped_packets
operator|=
name|status
operator|->
name|inb_packets
operator|-
name|status
operator|->
name|packets
expr_stmt|;
else|else
name|status
operator|->
name|dropped_packets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|inb_octets
operator|-
name|status
operator|->
name|inb_packets
operator|*
literal|4
operator|>
name|status
operator|->
name|octets
condition|)
name|status
operator|->
name|dropped_octets
operator|=
name|status
operator|->
name|inb_octets
operator|-
name|status
operator|->
name|inb_packets
operator|*
literal|4
operator|-
name|status
operator|->
name|octets
expr_stmt|;
else|else
name|status
operator|->
name|dropped_octets
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**  * Configure the hardware CRC engine  *  * @param interface Interface to configure (0 or 1)  * @param invert_result  *                 Invert the result of the CRC  * @param reflect  Reflect  * @param initialization_vector  *                 CRC initialization vector  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_crc
parameter_list|(
name|uint64_t
name|interface
parameter_list|,
name|uint64_t
name|invert_result
parameter_list|,
name|uint64_t
name|reflect
parameter_list|,
name|uint32_t
name|initialization_vector
parameter_list|)
block|{
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
block|{
name|cvmx_pip_crc_ctlx_t
name|config
decl_stmt|;
name|cvmx_pip_crc_ivx_t
name|pip_crc_ivx
decl_stmt|;
name|config
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|invres
operator|=
name|invert_result
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|reflect
operator|=
name|reflect
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_CRC_CTLX
argument_list|(
name|interface
argument_list|)
argument_list|,
name|config
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pip_crc_ivx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_crc_ivx
operator|.
name|s
operator|.
name|iv
operator|=
name|initialization_vector
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_CRC_IVX
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pip_crc_ivx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Clear all bits in a tag mask. This should be called on  * startup before any calls to cvmx_pip_tag_mask_set. Each bit  * set in the final mask represent a byte used in the packet for  * tag generation.  *  * @param mask_index Which tag mask to clear (0..3)  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_tag_mask_clear
parameter_list|(
name|uint64_t
name|mask_index
parameter_list|)
block|{
name|uint64_t
name|index
decl_stmt|;
name|cvmx_pip_tag_incx_t
name|pip_tag_incx
decl_stmt|;
name|pip_tag_incx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_tag_incx
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
name|mask_index
operator|*
literal|16
init|;
name|index
operator|<
operator|(
name|mask_index
operator|+
literal|1
operator|)
operator|*
literal|16
condition|;
name|index
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|,
name|pip_tag_incx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Sets a range of bits in the tag mask. The tag mask is used  * when the cvmx_pip_port_tag_cfg_t tag_mode is non zero.  * There are four separate masks that can be configured.  *  * @param mask_index Which tag mask to modify (0..3)  * @param offset     Offset into the bitmask to set bits at. Use the GCC macro  *                   offsetof() to determine the offsets into packet headers.  *                   For example, offsetof(ethhdr, protocol) returns the offset  *                   of the ethernet protocol field.  The bitmask selects which bytes  *                   to include the the tag, with bit offset X selecting byte at offset X  *                   from the beginning of the packet data.  * @param len        Number of bytes to include. Usually this is the sizeof()  *                   the field.  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_tag_mask_set
parameter_list|(
name|uint64_t
name|mask_index
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|cvmx_pip_tag_incx_t
name|pip_tag_incx
decl_stmt|;
name|uint64_t
name|index
init|=
name|mask_index
operator|*
literal|16
operator|+
name|offset
operator|/
literal|8
decl_stmt|;
name|pip_tag_incx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|pip_tag_incx
operator|.
name|s
operator|.
name|en
operator||=
literal|0x80
operator|>>
operator|(
name|offset
operator|&
literal|0x7
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|,
name|pip_tag_incx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __CVMX_PIP_H__ */
end_comment

end_unit

