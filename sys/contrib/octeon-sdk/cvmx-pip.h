begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware Packet Input Processing unit.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PIP_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PIP_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-pip-defs.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_DONT_INCLUDE_CONFIG
end_ifndef

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|CVMX_PIP_NUM_INPUT_PORTS
value|46
comment|/*  * Encodes the different error and exception codes  */
typedef|typedef
enum|enum
block|{
name|CVMX_PIP_L4_NO_ERR
init|=
literal|0ull
block|,
comment|/*        1  = TCP (UDP) packet not long enough to cover TCP (UDP) header */
name|CVMX_PIP_L4_MAL_ERR
init|=
literal|1ull
block|,
comment|/*        2  = TCP/UDP checksum failure */
name|CVMX_PIP_CHK_ERR
init|=
literal|2ull
block|,
comment|/*        3  = TCP/UDP length check (TCP/UDP length does not match IP length) */
name|CVMX_PIP_L4_LENGTH_ERR
init|=
literal|3ull
block|,
comment|/*        4  = illegal TCP/UDP port (either source or dest port is zero) */
name|CVMX_PIP_BAD_PRT_ERR
init|=
literal|4ull
block|,
comment|/*        8  = TCP flags = FIN only */
name|CVMX_PIP_TCP_FLG8_ERR
init|=
literal|8ull
block|,
comment|/*        9  = TCP flags = 0 */
name|CVMX_PIP_TCP_FLG9_ERR
init|=
literal|9ull
block|,
comment|/*        10 = TCP flags = FIN+RST+* */
name|CVMX_PIP_TCP_FLG10_ERR
init|=
literal|10ull
block|,
comment|/*        11 = TCP flags = SYN+URG+* */
name|CVMX_PIP_TCP_FLG11_ERR
init|=
literal|11ull
block|,
comment|/*        12 = TCP flags = SYN+RST+* */
name|CVMX_PIP_TCP_FLG12_ERR
init|=
literal|12ull
block|,
comment|/*        13 = TCP flags = SYN+FIN+* */
name|CVMX_PIP_TCP_FLG13_ERR
init|=
literal|13ull
block|}
name|cvmx_pip_l4_err_t
typedef|;
typedef|typedef
enum|enum
block|{
name|CVMX_PIP_IP_NO_ERR
init|=
literal|0ull
block|,
comment|/*        1 = not IPv4 or IPv6 */
name|CVMX_PIP_NOT_IP
init|=
literal|1ull
block|,
comment|/*        2 = IPv4 header checksum violation */
name|CVMX_PIP_IPV4_HDR_CHK
init|=
literal|2ull
block|,
comment|/*        3 = malformed (packet not long enough to cover IP hdr) */
name|CVMX_PIP_IP_MAL_HDR
init|=
literal|3ull
block|,
comment|/*        4 = malformed (packet not long enough to cover len in IP hdr) */
name|CVMX_PIP_IP_MAL_PKT
init|=
literal|4ull
block|,
comment|/*        5 = TTL / hop count equal zero */
name|CVMX_PIP_TTL_HOP
init|=
literal|5ull
block|,
comment|/*        6 = IPv4 options / IPv6 early extension headers */
name|CVMX_PIP_OPTS
init|=
literal|6ull
block|}
name|cvmx_pip_ip_exc_t
typedef|;
comment|/**  * NOTES  *       late collision (data received before collision)  *            late collisions cannot be detected by the receiver  *            they would appear as JAM bits which would appear as bad FCS  *            or carrier extend error which is CVMX_PIP_EXTEND_ERR  */
typedef|typedef
enum|enum
block|{
comment|/**      * No error      */
name|CVMX_PIP_RX_NO_ERR
init|=
literal|0ull
block|,
name|CVMX_PIP_PARTIAL_ERR
init|=
literal|1ull
block|,
comment|/* RGM+SPI            1 = partially received packet (buffering/bandwidth not adequate) */
name|CVMX_PIP_JABBER_ERR
init|=
literal|2ull
block|,
comment|/* RGM+SPI            2 = receive packet too large and truncated */
name|CVMX_PIP_OVER_FCS_ERR
init|=
literal|3ull
block|,
comment|/* RGM                3 = max frame error (pkt len> max frame len) (with FCS error) */
name|CVMX_PIP_OVER_ERR
init|=
literal|4ull
block|,
comment|/* RGM+SPI            4 = max frame error (pkt len> max frame len) */
name|CVMX_PIP_ALIGN_ERR
init|=
literal|5ull
block|,
comment|/* RGM                5 = nibble error (data not byte multiple - 100M and 10M only) */
name|CVMX_PIP_UNDER_FCS_ERR
init|=
literal|6ull
block|,
comment|/* RGM                6 = min frame error (pkt len< min frame len) (with FCS error) */
name|CVMX_PIP_GMX_FCS_ERR
init|=
literal|7ull
block|,
comment|/* RGM                7 = FCS error */
name|CVMX_PIP_UNDER_ERR
init|=
literal|8ull
block|,
comment|/* RGM+SPI            8 = min frame error (pkt len< min frame len) */
name|CVMX_PIP_EXTEND_ERR
init|=
literal|9ull
block|,
comment|/* RGM                9 = Frame carrier extend error */
name|CVMX_PIP_TERMINATE_ERR
init|=
literal|9ull
block|,
comment|/* XAUI               9 = Packet was terminated with an idle cycle */
name|CVMX_PIP_LENGTH_ERR
init|=
literal|10ull
block|,
comment|/* RGM               10 = length mismatch (len did not match len in L2 length/type) */
name|CVMX_PIP_DAT_ERR
init|=
literal|11ull
block|,
comment|/* RGM               11 = Frame error (some or all data bits marked err) */
name|CVMX_PIP_DIP_ERR
init|=
literal|11ull
block|,
comment|/*     SPI           11 = DIP4 error */
name|CVMX_PIP_SKIP_ERR
init|=
literal|12ull
block|,
comment|/* RGM               12 = packet was not large enough to pass the skipper - no inspection could occur */
name|CVMX_PIP_NIBBLE_ERR
init|=
literal|13ull
block|,
comment|/* RGM               13 = studder error (data not repeated - 100M and 10M only) */
name|CVMX_PIP_PIP_FCS
init|=
literal|16L
block|,
comment|/* RGM+SPI           16 = FCS error */
name|CVMX_PIP_PIP_SKIP_ERR
init|=
literal|17L
block|,
comment|/* RGM+SPI+PCI       17 = packet was not large enough to pass the skipper - no inspection could occur */
name|CVMX_PIP_PIP_L2_MAL_HDR
init|=
literal|18L
block|,
comment|/* RGM+SPI+PCI       18 = malformed l2 (packet not long enough to cover L2 hdr) */
name|CVMX_PIP_PUNY_ERR
init|=
literal|47L
comment|/* SGMII             47 = PUNY error (packet was 4B or less when FCS stripping is enabled) */
comment|/* NOTES      *       xx = late collision (data received before collision)      *            late collisions cannot be detected by the receiver      *            they would appear as JAM bits which would appear as bad FCS      *            or carrier extend error which is CVMX_PIP_EXTEND_ERR      */
block|}
name|cvmx_pip_rcv_err_t
typedef|;
comment|/**  * This defines the err_code field errors in the work Q entry  */
typedef|typedef
union|union
block|{
name|cvmx_pip_l4_err_t
name|l4_err
decl_stmt|;
name|cvmx_pip_ip_exc_t
name|ip_exc
decl_stmt|;
name|cvmx_pip_rcv_err_t
name|rcv_err
decl_stmt|;
block|}
name|cvmx_pip_err_t
typedef|;
comment|/**  * Status statistics for a port  */
typedef|typedef
struct|struct
block|{
name|uint32_t
name|dropped_octets
decl_stmt|;
comment|/**< Inbound octets marked to be dropped by the IPD */
name|uint32_t
name|dropped_packets
decl_stmt|;
comment|/**< Inbound packets marked to be dropped by the IPD */
name|uint32_t
name|pci_raw_packets
decl_stmt|;
comment|/**< RAW PCI Packets received by PIP per port */
name|uint32_t
name|octets
decl_stmt|;
comment|/**< Number of octets processed by PIP */
name|uint32_t
name|packets
decl_stmt|;
comment|/**< Number of packets processed by PIP */
name|uint32_t
name|multicast_packets
decl_stmt|;
comment|/**< Number of indentified L2 multicast packets.                                             Does not include broadcast packets.                                             Only includes packets whose parse mode is                                             SKIP_TO_L2 */
name|uint32_t
name|broadcast_packets
decl_stmt|;
comment|/**< Number of indentified L2 broadcast packets.                                             Does not include multicast packets.                                             Only includes packets whose parse mode is                                             SKIP_TO_L2 */
name|uint32_t
name|len_64_packets
decl_stmt|;
comment|/**< Number of 64B packets */
name|uint32_t
name|len_65_127_packets
decl_stmt|;
comment|/**< Number of 65-127B packets */
name|uint32_t
name|len_128_255_packets
decl_stmt|;
comment|/**< Number of 128-255B packets */
name|uint32_t
name|len_256_511_packets
decl_stmt|;
comment|/**< Number of 256-511B packets */
name|uint32_t
name|len_512_1023_packets
decl_stmt|;
comment|/**< Number of 512-1023B packets */
name|uint32_t
name|len_1024_1518_packets
decl_stmt|;
comment|/**< Number of 1024-1518B packets */
name|uint32_t
name|len_1519_max_packets
decl_stmt|;
comment|/**< Number of 1519-max packets */
name|uint32_t
name|fcs_align_err_packets
decl_stmt|;
comment|/**< Number of packets with FCS or Align opcode errors */
name|uint32_t
name|runt_packets
decl_stmt|;
comment|/**< Number of packets with length< min */
name|uint32_t
name|runt_crc_packets
decl_stmt|;
comment|/**< Number of packets with length< min and FCS error */
name|uint32_t
name|oversize_packets
decl_stmt|;
comment|/**< Number of packets with length> max */
name|uint32_t
name|oversize_crc_packets
decl_stmt|;
comment|/**< Number of packets with length> max and FCS error */
name|uint32_t
name|inb_packets
decl_stmt|;
comment|/**< Number of packets without GMX/SPX/PCI errors received by PIP */
name|uint64_t
name|inb_octets
decl_stmt|;
comment|/**< Total number of octets from all packets received by PIP, including CRC */
name|uint16_t
name|inb_errors
decl_stmt|;
comment|/**< Number of packets with GMX/SPX/PCI errors received by PIP */
name|uint32_t
name|mcast_l2_red_packets
decl_stmt|;
comment|/**< Number of packets with L2 Multicast DMAC                                              that were dropped due to RED.                                              The HW will consider a packet to be an L2                                              multicast packet when the least-significant bit                                              of the first byte of the DMAC is set and the                                              packet is not an L2 broadcast packet.                                              Only applies when the parse mode for the packets                                              is SKIP-TO-L2 */
name|uint32_t
name|bcast_l2_red_packets
decl_stmt|;
comment|/**< Number of packets with L2 Broadcast DMAC                                              that were dropped due to RED.                                              The HW will consider a packet to be an L2                                              broadcast packet when the 48-bit DMAC is all 1's.                                              Only applies when the parse mode for the packets                                              is SKIP-TO-L2 */
name|uint32_t
name|mcast_l3_red_packets
decl_stmt|;
comment|/**< Number of packets with L3 Multicast Dest Address                                              that were dropped due to RED.                                              The HW considers an IPv4 packet to be multicast                                              when the most-significant nibble of the 32-bit                                              destination address is 0xE (i.e it is a class D                                              address). The HW considers an IPv6 packet to be                                               multicast when the most-significant byte of the                                              128-bit destination address is all 1's.                                              Only applies when the parse mode for the packets                                              is SKIP-TO-L2 and the packet is IP or the parse                                              mode for the packet is SKIP-TO-IP */
name|uint32_t
name|bcast_l3_red_packets
decl_stmt|;
comment|/**< Number of packets with L3 Broadcast Dest Address                                              that were dropped due to RED.                                              The HW considers an IPv4 packet to be broadcast                                              when all bits are set in the MSB of the                                              destination address. IPv6 does not have the                                               concept of a broadcast packets.                                              Only applies when the parse mode for the packet                                              is SKIP-TO-L2 and the packet is IP or the parse                                              mode for the packet is SKIP-TO-IP */
block|}
name|cvmx_pip_port_status_t
typedef|;
comment|/**  * Definition of the PIP custom header that can be prepended  * to a packet by external hardware.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|rawfull
range|:
literal|1
decl_stmt|;
comment|/**< Documented as R - Set if the Packet is RAWFULL. If set,                                                             this header must be the full 8 bytes */
name|uint64_t
name|reserved0
range|:
literal|5
decl_stmt|;
comment|/**< Must be zero */
name|cvmx_pip_port_parse_mode_t
name|parse_mode
range|:
literal|2
decl_stmt|;
comment|/**< PIP parse mode for this packet */
name|uint64_t
name|reserved1
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|skip_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip amount, including this header, to the beginning of the packet */
name|uint64_t
name|grpext
range|:
literal|2
decl_stmt|;
comment|/**< These bits get concatenated with the                                                              PKT_INST_HDR[GRP] bits, creating a 6-bit                                                              GRP field. Added in pass2. */
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
comment|/**< Must be 0 when PKT_INST_HDR[R] = 0.                                                              When set to 1, NQOS prevents PIP from directly using                                                              PKT_INST_HDR[QOS] for the QOS value in WQE.                                                              When PIP_GBL_CTL[IHMSK_DIS] = 1, Octeon2 does not use NQOS */
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
comment|/**< Must be 0 when PKT_INST_HDR[R] = 0.                                                              When set to 1, NGPR prevents PIP from directly using                                                              PKT_INST_HDR[GPR] for the GPR value in WQE.                                                              When PIP_GBL_CTL[IHMSK_DIS] = 1, Octeon2 does not use NGRP */
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
comment|/**< Must be 0 when PKT_INST_HDR[R] = 0.                                                              When set to 1, NTT prevents PIP from directly using                                                              PKT_INST_HDR[TT] for the TT value in WQE.                                                              When PIP_GBL_CTL[IHMSK_DIS] = 1, Octeon2 does not use NTT */
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
comment|/**< Must be 0 when PKT_INST_HDR[R] = 0.                                                              When set to 1, NTAG prevents PIP from directly using                                                              PKT_INST_HDR[TAG] for the TAG value in WQE.                                                              When PIP_GBL_CTL[IHMSK_DIS] = 1, Octeon2 does not use NTAG */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< POW input queue for this packet */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< POW input group for this packet */
name|uint64_t
name|rs
range|:
literal|1
decl_stmt|;
comment|/**< Flag to store this packet in the work queue entry, if possible */
name|cvmx_pow_tag_type_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< POW input tag type */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< POW input tag */
block|}
name|s
struct|;
block|}
name|cvmx_pip_pkt_inst_hdr_t
typedef|;
comment|/* CSR typedefs have been moved to cvmx-pip-defs.h */
comment|/**  * Configure an ethernet input port  *  * @param port_num Port number to configure  * @param port_cfg Port hardware configuration  * @param port_tag_cfg  *                 Port POW tagging configuration  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_port
parameter_list|(
name|uint64_t
name|port_num
parameter_list|,
name|cvmx_pip_prt_cfgx_t
name|port_cfg
parameter_list|,
name|cvmx_pip_prt_tagx_t
name|port_tag_cfg
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|int
name|interface
decl_stmt|,
name|index
decl_stmt|,
name|pknd
decl_stmt|;
name|interface
operator|=
name|cvmx_helper_get_interface_num
argument_list|(
name|port_num
argument_list|)
expr_stmt|;
name|index
operator|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|port_num
argument_list|)
expr_stmt|;
name|pknd
operator|=
name|cvmx_helper_get_pknd
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|pknd
expr_stmt|;
comment|/* overload port_num with pknd */
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_PRT_CFGX
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|port_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|port_tag_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Configure the VLAN priority to QoS queue mapping.  *  * @param vlan_priority  *               VLAN priority (0-7)  * @param qos    QoS queue for packets matching this watcher  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_vlan_qos
parameter_list|(
name|uint64_t
name|vlan_priority
parameter_list|,
name|uint64_t
name|qos
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
comment|/* FIXME for 68xx. */
block|}
else|else
block|{
name|cvmx_pip_qos_vlanx_t
name|pip_qos_vlanx
decl_stmt|;
name|pip_qos_vlanx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_qos_vlanx
operator|.
name|s
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_QOS_VLANX
argument_list|(
name|vlan_priority
argument_list|)
argument_list|,
name|pip_qos_vlanx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Configure the Diffserv to QoS queue mapping.  *  * @param diffserv Diffserv field value (0-63)  * @param qos      QoS queue for packets matching this watcher  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_diffserv_qos
parameter_list|(
name|uint64_t
name|diffserv
parameter_list|,
name|uint64_t
name|qos
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
comment|/* FIXME for 68xx. */
block|}
else|else
block|{
name|cvmx_pip_qos_diffx_t
name|pip_qos_diffx
decl_stmt|;
name|pip_qos_diffx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_qos_diffx
operator|.
name|s
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_QOS_DIFFX
argument_list|(
name|diffserv
argument_list|)
argument_list|,
name|pip_qos_diffx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Get the status counters for a port.  *  * @param port_num Port number (ipd_port) to get statistics for.  * @param clear    Set to 1 to clear the counters after they are read  * @param status   Where to put the results.  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_get_port_status
parameter_list|(
name|uint64_t
name|port_num
parameter_list|,
name|uint64_t
name|clear
parameter_list|,
name|cvmx_pip_port_status_t
modifier|*
name|status
parameter_list|)
block|{
name|cvmx_pip_stat_ctl_t
name|pip_stat_ctl
decl_stmt|;
name|cvmx_pip_stat0_prtx_t
name|stat0
decl_stmt|;
name|cvmx_pip_stat1_prtx_t
name|stat1
decl_stmt|;
name|cvmx_pip_stat2_prtx_t
name|stat2
decl_stmt|;
name|cvmx_pip_stat3_prtx_t
name|stat3
decl_stmt|;
name|cvmx_pip_stat4_prtx_t
name|stat4
decl_stmt|;
name|cvmx_pip_stat5_prtx_t
name|stat5
decl_stmt|;
name|cvmx_pip_stat6_prtx_t
name|stat6
decl_stmt|;
name|cvmx_pip_stat7_prtx_t
name|stat7
decl_stmt|;
name|cvmx_pip_stat8_prtx_t
name|stat8
decl_stmt|;
name|cvmx_pip_stat9_prtx_t
name|stat9
decl_stmt|;
name|cvmx_pip_stat10_x_t
name|stat10
decl_stmt|;
name|cvmx_pip_stat11_x_t
name|stat11
decl_stmt|;
name|cvmx_pip_stat_inb_pktsx_t
name|pip_stat_inb_pktsx
decl_stmt|;
name|cvmx_pip_stat_inb_octsx_t
name|pip_stat_inb_octsx
decl_stmt|;
name|cvmx_pip_stat_inb_errsx_t
name|pip_stat_inb_errsx
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|port_num
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|port_num
argument_list|)
decl_stmt|;
name|pip_stat_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_stat_ctl
operator|.
name|s
operator|.
name|rdclr
operator|=
name|clear
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_STAT_CTL
argument_list|,
name|pip_stat_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|int
name|pknd
init|=
name|cvmx_helper_get_pknd
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
decl_stmt|;
comment|/*          * PIP_STAT_CTL[MODE] 0 means pkind.          */
name|stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT0_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT1_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT2_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT3_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat4
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT4_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat5
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT5_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat6
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT6_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat7
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT7_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT8_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT9_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat10
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT10_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|stat11
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT11_X
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|port_num
operator|>=
literal|40
condition|)
block|{
name|stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT0_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT1_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT2_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT3_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat4
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT4_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat5
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT5_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat6
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT6_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat7
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT7_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT8_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT9_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|stat10
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT10_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat11
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_XSTAT11_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT0_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT1_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT2_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT3_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat4
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT4_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat5
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT5_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat6
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT6_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat7
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT7_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT8_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT9_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|stat10
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT10_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|stat11
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT11_PRTX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|int
name|pknd
init|=
name|cvmx_helper_get_pknd
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|pip_stat_inb_pktsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_PKTS_PKNDX
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_octsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_OCTS_PKNDX
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_errsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_ERRS_PKNDX
argument_list|(
name|pknd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pip_stat_inb_pktsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_PKTSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_octsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_OCTSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
name|pip_stat_inb_errsx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_STAT_INB_ERRSX
argument_list|(
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|->
name|dropped_octets
operator|=
name|stat0
operator|.
name|s
operator|.
name|drp_octs
expr_stmt|;
name|status
operator|->
name|dropped_packets
operator|=
name|stat0
operator|.
name|s
operator|.
name|drp_pkts
expr_stmt|;
name|status
operator|->
name|octets
operator|=
name|stat1
operator|.
name|s
operator|.
name|octs
expr_stmt|;
name|status
operator|->
name|pci_raw_packets
operator|=
name|stat2
operator|.
name|s
operator|.
name|raw
expr_stmt|;
name|status
operator|->
name|packets
operator|=
name|stat2
operator|.
name|s
operator|.
name|pkts
expr_stmt|;
name|status
operator|->
name|multicast_packets
operator|=
name|stat3
operator|.
name|s
operator|.
name|mcst
expr_stmt|;
name|status
operator|->
name|broadcast_packets
operator|=
name|stat3
operator|.
name|s
operator|.
name|bcst
expr_stmt|;
name|status
operator|->
name|len_64_packets
operator|=
name|stat4
operator|.
name|s
operator|.
name|h64
expr_stmt|;
name|status
operator|->
name|len_65_127_packets
operator|=
name|stat4
operator|.
name|s
operator|.
name|h65to127
expr_stmt|;
name|status
operator|->
name|len_128_255_packets
operator|=
name|stat5
operator|.
name|s
operator|.
name|h128to255
expr_stmt|;
name|status
operator|->
name|len_256_511_packets
operator|=
name|stat5
operator|.
name|s
operator|.
name|h256to511
expr_stmt|;
name|status
operator|->
name|len_512_1023_packets
operator|=
name|stat6
operator|.
name|s
operator|.
name|h512to1023
expr_stmt|;
name|status
operator|->
name|len_1024_1518_packets
operator|=
name|stat6
operator|.
name|s
operator|.
name|h1024to1518
expr_stmt|;
name|status
operator|->
name|len_1519_max_packets
operator|=
name|stat7
operator|.
name|s
operator|.
name|h1519
expr_stmt|;
name|status
operator|->
name|fcs_align_err_packets
operator|=
name|stat7
operator|.
name|s
operator|.
name|fcs
expr_stmt|;
name|status
operator|->
name|runt_packets
operator|=
name|stat8
operator|.
name|s
operator|.
name|undersz
expr_stmt|;
name|status
operator|->
name|runt_crc_packets
operator|=
name|stat8
operator|.
name|s
operator|.
name|frag
expr_stmt|;
name|status
operator|->
name|oversize_packets
operator|=
name|stat9
operator|.
name|s
operator|.
name|oversz
expr_stmt|;
name|status
operator|->
name|oversize_crc_packets
operator|=
name|stat9
operator|.
name|s
operator|.
name|jabber
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|status
operator|->
name|mcast_l2_red_packets
operator|=
name|stat10
operator|.
name|s
operator|.
name|mcast
expr_stmt|;
name|status
operator|->
name|bcast_l2_red_packets
operator|=
name|stat10
operator|.
name|s
operator|.
name|bcast
expr_stmt|;
name|status
operator|->
name|mcast_l3_red_packets
operator|=
name|stat11
operator|.
name|s
operator|.
name|mcast
expr_stmt|;
name|status
operator|->
name|bcast_l3_red_packets
operator|=
name|stat11
operator|.
name|s
operator|.
name|bcast
expr_stmt|;
block|}
name|status
operator|->
name|inb_packets
operator|=
name|pip_stat_inb_pktsx
operator|.
name|s
operator|.
name|pkts
expr_stmt|;
name|status
operator|->
name|inb_octets
operator|=
name|pip_stat_inb_octsx
operator|.
name|s
operator|.
name|octs
expr_stmt|;
name|status
operator|->
name|inb_errors
operator|=
name|pip_stat_inb_errsx
operator|.
name|s
operator|.
name|errs
expr_stmt|;
block|}
comment|/**  * Configure the hardware CRC engine  *  * @param interface Interface to configure (0 or 1)  * @param invert_result  *                 Invert the result of the CRC  * @param reflect  Reflect  * @param initialization_vector  *                 CRC initialization vector  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_config_crc
parameter_list|(
name|uint64_t
name|interface
parameter_list|,
name|uint64_t
name|invert_result
parameter_list|,
name|uint64_t
name|reflect
parameter_list|,
name|uint32_t
name|initialization_vector
parameter_list|)
block|{
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
block|{
name|cvmx_pip_crc_ctlx_t
name|config
decl_stmt|;
name|cvmx_pip_crc_ivx_t
name|pip_crc_ivx
decl_stmt|;
name|config
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|invres
operator|=
name|invert_result
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|reflect
operator|=
name|reflect
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_CRC_CTLX
argument_list|(
name|interface
argument_list|)
argument_list|,
name|config
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pip_crc_ivx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_crc_ivx
operator|.
name|s
operator|.
name|iv
operator|=
name|initialization_vector
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_CRC_IVX
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pip_crc_ivx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Clear all bits in a tag mask. This should be called on  * startup before any calls to cvmx_pip_tag_mask_set. Each bit  * set in the final mask represent a byte used in the packet for  * tag generation.  *  * @param mask_index Which tag mask to clear (0..3)  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_tag_mask_clear
parameter_list|(
name|uint64_t
name|mask_index
parameter_list|)
block|{
name|uint64_t
name|index
decl_stmt|;
name|cvmx_pip_tag_incx_t
name|pip_tag_incx
decl_stmt|;
name|pip_tag_incx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pip_tag_incx
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
name|mask_index
operator|*
literal|16
init|;
name|index
operator|<
operator|(
name|mask_index
operator|+
literal|1
operator|)
operator|*
literal|16
condition|;
name|index
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|,
name|pip_tag_incx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Sets a range of bits in the tag mask. The tag mask is used  * when the cvmx_pip_port_tag_cfg_t tag_mode is non zero.  * There are four separate masks that can be configured.  *  * @param mask_index Which tag mask to modify (0..3)  * @param offset     Offset into the bitmask to set bits at. Use the GCC macro  *                   offsetof() to determine the offsets into packet headers.  *                   For example, offsetof(ethhdr, protocol) returns the offset  *                   of the ethernet protocol field.  The bitmask selects which bytes  *                   to include the the tag, with bit offset X selecting byte at offset X  *                   from the beginning of the packet data.  * @param len        Number of bytes to include. Usually this is the sizeof()  *                   the field.  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_tag_mask_set
parameter_list|(
name|uint64_t
name|mask_index
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|cvmx_pip_tag_incx_t
name|pip_tag_incx
decl_stmt|;
name|uint64_t
name|index
init|=
name|mask_index
operator|*
literal|16
operator|+
name|offset
operator|/
literal|8
decl_stmt|;
name|pip_tag_incx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|pip_tag_incx
operator|.
name|s
operator|.
name|en
operator||=
literal|0x80
operator|>>
operator|(
name|offset
operator|&
literal|0x7
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_TAG_INCX
argument_list|(
name|index
argument_list|)
argument_list|,
name|pip_tag_incx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
block|}
comment|/**  * Initialize Bit Select Extractor config. Their are 8 bit positions and valids  * to be used when using the corresponding extractor.  *   * @param bit     Bit Select Extractor to use  * @param pos     Which position to update  * @param val     The value to update the position with  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_set_bsel_pos
parameter_list|(
name|int
name|bit
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|cvmx_pip_bsel_ext_posx_t
name|bsel_pos
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return;
if|if
condition|(
name|bit
operator|<
literal|0
operator|||
name|bit
operator|>
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_pip_set_bsel_pos: Invalid Bit-Select Extractor (%d) passed\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bsel_pos
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_POSX
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
literal|0
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos0_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos0
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos1_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos1
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos2_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos2
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos3_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos3
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos4_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos4
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos5_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos5
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos6_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos6
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|bsel_pos
operator|.
name|s
operator|.
name|pos7_val
operator|=
literal|1
expr_stmt|;
name|bsel_pos
operator|.
name|s
operator|.
name|pos7
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
break|break;
default|default:
name|cvmx_dprintf
argument_list|(
literal|"Warning: cvmx_pip_set_bsel_pos: Invalid pos(%d)\n"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_POSX
argument_list|(
name|bit
argument_list|)
argument_list|,
name|bsel_pos
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Initialize offset and skip values to use by bit select extractor.   * @param bit     Bit Select Extractor to use  * @param offset  Offset to add to extractor mem addr to get final address                   to lookup table.  * @param skip    Number of bytes to skip from start of packet 0-64  */
specifier|static
specifier|inline
name|void
name|cvmx_pip_bsel_config
parameter_list|(
name|int
name|bit
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|skip
parameter_list|)
block|{
name|cvmx_pip_bsel_ext_cfgx_t
name|bsel_cfg
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return;
name|bsel_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_CFGX
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
name|bsel_cfg
operator|.
name|s
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|bsel_cfg
operator|.
name|s
operator|.
name|skip
operator|=
name|skip
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_CFGX
argument_list|(
name|bit
argument_list|)
argument_list|,
name|bsel_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Get the entry for the Bit Select Extractor Table.   * @param work   pointer to work queue entry  * @return       Index of the Bit Select Extractor Table  */
specifier|static
specifier|inline
name|int
name|cvmx_pip_get_bsel_table_index
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|int
name|bit
init|=
name|cvmx_wqe_get_port
argument_list|(
name|work
argument_list|)
operator|&
literal|0x3
decl_stmt|;
comment|/* Get the Bit select table index. */
name|int
name|index
decl_stmt|;
name|int
name|y
decl_stmt|;
name|cvmx_pip_bsel_ext_cfgx_t
name|bsel_cfg
decl_stmt|;
name|cvmx_pip_bsel_ext_posx_t
name|bsel_pos
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bsel_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_CFGX
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
name|bsel_pos
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_POSX
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|8
condition|;
name|y
operator|++
control|)
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|work
operator|->
name|packet_ptr
operator|.
name|s
operator|.
name|addr
argument_list|)
decl_stmt|;
name|int
name|bit_loc
init|=
literal|0
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|ptr
operator|+=
name|bsel_cfg
operator|.
name|s
operator|.
name|skip
expr_stmt|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
literal|0
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos0
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos0
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos1
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos1
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos2
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos2
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos3
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos3
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos4
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos4
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos5
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos5
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos6
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos6
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|ptr
operator|+=
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos7
operator|>>
literal|3
operator|)
expr_stmt|;
name|bit_loc
operator|=
literal|7
operator|-
operator|(
name|bsel_pos
operator|.
name|s
operator|.
name|pos7
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
block|}
name|bit
operator|=
operator|(
operator|*
name|ptr
operator|>>
name|bit_loc
operator|)
operator|&
literal|1
expr_stmt|;
name|index
operator||=
name|bit
operator|<<
name|y
expr_stmt|;
block|}
name|index
operator|+=
name|bsel_cfg
operator|.
name|s
operator|.
name|offset
expr_stmt|;
name|index
operator|&=
literal|0x1ff
expr_stmt|;
return|return
name|index
return|;
block|}
specifier|static
specifier|inline
name|int
name|cvmx_pip_get_bsel_qos
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|int
name|index
init|=
name|cvmx_pip_get_bsel_table_index
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|cvmx_pip_bsel_tbl_entx_t
name|bsel_tbl
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bsel_tbl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_TBL_ENTX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bsel_tbl
operator|.
name|s
operator|.
name|qos
return|;
block|}
specifier|static
specifier|inline
name|int
name|cvmx_pip_get_bsel_grp
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|int
name|index
init|=
name|cvmx_pip_get_bsel_table_index
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|cvmx_pip_bsel_tbl_entx_t
name|bsel_tbl
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bsel_tbl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_TBL_ENTX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bsel_tbl
operator|.
name|s
operator|.
name|grp
return|;
block|}
specifier|static
specifier|inline
name|int
name|cvmx_pip_get_bsel_tt
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|int
name|index
init|=
name|cvmx_pip_get_bsel_table_index
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|cvmx_pip_bsel_tbl_entx_t
name|bsel_tbl
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bsel_tbl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_TBL_ENTX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bsel_tbl
operator|.
name|s
operator|.
name|tt
return|;
block|}
specifier|static
specifier|inline
name|int
name|cvmx_pip_get_bsel_tag
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|int
name|index
init|=
name|cvmx_pip_get_bsel_table_index
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|cvmx_wqe_get_port
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|int
name|bit
init|=
name|port
operator|&
literal|0x3
decl_stmt|;
name|int
name|upper_tag
init|=
literal|0
decl_stmt|;
name|cvmx_pip_bsel_tbl_entx_t
name|bsel_tbl
decl_stmt|;
name|cvmx_pip_bsel_ext_cfgx_t
name|bsel_cfg
decl_stmt|;
name|cvmx_pip_prt_tagx_t
name|prt_tag
decl_stmt|;
comment|/* The bit select extractor is available in CN61XX and CN68XX pass2.0 onwards. */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_BIT_EXTRACTOR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bsel_tbl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_TBL_ENTX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|bsel_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_BSEL_EXT_CFGX
argument_list|(
name|bit
argument_list|)
argument_list|)
expr_stmt|;
name|prt_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_PRT_TAGX
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prt_tag
operator|.
name|s
operator|.
name|inc_prt_flag
operator|==
literal|0
condition|)
name|upper_tag
operator|=
name|bsel_cfg
operator|.
name|s
operator|.
name|upper_tag
expr_stmt|;
return|return
operator|(
name|bsel_tbl
operator|.
name|s
operator|.
name|tag
operator||
operator|(
operator|(
name|bsel_cfg
operator|.
name|s
operator|.
name|tag
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|upper_tag
operator|<<
literal|16
operator|)
operator|&
literal|0xffff0000
operator|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __CVMX_PIP_H__ */
end_comment

end_unit

