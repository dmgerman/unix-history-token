begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Support library for the SPI  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-stxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-srxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spi.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INVOKE_CB
parameter_list|(
name|function_p
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do { \             if (function_p) { \                 res = function_p(args); \                 if (res) \                     return res; \             } \         } while (0)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_DEBUG_PRINTS
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|modes
index|[]
init|=
block|{
literal|"UNKNOWN"
block|,
literal|"TX Halfplex"
block|,
literal|"Rx Halfplex"
block|,
literal|"Duplex"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default callbacks, can be overridden  *  using cvmx_spi_get_callbacks/cvmx_spi_set_callbacks  */
end_comment

begin_decl_stmt
specifier|static
name|cvmx_spi_callbacks_t
name|cvmx_spi_callbacks
init|=
block|{
operator|.
name|reset_cb
operator|=
name|cvmx_spi_reset_cb
block|,
operator|.
name|calendar_setup_cb
operator|=
name|cvmx_spi_calendar_setup_cb
block|,
operator|.
name|clock_detect_cb
operator|=
name|cvmx_spi_clock_detect_cb
block|,
operator|.
name|training_cb
operator|=
name|cvmx_spi_training_cb
block|,
operator|.
name|calendar_sync_cb
operator|=
name|cvmx_spi_calendar_sync_cb
block|,
operator|.
name|interface_up_cb
operator|=
name|cvmx_spi_interface_up_cb
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Get current SPI4 initialization callbacks  *  * @param callbacks  Pointer to the callbacks structure.to fill  *  * @return Pointer to cvmx_spi_callbacks_t structure.  */
end_comment

begin_function
name|void
name|cvmx_spi_get_callbacks
parameter_list|(
name|cvmx_spi_callbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|memcpy
argument_list|(
name|callbacks
argument_list|,
operator|&
name|cvmx_spi_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_spi_callbacks
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set new SPI4 initialization callbacks  *  * @param new_callbacks  Pointer to an updated callbacks structure.  */
end_comment

begin_function
name|void
name|cvmx_spi_set_callbacks
parameter_list|(
name|cvmx_spi_callbacks_t
modifier|*
name|new_callbacks
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|cvmx_spi_callbacks
argument_list|,
name|new_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_spi_callbacks
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize and start the SPI interface.  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param timeout   Timeout to wait for clock synchronization in seconds  * @param num_ports Number of SPI ports to configure  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_spi_start_interface
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
comment|// Callback to perform SPI4 reset
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|reset_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|// Callback to perform calendar setup
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|calendar_setup_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
comment|// Callback to perform clock detection
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|clock_detect_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to perform SPI4 link training
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|training_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to perform calendar sync
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|calendar_sync_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to handle interface coming up
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|interface_up_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * This routine restarts the SPI interface after it has lost synchronization  * with its correspondent system.  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param timeout   Timeout to wait for clock synchronization in seconds  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_spi_restart_interface
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Restart %s\n"
argument_list|,
name|interface
argument_list|,
name|modes
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
comment|// Callback to perform SPI4 reset
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|reset_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|// NOTE: Calendar setup is not performed during restart
comment|//       Refer to cvmx_spi_start_interface() for the full sequence
comment|// Callback to perform clock detection
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|clock_detect_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to perform SPI4 link training
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|training_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to perform calendar sync
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|calendar_sync_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// Callback to handle interface coming up
name|INVOKE_CB
argument_list|(
name|cvmx_spi_callbacks
operator|.
name|interface_up_cb
argument_list|,
name|interface
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_spi_restart_interface
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Callback to perform SPI4 reset  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_reset_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|)
block|{
name|cvmx_spxx_dbg_deskew_ctl_t
name|spxx_dbg_deskew_ctl
decl_stmt|;
name|cvmx_spxx_clk_ctl_t
name|spxx_clk_ctl
decl_stmt|;
name|cvmx_spxx_bist_stat_t
name|spxx_bist_stat
decl_stmt|;
name|cvmx_spxx_int_msk_t
name|spxx_int_msk
decl_stmt|;
name|cvmx_stxx_int_msk_t
name|stxx_int_msk
decl_stmt|;
name|cvmx_spxx_trn4_ctl_t
name|spxx_trn4_ctl
decl_stmt|;
name|int
name|index
decl_stmt|;
name|uint64_t
name|MS
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000
decl_stmt|;
comment|/* Disable SPI error events while we run BIST */
name|spxx_int_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stxx_int_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Run BIST in the SPI interface */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|runbist
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10
operator|*
name|MS
argument_list|)
expr_stmt|;
name|spxx_bist_stat
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_BIST_STAT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spxx_bist_stat
operator|.
name|s
operator|.
name|stat0
condition|)
name|cvmx_dprintf
argument_list|(
literal|"ERROR SPI%d: BIST failed on receive datapath FIFO\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|spxx_bist_stat
operator|.
name|s
operator|.
name|stat1
condition|)
name|cvmx_dprintf
argument_list|(
literal|"ERROR SPI%d: BIST failed on RX calendar table\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|spxx_bist_stat
operator|.
name|s
operator|.
name|stat2
condition|)
name|cvmx_dprintf
argument_list|(
literal|"ERROR SPI%d: BIST failed on TX calendar table\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
comment|/* Clear the calendar table after BIST to fix parity errors */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|32
condition|;
name|index
operator|++
control|)
block|{
name|cvmx_srxx_spi4_calx_t
name|srxx_spi4_calx
decl_stmt|;
name|cvmx_stxx_spi4_calx_t
name|stxx_spi4_calx
decl_stmt|;
name|srxx_spi4_calx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|oddpar
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_SPI4_CALX
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|srxx_spi4_calx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|oddpar
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_SPI4_CALX
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|stxx_spi4_calx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Re enable reporting of error interrupts */
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_int_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_INT_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_int_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Setup the CLKDLY right in the middle
name|spxx_clk_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|seetrn
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|clkdly
operator|=
literal|0x10
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|runbist
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|statdrv
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|statrcv
operator|=
literal|1
expr_stmt|;
comment|/* This should always be on the opposite edge as statdrv */
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|sndtrn
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|drptrn
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|rcvtrn
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|srxdlck
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|100
operator|*
name|MS
argument_list|)
expr_stmt|;
comment|// Reset SRX0 DLL
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|srxdlck
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Waiting for Inf0 Spi4 RX DLL to lock
name|cvmx_wait
argument_list|(
literal|100
operator|*
name|MS
argument_list|)
expr_stmt|;
comment|// Enable dynamic alignment
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|trntest
operator|=
literal|0
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|jitter
operator|=
literal|1
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|clr_boot
operator|=
literal|1
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|set_boot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|maxdist
operator|=
literal|3
expr_stmt|;
else|else
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|maxdist
operator|=
literal|8
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|macro_en
operator|=
literal|1
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|mux_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_TRN4_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_trn4_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|spxx_dbg_deskew_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_DBG_DESKEW_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_dbg_deskew_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback to setup calendar and miscellaneous settings before clock detection  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param num_ports Number of ports to configure on SPI  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_calendar_setup_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_RX_HALFPLEX
condition|)
block|{
name|cvmx_srxx_com_ctl_t
name|srxx_com_ctl
decl_stmt|;
name|cvmx_srxx_spi4_stat_t
name|srxx_spi4_stat
decl_stmt|;
comment|// SRX0 number of Ports
name|srxx_com_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|prts
operator|=
name|num_ports
operator|-
literal|1
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|st_en
operator|=
literal|0
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|inf_en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|srxx_com_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// SRX0 Calendar Table. This round robbins through all ports
name|port
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|port
operator|<
name|num_ports
condition|)
block|{
name|cvmx_srxx_spi4_calx_t
name|srxx_spi4_calx
decl_stmt|;
name|srxx_spi4_calx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|prt0
operator|=
name|port
operator|++
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|prt1
operator|=
name|port
operator|++
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|prt2
operator|=
name|port
operator|++
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|prt3
operator|=
name|port
operator|++
expr_stmt|;
name|srxx_spi4_calx
operator|.
name|s
operator|.
name|oddpar
operator|=
operator|~
operator|(
name|cvmx_dpop
argument_list|(
name|srxx_spi4_calx
operator|.
name|u64
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_SPI4_CALX
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|srxx_spi4_calx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|srxx_spi4_stat
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|srxx_spi4_stat
operator|.
name|s
operator|.
name|len
operator|=
name|num_ports
expr_stmt|;
name|srxx_spi4_stat
operator|.
name|s
operator|.
name|m
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_SPI4_STAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|srxx_spi4_stat
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_TX_HALFPLEX
condition|)
block|{
name|cvmx_stxx_arb_ctl_t
name|stxx_arb_ctl
decl_stmt|;
name|cvmx_gmxx_tx_spi_max_t
name|gmxx_tx_spi_max
decl_stmt|;
name|cvmx_gmxx_tx_spi_thresh_t
name|gmxx_tx_spi_thresh
decl_stmt|;
name|cvmx_gmxx_tx_spi_ctl_t
name|gmxx_tx_spi_ctl
decl_stmt|;
name|cvmx_stxx_spi4_stat_t
name|stxx_spi4_stat
decl_stmt|;
name|cvmx_stxx_spi4_dat_t
name|stxx_spi4_dat
decl_stmt|;
comment|// STX0 Config
name|stxx_arb_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_arb_ctl
operator|.
name|s
operator|.
name|igntpa
operator|=
literal|0
expr_stmt|;
name|stxx_arb_ctl
operator|.
name|s
operator|.
name|mintrn
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_ARB_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_arb_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmxx_tx_spi_max
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_tx_spi_max
operator|.
name|s
operator|.
name|max1
operator|=
literal|8
expr_stmt|;
name|gmxx_tx_spi_max
operator|.
name|s
operator|.
name|max2
operator|=
literal|4
expr_stmt|;
name|gmxx_tx_spi_max
operator|.
name|s
operator|.
name|slice
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_SPI_MAX
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxx_tx_spi_max
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmxx_tx_spi_thresh
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_tx_spi_thresh
operator|.
name|s
operator|.
name|thresh
operator|=
literal|4
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_SPI_THRESH
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxx_tx_spi_thresh
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmxx_tx_spi_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_tx_spi_ctl
operator|.
name|s
operator|.
name|tpa_clr
operator|=
literal|0
expr_stmt|;
name|gmxx_tx_spi_ctl
operator|.
name|s
operator|.
name|cont_pkt
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_SPI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxx_tx_spi_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// STX0 Training Control
name|stxx_spi4_dat
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_spi4_dat
operator|.
name|s
operator|.
name|alpha
operator|=
literal|32
expr_stmt|;
comment|/*Minimum needed by dynamic alignment*/
name|stxx_spi4_dat
operator|.
name|s
operator|.
name|max_t
operator|=
literal|0xFFFF
expr_stmt|;
comment|/*Minimum interval is 0x20*/
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_SPI4_DAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_spi4_dat
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// STX0 Calendar Table. This round robbins through all ports
name|port
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|port
operator|<
name|num_ports
condition|)
block|{
name|cvmx_stxx_spi4_calx_t
name|stxx_spi4_calx
decl_stmt|;
name|stxx_spi4_calx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|prt0
operator|=
name|port
operator|++
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|prt1
operator|=
name|port
operator|++
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|prt2
operator|=
name|port
operator|++
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|prt3
operator|=
name|port
operator|++
expr_stmt|;
name|stxx_spi4_calx
operator|.
name|s
operator|.
name|oddpar
operator|=
operator|~
operator|(
name|cvmx_dpop
argument_list|(
name|stxx_spi4_calx
operator|.
name|u64
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_SPI4_CALX
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|stxx_spi4_calx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|stxx_spi4_stat
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_spi4_stat
operator|.
name|s
operator|.
name|len
operator|=
name|num_ports
expr_stmt|;
name|stxx_spi4_stat
operator|.
name|s
operator|.
name|m
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_SPI4_STAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_spi4_stat
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback to perform clock detection  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param timeout   Timeout to wait for clock synchronization in seconds  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_clock_detect_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|clock_transitions
decl_stmt|;
name|cvmx_spxx_clk_stat_t
name|stat
decl_stmt|;
name|uint64_t
name|timeout_time
decl_stmt|;
name|uint64_t
name|MS
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000
decl_stmt|;
comment|/* Regardless of operating mode, both Tx and Rx clocks must be present         for the SPI interface to operate. */
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Waiting to see TsClk...\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|timeout_time
operator|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
name|timeout
expr_stmt|;
comment|/* Require 100 clock transitions in order to avoid any noise in the         beginning  */
name|clock_transitions
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|stat
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|s4clk0
operator|&&
name|stat
operator|.
name|s
operator|.
name|s4clk1
operator|&&
name|clock_transitions
condition|)
block|{
comment|/* We've seen a clock transition, so decrement the number we still                 need */
name|clock_transitions
operator|--
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stat
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|s4clk0
operator|=
literal|0
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|s4clk1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|timeout_time
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Timeout\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|stat
operator|.
name|s
operator|.
name|s4clk0
operator|==
literal|0
operator|||
name|stat
operator|.
name|s
operator|.
name|s4clk1
operator|==
literal|0
condition|)
do|;
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Waiting to see RsClk...\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|timeout_time
operator|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
name|timeout
expr_stmt|;
comment|/* Require 100 clock transitions in order to avoid any noise in the         beginning  */
name|clock_transitions
operator|=
literal|100
expr_stmt|;
do|do
block|{
name|stat
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|d4clk0
operator|&&
name|stat
operator|.
name|s
operator|.
name|d4clk1
operator|&&
name|clock_transitions
condition|)
block|{
comment|/* We've seen a clock transition, so decrement the number we still                 need */
name|clock_transitions
operator|--
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stat
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|d4clk0
operator|=
literal|0
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|d4clk1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|timeout_time
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Timeout\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|stat
operator|.
name|s
operator|.
name|d4clk0
operator|==
literal|0
operator|||
name|stat
operator|.
name|s
operator|.
name|d4clk1
operator|==
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback to perform link training  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param timeout   Timeout to wait for link to be trained (in seconds)  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_training_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|cvmx_spxx_trn4_ctl_t
name|spxx_trn4_ctl
decl_stmt|;
name|cvmx_spxx_clk_stat_t
name|stat
decl_stmt|;
name|uint64_t
name|MS
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000
decl_stmt|;
name|uint64_t
name|timeout_time
init|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
name|timeout
decl_stmt|;
name|int
name|rx_training_needed
decl_stmt|;
comment|// SRX0& STX0 Inf0 Links are configured - begin training
name|cvmx_spxx_clk_ctl_t
name|spxx_clk_ctl
decl_stmt|;
name|spxx_clk_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|seetrn
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|clkdly
operator|=
literal|0x10
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|runbist
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|statdrv
operator|=
literal|0
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|statrcv
operator|=
literal|1
expr_stmt|;
comment|/* This should always be on the opposite edge as statdrv */
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|sndtrn
operator|=
literal|1
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|drptrn
operator|=
literal|1
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|rcvtrn
operator|=
literal|1
expr_stmt|;
name|spxx_clk_ctl
operator|.
name|s
operator|.
name|srxdlck
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|1000
operator|*
name|MS
argument_list|)
expr_stmt|;
comment|// SRX0 clear the boot bit
name|spxx_trn4_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_TRN4_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|spxx_trn4_ctl
operator|.
name|s
operator|.
name|clr_boot
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_TRN4_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|spxx_trn4_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Wait for the training sequence to complete
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Waiting for training\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|1000
operator|*
name|MS
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
name|timeout_time
operator|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
literal|600
expr_stmt|;
comment|/* Wait a really long time here */
else|#
directive|else
name|timeout_time
operator|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
literal|10
expr_stmt|;
endif|#
directive|endif
comment|/* The HRM says we must wait for 34 + 16 * MAXDIST training sequences.         We'll be pessimistic and wait for a lot more */
name|rx_training_needed
operator|=
literal|500
expr_stmt|;
do|do
block|{
name|stat
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|srxtrn
operator|&&
name|rx_training_needed
condition|)
block|{
name|rx_training_needed
operator|--
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stat
operator|.
name|u64
argument_list|)
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|srxtrn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|timeout_time
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Timeout\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|stat
operator|.
name|s
operator|.
name|srxtrn
operator|==
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback to perform calendar data synchronization  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @param timeout   Timeout to wait for calendar data in seconds  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_calendar_sync_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|uint64_t
name|MS
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_RX_HALFPLEX
condition|)
block|{
comment|// SRX0 interface should be good, send calendar data
name|cvmx_srxx_com_ctl_t
name|srxx_com_ctl
decl_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Rx is synchronized, start sending calendar data\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|srxx_com_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|inf_en
operator|=
literal|1
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|st_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|srxx_com_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_TX_HALFPLEX
condition|)
block|{
comment|// STX0 has achieved sync
comment|// The corespondant board should be sending calendar data
comment|// Enable the STX0 STAT receiver.
name|cvmx_spxx_clk_stat_t
name|stat
decl_stmt|;
name|uint64_t
name|timeout_time
decl_stmt|;
name|cvmx_stxx_com_ctl_t
name|stxx_com_ctl
decl_stmt|;
name|stxx_com_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|stxx_com_ctl
operator|.
name|s
operator|.
name|st_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_com_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|// Waiting for calendar sync on STX0 STAT
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Waiting to sync on STX[%d] STAT\n"
argument_list|,
name|interface
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|timeout_time
operator|=
name|cvmx_get_cycle
argument_list|()
operator|+
literal|1000ull
operator|*
name|MS
operator|*
name|timeout
expr_stmt|;
comment|// SPX0_CLK_STAT - SPX0_CLK_STAT[STXCAL] should be 1 (bit10)
do|do
block|{
name|stat
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SPXX_CLK_STAT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|timeout_time
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Timeout\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|stat
operator|.
name|s
operator|.
name|stxcal
operator|==
literal|0
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Callback to handle interface up  *  * @param interface The identifier of the packet interface to configure and  *                  use as a SPI interface.  * @param mode      The operating mode for the SPI interface. The interface  *                  can operate as a full duplex (both Tx and Rx data paths  *                  active) or as a halfplex (either the Tx data path is  *                  active or the Rx data path is active, but not both).  * @return Zero on success, non-zero error code on failure (will cause SPI initialization to abort)  */
end_comment

begin_function
name|int
name|cvmx_spi_interface_up_cb
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_spi_mode_t
name|mode
parameter_list|)
block|{
name|cvmx_gmxx_rxx_frm_min_t
name|gmxx_rxx_frm_min
decl_stmt|;
name|cvmx_gmxx_rxx_frm_max_t
name|gmxx_rxx_frm_max
decl_stmt|;
name|cvmx_gmxx_rxx_jabber_t
name|gmxx_rxx_jabber
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_RX_HALFPLEX
condition|)
block|{
name|cvmx_srxx_com_ctl_t
name|srxx_com_ctl
decl_stmt|;
name|srxx_com_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|srxx_com_ctl
operator|.
name|s
operator|.
name|inf_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|srxx_com_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Rx is now up\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|CVMX_SPI_MODE_TX_HALFPLEX
condition|)
block|{
name|cvmx_stxx_com_ctl_t
name|stxx_com_ctl
decl_stmt|;
name|stxx_com_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_STXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|stxx_com_ctl
operator|.
name|s
operator|.
name|inf_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_STXX_COM_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|stxx_com_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"SPI%d: Tx is now up\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
block|}
name|gmxx_rxx_frm_min
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_rxx_frm_min
operator|.
name|s
operator|.
name|len
operator|=
literal|64
expr_stmt|;
ifdef|#
directive|ifdef
name|OCTEON_VENDOR_RADISYS
comment|/*      * Incoming packets on the RSYS4GBE have the FCS stripped.      */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CUST_RADISYS_RSYS4GBE
condition|)
name|gmxx_rxx_frm_min
operator|.
name|s
operator|.
name|len
operator|-=
literal|4
expr_stmt|;
endif|#
directive|endif
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_MIN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_frm_min
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmxx_rxx_frm_max
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_rxx_frm_max
operator|.
name|s
operator|.
name|len
operator|=
literal|64
operator|*
literal|1024
operator|-
literal|4
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_MAX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_frm_max
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmxx_rxx_jabber
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmxx_rxx_jabber
operator|.
name|s
operator|.
name|cnt
operator|=
literal|64
operator|*
literal|1024
operator|-
literal|4
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_JABBER
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_rxx_jabber
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

