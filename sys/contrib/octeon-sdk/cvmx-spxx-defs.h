begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-spxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon spxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SPXX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SPXX_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_BCKPRS_CNT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_BCKPRS_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000340ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_BCKPRS_CNT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000340ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_BIST_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_BIST_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800900007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_BIST_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800900007F8ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_CLK_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_CLK_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000348ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_CLK_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000348ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_CLK_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_CLK_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000350ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_CLK_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000350ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_DBG_DESKEW_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_DBG_DESKEW_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000368ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_DBG_DESKEW_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000368ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_DBG_DESKEW_STATE
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_DBG_DESKEW_STATE(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000370ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_DBG_DESKEW_STATE
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000370ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_DRV_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_DRV_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000358ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_DRV_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000358ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_ERR_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_ERR_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000320ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_ERR_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000320ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_INT_DAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_INT_DAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000318ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_INT_DAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000318ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_INT_MSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_INT_MSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000308ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_INT_MSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000308ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_INT_REG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000300ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_INT_REG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000300ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_INT_SYNC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_INT_SYNC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000310ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_INT_SYNC
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000310ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_TPA_ACC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_TPA_ACC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000338ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_TPA_ACC
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000338ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_TPA_MAX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_TPA_MAX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000330ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_TPA_MAX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000330ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_TPA_SEL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_TPA_SEL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000328ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_TPA_SEL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000328ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SPXX_TRN4_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SPXX_TRN4_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000360ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SPXX_TRN4_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000360ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_spx#_bckprs_cnt  */
end_comment

begin_union
union|union
name|cvmx_spxx_bckprs_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_bckprs_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Counts the number of core clock cycles in which                                                          the SPI-4.2 receiver receives data once the TPA                                                          for a particular port has been deasserted. The                                                          desired port to watch can be selected with the                                                          SPX_TPA_SEL[PRTSEL] field. CNT can be cleared by                                                          writing all 1s to it. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_bckprs_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_bckprs_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_bckprs_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_bckprs_cnt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_bckprs_cnt
name|cvmx_spxx_bckprs_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_bist_stat  *  * Notes:  * Bist results encoding  * - 0: good (or bist in progress/never run)  * - 1: bad  */
end_comment

begin_union
union|union
name|cvmx_spxx_bist_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_bist_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|stat2
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results/No Repair (Tx calendar table)                                                          (spx.stx.cal.calendar) */
name|uint64_t
name|stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results/No Repair (Rx calendar table)                                                          (spx.srx.spi4.cal.calendar) */
name|uint64_t
name|stat0
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results/No Repair (Spi4 receive datapath FIFO)                                                          (spx.srx.spi4.dat.dpr) */
else|#
directive|else
name|uint64_t
name|stat0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_bist_stat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_bist_stat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_bist_stat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_bist_stat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_bist_stat
name|cvmx_spxx_bist_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_clk_ctl  *  * Notes:  * * SRXDLCK  *   When asserted, this bit locks the Spi4 receive DLLs.  This bit also  *   acts as the Spi4 receiver reset and must be asserted before the  *   training sequences are used to initialize the interface.  This bit  *   only applies to the receiver interface.  *  * * RCVTRN  *   Once the SRXDLCK bit is asserted and the DLLs have locked and the  *   system has been programmed, software should assert this bit in order  *   to start looking for valid training sequence and synchronize the  *   interface. This bit only applies to the receiver interface.  *  * * DRPTRN  *   The Spi4 receiver can either convert training packets into NOPs or  *   drop them entirely.  Dropping ticks allows the interface to deskew  *   periodically if the dclk and eclk ratios are close. This bit only  *   applies to the receiver interface.  *  * * SNDTRN  *   When software sets this bit, it indicates that the Spi4 transmit  *   interface has been setup and has seen the calendare status.  Once the  *   transmitter begins sending training data, the receiving device is free  *   to start traversing the calendar table to synch the link.  *  * * STATRCV  *   This bit determines which status clock edge to sample the status  *   channel in Spi4 mode.  Since the status channel is in the opposite  *   direction to the datapath, the STATRCV actually effects the  *   transmitter/TX block.  *  * * STATDRV  *   This bit determines which status clock edge to drive the status  *   channel in Spi4 mode.  Since the status channel is in the opposite  *   direction to the datapath, the STATDRV actually effects the  *   receiver/RX block.  *  * * RUNBIST  *   RUNBIST will beginning BIST/BISR in all the SPX compilied memories.  *   These memories are...  *  *       * spx.srx.spi4.dat.dpr        // FIFO Spi4 to IMX  *       * spx.stx.cal.calendar        // Spi4 TX calendar table  *       * spx.srx.spi4.cal.calendar   // Spi4 RX calendar table  *  *   RUNBIST must never be asserted when the interface is enabled.  *   Furthmore, setting RUNBIST at any other time is destructive and can  *   cause data and configuration corruption.  The entire interface must be  *   reconfigured when this bit is set.  *  * * CLKDLY  *   CLKDLY should be kept at its reset value during normal operation.  This  *   register controls the SPI4.2 static clock positioning which normally only is  *   set to the non-reset value in quarter clocking schemes.  In this mode, the  *   delay window is not large enough for slow clock freq, therefore clock and  *   data must be statically positioned with CSRs.  By changing the clock position  *   relative to the data bits, we give the system a wider window.  *  * * SEETRN  *   In systems in which no training data is sent to N2 or N2 cannot  *   correctly sample the training data, software may pulse this bit by  *   writing a '1' followed by a '0' in order to correctly set the  *   receivers state.  The receive data bus should be idle at this time  *   (only NOPs on the bus).  If N2 cannot see at least on training  *   sequence, the data bus will not send any data to the core.  The  *   interface will hang.  */
end_comment

begin_union
union|union
name|cvmx_spxx_clk_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_clk_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|seetrn
range|:
literal|1
decl_stmt|;
comment|/**< Force the Spi4 receive into seeing a traing                                                          sequence */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|clkdly
range|:
literal|5
decl_stmt|;
comment|/**< Set the spx__clkdly lines to this value to                                                          control the delay on the incoming dclk                                                          (spx__clkdly) */
name|uint64_t
name|runbist
range|:
literal|1
decl_stmt|;
comment|/**< Write this bit to begin BIST testing in SPX */
name|uint64_t
name|statdrv
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 status channel drive mode                                                          - 1: Drive STAT on posedge of SCLK                                                          - 0: Drive STAT on negedge of SCLK */
name|uint64_t
name|statrcv
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 status channel sample mode                                                          - 1: Sample STAT on posedge of SCLK                                                          - 0: Sample STAT on negedge of SCLK */
name|uint64_t
name|sndtrn
range|:
literal|1
decl_stmt|;
comment|/**< Start sending training patterns on the Spi4                                                          Tx Interface */
name|uint64_t
name|drptrn
range|:
literal|1
decl_stmt|;
comment|/**< Drop blocks of training packets */
name|uint64_t
name|rcvtrn
range|:
literal|1
decl_stmt|;
comment|/**< Write this bit once the DLL is locked to sync                                                          on the training seqeunce */
name|uint64_t
name|srxdlck
range|:
literal|1
decl_stmt|;
comment|/**< Write this bit to lock the Spi4 receive DLL */
else|#
directive|else
name|uint64_t
name|srxdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcvtrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drptrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sndtrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|statrcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|statdrv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|runbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkdly
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|seetrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_clk_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_clk_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_clk_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_clk_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_clk_ctl
name|cvmx_spxx_clk_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_clk_stat  */
end_comment

begin_union
union|union
name|cvmx_spxx_clk_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_clk_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|stxcal
range|:
literal|1
decl_stmt|;
comment|/**< The transistion from Sync to Calendar on status                                                          channel */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srxtrn
range|:
literal|1
decl_stmt|;
comment|/**< Saw a good data training sequence */
name|uint64_t
name|s4clk1
range|:
literal|1
decl_stmt|;
comment|/**< Saw '1' on Spi4 transmit status forward clk input */
name|uint64_t
name|s4clk0
range|:
literal|1
decl_stmt|;
comment|/**< Saw '0' on Spi4 transmit status forward clk input */
name|uint64_t
name|d4clk1
range|:
literal|1
decl_stmt|;
comment|/**< Saw '1' on Spi4 receive data forward clk input */
name|uint64_t
name|d4clk0
range|:
literal|1
decl_stmt|;
comment|/**< Saw '0' on Spi4 receive data forward clk input */
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|d4clk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d4clk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s4clk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|s4clk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srxtrn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stxcal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_clk_stat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_clk_stat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_clk_stat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_clk_stat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_clk_stat
name|cvmx_spxx_clk_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_dbg_deskew_ctl  *  * Notes:  * These bits are meant as a backdoor to control Spi4 per-bit deskew.  See  * that Spec for more details.  *  *   The basic idea is to allow software to disable the auto-deskew widgets  *   and make any adjustments by hand.  These steps should only be taken  *   once the RCVTRN bit is set and before any real traffic is sent on the  *   Spi4 bus.  Great care should be taken when messing with these bits as  *   improper programmings can cause catestrophic or intermitent problems.  *  *   The params we have to test are the MUX tap selects and the XCV delay  *   tap selects.  *  *   For the muxes, we can set each tap to a random value and then read  *   back the taps.  To write...  *  *    SPXX_DBG_DESKEW_CTL[BITSEL]   = bit to set  *    SPXX_DBG_DESKEW_CTL[OFFSET]   = mux tap value (2-bits)  *    SPXX_DBG_DESKEW_CTL[MUX]      = go bit  *  *   Notice this can all happen with a single CSR write.  To read, first  *   set the bit you to look at with the SPXX_DBG_DESKEW_CTL[BITSEL], then  *   simply read SPXX_DBG_DESKEW_STATE[MUXSEL]...  *  *    SPXX_DBG_DESKEW_CTL[BITSEL]   = bit to set  *    SPXX_DBG_DESKEW_STATE[MUXSEL] = 2-bit value  *  *   For the xcv delay taps, the CSR controls increment and decrement the  *   5-bit count value in the XCV.  This is a saturating counter, so it  *   will not wrap when decrementing below zero or incrementing above 31.  *  *   To write...  *  *    SPXX_DBG_DESKEW_CTL[BITSEL]   = bit to set  *    SPXX_DBG_DESKEW_CTL[OFFSET]   = tap value increment or decrement amount (5-bits)  *    SPXX_DBG_DESKEW_CTL[INC|DEC]  = go bit  *  *   These values are copied in SPX, so that they can be read back by  *   software by a similar mechanism to the MUX selects...  *  *    SPXX_DBG_DESKEW_CTL[BITSEL]   = bit to set  *    SPXX_DBG_DESKEW_STATE[OFFSET] = 5-bit value  *  *   In addition, there is a reset bit that sets all the state back to the  *   default/starting value of 0x10.  *  *    SPXX_DBG_DESKEW_CTL[CLRDLY]   = 1  *  * SINGLE STEP TRAINING MODE (WILMA)  *     Debug feature that will enable the user to single-step the debug  *     logic to watch initial movement and trends by putting the training  *     machine in single step mode.  *  * * SPX*_DBG_DESKEW_CTL[SSTEP]  *        This will put the training control logic into single step mode.  We  *        will not deskew in this scenario and will require the TX device to  *        send continuous training sequences.  *  *        It is required that SRX*_COM_CTL[INF_EN] be clear so that suspect  *        data does not flow into the chip.  *  *        Deasserting SPX*_DBG_DESKEW_CTL[SSTEP] will attempt to deskew as per  *        the normal definition.  Single step mode is for debug only.  Special  *        care must be given to correctly deskew the interface if normal  *        operation is desired.  *  * * SPX*_DBG_DESKEW_CTL[SSTEP_GO]  *        Each write of '1' to SSTEP_GO will go through a single training  *        iteration and will perform...  *  *        - DLL update, if SPX*_DBG_DESKEW_CTL[DLLDIS] is clear  *        - coarse update, if SPX*_TRN4_CTL[MUX_EN] is set  *        - single fine update, if SPX*_TRN4_CTL[MACRO_EN] is set and an edge  *       was detected after walked +/- SPX*_TRN4_CTL[MAXDIST] taps.  *  *        Writes to this register have no effect if the interface is not in  *        SSTEP mode (SPX*_DBG_DESKEW_CTL[SSTEP]).  *  *        The WILMA mode will be cleared at the final state transition, so  *        that software can set SPX*_DBG_DESKEW_CTL[SSTEP] and  *        SPX*_DBG_DESKEW_CTL[SSTEP_GO] before setting SPX*_CLK_CTL[RCVTRN]  *        and the machine will go through the initial iteration and stop -  *        waiting for another SPX*_DBG_DESKEW_CTL[SSTEP_GO] or an interface  *        enable.  *  * * SPX*_DBG_DESKEW_CTL[FALL8]  *   Determines how many pattern matches are required during training  *   operations to fallout of training and begin processing the normal data  *   stream.  The default value is 10 pattern matches.  The pattern that is  *   used is dependent on the SPX*_DBG_DESKEW_CTL[FALLNOP] CSR which  *   determines between non-training packets (the default) and NOPs.  *  * * SPX*_DBG_DESKEW_CTL[FALLNOP]  *   Determines the pattern that is required during training operations to  *   fallout of training and begin processing the normal data stream.  The  *   default value is to match against non-training data.  Setting this  *   bit, changes the behavior to watch for NOPs packet instead.  *  *   This bit should not be changed dynamically while the link is  *   operational.  */
end_comment

begin_union
union|union
name|cvmx_spxx_dbg_deskew_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_dbg_deskew_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|fallnop
range|:
literal|1
decl_stmt|;
comment|/**< Training fallout on NOP matches instead of                                                          non-training matches.                                                          (spx_csr__spi4_fallout_nop) */
name|uint64_t
name|fall8
range|:
literal|1
decl_stmt|;
comment|/**< Training fallout at 8 pattern matches instead of 10                                                          (spx_csr__spi4_fallout_8_match) */
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sstep_go
range|:
literal|1
decl_stmt|;
comment|/**< Single Step Training Sequence                                                          (spx_csr__spi4_single_step_go) */
name|uint64_t
name|sstep
range|:
literal|1
decl_stmt|;
comment|/**< Single Step Training Mode                                                          (spx_csr__spi4_single_step_mode) */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clrdly
range|:
literal|1
decl_stmt|;
comment|/**< Resets the offset control in the XCV                                                          (spx_csr__spi4_dll_clr_dly) */
name|uint64_t
name|dec
range|:
literal|1
decl_stmt|;
comment|/**< Decrement the offset by OFFSET for the Spi4                                                          bit selected by BITSEL                                                          (spx_csr__spi4_dbg_trn_dec) */
name|uint64_t
name|inc
range|:
literal|1
decl_stmt|;
comment|/**< Increment the offset by OFFSET for the Spi4                                                          bit selected by BITSEL                                                          (spx_csr__spi4_dbg_trn_inc) */
name|uint64_t
name|mux
range|:
literal|1
decl_stmt|;
comment|/**< Set the mux select tap for the Spi4 bit                                                          selected by BITSEL                                                          (spx_csr__spi4_dbg_trn_mux) */
name|uint64_t
name|offset
range|:
literal|5
decl_stmt|;
comment|/**< Adds or subtracts (Based on INC or DEC) the                                                          offset to Spi4 bit BITSEL.                                                          (spx_csr__spi4_dbg_trn_offset) */
name|uint64_t
name|bitsel
range|:
literal|5
decl_stmt|;
comment|/**< Select the Spi4 CTL or DAT bit                                                          15-0 : Spi4 DAT[15:0]                                                          16   : Spi4 CTL                                                          - 31-17: Invalid                                                          (spx_csr__spi4_dbg_trn_bitsel) */
name|uint64_t
name|offdly
range|:
literal|6
decl_stmt|;
comment|/**< Set the spx__offset lines to this value when                                                          not in macro sequence                                                          (spx_csr__spi4_mac_offdly) */
name|uint64_t
name|dllfrc
range|:
literal|1
decl_stmt|;
comment|/**< Force the Spi4 RX DLL to update                                                          (spx_csr__spi4_dll_force) */
name|uint64_t
name|dlldis
range|:
literal|1
decl_stmt|;
comment|/**< Disable sending the update signal to the Spi4                                                          RX DLL when set                                                          (spx_csr__spi4_dll_trn_en) */
else|#
directive|else
name|uint64_t
name|dlldis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dllfrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|offdly
range|:
literal|6
decl_stmt|;
name|uint64_t
name|bitsel
range|:
literal|5
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mux
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dec
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clrdly
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sstep
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sstep_go
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fall8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fallnop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_dbg_deskew_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_dbg_deskew_ctl
name|cvmx_spxx_dbg_deskew_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_dbg_deskew_state  *  * Notes:  * These bits are meant as a backdoor to control Spi4 per-bit deskew.  See  * that Spec for more details.  */
end_comment

begin_union
union|union
name|cvmx_spxx_dbg_deskew_state
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_dbg_deskew_state_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|testres
range|:
literal|1
decl_stmt|;
comment|/**< Training Test Mode Result                                                          (srx_spi4__test_mode_result) */
name|uint64_t
name|unxterm
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected training terminiation                                                          (srx_spi4__top_unxexp_trn_term) */
name|uint64_t
name|muxsel
range|:
literal|2
decl_stmt|;
comment|/**< The mux select value of the bit selected by                                                          SPX_DBG_DESKEW_CTL[BITSEL]                                                          (srx_spi4__trn_mux_sel) */
name|uint64_t
name|offset
range|:
literal|5
decl_stmt|;
comment|/**< The counter value of the bit selected by                                                          SPX_DBG_DESKEW_CTL[BITSEL]                                                          (srx_spi4__xcv_tap_select) */
else|#
directive|else
name|uint64_t
name|offset
range|:
literal|5
decl_stmt|;
name|uint64_t
name|muxsel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|unxterm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|testres
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_dbg_deskew_state_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_state_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_state_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_dbg_deskew_state_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_dbg_deskew_state
name|cvmx_spxx_dbg_deskew_state_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_drv_ctl  *  * Notes:  * These bits all come from Duke - he will provide documentation and  * explanation.  I'll just butcher it.  */
end_comment

begin_union
union|union
name|cvmx_spxx_drv_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_drv_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_spxx_drv_ctl_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|stx4ncmp
range|:
literal|4
decl_stmt|;
comment|/**< Duke (spx__spi4_tx_nctl_comp) */
name|uint64_t
name|stx4pcmp
range|:
literal|4
decl_stmt|;
comment|/**< Duke (spx__spi4_tx_pctl_comp) */
name|uint64_t
name|srx4cmp
range|:
literal|8
decl_stmt|;
comment|/**< Duke (spx__spi4_rx_rctl_comp) */
else|#
directive|else
name|uint64_t
name|srx4cmp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|stx4pcmp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stx4ncmp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_spxx_drv_ctl_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_spxx_drv_ctl_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|stx4ncmp
range|:
literal|4
decl_stmt|;
comment|/**< Not used in CN58XX (spx__spi4_tx_nctl_comp) */
name|uint64_t
name|stx4pcmp
range|:
literal|4
decl_stmt|;
comment|/**< Not used in CN58XX (spx__spi4_tx_pctl_comp) */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|srx4cmp
range|:
literal|10
decl_stmt|;
comment|/**< Suresh (spx__spi4_rx_rctl_comp)                                                          Can be used to bypass the RX termination resistor                                                          value. We have an on-chip RX termination resistor                                                          compensation control block, which adjusts the                                                          resistor value to a nominal 100 ohms. This                                                          register can be used to bypass this automatically                                                          computed value. */
else|#
directive|else
name|uint64_t
name|srx4cmp
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stx4pcmp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stx4ncmp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_spxx_drv_ctl_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_drv_ctl
name|cvmx_spxx_drv_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_err_ctl  *  * SPX_ERR_CTL - Spi error control register  *  *  * Notes:  * * DIPPAY, DIPCLS, PRTNXA  * These bits control whether or not the packet's ERR bit is set when any of  * the these error is detected.  If the corresponding error's bit is clear,  * the packet ERR will be set.  If the error bit is set, the SPX will simply  * pass through the ERR bit without modifying it in anyway - the error bit  * may or may not have been set by the transmitter device.  */
end_comment

begin_union
union|union
name|cvmx_spxx_err_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_err_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 - set the ERR bit on packets in which the                                                          port is out-of-range */
name|uint64_t
name|dipcls
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 DIPERR on closing control words cause the                                                          ERR bit to be set */
name|uint64_t
name|dippay
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 DIPERR on payload control words cause the                                                          ERR bit to be set */
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|errcnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of Dip4 errors before bringing down the                                                          interface */
else|#
directive|else
name|uint64_t
name|errcnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dippay
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dipcls
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_err_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_err_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_err_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_err_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_err_ctl
name|cvmx_spxx_err_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_int_dat  *  * SPX_INT_DAT - Interrupt Data Register  *  *  * Notes:  * Note: The SPX_INT_DAT[MUL] bit is set when multiple errors have been  * detected that would set any of the data fields: PRT, RSVOP, and CALBNK.  *  * The following errors will cause MUL to assert for PRT conflicts.  * - ABNORM  * - APERR  * - DPERR  *  * The following errors will cause MUL to assert for RSVOP conflicts.  * - RSVERR  *  * The following errors will cause MUL to assert for CALBNK conflicts.  * - CALERR  *  * The following errors will cause MUL to assert if multiple interrupts are  * asserted.  * - TPAOVR  *  * The MUL bit will be cleared once all outstanding errors have been  * cleared by software (not just MUL errors - all errors).  */
end_comment

begin_union
union|union
name|cvmx_spxx_int_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_int_dat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|mul
range|:
literal|1
decl_stmt|;
comment|/**< Multiple errors have occured */
name|uint64_t
name|reserved_14_30
range|:
literal|17
decl_stmt|;
name|uint64_t
name|calbnk
range|:
literal|2
decl_stmt|;
comment|/**< Spi4 Calendar table parity error bank */
name|uint64_t
name|rsvop
range|:
literal|4
decl_stmt|;
comment|/**< Spi4 reserved control word */
name|uint64_t
name|prt
range|:
literal|8
decl_stmt|;
comment|/**< Port associated with error */
else|#
directive|else
name|uint64_t
name|prt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rsvop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|calbnk
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_30
range|:
literal|17
decl_stmt|;
name|uint64_t
name|mul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_int_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_dat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_int_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_dat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_int_dat
name|cvmx_spxx_int_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_int_msk  *  * SPX_INT_MSK - Interrupt Mask Register  *  */
end_comment

begin_union
union|union
name|cvmx_spxx_int_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_int_msk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 Calendar table parity error */
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
comment|/**< Consecutive Spi4 DIP4 errors have exceeded                                                          SPX_ERR_CTL[ERRCNT] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 DIP4 error */
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
comment|/**< Selected port has hit TPA overflow */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 reserved control word detected */
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 receive FIFO drowning/overflow */
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 packet closed on non-16B alignment without EOP */
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi async FIFO overflow (Spi3 or Spi4) */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
comment|/**< Abnormal packet termination (ERR bit) */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Port out of range */
else|#
directive|else
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_int_msk_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_msk_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_int_msk_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_msk_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_int_msk
name|cvmx_spxx_int_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_int_reg  *  * SPX_INT_REG - Interrupt Register  *  *  * Notes:  * * PRTNXA  *   This error indicates that the port on the Spi bus was not a valid port  *   for the system.  Spi4 accesses occur on payload control bit-times. The  *   SRX can be configured with the exact number of ports available (by  *   SRX_COM_CTL[PRTS] register).  Any Spi access to anthing outside the range  *   of 0 .. (SRX_COM_CTL[PRTS] - 1) is considered an error.  The offending  *   port is logged in SPX_INT_DAT[PRT] if there are no pending interrupts in  *   SPX_INT_REG that require SPX_INT_DAT[PRT].  *  *   SRX will not drop the packet with the bogus port address.  Instead, the  *   port will be mapped into the supported port range.  The remapped address  *   in simply...  *  *            Address = [ interfaceId, ADR[3:0] ]  *  *   If the SPX detects that a PRTNXA error has occured, the packet will  *   have its ERR bit set (or'ed in with the ERR bit from the transmitter)  *   if the SPX_ERR_CTL[PRTNXA] bit is clear.  *  *   In Spi4 mode, SPX will generate an interrupt for every 8B data burst  *   associated with the invalid address.  The SPX_INT_DAT[MUL] bit will never  *   be set.  *  * * ABNORM  *   This bit simply indicates that a given packet had abnormal terminiation.  *   In Spi4 mode, this means that packet completed with an EOPS[1:0] code of  *   2'b01.  This error can also be thought of as the application specific  *   error (as mentioned in the Spi4 spec).  The offending port is logged in  *   SPX_INT_DAT[PRT] if there are no pending interrupts in SPX_INT_REG that  *   require SPX_INT_DAT[PRT].  *  *   The ABNORM error is only raised when the ERR bit that comes from the  *   Spi interface is set.  It will never assert if any internal condition  *   causes the ERR bit to assert (e.g. PRTNXA or DPERR).  *  * * SPIOVR  *   This error indicates that the FIFOs that manage the async crossing from  *   the Spi clocks to the core clock domains have overflowed.  This is a  *   fatal error and can cause much data/control corruption since ticks will  *   be dropped and reordered.  This is purely a function of clock ratios and  *   correct system ratios should make this an impossible condition.  *  * * CLSERR  *   This is a Spi4 error that indicates that a given data transfer burst  *   that did not terminate with an EOP, did not end with the 16B alignment  *   as per the Spi4 spec.  The offending port cannot be logged since the  *   block does not know the streamm terminated until the port switches.  *   At that time, that packet has already been pushed down the pipe.  *  *   The CLSERR bit does not actually check the Spi4 burst - just how data  *   is accumulated for the downstream logic.  Bursts that are separted by  *   idles or training will still be merged into accumulated transfers and  *   will not fire the CLSERR condition.  The checker is really checking  *   non-8B aligned, non-EOP data ticks that are sent downstream.  These  *   ticks are what will really mess up the core.  *  *   This is an expensive fix, so we'll probably let it ride.  We never  *   claim to check Spi4 protocol anyway.  *  * * DRWNNG  *   This error indicates that the Spi4 FIFO that services the GMX has  *   overflowed.  Like the SPIOVR error condition, correct system ratios  *   should make this an impossible condition.  *  * * RSVERR  *   This Spi4 error indicates that the Spi4 receiver has seen a reserve  *   control packet.  A reserve control packet is an invalid combiniation  *   of bits on DAT[15:12].  Basically this is DAT[15] == 1'b0 and DAT[12]  *   == 1'b1 (an SOP without a payload command).  The RSVERR indicates an  *   error has occured and SPX_INT_DAT[RSVOP] holds the first reserved  *   opcode and will be set if there are no pending interrupts in  *   SPX_INT_REG that require SPX_INT_DAT[RSVOP].  *  * * TPAOVR  *   This bit indicates that the TPA Watcher has flagged an event.  See the  *   TPA Watcher for a more detailed discussion.  *  * * DIPERR  *   This bit indicates that the Spi4 receiver has encountered a DIP4  *   miscompare on the datapath.  A DIPERR can occur in an IDLE or a  *   control word that frames a data burst.  If the DIPERR occurs on a  *   framing word there are three cases.  *  *   1) DIPERR occurs at the end of a data burst.  The previous packet is  *      marked with the ERR bit to be processed later if  *      SPX_ERR_CTL[DIPCLS] is clear.  *   2) DIPERR occurs on a payload word.  The subsequent packet is marked  *      with the ERR bit to be processed later if SPX_ERR_CTL[DIPPAY] is  *      clear.  *   3) DIPERR occurs on a control word that closes on packet and is a  *      payload for another packet.  In this case, both packets will have  *      their ERR bit marked depending on the respective values of  *      SPX_ERR_CTL[DIPCLS] and SPX_ERR_CTL[DIPPAY] as discussed above.  *  * * SYNCERR  *   This bit indicates that the Spi4 receiver has encountered  *   SPX_ERR_CTL[ERRCNT] consecutive Spi4 DIP4 errors and the interface  *   should be synched.  *  * * CALERR  *   This bit indicates that the Spi4 calendar table encountered a parity  *   error.  This error bit is associated with the calendar table on the RX  *   interface - the interface that receives the Spi databus.  Parity errors  *   can occur during normal operation when the calendar table is constantly  *   being read for the port information, or during initialization time, when  *   the user has access.  Since the calendar table is split into two banks,  *   SPX_INT_DAT[CALBNK] indicates which banks have taken a parity error.  *   CALBNK[1] indicates the error occured in the upper bank, while CALBNK[0]  *   indicates that the error occured in the lower bank.  SPX_INT_DAT[CALBNK]  *   will be set if there are no pending interrupts in SPX_INT_REG that  *   require SPX_INT_DAT[CALBNK].  *  * * SPF  *   This bit indicates that a Spi fatal error has occurred.  A fatal error  *   is defined as any error condition for which the corresponding  *   SPX_INT_SYNC bit is set.  Therefore, conservative systems can halt the  *   interface on any error condition although this is not strictly  *   necessary.  Some error are much more fatal in nature than others.  *  *   PRTNXA, SPIOVR, CLSERR, DRWNNG, DIPERR, CALERR, and SYNCERR are examples  *   of fatal error for different reasons - usually because multiple port  *   streams could be effected.  ABNORM, RSVERR, and TPAOVR are conditions  *   that are contained to a single packet which allows the interface to drop  *   a single packet and remain up and stable.  */
end_comment

begin_union
union|union
name|cvmx_spxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|spf
range|:
literal|1
decl_stmt|;
comment|/**< Spi interface down */
name|uint64_t
name|reserved_12_30
range|:
literal|19
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 Calendar table parity error */
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
comment|/**< Consecutive Spi4 DIP4 errors have exceeded                                                          SPX_ERR_CTL[ERRCNT] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 DIP4 error */
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
comment|/**< Selected port has hit TPA overflow */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 reserved control word detected */
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 receive FIFO drowning/overflow */
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 packet closed on non-16B alignment without EOP */
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi async FIFO overflow */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
comment|/**< Abnormal packet termination (ERR bit) */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Port out of range */
else|#
directive|else
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_30
range|:
literal|19
decl_stmt|;
name|uint64_t
name|spf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_int_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_int_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_int_reg
name|cvmx_spxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_int_sync  *  * SPX_INT_SYNC - Interrupt Sync Register  *  *  * Notes:  * This mask set indicates which exception condition should cause the  * SPX_INT_REG[SPF] bit to assert  *  * It is recommended that software set the PRTNXA, SPIOVR, CLSERR, DRWNNG,  * DIPERR, CALERR, and SYNCERR errors as synchronization events.  Software is  * free to synchronize the bus on other conditions, but this is the minimum  * recommended set.  */
end_comment

begin_union
union|union
name|cvmx_spxx_int_sync
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_int_sync_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 Calendar table parity error */
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
comment|/**< Consecutive Spi4 DIP4 errors have exceeded                                                          SPX_ERR_CTL[ERRCNT] */
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 DIP4 error */
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
comment|/**< Selected port has hit TPA overflow */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 reserved control word detected */
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 receive FIFO drowning/overflow */
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
comment|/**< Spi4 packet closed on non-16B alignment without EOP */
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
comment|/**< Spi async FIFO overflow (Spi3 or Spi4) */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
comment|/**< Abnormal packet termination (ERR bit) */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Port out of range */
else|#
directive|else
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|abnorm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|spiovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drwnng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tpaovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|diperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syncerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|calerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_int_sync_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_sync_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_int_sync_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_int_sync_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_int_sync
name|cvmx_spxx_int_sync_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_tpa_acc  *  * SPX_TPA_ACC - TPA watcher byte accumulator  *  *  * Notes:  * This field allows the user to access the TPA watcher accumulator counter.  * This register reflects the number of bytes sent to IMX once the port  * specified by SPX_TPA_SEL[PRTSEL] has lost its TPA.  The SPX_INT_REG[TPAOVR]  * bit is asserted when CNT>= SPX_TPA_MAX[MAX].  The CNT will continue to  * increment until the TPA for the port is asserted.  At that point the CNT  * value is frozen until software clears the interrupt bit.  */
end_comment

begin_union
union|union
name|cvmx_spxx_tpa_acc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_tpa_acc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< TPA watcher accumulate count */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_tpa_acc_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_acc_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_acc_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_acc_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_tpa_acc
name|cvmx_spxx_tpa_acc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_tpa_max  *  * SPX_TPA_MAX - TPA watcher assertion threshold  *  *  * Notes:  * The TPA watcher has the ability to notify the system with an interrupt when  * too much data has been received on loss of TPA.  The user sets the  * SPX_TPA_MAX[MAX] register and when the watcher has accumulated that many  * ticks, then the interrupt is conditionally raised (based on interrupt mask  * bits).  This feature will be disabled if the programmed count is zero.  */
end_comment

begin_union
union|union
name|cvmx_spxx_tpa_max
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_tpa_max_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|max
range|:
literal|32
decl_stmt|;
comment|/**< TPA watcher TPA threshold */
else|#
directive|else
name|uint64_t
name|max
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_tpa_max_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_max_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_max_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_max_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_tpa_max
name|cvmx_spxx_tpa_max_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_tpa_sel  *  * SPX_TPA_SEL - TPA watcher port selector  *  *  * Notes:  * The TPA Watcher is primarily a debug vehicle used to help initial bringup  * of a system.  The TPA watcher counts bytes that roll in from the Spi  * interface.  The user programs the Spi port to watch using  * SPX_TPA_SEL[PRTSEL].  Once the TPA is deasserted for that port, the watcher  * begins to count the data ticks that have been delivered to the inbound  * datapath (and eventually to the IOB).  The result is that we can derive  * turn-around times of the other device by watching how much data was sent  * after a loss of TPA through the SPX_TPA_ACC[CNT] register.  An optional  * interrupt may be raised as well.  See SPX_TPA_MAX for further information.  *  * TPA's can be deasserted for a number of reasons...  *  * 1) IPD indicates backpressure  * 2) The GMX inbound FIFO is filling up and should BP  * 3) User has out an override on the TPA wires  */
end_comment

begin_union
union|union
name|cvmx_spxx_tpa_sel
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_tpa_sel_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|prtsel
range|:
literal|4
decl_stmt|;
comment|/**< TPA watcher port select */
else|#
directive|else
name|uint64_t
name|prtsel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_tpa_sel_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_sel_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_sel_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_tpa_sel_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_tpa_sel
name|cvmx_spxx_tpa_sel_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_spx#_trn4_ctl  *  * Notes:  * These bits are controls for the Spi4 RX bit deskew logic.  See that Spec  * for further details.  *  * * BOOT_BIT  *   On the initial training synchronization sequence, the hardware has the  *   BOOT_BIT set which means that it will continueously perform macro  *   operations.  Once the BOOT_BIT is cleared, the macro machine will finish  *   the macro operation is working on and then return to the idle state.  *   Subsequent training sequences will only go through a single macro  *   operation in order to do slight deskews.  *  * * JITTER  *   Minimum value is 1.  This parameter must be set for Spi4 mode using  *   auto-bit deskew.  Regardless of the original intent, this field must be  *   set non-zero for deskew to function correctly.  *  *   The thought is the JITTER range is no longer required since the macro  *   machine was enhanced to understand about edge direction.  Originally  *   these bits were intended to compensate for clock jitter.  *  *   dly:    this is the intrinsic delay of each delay element  *              tap currently, it is 70ps-110ps.  *   jitter: amount of jitter we expect in the system (~200ps)  *   j:      number of taps to account for jitter  *  *   j = ((jitter / dly) + 1)  *  * * TRNTEST  *   This mode is used to test systems to make sure that the bit deskew  *   parameters have been correctly setup.  After configuration, software can  *   set the TRNTEST mode bit.  This should be done before SRX_COM_CTL[ST_EN]  *   is set such that we can be sure that the TX device is simply sending  *   continuous training patterns.  *  *   The test mode samples every incoming bit-time and makes sure that it is  *   either a training control or a training data packet.  If any other data  *   is observed, then SPX_DBG_DESKEW_STATE[TESTRES] will assert signaling a  *   test failure.  *  *   Software must clear TRNTEST before training is terminated.  *  * * Example Spi4 RX init flow...  *  * 1) set the CLKDLY lines (SPXX_CLK_CTL[CLKDLY])  *    - these bits must be set before the DLL can successfully lock  *  * 2) set the SRXDLCK (SPXX_CLK_CTL[SRXDLCK])  *    - this is the DLL lock bit which also acts as a block reset  *  * 3) wait for the DLLs lock  *  * 4) set any desired fields in SPXX_DBG_DESKEW_CTL  *    - This register has only one field that most users will care about.  *      When set, DLLDIS will disable sending update pulses to the Spi4 RX  *      DLLs.  This pulse allows the DLL to adjust to clock variations over  *      time.  In general, it is desired behavior.  *  * 5) set fields in SPXX_TRN4_CTL  *    - These fields deal with the MUX training sequence  *      * MUX_EN  *        This is the enable bit for the mux select.  The MUX select will  *        run in the training sequence between the DLL and the Macro  *        sequence when enabled.  Once the MUX selects are selected, the  *        entire macro sequence must be rerun.  The expectation is that  *        this is only run at boot time and this is bit cleared at/around  *        step \#8.  *    - These fields deal with the Macro training sequence  *      * MACRO_EN  *        This is the enable bit for the macro sequence.  Macro sequences  *        will run after the DLL and MUX training sequences.  Each macro  *        sequence can move the offset by one value.  *      * MAXDIST  *        This is how far we will search for an edge.  Example...  *  *           dly:    this is the intrinsic delay of each delay element  *                   tap currently, it is 70ps-110ps.  *           U:      bit time period in time units.  *  *           MAXDIST = MIN(16, ((bit_time / 2) / dly)  *  *           Each MAXDIST iteration consists of an edge detect in the early  *           and late (+/-) directions in an attempt to center the data.  This  *           requires two training transistions, the control/data and  *           data/control transistions which comprise a training sequence.  *           Therefore, the number of training sequences required for a single  *           macro operation is simply MAXDIST.  *  * 6) set the RCVTRN go bit (SPXX_CLK_CTL[RCVTRN])  *    - this bit synchs on the first valid complete training cycle and  *      starts to process the training packets  *  * 6b) This is where software could manually set the controls as opposed to  *     letting the hardware do it.  See the SPXX_DBG_DESKEW_CTL register  *        description for more detail.  *  * 7) the TX device must continue to send training packets for the initial  *    time period.  *    - this can be determined by...  *  *      DLL: one training sequence for the DLL adjustment (regardless of enable/disable)  *      MUX: one training sequence for the Flop MUX taps (regardless of enable/disable)  *      INIT_SEQUENCES: max number of taps that we must move  *  *         INIT_SEQUENCES = MIN(16, ((bit_time / 2) / dly))  *  *         INIT_TRN = DLL + MUX + ROUNDUP((INIT_SEQUENCES * (MAXDIST + 2)))  *  *  *    - software can either wait a fixed amount of time based on the clock  *      frequencies or poll the SPXX_CLK_STAT[SRXTRN] register.  Each  *      assertion of SRXTRN means that at least one training sequence has  *      been received.  Software can poll, clear, and repeat on this bit to  *      eventually count all required transistions.  *  *      int cnt = 0;  *      while (cnt< INIT_TRN) [  *             if (SPXX_CLK_STAT[SRXTRN]) [  *                cnt++;  *                SPXX_CLK_STAT[SRXTRN] = 0;  *             ]  *      ]  *  *   - subsequent training sequences will normally move the taps only  *     one position, so the ALPHA equation becomes...  *  *     MAC   = (MAXDIST == 0) ? 1 : ROUNDUP((1 * (MAXDIST + 2))) + 1  *  *        ALPHA = DLL + MUX + MAC  *  *     ergo, MAXDIST simplifies to...  *  *        ALPHA = (MAXDIST == 0) ? 3 : MAXDIST + 5  *  *        DLL and MUX and MAC will always require at least a training sequence  *        each - even if disabled.  If the macro sequence is enabled, an  *        additional training sequenece at the end is necessary.  The extra  *        sequence allows for all training state to be cleared before resuming  *        normal operation.  *  * 8) after the recevier gets enough training sequences in order to achieve  *    deskew lock, set SPXX_TRN4_CTL[CLR_BOOT]  *    - this disables the continuous macro sequences and puts into into one  *      macro sequnence per training operation  *    - optionally, the machine can choose to fall out of training if  *      enough NOPs follow the training operation (require at least 32 NOPs  *      to follow the training sequence).  *  *    There must be at least MAXDIST + 3 training sequences after the  *    SPXX_TRN4_CTL[CLR_BOOT] is set or sufficient NOPs from the TX device.  *  * 9) the TX device continues to send training sequences until the RX  *    device sends a calendar transistion.  This is controlled by  *    SRXX_COM_CTL[ST_EN].  Other restrictions require other Spi parameters  *    (e.g. the calendar table) to be setup before this bit can be enabled.  *    Once the entire interface is properly programmed, software writes  *    SRXX_COM_CTL[INF_EN].  At this point, the Spi4 packets will begin to  *    be sent into the N2K core and processed by the chip.  */
end_comment

begin_union
union|union
name|cvmx_spxx_trn4_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_spxx_trn4_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|trntest
range|:
literal|1
decl_stmt|;
comment|/**< Training Test Mode                                                          This bit is only for initial bringup                                                          (spx_csr__spi4_trn_test_mode) */
name|uint64_t
name|jitter
range|:
literal|3
decl_stmt|;
comment|/**< Accounts for jitter when the macro sequence is                                                          locking.  The value is how many consecutive                                                          transititions before declaring en edge.  Minimum                                                          value is 1.  This parameter must be set for Spi4                                                          mode using auto-bit deskew.                                                          (spx_csr__spi4_mac_jitter) */
name|uint64_t
name|clr_boot
range|:
literal|1
decl_stmt|;
comment|/**< Clear the macro boot sequence mode bit                                                          (spx_csr__spi4_mac_clr_boot) */
name|uint64_t
name|set_boot
range|:
literal|1
decl_stmt|;
comment|/**< Enable the macro boot sequence mode bit                                                          (spx_csr__spi4_mac_set_boot) */
name|uint64_t
name|maxdist
range|:
literal|5
decl_stmt|;
comment|/**< This field defines how far from center the                                                          deskew logic will search in a single macro                                                           sequence (spx_csr__spi4_mac_iters) */
name|uint64_t
name|macro_en
range|:
literal|1
decl_stmt|;
comment|/**< Allow the macro sequence to center the sample                                                          point in the data window through hardware                                                          (spx_csr__spi4_mac_trn_en) */
name|uint64_t
name|mux_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable the hardware machine that selects the                                                          proper coarse FLOP selects                                                          (spx_csr__spi4_mux_trn_en) */
else|#
directive|else
name|uint64_t
name|mux_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|macro_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxdist
range|:
literal|5
decl_stmt|;
name|uint64_t
name|set_boot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clr_boot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jitter
range|:
literal|3
decl_stmt|;
name|uint64_t
name|trntest
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_spxx_trn4_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_spxx_trn4_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_spxx_trn4_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_spxx_trn4_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_spxx_trn4_ctl
name|cvmx_spxx_trn4_ctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

