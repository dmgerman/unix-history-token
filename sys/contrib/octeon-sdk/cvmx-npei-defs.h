begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-npei-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon npei.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_NPEI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_NPEI_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_BAR1_INDEXX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_BAR1_INDEXX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_BAR1_INDEXX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000000ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_BIST_STATUS
value|CVMX_NPEI_BIST_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_BIST_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_BIST_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000580ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_BIST_STATUS
value|(0x0000000000000580ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_BIST_STATUS2
value|CVMX_NPEI_BIST_STATUS2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_BIST_STATUS2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_BIST_STATUS2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000680ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_BIST_STATUS2
value|(0x0000000000000680ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_PORT0
value|CVMX_NPEI_CTL_PORT0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_CTL_PORT0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_CTL_PORT0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000250ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_PORT0
value|(0x0000000000000250ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_PORT1
value|CVMX_NPEI_CTL_PORT1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_CTL_PORT1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_CTL_PORT1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000260ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_PORT1
value|(0x0000000000000260ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_STATUS
value|CVMX_NPEI_CTL_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_CTL_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_CTL_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000570ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_STATUS
value|(0x0000000000000570ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_STATUS2
value|CVMX_NPEI_CTL_STATUS2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_CTL_STATUS2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_CTL_STATUS2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C00ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_CTL_STATUS2
value|(0x0000000000003C00ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DATA_OUT_CNT
value|CVMX_NPEI_DATA_OUT_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DATA_OUT_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DATA_OUT_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DATA_OUT_CNT
value|(0x00000000000005F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DBG_DATA
value|CVMX_NPEI_DBG_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DBG_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DBG_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000510ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DBG_DATA
value|(0x0000000000000510ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DBG_SELECT
value|CVMX_NPEI_DBG_SELECT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DBG_SELECT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DBG_SELECT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000500ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DBG_SELECT
value|(0x0000000000000500ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA0_INT_LEVEL
value|CVMX_NPEI_DMA0_INT_LEVEL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA0_INT_LEVEL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA0_INT_LEVEL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005C0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA0_INT_LEVEL
value|(0x00000000000005C0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA1_INT_LEVEL
value|CVMX_NPEI_DMA1_INT_LEVEL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA1_INT_LEVEL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA1_INT_LEVEL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA1_INT_LEVEL
value|(0x00000000000005D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMAX_COUNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMAX_COUNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000450ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMAX_COUNTS
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000450ull + ((offset)& 7) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMAX_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMAX_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000003B0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMAX_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000003B0ull + ((offset)& 7) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMAX_IBUFF_SADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMAX_IBUFF_SADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMAX_IBUFF_SADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000400ull + ((offset)& 7) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMAX_NADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMAX_NADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000004A0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMAX_NADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000004A0ull + ((offset)& 7) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_CNTS
value|CVMX_NPEI_DMA_CNTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA_CNTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA_CNTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005E0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_CNTS
value|(0x00000000000005E0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_CONTROL
value|CVMX_NPEI_DMA_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000003A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_CONTROL
value|(0x00000000000003A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_PCIE_REQ_NUM
value|CVMX_NPEI_DMA_PCIE_REQ_NUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA_PCIE_REQ_NUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA_PCIE_REQ_NUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_PCIE_REQ_NUM
value|(0x00000000000005B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE1
value|CVMX_NPEI_DMA_STATE1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA_STATE1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA_STATE1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006C0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE1
value|(0x00000000000006C0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE1_P1
value|(0x0000000000000680ull)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE2
value|CVMX_NPEI_DMA_STATE2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_DMA_STATE2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_DMA_STATE2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE2
value|(0x00000000000006D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE2_P1
value|(0x0000000000000690ull)
end_define

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE3_P1
value|(0x00000000000006A0ull)
end_define

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE4_P1
value|(0x00000000000006B0ull)
end_define

begin_define
define|#
directive|define
name|CVMX_NPEI_DMA_STATE5_P1
value|(0x00000000000006C0ull)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_ENB
value|CVMX_NPEI_INT_A_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_A_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_A_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000560ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_ENB
value|(0x0000000000000560ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_ENB2
value|CVMX_NPEI_INT_A_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_A_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_A_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CE0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_ENB2
value|(0x0000000000003CE0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_SUM
value|CVMX_NPEI_INT_A_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_A_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_A_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000550ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_A_SUM
value|(0x0000000000000550ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_ENB
value|CVMX_NPEI_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000540ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_ENB
value|(0x0000000000000540ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_ENB2
value|CVMX_NPEI_INT_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CD0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_ENB2
value|(0x0000000000003CD0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_INFO
value|CVMX_NPEI_INT_INFO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_INFO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_INFO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000590ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_INFO
value|(0x0000000000000590ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_SUM
value|CVMX_NPEI_INT_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000530ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_SUM
value|(0x0000000000000530ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_SUM2
value|CVMX_NPEI_INT_SUM2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_INT_SUM2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_INT_SUM2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CC0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_INT_SUM2
value|(0x0000000000003CC0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_LAST_WIN_RDATA0
value|CVMX_NPEI_LAST_WIN_RDATA0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_LAST_WIN_RDATA0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_LAST_WIN_RDATA0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000600ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_LAST_WIN_RDATA0
value|(0x0000000000000600ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_LAST_WIN_RDATA1
value|CVMX_NPEI_LAST_WIN_RDATA1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_LAST_WIN_RDATA1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_LAST_WIN_RDATA1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000610ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_LAST_WIN_RDATA1
value|(0x0000000000000610ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MEM_ACCESS_CTL
value|CVMX_NPEI_MEM_ACCESS_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MEM_ACCESS_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MEM_ACCESS_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000004F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MEM_ACCESS_CTL
value|(0x00000000000004F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MEM_ACCESS_SUBIDX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000280ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
operator|-
literal|16
operator|*
literal|12
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MEM_ACCESS_SUBIDX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000280ull + ((offset)& 31) * 16 - 16*12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB0
value|CVMX_NPEI_MSI_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C50ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB0
value|(0x0000000000003C50ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB1
value|CVMX_NPEI_MSI_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C60ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB1
value|(0x0000000000003C60ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB2
value|CVMX_NPEI_MSI_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C70ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB2
value|(0x0000000000003C70ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB3
value|CVMX_NPEI_MSI_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C80ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_ENB3
value|(0x0000000000003C80ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV0
value|CVMX_NPEI_MSI_RCV0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_RCV0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_RCV0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C10ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV0
value|(0x0000000000003C10ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV1
value|CVMX_NPEI_MSI_RCV1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_RCV1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_RCV1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C20ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV1
value|(0x0000000000003C20ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV2
value|CVMX_NPEI_MSI_RCV2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_RCV2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_RCV2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C30ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV2
value|(0x0000000000003C30ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV3
value|CVMX_NPEI_MSI_RCV3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_RCV3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_RCV3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C40ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RCV3
value|(0x0000000000003C40ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RD_MAP
value|CVMX_NPEI_MSI_RD_MAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_RD_MAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_RD_MAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CA0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_RD_MAP
value|(0x0000000000003CA0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB0
value|CVMX_NPEI_MSI_W1C_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1C_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1C_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CF0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB0
value|(0x0000000000003CF0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB1
value|CVMX_NPEI_MSI_W1C_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1C_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1C_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D00ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB1
value|(0x0000000000003D00ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB2
value|CVMX_NPEI_MSI_W1C_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1C_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1C_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D10ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB2
value|(0x0000000000003D10ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB3
value|CVMX_NPEI_MSI_W1C_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1C_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1C_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D20ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1C_ENB3
value|(0x0000000000003D20ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB0
value|CVMX_NPEI_MSI_W1S_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1S_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1S_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D30ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB0
value|(0x0000000000003D30ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB1
value|CVMX_NPEI_MSI_W1S_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1S_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1S_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D40ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB1
value|(0x0000000000003D40ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB2
value|CVMX_NPEI_MSI_W1S_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1S_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1S_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D50ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB2
value|(0x0000000000003D50ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB3
value|CVMX_NPEI_MSI_W1S_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_W1S_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_W1S_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D60ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_W1S_ENB3
value|(0x0000000000003D60ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_WR_MAP
value|CVMX_NPEI_MSI_WR_MAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_MSI_WR_MAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_MSI_WR_MAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C90ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_MSI_WR_MAP
value|(0x0000000000003C90ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_CREDIT_CNT
value|CVMX_NPEI_PCIE_CREDIT_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PCIE_CREDIT_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PCIE_CREDIT_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D70ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_CREDIT_CNT
value|(0x0000000000003D70ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV
value|CVMX_NPEI_PCIE_MSI_RCV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PCIE_MSI_RCV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PCIE_MSI_RCV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CB0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV
value|(0x0000000000003CB0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B1
value|CVMX_NPEI_PCIE_MSI_RCV_B1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PCIE_MSI_RCV_B1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PCIE_MSI_RCV_B1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000650ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B1
value|(0x0000000000000650ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B2
value|CVMX_NPEI_PCIE_MSI_RCV_B2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PCIE_MSI_RCV_B2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PCIE_MSI_RCV_B2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000660ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B2
value|(0x0000000000000660ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B3
value|CVMX_NPEI_PCIE_MSI_RCV_B3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PCIE_MSI_RCV_B3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PCIE_MSI_RCV_B3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000670ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PCIE_MSI_RCV_B3
value|(0x0000000000000670ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_INSTR_BADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_INSTR_BADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_INSTR_BAOFF_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002C00ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_INSTR_BAOFF_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002C00ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_INSTR_FIFO_RSIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003000ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_INSTR_FIFO_RSIZE
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003000ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_INSTR_HEADER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_INSTR_HEADER(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_INSTR_HEADER
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_IN_BP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_IN_BP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_IN_BP
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_SLIST_BADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_SLIST_BADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_SLIST_BAOFF_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_SLIST_BAOFF_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKTX_SLIST_FIFO_RSIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001C00ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKTX_SLIST_FIFO_RSIZE
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001C00ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_CNT_INT
value|CVMX_NPEI_PKT_CNT_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_CNT_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_CNT_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001110ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_CNT_INT
value|(0x0000000000001110ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_CNT_INT_ENB
value|CVMX_NPEI_PKT_CNT_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_CNT_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_CNT_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001130ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_CNT_INT_ENB
value|(0x0000000000001130ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_ES
value|CVMX_NPEI_PKT_DATA_OUT_ES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_DATA_OUT_ES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_DATA_OUT_ES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_ES
value|(0x00000000000010B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_NS
value|CVMX_NPEI_PKT_DATA_OUT_NS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_DATA_OUT_NS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_DATA_OUT_NS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_NS
value|(0x00000000000010A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_ROR
value|CVMX_NPEI_PKT_DATA_OUT_ROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_DATA_OUT_ROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_DATA_OUT_ROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001090ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DATA_OUT_ROR
value|(0x0000000000001090ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DPADDR
value|CVMX_NPEI_PKT_DPADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_DPADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_DPADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001080ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_DPADDR
value|(0x0000000000001080ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INPUT_CONTROL
value|CVMX_NPEI_PKT_INPUT_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_INPUT_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_INPUT_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001150ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INPUT_CONTROL
value|(0x0000000000001150ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_ENB
value|CVMX_NPEI_PKT_INSTR_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_INSTR_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_INSTR_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_ENB
value|(0x0000000000001000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_RD_SIZE
value|CVMX_NPEI_PKT_INSTR_RD_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_INSTR_RD_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_INSTR_RD_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001190ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_RD_SIZE
value|(0x0000000000001190ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_SIZE
value|CVMX_NPEI_PKT_INSTR_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_INSTR_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_INSTR_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INSTR_SIZE
value|(0x0000000000001020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INT_LEVELS
value|CVMX_NPEI_PKT_INT_LEVELS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_INT_LEVELS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_INT_LEVELS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001100ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_INT_LEVELS
value|(0x0000000000001100ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_BP
value|CVMX_NPEI_PKT_IN_BP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_IN_BP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_IN_BP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_BP
value|(0x00000000000006B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_IN_DONEX_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002000ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_DONEX_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002000ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_INSTR_COUNTS
value|CVMX_NPEI_PKT_IN_INSTR_COUNTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_IN_INSTR_COUNTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_IN_INSTR_COUNTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_INSTR_COUNTS
value|(0x00000000000006A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_PCIE_PORT
value|CVMX_NPEI_PKT_IN_PCIE_PORT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_IN_PCIE_PORT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_IN_PCIE_PORT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000011A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IN_PCIE_PORT
value|(0x00000000000011A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IPTR
value|CVMX_NPEI_PKT_IPTR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_IPTR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_IPTR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001070ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_IPTR
value|(0x0000000000001070ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUTPUT_WMARK
value|CVMX_NPEI_PKT_OUTPUT_WMARK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_OUTPUT_WMARK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_OUTPUT_WMARK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001160ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUTPUT_WMARK
value|(0x0000000000001160ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUT_BMODE
value|CVMX_NPEI_PKT_OUT_BMODE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_OUT_BMODE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_OUT_BMODE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUT_BMODE
value|(0x00000000000010D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUT_ENB
value|CVMX_NPEI_PKT_OUT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_OUT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_OUT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_OUT_ENB
value|(0x0000000000001010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_PCIE_PORT
value|CVMX_NPEI_PKT_PCIE_PORT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_PCIE_PORT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_PCIE_PORT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010E0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_PCIE_PORT
value|(0x00000000000010E0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_PORT_IN_RST
value|CVMX_NPEI_PKT_PORT_IN_RST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_PORT_IN_RST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_PORT_IN_RST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000690ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_PORT_IN_RST
value|(0x0000000000000690ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ES
value|CVMX_NPEI_PKT_SLIST_ES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_SLIST_ES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_SLIST_ES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ES
value|(0x0000000000001050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ID_SIZE
value|CVMX_NPEI_PKT_SLIST_ID_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_SLIST_ID_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_SLIST_ID_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001180ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ID_SIZE
value|(0x0000000000001180ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_NS
value|CVMX_NPEI_PKT_SLIST_NS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_SLIST_NS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_SLIST_NS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_NS
value|(0x0000000000001040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ROR
value|CVMX_NPEI_PKT_SLIST_ROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_SLIST_ROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_SLIST_ROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_SLIST_ROR
value|(0x0000000000001030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_TIME_INT
value|CVMX_NPEI_PKT_TIME_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_TIME_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_TIME_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001120ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_TIME_INT
value|(0x0000000000001120ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_TIME_INT_ENB
value|CVMX_NPEI_PKT_TIME_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_PKT_TIME_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_PKT_TIME_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001140ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_PKT_TIME_INT_ENB
value|(0x0000000000001140ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_RSL_INT_BLOCKS
value|CVMX_NPEI_RSL_INT_BLOCKS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_RSL_INT_BLOCKS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_RSL_INT_BLOCKS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000520ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_RSL_INT_BLOCKS
value|(0x0000000000000520ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_SCRATCH_1
value|CVMX_NPEI_SCRATCH_1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_SCRATCH_1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_SCRATCH_1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000270ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_SCRATCH_1
value|(0x0000000000000270ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE1
value|CVMX_NPEI_STATE1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_STATE1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_STATE1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000620ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE1
value|(0x0000000000000620ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE2
value|CVMX_NPEI_STATE2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_STATE2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_STATE2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000630ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE2
value|(0x0000000000000630ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE3
value|CVMX_NPEI_STATE3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_STATE3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_STATE3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000640ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_STATE3
value|(0x0000000000000640ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WINDOW_CTL
value|CVMX_NPEI_WINDOW_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WINDOW_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WINDOW_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000380ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WINDOW_CTL
value|(0x0000000000000380ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_RD_ADDR
value|CVMX_NPEI_WIN_RD_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WIN_RD_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WIN_RD_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000210ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_RD_ADDR
value|(0x0000000000000210ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_RD_DATA
value|CVMX_NPEI_WIN_RD_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WIN_RD_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WIN_RD_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000240ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_RD_DATA
value|(0x0000000000000240ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_ADDR
value|CVMX_NPEI_WIN_WR_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WIN_WR_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WIN_WR_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000200ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_ADDR
value|(0x0000000000000200ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_DATA
value|CVMX_NPEI_WIN_WR_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WIN_WR_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WIN_WR_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000220ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_DATA
value|(0x0000000000000220ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_MASK
value|CVMX_NPEI_WIN_WR_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPEI_WIN_WR_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPEI_WIN_WR_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000230ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPEI_WIN_WR_MASK
value|(0x0000000000000230ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_npei_bar1_index#  *  * Total Address is 16Kb; 0x0000 - 0x3fff, 0x000 - 0x7fe(Reg, every other 8B)  *  * General  5kb; 0x0000 - 0x13ff, 0x000 - 0x27e(Reg-General)  * PktMem  10Kb; 0x1400 - 0x3bff, 0x280 - 0x77e(Reg-General-Packet)  * Rsvd     1Kb; 0x3c00 - 0x3fff, 0x780 - 0x7fe(Reg-NCB Only Mode)  *                                   == NPEI_PKT_CNT_INT_ENB[PORT]  *                                   == NPEI_PKT_TIME_INT_ENB[PORT]  *                                   == NPEI_PKT_CNT_INT[PORT]  *                                   == NPEI_PKT_TIME_INT[PORT]  *                                   == NPEI_PKT_PCIE_PORT[PP]  *                                   == NPEI_PKT_SLIST_ROR[ROR]  *                                   == NPEI_PKT_SLIST_ROR[NSR] ?  *                                   == NPEI_PKT_SLIST_ES[ES]  *                                   == NPEI_PKTn_SLIST_BAOFF_DBELL[AOFF]  *                                   == NPEI_PKTn_SLIST_BAOFF_DBELL[DBELL]  *                                   == NPEI_PKTn_CNTS[CNT]  * NPEI_CTL_STATUS[OUTn_ENB]         == NPEI_PKT_OUT_ENB[ENB]  * NPEI_BASE_ADDRESS_OUTPUTn[BADDR]  == NPEI_PKTn_SLIST_BADDR[ADDR]  * NPEI_DESC_OUTPUTn[SIZE]           == NPEI_PKTn_SLIST_FIFO_RSIZE[RSIZE]  * NPEI_Pn_DBPAIR_ADDR[NADDR]        == NPEI_PKTn_SLIST_BADDR[ADDR] + NPEI_PKTn_SLIST_BAOFF_DBELL[AOFF]  * NPEI_PKT_CREDITSn[PTR_CNT]        == NPEI_PKTn_SLIST_BAOFF_DBELL[DBELL]  * NPEI_P0_PAIR_CNTS[AVAIL]          == NPEI_PKTn_SLIST_BAOFF_DBELL[DBELL]  * NPEI_P0_PAIR_CNTS[FCNT]           ==  * NPEI_PKTS_SENTn[PKT_CNT]          == NPEI_PKTn_CNTS[CNT]  * NPEI_OUTPUT_CONTROL[Pn_BMODE]     == NPEI_PKT_OUT_BMODE[BMODE]  * NPEI_PKT_CREDITSn[PKT_CNT]        == NPEI_PKTn_CNTS[CNT]  * NPEI_BUFF_SIZE_OUTPUTn[BSIZE]     == NPEI_PKT_SLIST_ID_SIZE[BSIZE]  * NPEI_BUFF_SIZE_OUTPUTn[ISIZE]     == NPEI_PKT_SLIST_ID_SIZE[ISIZE]  * NPEI_OUTPUT_CONTROL[On_CSRM]      == NPEI_PKT_DPADDR[DPTR]& NPEI_PKT_OUT_USE_IPTR[PORT]  * NPEI_OUTPUT_CONTROL[On_ES]        == NPEI_PKT_DATA_OUT_ES[ES]  * NPEI_OUTPUT_CONTROL[On_NS]        == NPEI_PKT_DATA_OUT_NS[NSR] ?  * NPEI_OUTPUT_CONTROL[On_RO]        == NPEI_PKT_DATA_OUT_ROR[ROR]  * NPEI_PKTS_SENT_INT_LEVn[PKT_CNT]  == NPEI_PKT_INT_LEVELS[CNT]  * NPEI_PKTS_SENT_TIMEn[PKT_TIME]    == NPEI_PKT_INT_LEVELS[TIME]  * NPEI_OUTPUT_CONTROL[IPTR_On]      == NPEI_PKT_IPTR[IPTR]  * NPEI_PCIE_PORT_OUTPUT[]           == NPEI_PKT_PCIE_PORT[PP]  *  *                  NPEI_BAR1_INDEXX = NPEI BAR1 IndexX Register  *  * Contains address index and control bits for access to memory ranges of BAR-1. Index is build from supplied address [25:22].  * NPEI_BAR1_INDEX0 through NPEI_BAR1_INDEX15 is used for transactions orginating with PCIE-PORT0 and NPEI_BAR1_INDEX16  * through NPEI_BAR1_INDEX31 is used for transactions originating with PCIE-PORT1.  */
end_comment

begin_union
union|union
name|cvmx_npei_bar1_indexx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_npei_bar1_indexx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint32_t
name|addr_idx
range|:
literal|14
decl_stmt|;
comment|/**< Address bits [35:22] sent to L2C */
name|uint32_t
name|ca
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when access is not to be cached in L2. */
name|uint32_t
name|end_swp
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode */
name|uint32_t
name|addr_v
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the selected address range is valid. */
else|#
directive|else
name|uint32_t
name|addr_v
range|:
literal|1
decl_stmt|;
name|uint32_t
name|end_swp
range|:
literal|2
decl_stmt|;
name|uint32_t
name|ca
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr_idx
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_bar1_indexx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_bar1_indexx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_bar1_indexx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_bar1_indexx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_bar1_indexx
name|cvmx_npei_bar1_indexx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_bist_status  *  * NPEI_BIST_STATUS = NPI's BIST Status Register  *  * Results from BIST runs of NPEI's memories.  */
end_comment

begin_union
union|union
name|cvmx_npei_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pkt_rdf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Read FIFO */
name|uint64_t
name|reserved_60_62
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pcr_gim
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Gather Instr MEM */
name|uint64_t
name|pkt_pif
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT INB FIFO */
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pout_int_bstatus */
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_instr_mem_bstatus */
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pin_cnt_bstatus */
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_in_done_bstatus */
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_slist_bstatus */
name|uint64_t
name|reserved_50_52
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pkt_ind
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Instruction Done MEM */
name|uint64_t
name|pkt_slm
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT SList MEM */
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Pcie Store */
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Pcie Store */
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Pcie Store */
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Pcie Store */
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P Order */
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N Order */
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C Order */
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P Order */
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N Order */
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C Order */
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM0 */
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM1 */
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|pkt_slm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_ind
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_50_52
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_gim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_62
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pkt_rdf
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npei_bist_status_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pkt_rdf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Read FIFO */
name|uint64_t
name|reserved_60_62
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pcr_gim
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Gather Instr MEM */
name|uint64_t
name|pkt_pif
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT INB FIFO */
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB Interrupt MEM */
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT CSR Instr MEM */
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT INB Count MEM */
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT INB Instr Done MEM */
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB SLIST MEM */
name|uint64_t
name|pkt_imem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB IFIFO */
name|uint64_t
name|pkt_pfm
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Front MEM */
name|uint64_t
name|pkt_pof
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB FIFO */
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_pop0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB Slist0 */
name|uint64_t
name|pkt_pop1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB Slist1 */
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA MEM 0 */
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA MEM 1 */
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA MEM 2 */
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA MEM 3 */
name|uint64_t
name|d4_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA MEM 4 */
name|uint64_t
name|ds_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA  Memory */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Pcie Store */
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Pcie Store */
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Pcie Store */
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Pcie Store */
name|uint64_t
name|d4_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA4 Pcie Store */
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P Order */
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N Order */
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C Order */
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P Order */
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N Order */
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C Order */
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM0 */
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM1 */
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif4
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d4_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ds_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d4_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pop1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pop0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_pof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pfm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_imem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_gim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_62
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pkt_rdf
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
struct|struct
name|cvmx_npei_bist_status_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|d0_mem0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Memory */
name|uint64_t
name|d1_mem1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Memory */
name|uint64_t
name|d2_mem2
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Memory */
name|uint64_t
name|d3_mem3
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Memory */
name|uint64_t
name|dr0_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Store */
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Memory */
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Memory */
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Memory */
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Memory */
name|uint64_t
name|dr1_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Store */
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Pcie Store */
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Pcie Store */
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Pcie Store */
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Pcie Store */
name|uint64_t
name|dr2_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Store */
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P Order */
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N Order */
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C Order */
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P Order */
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N Order */
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C Order */
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM0 */
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM1 */
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dr3_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Store */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dr3_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dr2_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dr1_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dr0_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_mem3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_mem2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_mem1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_mem0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_bist_status_cn52xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_bist_status_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pout_int_bstatus */
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_instr_mem_bstatus */
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pin_cnt_bstatus */
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_in_done_bstatus */
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT pcsr_slist_bstatus */
name|uint64_t
name|pkt_pout
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUT Count MEM */
name|uint64_t
name|pkt_imem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Instruction MEM */
name|uint64_t
name|pkt_cntm
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Count MEM */
name|uint64_t
name|pkt_ind
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Instruction Done MEM */
name|uint64_t
name|pkt_slm
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT SList MEM */
name|uint64_t
name|pkt_odf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Output Data FIFO */
name|uint64_t
name|pkt_oif
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Output INFO FIFO */
name|uint64_t
name|pkt_out
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Output FIFO */
name|uint64_t
name|pkt_i0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Instr0 */
name|uint64_t
name|pkt_i1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Instr1 */
name|uint64_t
name|pkt_s0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Slist0 */
name|uint64_t
name|pkt_s1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT Slist1 */
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Memory */
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Memory */
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Memory */
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Memory */
name|uint64_t
name|d4_mem
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA4 Memory */
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA0 Pcie Store */
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA1 Pcie Store */
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA2 Pcie Store */
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA3 Pcie Store */
name|uint64_t
name|d4_pst
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA4 Pcie Store */
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P Order */
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N Order */
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C Order */
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P Order */
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N Order */
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C Order */
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM0 */
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CSM1 */
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|dif4
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA Instr0 */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_co
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_no
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_po
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d4_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_pst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d4_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d3_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d2_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d1_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d0_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_s1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_s0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_i1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_i0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_out
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_oif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_odf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_slm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_ind
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_cntm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_imem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_pout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_sl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_id
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_cnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_im
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcsr_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_bist_status
name|cvmx_npei_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_bist_status2  *  * NPEI_BIST_STATUS2 = NPI's BIST Status Register2  *  * Results from BIST runs of NPEI's memories.  */
end_comment

begin_union
union|union
name|cvmx_npei_bist_status2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_bist_status2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|prd_tag
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA PCIE RD Tag MEM */
name|uint64_t
name|prd_st0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA PCIE RD state MEM 0 */
name|uint64_t
name|prd_st1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA PCIE RD state MEM 1 */
name|uint64_t
name|prd_err
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA PCIE RD ERR state MEM */
name|uint64_t
name|nrd_st
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA L2C RD state MEM */
name|uint64_t
name|nwe_st
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA L2C WR state MEM */
name|uint64_t
name|nwe_wr0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA L2C WR MEM 0 */
name|uint64_t
name|nwe_wr1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DMA L2C WR MEM 1 */
name|uint64_t
name|pkt_rd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for Inbound PKT MEM */
name|uint64_t
name|psc_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PSC TLP 0 MEM */
name|uint64_t
name|psc_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PSC TLP 1 MEM */
name|uint64_t
name|pkt_gd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB Gather Data FIFO */
name|uint64_t
name|pkt_gl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT_OUTB Gather List FIFO */
name|uint64_t
name|pkt_blk
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for PKT OUTB Blocked FIFO */
else|#
directive|else
name|uint64_t
name|pkt_blk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_gl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_gd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psc_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psc_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nwe_wr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nwe_wr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nwe_st
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nrd_st
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prd_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prd_st1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prd_st0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prd_tag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_bist_status2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_bist_status2_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_bist_status2
name|cvmx_npei_bist_status2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_ctl_port0  *  * NPEI_CTL_PORT0 = NPEI's Control Port 0  *  * Contains control for access for Port0  */
end_comment

begin_union
union|union
name|cvmx_npei_ctl_port0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_port0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional completions                                                          to the L2C from the PCIe.                                                          Set this for more conservative behavior. Clear                                                          this for more aggressive, higher-performance                                                          behavior */
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intd wire asserted. Before mapping. */
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intc wire asserted. Before mapping. */
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intb wire asserted. Before mapping. */
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Inta wire asserted. Before mapping. */
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTD to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTC to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTB to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTA to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Completion TLPS. */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Posted TLPS. */
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BAR2 is enable and will respond when                                                          clear '0' BAR2 access will cause UR responses. */
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
comment|/**< Value will be XORed with pci-address[37:36] to                                                          determine the endian swap mode. */
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
comment|/**< Value will be XORed with pcie-address[38] to                                                          determine the L2 cache attribute.                                                          Not cached in L2 if XOR result is 1 */
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional stores to                                                          the L2C from the PCIe.                                                          Most applications will not notice a difference, so                                                          should not set this bit. Setting the bit is more                                                          conservative on ordering, lower performance */
else|#
directive|else
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_ctl_port0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_ctl_port0
name|cvmx_npei_ctl_port0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_ctl_port1  *  * NPEI_CTL_PORT1 = NPEI's Control Port1  *  * Contains control for access for Port1  */
end_comment

begin_union
union|union
name|cvmx_npei_ctl_port1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_port1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional completions                                                          to the L2C from the PCIe.                                                          Set this for more conservative behavior. Clear                                                          this for more aggressive, higher-performance */
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intd wire asserted. Before mapping. */
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intc wire asserted. Before mapping. */
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intv wire asserted. Before mapping. */
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Inta wire asserted. Before mapping. */
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTD to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTC to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTB to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTA to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Completion TLPS. */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Posted TLPS. */
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BAR2 is enable and will respond when                                                          clear '0' BAR2 access will cause UR responses. */
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
comment|/**< Value will be XORed with pci-address[37:36] to                                                          determine the endian swap mode. */
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
comment|/**< Value will be XORed with pcie-address[38] to                                                          determine the L2 cache attribute.                                                          Not cached in L2 if XOR result is 1 */
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional stores to                                                          the L2C from the PCIe.                                                          Most applications will not notice a difference, so                                                          should not set this bit. Setting the bit is more                                                          conservative on ordering, lower performance */
else|#
directive|else
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_ctl_port1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_port1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_ctl_port1
name|cvmx_npei_ctl_port1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_ctl_status  *  * NPEI_CTL_STATUS = NPEI Control Status Register  *  * Contains control and status for NPEI. Writes to this register are not oSrdered with writes/reads to the PCIe Memory space.  * To ensure that a write has completed the user must read the register before making an access(i.e. PCIe memory space)  * that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_npei_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags avaiable for PCIe Port1.                                                          In RC mode 1 tag is needed for each outbound TLP                                                          that requires a CPL TLP. In Endpoint mode the                                                          number of tags required for a TLP request is                                                          1 per 64-bytes of CPL data + 1.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags avaiable for PCIe Port0.                                                          In RC mode 1 tag is needed for each outbound TLP                                                          that requires a CPL TLP. In Endpoint mode the                                                          number of tags required for a TLP request is                                                          1 per 64-bytes of CPL data + 1.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
comment|/**< The time x 0x10000 in core clocks to wait for a                                                          CPL to a CFG RD that does not carry a Retry Status.                                                          Until such time that the timeout occurs and Retry                                                          Status is received for a CFG RD, the Read CFG Read                                                          will be resent. A value of 0 disables retries and                                                          treats a CPL Retry as a CPL UR. */
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
comment|/**< When '0' forces "relative Q position" received                                                          from PKO to be zero, and replicates the back-                                                          pressure indication for the first ring attached                                                          to a PKO port across all the rings attached to a                                                          PKO port.  When '1' backpressure is on a per                                                          port/ring. */
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
comment|/**< Set when PCIe Core 0 request a link reset due to                                                          link down state. This bit is only reset on raw                                                          reset so it can be read for state to determine if                                                          a reset occured. Bit is cleared when a '1' is                                                          written to this field. */
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
comment|/**< PCIe switch arbitration mode. '0' == fixed priority                                                          NPEI, PCIe0, then PCIe1. '1' == round robin. */
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
comment|/**< Unused */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< Host mode */
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The chip revision. */
else|#
directive|else
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_ctl_status_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_status_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags avaiable for PCIe Port1.                                                          In RC mode 1 tag is needed for each outbound TLP                                                          that requires a CPL TLP. In Endpoint mode the                                                          number of tags required for a TLP request is                                                          1 per 64-bytes of CPL data + 1.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags avaiable for PCIe Port0.                                                          In RC mode 1 tag is needed for each outbound TLP                                                          that requires a CPL TLP. In Endpoint mode the                                                          number of tags required for a TLP request is                                                          1 per 64-bytes of CPL data + 1.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
comment|/**< The time x 0x10000 in core clocks to wait for a                                                          CPL to a CFG RD that does not carry a Retry Status.                                                          Until such time that the timeout occurs and Retry                                                          Status is received for a CFG RD, the Read CFG Read                                                          will be resent. A value of 0 disables retries and                                                          treats a CPL Retry as a CPL UR. */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
comment|/**< Set when PCIe Core 0 request a link reset due to                                                          link down state. This bit is only reset on raw                                                          reset so it can be read for state to determine if                                                          a reset occured. Bit is cleared when a '1' is                                                          written to this field. */
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
comment|/**< PCIe switch arbitration mode. '0' == fixed priority                                                          NPEI, PCIe0, then PCIe1. '1' == round robin. */
name|uint64_t
name|reserved_9_12
range|:
literal|4
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< Host mode */
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The chip revision. */
else|#
directive|else
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_12
range|:
literal|4
decl_stmt|;
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_ctl_status_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_status_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
comment|/**< Set when PCIe Core 0 request a link reset due to                                                          link down state. This bit is only reset on raw                                                          reset so it can be read for state to determine if                                                          a reset occured. Bit is cleared when a '1' is                                                          written to this field. */
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
comment|/**< PCIe switch arbitration mode. '0' == fixed priority                                                          NPEI, PCIe0, then PCIe1. '1' == round robin. */
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
comment|/**< Unused */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< Host mode */
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The chip revision. */
else|#
directive|else
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_ctl_status
name|cvmx_npei_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_ctl_status2  *  * NPEI_CTL_STATUS2 = NPEI's Control Status2 Register  *  * Contains control and status for NPEI.  * Writes to this register are not ordered with writes/reads to the PCI Memory space.  * To ensure that a write has completed the user must read the register before  * making an access(i.e. PCI memory space) that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_npei_ctl_status2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_ctl_status2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
comment|/**< Max Payload Size                                                                   0  = 128B                                                                   1  = 256B                                                          Note: PCIE*_CFG030[MPS] must be set to the same                                                                value for proper function. */
name|uint64_t
name|mrrs
range|:
literal|3
decl_stmt|;
comment|/**< Max Read Request Size                                                                  0 = 128B                                                                  1 = 256B                                                                  2 = 512B                                                                  3 = 1024B                                                                  4 = 2048B                                                                  5 = 4096B                                                          Note: This field must not exceed the desired                                                                max read request size. This means this field                                                                should not exceed PCIE*_CFG030[MRRS]. */
name|uint64_t
name|c1_w_flt
range|:
literal|1
decl_stmt|;
comment|/**< When '1' enables the window filter for reads and                                                          writes using the window registers.                                                          PCIE-Port1.                                                          Unfilter writes are:                                                          MIO,   SubId0                                                          MIO,   SubId7                                                          NPEI,  SubId0                                                          NPEI,  SubId7                                                          POW,   SubId7                                                          IPD,   SubId7                                                          USBN0, SubId7                                                          Unfiltered Reads are:                                                          MIO,   SubId0                                                          MIO,   SubId7                                                          NPEI,  SubId0                                                          NPEI,  SubId7                                                          POW,   SubId1                                                          POW,   SubId2                                                          POW,   SubId3                                                          POW,   SubId7                                                          IPD,   SubId7                                                          USBN0, SubId7 */
name|uint64_t
name|c0_w_flt
range|:
literal|1
decl_stmt|;
comment|/**< When '1' enables the window filter for reads and                                                          writes using the window registers.                                                          PCIE-Port0.                                                          Unfilter writes are:                                                          MIO,   SubId0                                                          MIO,   SubId7                                                          NPEI,  SubId0                                                          NPEI,  SubId7                                                          POW,   SubId7                                                          IPD,   SubId7                                                          USBN0, SubId7                                                          Unfiltered Reads are:                                                          MIO,   SubId0                                                          MIO,   SubId7                                                          NPEI,  SubId0                                                          NPEI,  SubId7                                                          POW,   SubId1                                                          POW,   SubId2                                                          POW,   SubId3                                                          POW,   SubId7                                                          IPD,   SubId7                                                          USBN0, SubId7 */
name|uint64_t
name|c1_b1_s
range|:
literal|3
decl_stmt|;
comment|/**< Pcie-Port1, Bar1 Size. 1 == 64MB, 2 == 128MB,                                                          3 == 256MB, 4 == 512MB, 5 == 1024MB, 6 == 2048MB,                                                          0 and 7 are reserved. */
name|uint64_t
name|c0_b1_s
range|:
literal|3
decl_stmt|;
comment|/**< Pcie-Port0, Bar1 Size. 1 == 64MB, 2 == 128MB,                                                          3 == 256MB, 4 == 512MB, 5 == 1024MB, 6 == 2048MB,                                                          0 and 7 are reserved. */
name|uint64_t
name|c1_wi_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to the Window                                                          Registers from the PCIe-Port1. */
name|uint64_t
name|c1_b0_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access from PCIe-Port1 to                                                          BAR-0 address offsets: Less Than 0x270,                                                          Greater than 0x270 AND less than 0x0520, 0x3BC0,                                                          0x3CD0. */
name|uint64_t
name|c0_wi_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to the Window                                                          Registers from the PCIe-Port0. */
name|uint64_t
name|c0_b0_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access from PCIe-Port0 to                                                          BAR-0 address offsets: Less Than 0x270,                                                          Greater than 0x270 AND less than 0x0520, 0x3BC0,                                                          0x3CD0. */
else|#
directive|else
name|uint64_t
name|c0_b0_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wi_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_b0_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wi_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_b1_s
range|:
literal|3
decl_stmt|;
name|uint64_t
name|c1_b1_s
range|:
literal|3
decl_stmt|;
name|uint64_t
name|c0_w_flt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_w_flt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrrs
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_ctl_status2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_status2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_ctl_status2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_ctl_status2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_ctl_status2
name|cvmx_npei_ctl_status2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_data_out_cnt  *  * NPEI_DATA_OUT_CNT = NPEI DATA OUT COUNT  *  * The EXEC data out fifo-count and the data unload counter.  */
end_comment

begin_union
union|union
name|cvmx_npei_data_out_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_data_out_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|p1_ucnt
range|:
literal|16
decl_stmt|;
comment|/**< PCIE-Port1 Fifo Unload Count. This counter is                                                          incremented by '1' every time a word is removed                                                          from the Data Out FIFO, whose count is shown in                                                          P0_FCNT. */
name|uint64_t
name|p1_fcnt
range|:
literal|6
decl_stmt|;
comment|/**< PCIE-Port1 Data Out Fifo Count. Number of address                                                          data words to be sent out the PCIe port presently                                                          buffered in the FIFO. */
name|uint64_t
name|p0_ucnt
range|:
literal|16
decl_stmt|;
comment|/**< PCIE-Port0 Fifo Unload Count. This counter is                                                          incremented by '1' every time a word is removed                                                          from the Data Out FIFO, whose count is shown in                                                          P0_FCNT. */
name|uint64_t
name|p0_fcnt
range|:
literal|6
decl_stmt|;
comment|/**< PCIE-Port0 Data Out Fifo Count. Number of address                                                          data words to be sent out the PCIe port presently                                                          buffered in the FIFO. */
else|#
directive|else
name|uint64_t
name|p0_fcnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p0_ucnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p1_fcnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p1_ucnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_data_out_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_data_out_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_data_out_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_data_out_cnt_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_data_out_cnt
name|cvmx_npei_data_out_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dbg_data  *  * NPEI_DBG_DATA = NPEI Debug Data Register  *  * Value returned on the debug-data lines from the RSLs  */
end_comment

begin_union
union|union
name|cvmx_npei_dbg_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dbg_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal for PCIe port 0 */
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
comment|/**< Sets the QLM1 frequency                                                          0=1.25 Gbaud                                                          1=2.5 Gbaud                                                          2=3.125 Gbaud                                                          3=3.75 Gbaud */
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
comment|/**< PLL_MUL pins sampled at DCOK assertion                                                          Core frequency = 50MHz*C_MUL */
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
comment|/**< Allows changes in the external pins to set the                                                          debug select value. */
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
comment|/**< Value on the debug data lines. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npei_dbg_data_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|qlm0_link_width
range|:
literal|1
decl_stmt|;
comment|/**< Link width of PCIe port 0                                                          0 = PCIe port 0 is 2 lanes,                                                              2 lane PCIe port 1 exists                                                          1 = PCIe port 0 is 4 lanes,                                                              PCIe port 1 does not exist */
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal for PCIe port 0 */
name|uint64_t
name|qlm1_mode
range|:
literal|2
decl_stmt|;
comment|/**< Sets the QLM1 Mode                                                          0=Reserved                                                          1=XAUI                                                          2=SGMII                                                          3=PICMG */
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
comment|/**< Sets the QLM1 frequency                                                          0=1.25 Gbaud                                                          1=2.5 Gbaud                                                          2=3.125 Gbaud                                                          3=3.75 Gbaud */
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
comment|/**< PLL_MUL pins sampled at DCOK assertion                                                          Core frequency = 50MHz*C_MUL */
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
comment|/**< Allows changes in the external pins to set the                                                          debug select value. */
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
comment|/**< Value on the debug data lines. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm1_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qlm0_link_width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_npei_dbg_data_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_npei_dbg_data_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|qlm2_rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal for PCIe port 1 */
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal for PCIe port 0 */
name|uint64_t
name|qlm3_spd
range|:
literal|2
decl_stmt|;
comment|/**< Sets the QLM3 frequency                                                          0=1.25 Gbaud                                                          1=2.5 Gbaud                                                          2=3.125 Gbaud                                                          3=3.75 Gbaud */
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
comment|/**< Sets the QLM1 frequency                                                          0=1.25 Gbaud                                                          1=2.5 Gbaud                                                          2=3.125 Gbaud                                                          3=3.75 Gbaud */
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
comment|/**< PLL_MUL pins sampled at DCOK assertion                                                          Core frequency = 50MHz*C_MUL */
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
comment|/**< Allows changes in the external pins to set the                                                          debug select value. */
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
comment|/**< Value on the debug data lines. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm3_spd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm0_rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qlm2_rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_npei_dbg_data_cn56xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dbg_data
name|cvmx_npei_dbg_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dbg_select  *  * NPEI_DBG_SELECT = Debug Select Register  *  * Contains the debug select value last written to the RSLs.  */
end_comment

begin_union
union|union
name|cvmx_npei_dbg_select
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dbg_select_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dbg_sel
range|:
literal|16
decl_stmt|;
comment|/**< When this register is written its value is sent to                                                          all RSLs. */
else|#
directive|else
name|uint64_t
name|dbg_sel
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dbg_select_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dbg_select_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dbg_select_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dbg_select_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dbg_select
name|cvmx_npei_dbg_select_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma#_counts  *  * NPEI_DMA[0..4]_COUNTS = DMA Instruction Counts  *  * Values for determing the number of instructions for DMA[0..4] in the NPEI.  */
end_comment

begin_union
union|union
name|cvmx_npei_dmax_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dmax_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of words in the Instruction FIFO. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Number of available words of Instructions to read. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dmax_counts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_counts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dmax_counts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_counts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dmax_counts
name|cvmx_npei_dmax_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma#_dbell  *  * NPEI_DMA_DBELL[0..4] = DMA Door Bell  *  * The door bell register for DMA[0..4] queue.  */
end_comment

begin_union
union|union
name|cvmx_npei_dmax_dbell
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_npei_dmax_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|dbell
range|:
literal|16
decl_stmt|;
comment|/**< The value written to this register is added to the                                                          number of 8byte words to be read and processes for                                                          the low priority dma queue. */
else|#
directive|else
name|uint32_t
name|dbell
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dmax_dbell_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_dbell_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dmax_dbell_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_dbell_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dmax_dbell
name|cvmx_npei_dmax_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma#_ibuff_saddr  *  * NPEI_DMA[0..4]_IBUFF_SADDR = DMA Instruction Buffer Starting Address  *  * The address to start reading Instructions from for DMA[0..4].  */
end_comment

begin_union
union|union
name|cvmx_npei_dmax_ibuff_saddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dmax_ibuff_saddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine IDLE state */
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
comment|/**< The 128 byte aligned starting address to read the                                                          first instruction. SADDR is address bit 35:7 of the                                                          first instructions address. */
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dmax_ibuff_saddr_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_dmax_ibuff_saddr_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
comment|/**< The 128 byte aligned starting address to read the                                                          first instruction. SADDR is address bit 35:7 of the                                                          first instructions address. */
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_dmax_ibuff_saddr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_ibuff_saddr_cn52xxp1
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dmax_ibuff_saddr
name|cvmx_npei_dmax_ibuff_saddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma#_naddr  *  * NPEI_DMA[0..4]_NADDR = DMA Next Ichunk Address  *  * Place NPEI will read the next Ichunk data from. This is valid when state is 0  */
end_comment

begin_union
union|union
name|cvmx_npei_dmax_naddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dmax_naddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< The next L2C address to read DMA# instructions                                                          from. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dmax_naddr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_naddr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dmax_naddr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dmax_naddr_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dmax_naddr
name|cvmx_npei_dmax_naddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma0_int_level  *  * NPEI_DMA0_INT_LEVEL = NPEI DMA0 Interrupt Level  *  * Thresholds for DMA count and timer interrupts for DMA0.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma0_int_level
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma0_int_level_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Whenever the DMA_CNT0 timer exceeds                                                          this value, NPEI_INT_SUM[DTIME0] is set.                                                          The DMA_CNT0 timer increments every core clock                                                          whenever NPEI_DMA_CNTS[DMA0]!=0, and is cleared                                                          when NPEI_INT_SUM[DTIME0] is written with one. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA0] exceeds this value,                                                          NPEI_INT_SUM[DCNT0] is set. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma0_int_level_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dma0_int_level_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dma0_int_level_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dma0_int_level_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma0_int_level
name|cvmx_npei_dma0_int_level_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma1_int_level  *  * NPEI_DMA1_INT_LEVEL = NPEI DMA1 Interrupt Level  *  * Thresholds for DMA count and timer interrupts for DMA1.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma1_int_level
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma1_int_level_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Whenever the DMA_CNT1 timer exceeds                                                          this value, NPEI_INT_SUM[DTIME1] is set.                                                          The DMA_CNT1 timer increments every core clock                                                          whenever NPEI_DMA_CNTS[DMA1]!=0, and is cleared                                                          when NPEI_INT_SUM[DTIME1] is written with one. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA1] exceeds this value,                                                          NPEI_INT_SUM[DCNT1] is set. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma1_int_level_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dma1_int_level_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dma1_int_level_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dma1_int_level_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma1_int_level
name|cvmx_npei_dma1_int_level_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_cnts  *  * NPEI_DMA_CNTS = NPEI DMA Count  *  * The DMA Count values for DMA0 and DMA1.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dma1
range|:
literal|32
decl_stmt|;
comment|/**< The DMA counter 1.                                                          Writing this field will cause the written value to                                                          be subtracted from DMA1. SW should use a 4-byte                                                          write to access this field so as not to change the                                                          value of other fields in this register.                                                          HW will optionally increment this field after                                                          it completes an OUTBOUND or EXTERNAL-ONLY DMA                                                          instruction. These increments may cause interrupts.                                                          Refer to NPEI_DMA1_INT_LEVEL and                                                          NPEI_INT_SUM[DCNT1,DTIME1]. */
name|uint64_t
name|dma0
range|:
literal|32
decl_stmt|;
comment|/**< The DMA counter 0.                                                          Writing this field will cause the written value to                                                          be subtracted from DMA0. SW should use a 4-byte                                                          write to access this field so as not to change the                                                          value of other fields in this register.                                                          HW will optionally increment this field after                                                          it completes an OUTBOUND or EXTERNAL-ONLY DMA                                                          instruction. These increments may cause interrupts.                                                          Refer to NPEI_DMA0_INT_LEVEL and                                                          NPEI_INT_SUM[DCNT0,DTIME0]. */
else|#
directive|else
name|uint64_t
name|dma0
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dma1
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_cnts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dma_cnts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dma_cnts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_dma_cnts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_cnts
name|cvmx_npei_dma_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_control  *  * NPEI_DMA_CONTROL = DMA Control Register  *  * Controls operation of the DMA IN/OUT.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|p_32b_m
range|:
literal|1
decl_stmt|;
comment|/**< DMA PCIE 32-bit word read disable bit                                                          When 0, enable the feature */
name|uint64_t
name|dma4_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the NPEI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the NPEI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are freed                                                          this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma transfer                                                          will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          '1' use pointer values for address and register                                                          values for RO, ES, and NS, '0' use register                                                          values for address and pointer values for                                                          RO, ES, and NS. */
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in words of the DMA Instruction Chunk.                                                          This value should only be written once. After                                                          writing this value a new value will not be                                                          recognized until the end of the DMA I-Chunk is                                                          reached. */
else|#
directive|else
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_32b_m
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_control_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_dma_control_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the NPEI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the NPEI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are freed                                                          this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma transfer                                                          will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          '1' use pointer values for address and register                                                          values for RO, ES, and NS, '0' use register                                                          values for address and pointer values for                                                          RO, ES, and NS. */
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in words of the DMA Instruction Chunk.                                                          This value should only be written once. After                                                          writing this value a new value will not be                                                          recognized until the end of the DMA I-Chunk is                                                          reached. */
else|#
directive|else
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_dma_control_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_dma_control_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|dma4_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
comment|/**< DMA# enable. Enables the operation of the DMA                                                          engine. After being enabled a DMA engine should not                                                          be dis-abled while processing instructions. */
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the NPEI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the NPEI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are freed                                                          this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma transfer                                                          will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          '1' use pointer values for address and register                                                          values for RO, ES, and NS, '0' use register                                                          values for address and pointer values for                                                          RO, ES, and NS. */
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in words of the DMA Instruction Chunk.                                                          This value should only be written once. After                                                          writing this value a new value will not be                                                          recognized until the end of the DMA I-Chunk is                                                          reached. */
else|#
directive|else
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_control
name|cvmx_npei_dma_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_pcie_req_num  *  * NPEI_DMA_PCIE_REQ_NUM = NPEI DMA PCIE Outstanding Read Request Number  *  * Outstanding PCIE read request number for DMAs and Packet, maximum number is 16  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_pcie_req_num
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_pcie_req_num_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dma_arb
range|:
literal|1
decl_stmt|;
comment|/**< DMA_PKT Read Request Arbitration                                                          - 1: DMA0-4 and PKT are round robin. i.e.                                                              DMA0-DMA1-DMA2-DMA3-DMA4-PKT...                                                          - 0: DMA0-4 are round robin, pkt gets selected                                                              half the time. i.e.                                                              DMA0-PKT-DMA1-PKT-DMA2-PKT-DMA3-PKT-DMA4-PKT... */
name|uint64_t
name|reserved_53_62
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pkt_cnt
range|:
literal|5
decl_stmt|;
comment|/**< PKT outstanding PCIE Read Request Number for each                                                          PCIe port                                                          When PKT_CNT=x, for each PCIe port, the number                                                          of outstanding PCIe memory space reads by the PCIe                                                          packet input/output will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma4_cnt
range|:
literal|5
decl_stmt|;
comment|/**< DMA4 outstanding PCIE Read Request Number                                                          When DMA4_CNT=x, the number of outstanding PCIe                                                          memory space reads by the PCIe DMA engine 4                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma3_cnt
range|:
literal|5
decl_stmt|;
comment|/**< DMA3 outstanding PCIE Read Request Number                                                          When DMA3_CNT=x, the number of outstanding PCIe                                                          memory space reads by the PCIe DMA engine 3                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma2_cnt
range|:
literal|5
decl_stmt|;
comment|/**< DMA2 outstanding PCIE Read Request Number                                                          When DMA2_CNT=x, the number of outstanding PCIe                                                          memory space reads by the PCIe DMA engine 2                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma1_cnt
range|:
literal|5
decl_stmt|;
comment|/**< DMA1 outstanding PCIE Read Request Number                                                          When DMA1_CNT=x, the number of outstanding PCIe                                                          memory space reads by the PCIe DMA engine 1                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma0_cnt
range|:
literal|5
decl_stmt|;
comment|/**< DMA0 outstanding PCIE Read Request Number                                                          When DMA0_CNT=x, the number of outstanding PCIe                                                          memory space reads by the PCIe DMA engine 0                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma_cnt
range|:
literal|5
decl_stmt|;
comment|/**< Total outstanding PCIE Read Request Number for each                                                          PCIe port                                                          When DMA_CNT=x, for each PCIe port, the total                                                          number of outstanding PCIe memory space reads                                                          by the PCIe DMA engines and packet input/output                                                          will not exceed x.                                                          Valid Number is between 1 and 16 */
else|#
directive|else
name|uint64_t
name|dma_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma0_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma1_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma2_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma3_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dma4_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pkt_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_53_62
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dma_arb
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_pcie_req_num_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_dma_pcie_req_num_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_pcie_req_num
name|cvmx_npei_dma_pcie_req_num_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state1  *  * NPEI_DMA_STATE1 = NPI's DMA State 1  *  * Results from DMA state register 1  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|d4_dwe
range|:
literal|8
decl_stmt|;
comment|/**< DMA4 PICe Write State */
name|uint64_t
name|d3_dwe
range|:
literal|8
decl_stmt|;
comment|/**< DMA3 PICe Write State */
name|uint64_t
name|d2_dwe
range|:
literal|8
decl_stmt|;
comment|/**< DMA2 PICe Write State */
name|uint64_t
name|d1_dwe
range|:
literal|8
decl_stmt|;
comment|/**< DMA1 PICe Write State */
name|uint64_t
name|d0_dwe
range|:
literal|8
decl_stmt|;
comment|/**< DMA0 PICe Write State */
else|#
directive|else
name|uint64_t
name|d0_dwe
range|:
literal|8
decl_stmt|;
name|uint64_t
name|d1_dwe
range|:
literal|8
decl_stmt|;
name|uint64_t
name|d2_dwe
range|:
literal|8
decl_stmt|;
name|uint64_t
name|d3_dwe
range|:
literal|8
decl_stmt|;
name|uint64_t
name|d4_dwe
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_state1_s
name|cn52xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state1
name|cvmx_npei_dma_state1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state1_p1  *  * NPEI_DMA_STATE1_P1 = NPEI DMA Request and Instruction State  *  * DMA engine Debug information.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state1_p1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state1_p1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|d0_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 0 dif instruction read state */
name|uint64_t
name|d1_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 1 dif instruction read state */
name|uint64_t
name|d2_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 2 dif instruction read state */
name|uint64_t
name|d3_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 3 dif instruction read state */
name|uint64_t
name|d4_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 4 dif instruction read state */
name|uint64_t
name|d0_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 0 request data state */
name|uint64_t
name|d1_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 1 request data state */
name|uint64_t
name|d2_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 2 request data state */
name|uint64_t
name|d3_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 3 request data state */
name|uint64_t
name|d4_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 4 request data state */
else|#
directive|else
name|uint64_t
name|d4_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d3_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d2_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d1_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d0_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d4_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d3_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d2_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d1_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d0_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npei_dma_state1_p1_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|d0_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 0 dif instruction read state */
name|uint64_t
name|d1_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 1 dif instruction read state */
name|uint64_t
name|d2_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 2 dif instruction read state */
name|uint64_t
name|d3_difst
range|:
literal|7
decl_stmt|;
comment|/**< DMA engine 3 dif instruction read state */
name|uint64_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d0_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 0 request data state */
name|uint64_t
name|d1_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 1 request data state */
name|uint64_t
name|d2_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 2 request data state */
name|uint64_t
name|d3_reqst
range|:
literal|5
decl_stmt|;
comment|/**< DMA engine 3 request data state */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d3_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d2_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d1_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|d0_reqst
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d3_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d2_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d1_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|d0_difst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_dma_state1_p1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state1_p1
name|cvmx_npei_dma_state1_p1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state2  *  * NPEI_DMA_STATE2 = NPI's DMA State 2  *  * Results from DMA state register 2  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|ndwe
range|:
literal|4
decl_stmt|;
comment|/**< DMA L2C Write State */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ndre
range|:
literal|5
decl_stmt|;
comment|/**< DMA L2C Read State */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|prd
range|:
literal|10
decl_stmt|;
comment|/**< DMA PICe Read State */
else|#
directive|else
name|uint64_t
name|prd
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ndre
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ndwe
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_state2_s
name|cn52xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state2
name|cvmx_npei_dma_state2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state2_p1  *  * NPEI_DMA_STATE2_P1 = NPEI DMA Instruction Fetch State  *  * DMA engine Debug information.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state2_p1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state2_p1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
name|uint64_t
name|d0_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 0 dif instruction fetch state */
name|uint64_t
name|d1_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 1 dif instruction fetch state */
name|uint64_t
name|d2_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 2 dif instruction fetch state */
name|uint64_t
name|d3_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 3 dif instruction fetch state */
name|uint64_t
name|d4_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 4 dif instruction fetch state */
else|#
directive|else
name|uint64_t
name|d4_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d3_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d2_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d1_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d0_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npei_dma_state2_p1_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
name|uint64_t
name|d0_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 0 dif instruction fetch state */
name|uint64_t
name|d1_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 1 dif instruction fetch state */
name|uint64_t
name|d2_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 2 dif instruction fetch state */
name|uint64_t
name|d3_dffst
range|:
literal|9
decl_stmt|;
comment|/**< DMA engine 3 dif instruction fetch state */
name|uint64_t
name|reserved_0_8
range|:
literal|9
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_8
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d3_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d2_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d1_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|d0_dffst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_dma_state2_p1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state2_p1
name|cvmx_npei_dma_state2_p1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state3_p1  *  * NPEI_DMA_STATE3_P1 = NPEI DMA DRE State  *  * DMA engine Debug information.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state3_p1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state3_p1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|d0_drest
range|:
literal|15
decl_stmt|;
comment|/**< DMA engine 0 dre state */
name|uint64_t
name|d1_drest
range|:
literal|15
decl_stmt|;
comment|/**< DMA engine 1 dre state */
name|uint64_t
name|d2_drest
range|:
literal|15
decl_stmt|;
comment|/**< DMA engine 2 dre state */
name|uint64_t
name|d3_drest
range|:
literal|15
decl_stmt|;
comment|/**< DMA engine 3 dre state */
else|#
directive|else
name|uint64_t
name|d3_drest
range|:
literal|15
decl_stmt|;
name|uint64_t
name|d2_drest
range|:
literal|15
decl_stmt|;
name|uint64_t
name|d1_drest
range|:
literal|15
decl_stmt|;
name|uint64_t
name|d0_drest
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_state3_p1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dma_state3_p1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state3_p1
name|cvmx_npei_dma_state3_p1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state4_p1  *  * NPEI_DMA_STATE4_P1 = NPEI DMA DWE State  *  * DMA engine Debug information.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state4_p1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state4_p1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|d0_dwest
range|:
literal|13
decl_stmt|;
comment|/**< DMA engine 0 dwe state */
name|uint64_t
name|d1_dwest
range|:
literal|13
decl_stmt|;
comment|/**< DMA engine 1 dwe state */
name|uint64_t
name|d2_dwest
range|:
literal|13
decl_stmt|;
comment|/**< DMA engine 2 dwe state */
name|uint64_t
name|d3_dwest
range|:
literal|13
decl_stmt|;
comment|/**< DMA engine 3 dwe state */
else|#
directive|else
name|uint64_t
name|d3_dwest
range|:
literal|13
decl_stmt|;
name|uint64_t
name|d2_dwest
range|:
literal|13
decl_stmt|;
name|uint64_t
name|d1_dwest
range|:
literal|13
decl_stmt|;
name|uint64_t
name|d0_dwest
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_state4_p1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_dma_state4_p1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state4_p1
name|cvmx_npei_dma_state4_p1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_dma_state5_p1  *  * NPEI_DMA_STATE5_P1 = NPEI DMA DWE and DRE State  *  * DMA engine Debug information.  */
end_comment

begin_union
union|union
name|cvmx_npei_dma_state5_p1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_dma_state5_p1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|d4_drest
range|:
literal|15
decl_stmt|;
comment|/**< DMA engine 4 dre state */
name|uint64_t
name|d4_dwest
range|:
literal|13
decl_stmt|;
comment|/**< DMA engine 4 dwe state */
else|#
directive|else
name|uint64_t
name|d4_dwest
range|:
literal|13
decl_stmt|;
name|uint64_t
name|d4_drest
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_dma_state5_p1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_dma_state5_p1
name|cvmx_npei_dma_state5_p1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_a_enb  *  * NPEI_INTERRUPT_A_ENB = NPI's Interrupt A Enable Register  *  * Used to allow the generation of interrupts (MSI/INTA) to the PCIe CoresUsed to enable the various interrupting conditions of NPEI  */
end_comment

begin_union
union|union
name|cvmx_npei_int_a_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[7] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[6] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_a_enb_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_enb_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_a_enb_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_a_enb
name|cvmx_npei_int_a_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_a_enb2  *  * NPEI_INTERRUPT_A_ENB2 = NPEI's Interrupt A Enable2 Register  *  * Used to enable the various interrupting conditions of NPEI  */
end_comment

begin_union
union|union
name|cvmx_npei_int_a_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[7] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[6] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_a_enb2_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_enb2_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_A_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_a_enb2_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_a_enb2
name|cvmx_npei_int_a_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_a_sum  *  * NPEI_INTERRUPT_A_SUM = NPI Interrupt A Summary Register  *  * Set when an interrupt condition occurs, write '1' to clear. When an interrupt bitin this register is set and  * the cooresponding bit in the NPEI_INT_A_ENB register is set, then NPEI_INT_SUM[61] will be set.  */
end_comment

begin_union
union|union
name|cvmx_npei_int_a_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when PKO sends packet data with the error bit                                                          set. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet input count has exceeded the WMARK.                                                          See NPEI_PKT_IN_BP */
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< PCIe port 1 received a read lock. */
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
comment|/**< PCIe port 0 received a read lock. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet gather list                                                          read this bit is set. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet data read                                                          this bit is set. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet scatter                                                          pointer pair this bit is set. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet instruction                                                          this bit is set. */
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Set each time any PCIe DMA engine recieves a UR/CA                                                          response from PCIe Port 1 */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Set each time any PCIe DMA engine recieves a UR/CA                                                          response from PCIe Port 0 */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_a_sum_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_a_sum_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Set each time any PCIe DMA engine recieves a UR/CA                                                          response from PCIe Port 1 */
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
comment|/**< Set each time any PCIe DMA engine recieves a UR/CA                                                          response from PCIe Port 0 */
else|#
directive|else
name|uint64_t
name|dma0_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_a_sum_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_a_sum
name|cvmx_npei_int_a_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_enb  *  * NPEI_INTERRUPT_ENB = NPI's Interrupt Enable Register  *  * Used to allow the generation of interrupts (MSI/INTA) to the PCIe CoresUsed to enable the various interrupting conditions of NPI  */
end_comment

begin_union
union|union
name|cvmx_npei_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[63] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[61] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[60] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[59] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[58] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[57] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[56] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[55] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[54] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[53] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[52] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[51] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[50] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[49] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[48] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[47] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[46] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[45] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[44] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[43] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[42] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[41] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[40] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[39] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[38] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[37] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[36] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[35] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[34] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[33] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[32] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[31] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[30] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[29] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[28] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[27] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[26] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[25] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[24] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[23] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[22] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[21] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[20] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[19] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[18] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[7] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[6] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_enb_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[63] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[61] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[60] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[59] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[58] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[57] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[56] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[55] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[54] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[53] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[52] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[51] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[50] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[49] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[48] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[47] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[46] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[45] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[44] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[43] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[42] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[41] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[40] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[39] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[38] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[37] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[36] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[35] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[34] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[33] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[32] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[31] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[30] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[29] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[28] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[27] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[26] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[25] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[24] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[23] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[22] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[21] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[20] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[19] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[18] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[7] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[6] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_enb_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[63] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_61_62
range|:
literal|2
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[60] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[59] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[58] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[57] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[56] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[55] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[54] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[53] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[52] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[51] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[50] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[49] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[48] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[47] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[46] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[45] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[44] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[43] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[42] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[41] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[40] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[39] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[38] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[37] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[36] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[35] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[34] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[33] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[32] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[31] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[30] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[28] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[26] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[25] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[24] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[23] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[21] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[19] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[18] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[7] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[6] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[1] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_62
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_enb
name|cvmx_npei_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_enb2  *  * NPEI_INTERRUPT_ENB2 = NPI's Interrupt Enable2 Register  *  * Used to enable the various interrupting conditions of NPI  */
end_comment

begin_union
union|union
name|cvmx_npei_int_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[61] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[60] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[59] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[58] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[57] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[56] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[55] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[54] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[53] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[52] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[51] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[50] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[49] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[48] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[47] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[46] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[45] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[44] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[43] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[42] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[41] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[40] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[39] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[38] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[37] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[36] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[35] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[34] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[33] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[32] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[31] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[30] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[29] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[28] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[27] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[26] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[25] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[24] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[23] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[22] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[21] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[20] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[19] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[18] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[17] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[16] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[7] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[6] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[1] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_UM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_enb2_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb2_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[61] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[60] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[59] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[58] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[57] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[56] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[55] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[54] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[53] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[52] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[51] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[50] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[49] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[48] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[47] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[46] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[45] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[44] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[43] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[42] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[41] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[40] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[39] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[38] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[37] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[36] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[35] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[34] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[33] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[32] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[31] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[30] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[29] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[28] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[27] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[26] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[25] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[24] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[23] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[22] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[21] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[20] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[19] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[18] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[17] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[16] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[7] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[6] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[1] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM2[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_enb2_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_enb2_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[60] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[59] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[58] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[57] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[56] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[55] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[54] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[53] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[52] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[51] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[50] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[49] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[48] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[47] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[46] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[45] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[44] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[43] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[42] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[41] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[40] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[39] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[38] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[37] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[36] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[35] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[34] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[33] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[32] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[31] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[30] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[28] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[26] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[25] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[24] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[23] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[21] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[19] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[18] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[17] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[16] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[7] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[6] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_SUM[1] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPEI_INT_UM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_enb2
name|cvmx_npei_int_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_info  *  * NPEI_INT_INFO = NPI Interrupt Information  *  * Contains information about some of the interrupt condition that can occur in the NPEI_INTERRUPT_SUM register.  */
end_comment

begin_union
union|union
name|cvmx_npei_int_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|6
decl_stmt|;
comment|/**< Field set when the NPEI_INTERRUPT_SUM[PIDBOF] bit                                                          is set. This field when set will not change again                                                          unitl NPEI_INTERRUPT_SUM[PIDBOF] is cleared. */
name|uint64_t
name|psldbof
range|:
literal|6
decl_stmt|;
comment|/**< Field set when the NPEI_INTERRUPT_SUM[PSLDBOF] bit                                                          is set. This field when set will not change again                                                          unitl NPEI_INTERRUPT_SUM[PSLDBOF] is cleared. */
else|#
directive|else
name|uint64_t
name|psldbof
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_info_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_int_info_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_int_info_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_info
name|cvmx_npei_int_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_sum  *  * NPEI_INTERRUPT_SUM = NPI Interrupt Summary Register  *  * Set when an interrupt condition occurs, write '1' to clear.  *  * HACK: These used to exist, how are TO handled?  *<3>     PO0_2SML R/W1C    0x0         0         The packet being sent out on Port0 is smaller          $R     NS  *                                                            than the NPI_BUFF_SIZE_OUTPUT0[ISIZE] field.  *<7>     I0_RTOUT R/W1C    0x0         0         Port-0 had a read timeout while attempting to          $R     NS  *                                                 read instructions.  *<15>    P0_RTOUT R/W1C    0x0         0         Port-0 had a read timeout while attempting to          $R     NS  *                                                 read packet data.  *<23>    G0_RTOUT R/W1C    0x0         0         Port-0 had a read timeout while attempting to          $R     NS  *                                                 read a gather list.  *<31>    P0_PTOUT R/W1C    0x0         0         Port-0 output had a read timeout on a DATA/INFO         $R     NS  *                                                 pair.  */
end_comment

begin_union
union|union
name|cvmx_npei_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Set when a bit in the NPEI_INT_A_SUM register and                                                          the cooresponding bit in the NPEI_INT_A_ENB                                                          register is set. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link1 down status. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link0 down status. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC1_DBG_INFO register has a bit                                                          set and its cooresponding PESC1_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC0_DBG_INFO register has a bit                                                          set and its cooresponding PESC0_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 1 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC1_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 1. (cfg_pme_int) */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 1. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS when Retries were disabled. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 1. (cfg_sys_err_rc) */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were enabled. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 1. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 0 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC0_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 0. (cfg_pme_int) */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 0. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS when Retries were disabled. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 0. (cfg_sys_err_rc) */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were enabled. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 0 (cfg_aer_rc_err_int). */
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Packet Timer has an interrupt. Which rings can                                                          be found in NPEI_PKT_TIME_INT. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Packet Counter has an interrupt. Which rings can                                                          be found in NPEI_PKT_CNT_INT. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflowed. Which                                                          doorbell can be found in NPEI_INT_INFO[PIDBOF] */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflowed. Which                                                          doorbell can be found in NPEI_INT_INFO[PSLDBOF] */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA1] is not 0, the                                                          DMA_CNT1 timer increments every core clock. When                                                          DMA_CNT1 timer exceeds NPEI_DMA1_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT1 timer. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA0] is not 0, the                                                          DMA_CNT0 timer increments every core clock. When                                                          DMA_CNT0 timer exceeds NPEI_DMA0_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT0 timer. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA1] was/is                                                          greater than NPEI_DMA1_INT_LEVEL[CNT]. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA0] was/is                                                          greater than NPEI_DMA0_INT_LEVEL[CNT]. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA4 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA3 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA2 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA1 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< RML write did not get commit in 0xffff core clocks. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< RML read did not return data in 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_sum_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_sum_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Set when a bit in the NPEI_INT_A_SUM register and                                                          the cooresponding bit in the NPEI_INT_A_ENB                                                          register is set. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link1 down status. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link0 down status. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC1_DBG_INFO register has a bit                                                          set and its cooresponding PESC1_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC0_DBG_INFO register has a bit                                                          set and its cooresponding PESC0_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 1 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC1_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 1. (cfg_pme_int) */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 1. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS when Retries were disabled. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 1. (cfg_sys_err_rc) */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were enabled. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 1. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 0 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC0_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 0. (cfg_pme_int) */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 0. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS when Retries were disabled. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 0. (cfg_sys_err_rc) */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were enabled. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 0 (cfg_aer_rc_err_int). */
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA1] is not 0, the                                                          DMA_CNT1 timer increments every core clock. When                                                          DMA_CNT1 timer exceeds NPEI_DMA1_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT1 timer. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA0] is not 0, the                                                          DMA_CNT0 timer increments every core clock. When                                                          DMA_CNT0 timer exceeds NPEI_DMA0_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT0 timer. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA1] was/is                                                          greater than NPEI_DMA1_INT_LEVEL[CNT]. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA0] was/is                                                          greater than NPEI_DMA0_INT_LEVEL[CNT]. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA3 doorbell count overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA2 doorbell count overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA1 doorbell count overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 doorbell count overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< RML write did not get commit in 0xffff core clocks. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< RML read did not return data in 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_npei_int_sum_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_npei_int_sum_cn56xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO. */
name|uint64_t
name|reserved_61_62
range|:
literal|2
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link1 down status. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Reset request due to link0 down status. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC1_DBG_INFO register has a bit                                                          set and its cooresponding PESC1_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PESC0_DBG_INFO register has a bit                                                          set and its cooresponding PESC0_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core1. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for filtered window                                                          register. Core0. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 1. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 1. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 1. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 1. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 1. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for unknown Bar.                                                          Core 0. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register.                                                          Core 0. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar2.                                                          Core 0. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar1.                                                          Core 0. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0.                                                          Core 0. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 1 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC1_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 1. (cfg_pme_int) */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 1. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 1. (cfg_sys_err_rc) */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 1. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Hot-Plug Interrupt.                                                          Pcie Core 0 (hp_int).                                                          This interrupt will only be generated when                                                          PCIERC0_CFG034[DLLS_C] is generated. Hot plug is                                                          not supported. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          Pcie Core 0. (cfg_pme_int) */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Wake up from Power Management Unit.                                                          Pcie Core 0. (wake_n)                                                          Octeon will never generate this interrupt. */
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          Pcie Core 0. (cfg_sys_err_rc) */
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          Pcie Core 0 (cfg_aer_rc_err_int). */
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA1] is not 0, the                                                          DMA_CNT1 timer increments every core clock. When                                                          DMA_CNT1 timer exceeds NPEI_DMA1_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT1 timer. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Whenever NPEI_DMA_CNTS[DMA0] is not 0, the                                                          DMA_CNT0 timer increments every core clock. When                                                          DMA_CNT0 timer exceeds NPEI_DMA0_INT_LEVEL[TIME],                                                          this bit is set. Writing a '1' to this bit also                                                          clears the DMA_CNT0 timer. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA1] was/is                                                          greater than NPEI_DMA1_INT_LEVEL[CNT]. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that NPEI_DMA_CNTS[DMA0] was/is                                                          greater than NPEI_DMA0_INT_LEVEL[CNT]. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 set Forced Interrupt. */
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA4 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA3 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA2 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA1 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< DMA0 doorbell overflow.                                                          Bit[32] of the doorbell count was set. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< RML write did not get commit in 0xffff core clocks. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< RML read did not return data in 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma4dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_62
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_sum
name|cvmx_npei_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_int_sum2  *  * NPEI_INTERRUPT_SUM2 = NPI Interrupt Summary2 Register  *  * This is a read only copy of the NPEI_INTERRUPT_SUM register with bit variances.  */
end_comment

begin_union
union|union
name|cvmx_npei_int_sum2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_int_sum2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
comment|/**< Set when a bit in the NPEI_INT_A_SUM register and                                                          the cooresponding bit in the NPEI_INT_A_ENB2                                                          register is set. */
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Equal to the cooresponding bit if the                                                          NPEI_INT_SUM register. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma2dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma3dbo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|c0_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs0_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs1_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_wake
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_hpint
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_un_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_up_wf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c0_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c1_ldwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_a
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_inta
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_int_sum2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_int_sum2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_int_sum2_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_int_sum2
name|cvmx_npei_int_sum2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_last_win_rdata0  *  * NPEI_LAST_WIN_RDATA0 = NPEI Last Window Read Data Port0  *  * The data from the last initiated window read.  */
end_comment

begin_union
union|union
name|cvmx_npei_last_win_rdata0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_last_win_rdata0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_last_win_rdata0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_last_win_rdata0
name|cvmx_npei_last_win_rdata0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_last_win_rdata1  *  * NPEI_LAST_WIN_RDATA1 = NPEI Last Window Read Data Port1  *  * The data from the last initiated window read.  */
end_comment

begin_union
union|union
name|cvmx_npei_last_win_rdata1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_last_win_rdata1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_last_win_rdata1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_last_win_rdata1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_last_win_rdata1
name|cvmx_npei_last_win_rdata1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_mem_access_ctl  *  * NPEI_MEM_ACCESS_CTL = NPEI's Memory Access Control  *  * Contains control for access to the PCIe address space.  */
end_comment

begin_union
union|union
name|cvmx_npei_mem_access_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_mem_access_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|4
decl_stmt|;
comment|/**< The maximum number of words to merge into a single                                                          write operation from the PPs to the PCIe. Legal                                                          values are 1 to 16, where a '0' is treated as 16. */
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
comment|/**< When the NPEI starts a PP to PCIe write it waits                                                          no longer than the value of TIMER in eclks to                                                          merge additional writes from the PPs into 1                                                          large write. The values for this field is 1 to                                                          1024 where a value of '0' is treated as 1024. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_mem_access_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_mem_access_ctl
name|cvmx_npei_mem_access_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_mem_access_subid#  *  * NPEI_MEM_ACCESS_SUBIDX = NPEI Memory Access SubidX Register  *  * Contains address index and control bits for access to memory from Core PPs.  */
end_comment

begin_union
union|union
name|cvmx_npei_mem_access_subidx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_mem_access_subidx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
comment|/**< Causes all byte reads to be zero length reads.                                                          Returns to the EXEC a zero for all read data. */
name|uint64_t
name|port
range|:
literal|2
decl_stmt|;
comment|/**< Port the request is sent to. */
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
comment|/**< No merging is allowed in this window. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< Endian-swap for Reads. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< Endian-swap for Writes. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< No Snoop for Reads. */
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
comment|/**< No Snoop for Writes. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering for Reads. */
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering for Writes. */
name|uint64_t
name|ba
range|:
literal|30
decl_stmt|;
comment|/**< PCIe Adddress Bits<63:34>. */
else|#
directive|else
name|uint64_t
name|ba
range|:
literal|30
decl_stmt|;
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|port
range|:
literal|2
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_mem_access_subidx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_subidx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_subidx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_mem_access_subidx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_mem_access_subidx
name|cvmx_npei_mem_access_subidx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_enb0  *  * NPEI_MSI_ENB0 = NPEI MSI Enable0  *  * Used to enable the interrupt generation for the bits in the NPEI_MSI_RCV0.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of NPEI_MSI_RCV0. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_enb0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_enb0
name|cvmx_npei_msi_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_enb1  *  * NPEI_MSI_ENB1 = NPEI MSI Enable1  *  * Used to enable the interrupt generation for the bits in the NPEI_MSI_RCV1.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of NPEI_MSI_RCV1. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_enb1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_enb1
name|cvmx_npei_msi_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_enb2  *  * NPEI_MSI_ENB2 = NPEI MSI Enable2  *  * Used to enable the interrupt generation for the bits in the NPEI_MSI_RCV2.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of NPEI_MSI_RCV2. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_enb2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_enb2
name|cvmx_npei_msi_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_enb3  *  * NPEI_MSI_ENB3 = NPEI MSI Enable3  *  * Used to enable the interrupt generation for the bits in the NPEI_MSI_RCV3.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of NPEI_MSI_RCV3. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_enb3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_enb3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_enb3
name|cvmx_npei_msi_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_rcv0  *  * NPEI_MSI_RCV0 = NPEI MSI Receive0  *  * Contains bits [63:0] of the 256 bits oof MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_rcv0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_rcv0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 63-0 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_rcv0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_rcv0
name|cvmx_npei_msi_rcv0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_rcv1  *  * NPEI_MSI_RCV1 = NPEI MSI Receive1  *  * Contains bits [127:64] of the 256 bits oof MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_rcv1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_rcv1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 127-64 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_rcv1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_rcv1
name|cvmx_npei_msi_rcv1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_rcv2  *  * NPEI_MSI_RCV2 = NPEI MSI Receive2  *  * Contains bits [191:128] of the 256 bits oof MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_rcv2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_rcv2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 191-128 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_rcv2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_rcv2
name|cvmx_npei_msi_rcv2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_rcv3  *  * NPEI_MSI_RCV3 = NPEI MSI Receive3  *  * Contains bits [255:192] of the 256 bits oof MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_rcv3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_rcv3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 255-192 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_rcv3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rcv3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_rcv3
name|cvmx_npei_msi_rcv3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_rd_map  *  * NPEI_MSI_RD_MAP = NPEI MSI Read MAP  *  * Used to read the mapping function of the NPEI_PCIE_MSI_RCV to NPEI_MSI_RCV registers.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_rd_map
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_rd_map_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|rd_int
range|:
literal|8
decl_stmt|;
comment|/**< The value of the map at the location PREVIOUSLY                                                          written to the MSI_INT field of this register. */
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects the value that would be received when the                                                          NPEI_PCIE_MSI_RCV register is written. */
else|#
directive|else
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rd_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_rd_map_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rd_map_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_rd_map_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_rd_map_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_rd_map
name|cvmx_npei_msi_rd_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1c_enb0  *  * NPEI_MSI_W1C_ENB0 = NPEI MSI Write 1 To Clear Enable0  *  * Used to clear bits in NPEI_MSI_ENB0. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1c_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1c_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in NPEI_MSI_ENB0.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1c_enb0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1c_enb0_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1c_enb0
name|cvmx_npei_msi_w1c_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1c_enb1  *  * NPEI_MSI_W1C_ENB1 = NPEI MSI Write 1 To Clear Enable1  *  * Used to clear bits in NPEI_MSI_ENB1. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1c_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1c_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in NPEI_MSI_ENB1.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1c_enb1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1c_enb1_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1c_enb1
name|cvmx_npei_msi_w1c_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1c_enb2  *  * NPEI_MSI_W1C_ENB2 = NPEI MSI Write 1 To Clear Enable2  *  * Used to clear bits in NPEI_MSI_ENB2. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1c_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1c_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in NPEI_MSI_ENB2.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1c_enb2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1c_enb2_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1c_enb2
name|cvmx_npei_msi_w1c_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1c_enb3  *  * NPEI_MSI_W1C_ENB3 = NPEI MSI Write 1 To Clear Enable3  *  * Used to clear bits in NPEI_MSI_ENB3. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1c_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1c_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in NPEI_MSI_ENB3.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1c_enb3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1c_enb3_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1c_enb3
name|cvmx_npei_msi_w1c_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1s_enb0  *  * NPEI_MSI_W1S_ENB0 = NPEI MSI Write 1 To Set Enable0  *  * Used to set bits in NPEI_MSI_ENB0. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1s_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1s_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in NPEI_MSI_ENB0.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1s_enb0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1s_enb0_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1s_enb0
name|cvmx_npei_msi_w1s_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1s_enb1  *  * NPEI_MSI_W1S_ENB0 = NPEI MSI Write 1 To Set Enable1  *  * Used to set bits in NPEI_MSI_ENB1. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1s_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1s_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in NPEI_MSI_ENB1.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1s_enb1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1s_enb1_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1s_enb1
name|cvmx_npei_msi_w1s_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1s_enb2  *  * NPEI_MSI_W1S_ENB2 = NPEI MSI Write 1 To Set Enable2  *  * Used to set bits in NPEI_MSI_ENB2. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1s_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1s_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in NPEI_MSI_ENB2.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1s_enb2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1s_enb2_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1s_enb2
name|cvmx_npei_msi_w1s_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_w1s_enb3  *  * NPEI_MSI_W1S_ENB3 = NPEI MSI Write 1 To Set Enable3  *  * Used to set bits in NPEI_MSI_ENB3. This is a PASS2 register.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_w1s_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_w1s_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in NPEI_MSI_ENB3.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_w1s_enb3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_w1s_enb3_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_w1s_enb3
name|cvmx_npei_msi_w1s_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_msi_wr_map  *  * NPEI_MSI_WR_MAP = NPEI MSI Write MAP  *  * Used to write the mapping function of the NPEI_PCIE_MSI_RCV to NPEI_MSI_RCV registers.  */
end_comment

begin_union
union|union
name|cvmx_npei_msi_wr_map
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_msi_wr_map_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ciu_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects which bit in the NPEI_MSI_RCV# (0-255)                                                          will be set when the value specified in the                                                          MSI_INT of this register is recevied during a                                                          write to the NPEI_PCIE_MSI_RCV register. */
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects the value that would be received when the                                                          NPEI_PCIE_MSI_RCV register is written. */
else|#
directive|else
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ciu_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_msi_wr_map_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_wr_map_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_msi_wr_map_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_msi_wr_map_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_msi_wr_map
name|cvmx_npei_msi_wr_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pcie_credit_cnt  *  * NPEI_PCIE_CREDIT_CNT = NPEI PCIE Credit Count  *  * Contains the number of credits for the pcie port FIFOs used by the NPEI. This value needs to be set BEFORE PCIe traffic  * flow from NPEI to PCIE Ports starts. A write to this register will cause the credit counts in the NPEI for the two  * PCIE ports to be reset to the value in this register.  */
end_comment

begin_union
union|union
name|cvmx_npei_pcie_credit_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pcie_credit_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
else|#
directive|else
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pcie_credit_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_credit_cnt_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pcie_credit_cnt
name|cvmx_npei_pcie_credit_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pcie_msi_rcv  *  * NPEI_PCIE_MSI_RCV = NPEI PCIe MSI Receive  *  * Register where MSI writes are directed from the PCIe.  */
end_comment

begin_union
union|union
name|cvmx_npei_pcie_msi_rcv
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pcie_msi_rcv_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the NPEI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the NPEI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pcie_msi_rcv_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pcie_msi_rcv
name|cvmx_npei_pcie_msi_rcv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pcie_msi_rcv_b1  *  * NPEI_PCIE_MSI_RCV_B1 = NPEI PCIe MSI Receive Byte 1  *  * Register where MSI writes are directed from the PCIe.  */
end_comment

begin_union
union|union
name|cvmx_npei_pcie_msi_rcv_b1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pcie_msi_rcv_b1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the NPEI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the NPEI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pcie_msi_rcv_b1
name|cvmx_npei_pcie_msi_rcv_b1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pcie_msi_rcv_b2  *  * NPEI_PCIE_MSI_RCV_B2 = NPEI PCIe MSI Receive Byte 2  *  * Register where MSI writes are directed from the PCIe.  */
end_comment

begin_union
union|union
name|cvmx_npei_pcie_msi_rcv_b2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pcie_msi_rcv_b2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the NPEI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the NPEI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pcie_msi_rcv_b2
name|cvmx_npei_pcie_msi_rcv_b2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pcie_msi_rcv_b3  *  * NPEI_PCIE_MSI_RCV_B3 = NPEI PCIe MSI Receive Byte 3  *  * Register where MSI writes are directed from the PCIe.  */
end_comment

begin_union
union|union
name|cvmx_npei_pcie_msi_rcv_b3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pcie_msi_rcv_b3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the NPEI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the NPEI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_pcie_msi_rcv_b3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pcie_msi_rcv_b3
name|cvmx_npei_pcie_msi_rcv_b3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_cnts  *  * NPEI_PKT[0..31]_CNTS = NPEI Packet ring# Counts  *  * The counters for output rings.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|22
decl_stmt|;
comment|/**< Timer incremented every 1024 core clocks                                                          when NPEI_PKTS#_CNTS[CNT] is non zero. Field                                                          cleared when NPEI_PKTS#_CNTS[CNT] goes to 0.                                                          Field is also cleared when NPEI_PKT_TIME_INT is                                                          cleared.                                                          The first increment of this count can occur                                                          between 0 to 1023 core clocks. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< ring counter. This field is incremented as                                                          packets are sent out and decremented in response to                                                          writes to this field.                                                          When NPEI_PKT_OUT_BMODE is '0' a value of 1 is                                                          added to the register for each packet, when '1'                                                          and the info-pointer is NOT used the length of the                                                          packet plus 8 is added, when '1' and info-pointer                                                          mode IS used the packet length is added to this                                                          field. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_cnts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_cnts_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_cnts
name|cvmx_npei_pktx_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_in_bp  *  * NPEI_PKT[0..31]_IN_BP = NPEI Packet ring# Input Backpressure  *  * The counters and thresholds for input packets to apply backpressure to processing of the packets.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_in_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_in_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
comment|/**< When CNT is greater than this threshold no more                                                          packets will be processed for this ring.                                                          When writing this field of the NPEI_PKT#_IN_BP                                                          register, use a 4-byte write so as to not write                                                          any other field of this register. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< ring counter. This field is incremented by one                                                          whenever OCTEON receives, buffers, and creates a                                                          work queue entry for a packet that arrives by the                                                          cooresponding input ring. A write to this field                                                          will be subtracted from the field value.                                                          When writing this field of the NPEI_PKT#_IN_BP                                                          register, use a 4-byte write so as to not write                                                          any other field of this register. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_in_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_in_bp_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_in_bp
name|cvmx_npei_pktx_in_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_instr_baddr  *  * NPEI_PKT[0..31]_INSTR_BADDR = NPEI Packet ring# Instruction Base Address  *  * Start of Instruction for input packets.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_instr_baddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_instr_baddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
comment|/**< Base address for Instructions. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_instr_baddr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_instr_baddr_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_instr_baddr
name|cvmx_npei_pktx_instr_baddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_instr_baoff_dbell  *  * NPEI_PKT[0..31]_INSTR_BAOFF_DBELL = NPEI Packet ring# Instruction Base Address Offset and Doorbell  *  * The doorbell and base address offset for next read.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_instr_baoff_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_instr_baoff_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
comment|/**< The offset from the NPEI_PKT[0..31]_INSTR_BADDR                                                          where the next instruction will be read. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Instruction doorbell count. Writes to this field                                                          will increment the value here. Reads will return                                                          present value. A write of 0xffffffff will set the                                                          DBELL and AOFF fields to '0'. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_instr_baoff_dbell_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_instr_baoff_dbell_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_instr_baoff_dbell
name|cvmx_npei_pktx_instr_baoff_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_instr_fifo_rsize  *  * NPEI_PKT[0..31]_INSTR_FIFO_RSIZE = NPEI Packet ring# Instruction FIFO and Ring Size.  *  * Fifo field and ring size for Instructions.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_instr_fifo_rsize
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_instr_fifo_rsize_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|max
range|:
literal|9
decl_stmt|;
comment|/**< Max Fifo Size. */
name|uint64_t
name|rrp
range|:
literal|9
decl_stmt|;
comment|/**< Fifo read pointer. */
name|uint64_t
name|wrp
range|:
literal|9
decl_stmt|;
comment|/**< Fifo write pointer. */
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
comment|/**< Fifo count. */
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
comment|/**< Instruction ring size. */
else|#
directive|else
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|wrp
range|:
literal|9
decl_stmt|;
name|uint64_t
name|rrp
range|:
literal|9
decl_stmt|;
name|uint64_t
name|max
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_instr_fifo_rsize_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_instr_fifo_rsize_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_instr_fifo_rsize
name|cvmx_npei_pktx_instr_fifo_rsize_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_instr_header  *  * NPEI_PKT[0..31]_INSTR_HEADER = NPEI Packet ring# Instruction Header.  *  * VAlues used to build input packet header.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_instr_header
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_instr_header_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode. */
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when packet is raw and PBP==0. */
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when packet is raw and PBP==0. */
name|uint64_t
name|reserved_22_27
range|:
literal|6
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the instruction header will be sent                                                          as part of the packet data, regardless of the                                                          value of bit [63] of the instruction header.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|reserved_0_5
range|:
literal|6
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_5
range|:
literal|6
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_27
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_instr_header_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_instr_header_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_instr_header
name|cvmx_npei_pktx_instr_header_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_slist_baddr  *  * NPEI_PKT[0..31]_SLIST_BADDR = NPEI Packet ring# Scatter List Base Address  *  * Start of Scatter List for output packet pointers - MUST be 16 byte alligned  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_slist_baddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_slist_baddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|addr
range|:
literal|60
decl_stmt|;
comment|/**< Base address for scatter list pointers. */
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_slist_baddr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_slist_baddr_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_slist_baddr
name|cvmx_npei_pktx_slist_baddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_slist_baoff_dbell  *  * NPEI_PKT[0..31]_SLIST_BAOFF_DBELL = NPEI Packet ring# Scatter List Base Address Offset and Doorbell  *  * The doorbell and base address offset for next read.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_slist_baoff_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_slist_baoff_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
comment|/**< The offset from the NPEI_PKT[0..31]_SLIST_BADDR                                                          where the next SList pointer will be read.                                                          A write of 0xFFFFFFFF to the DBELL field will                                                          clear DBELL and AOFF */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Scatter list doorbell count. Writes to this field                                                          will increment the value here. Reads will return                                                          present value. The value of this field is                                                          decremented as read operations are ISSUED for                                                          scatter pointers.                                                          A write of 0xFFFFFFFF will clear DBELL and AOFF */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_slist_baoff_dbell_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_slist_baoff_dbell_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_slist_baoff_dbell
name|cvmx_npei_pktx_slist_baoff_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt#_slist_fifo_rsize  *  * NPEI_PKT[0..31]_SLIST_FIFO_RSIZE = NPEI Packet ring# Scatter List FIFO and Ring Size.  *  * The number of scatter pointer pairs in the scatter list.  */
end_comment

begin_union
union|union
name|cvmx_npei_pktx_slist_fifo_rsize
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pktx_slist_fifo_rsize_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
comment|/**< The number of scatter pointer pairs contained in                                                          the scatter list ring. */
else|#
directive|else
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pktx_slist_fifo_rsize_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pktx_slist_fifo_rsize_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pktx_slist_fifo_rsize
name|cvmx_npei_pktx_slist_fifo_rsize_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_cnt_int  *  * NPEI_PKT_CNT_INT = NPI Packet Counter Interrupt  *  * The packets rings that are interrupting because of Packet Counters.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_cnt_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_cnt_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector cooresponding to ring number is set when                                                          NPEI_PKT#_CNTS[CNT] is greater                                                          than NPEI_PKT_INT_LEVELS[CNT]. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_cnt_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_cnt_int_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_cnt_int
name|cvmx_npei_pkt_cnt_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_cnt_int_enb  *  * NPEI_PKT_CNT_INT_ENB = NPI Packet Counter Interrupt Enable  *  * Enable for the packets rings that are interrupting because of Packet Counters.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_cnt_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_cnt_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector cooresponding to ring number when set                                                          allows NPEI_PKT_CNT_INT to generate an interrupt. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_cnt_int_enb_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_cnt_int_enb_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_cnt_int_enb
name|cvmx_npei_pkt_cnt_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_data_out_es  *  * NPEI_PKT_DATA_OUT_ES = NPEI's Packet Data Out Endian Swap  *  * The Endian Swap for writing Data Out.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_data_out_es
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_data_out_es_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
comment|/**< The endian swap mode for Packet rings 0 through 31.                                                          Two bits are used per ring (i.e. ring 0 [1:0],                                                          ring 1 [3:2], ....). */
else|#
directive|else
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_data_out_es_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_data_out_es_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_data_out_es
name|cvmx_npei_pkt_data_out_es_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_data_out_ns  *  * NPEI_PKT_DATA_OUT_NS = NPEI's Packet Data Out No Snoop  *  * The NS field for the TLP when writing packet data.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_data_out_ns
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_data_out_ns_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will enable NS in TLP header. */
else|#
directive|else
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_data_out_ns_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_data_out_ns_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_data_out_ns
name|cvmx_npei_pkt_data_out_ns_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_data_out_ror  *  * NPEI_PKT_DATA_OUT_ROR = NPEI's Packet Data Out Relaxed Ordering  *  * The ROR field for the TLP when writing Packet Data.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_data_out_ror
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_data_out_ror_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will enable ROR in TLP header. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_data_out_ror_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_data_out_ror_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_data_out_ror
name|cvmx_npei_pkt_data_out_ror_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_dpaddr  *  * NPEI_PKT_DPADDR = NPEI's Packet Data Pointer Addr  *  * Used to detemine address and attributes for packet data writes.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_dpaddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_dpaddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dptr
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will use:                                                          the address[63:60] to write packet data                                                          comes from the DPTR[63:60] in the scatter-list                                                          pair and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. */
else|#
directive|else
name|uint64_t
name|dptr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_dpaddr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_dpaddr_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_dpaddr
name|cvmx_npei_pkt_dpaddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_in_bp  *  * NPEI_PKT_IN_BP = NPEI Packet Input Backpressure  *  * Which input rings have backpressure applied.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_in_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_in_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|32
decl_stmt|;
comment|/**< A packet input  ring that has its count greater                                                          than its WMARK will have backpressure applied.                                                          Each of the 32 bits coorespond to an input ring.                                                          When '1' that ring has backpressure applied an                                                          will fetch no more instructions, but will process                                                          any previously fetched instructions. */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_in_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_in_bp_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_in_bp
name|cvmx_npei_pkt_in_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_in_done#_cnts  *  * NPEI_PKT_IN_DONE[0..31]_CNTS = NPEI Instruction Done ring# Counts  *  * Counters for instructions completed on Input rings.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_in_donex_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_in_donex_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< This field is incrmented by '1' when an instruction                                                          is completed. This field is incremented as the                                                          last of the data is read from the PCIe. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_in_donex_cnts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_in_donex_cnts_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_in_donex_cnts
name|cvmx_npei_pkt_in_donex_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_in_instr_counts  *  * NPEI_PKT_IN_INSTR_COUNTS = NPEI Packet Input Instrutction Counts  *  * Keeps track of the number of instructions read into the FIFO and Packets sent to IPD.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_in_instr_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_in_instr_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wr_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Shows the number of packets sent to the IPD. */
name|uint64_t
name|rd_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Shows the value of instructions that have had reads                                                          issued for them.                                                          to the Packet-ring is in reset. */
else|#
directive|else
name|uint64_t
name|rd_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wr_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_in_instr_counts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_in_instr_counts_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_in_instr_counts
name|cvmx_npei_pkt_in_instr_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_in_pcie_port  *  * NPEI_PKT_IN_PCIE_PORT = NPEI's Packet In To PCIe Port Assignment  *  * Assigns Packet Input rings to PCIe ports.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_in_pcie_port
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_in_pcie_port_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
comment|/**< The PCIe port that the Packet ring number is                                                          assigned. Two bits are used per ring (i.e. ring 0                                                          [1:0], ring 1 [3:2], ....). A value of '0 means                                                          that the Packetring is assign to PCIe Port 0, a '1'                                                          PCIe Port 1, '2' and '3' are reserved. */
else|#
directive|else
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_in_pcie_port_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_in_pcie_port_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_in_pcie_port
name|cvmx_npei_pkt_in_pcie_port_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_input_control  *  * NPEI_PKT_INPUT_CONTROL = NPEI's Packet Input Control  *  * Control for reads for gather list and instructions.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_input_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_input_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the input packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the input packet ring is fixed in priority,                                                          where the lower ring number has higher priority. */
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
comment|/**< Field when in [PBP] is set to be used in                                                          calculating a DPTR. */
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather data. */
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather data. */
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather data. */
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the csr value will be used for                                                          ROR, ESR, and NSR. When clear '0' the value in                                                          DPTR will be used. In turn the bits not used for                                                          ROR, ESR, and NSR, will be used for bits [63:60]                                                          of the address used to fetch packet data. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather list and gather instruction. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_input_control_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_input_control_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_input_control
name|cvmx_npei_pkt_input_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_instr_enb  *  * NPEI_PKT_INSTR_ENB = NPEI's Packet Instruction Enable  *  * Enables the instruction fetch for a Packet-ring.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_instr_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_instr_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring is enabled. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_instr_enb_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_instr_enb_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_instr_enb
name|cvmx_npei_pkt_instr_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_instr_rd_size  *  * NPEI_PKT_INSTR_RD_SIZE = NPEI Instruction Read Size  *  * The number of instruction allowed to be read at one time.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_instr_rd_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_instr_rd_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rdsize
range|:
literal|64
decl_stmt|;
comment|/**< Number of instructions to be read in one PCIe read                                                          request for the 4 PKOport - 8 rings. Every two bits                                                          (i.e. 1:0, 3:2, 5:4..) are assign to the port/ring                                                          combinations.                                                          - 15:0  PKOPort0,Ring 7..0  31:16 PKOPort1,Ring 7..0                                                          - 47:32 PKOPort2,Ring 7..0  63:48 PKOPort3,Ring 7..0                                                          Two bit value are:                                                          0 - 1 Instruction                                                          1 - 2 Instructions                                                          2 - 3 Instructions                                                          3 - 4 Instructions */
else|#
directive|else
name|uint64_t
name|rdsize
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_instr_rd_size_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_instr_rd_size_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_instr_rd_size
name|cvmx_npei_pkt_instr_rd_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_instr_size  *  * NPEI_PKT_INSTR_SIZE = NPEI's Packet Instruction Size  *  * Determines if instructions are 64 or 32 byte in size for a Packet-ring.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_instr_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_instr_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|is_64b
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring is a 64-byte instruction. */
else|#
directive|else
name|uint64_t
name|is_64b
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_instr_size_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_instr_size_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_instr_size
name|cvmx_npei_pkt_instr_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_int_levels  *  * 0x90F0 reserved NPEI_PKT_PCIE_PORT2  *  *  *                  NPEI_PKT_INT_LEVELS = NPEI's Packet Interrupt Levels  *  * Output packet interrupt levels.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_int_levels
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_int_levels_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|time
range|:
literal|22
decl_stmt|;
comment|/**< When NPEI_PKT#_CNTS[TIMER] is greater than this                                                          value an interrupt is generated. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< When NPEI_PKT#_CNTS[CNT] becomes                                                          greater than this value an interrupt is generated. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_int_levels_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_int_levels_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_int_levels
name|cvmx_npei_pkt_int_levels_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_iptr  *  * NPEI_PKT_IPTR = NPEI's Packet Info Poitner  *  * Controls using the Info-Pointer to store length and data.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_iptr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_iptr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iptr
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will use the Info-Pointer to                                                          store length and data. */
else|#
directive|else
name|uint64_t
name|iptr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_iptr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_iptr_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_iptr
name|cvmx_npei_pkt_iptr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_out_bmode  *  * NPEI_PKT_OUT_BMODE = NPEI's Packet Out Byte Mode  *  * Control the updating of the NPEI_PKT#_CNT register.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_out_bmode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_out_bmode_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bmode
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will have its NPEI_PKT#_CNT                                                          register updated with the number of bytes in the                                                          packet sent, when '0' the register will have a                                                          value of '1' added. */
else|#
directive|else
name|uint64_t
name|bmode
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_out_bmode_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_out_bmode_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_out_bmode
name|cvmx_npei_pkt_out_bmode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_out_enb  *  * NPEI_PKT_OUT_ENB = NPEI's Packet Output Enable  *  * Enables the output packet engines.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_out_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_out_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring is enabled.                                                          If an error occurs on reading pointers for an                                                          output ring, the ring will be disabled by clearing                                                          the bit associated with the ring to '0'. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_out_enb_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_out_enb_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_out_enb
name|cvmx_npei_pkt_out_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_output_wmark  *  * NPEI_PKT_OUTPUT_WMARK = NPEI's Packet Output Water Mark  *  * Value that when the NPEI_PKT#_SLIST_BAOFF_DBELL[DBELL] value is less then that backpressure for the rings will be applied.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_output_wmark
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_output_wmark_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
comment|/**< Value when DBELL count drops below backpressure                                                          for the ring will be applied to the PKO. */
else|#
directive|else
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_output_wmark_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_output_wmark_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_output_wmark
name|cvmx_npei_pkt_output_wmark_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_pcie_port  *  * NPEI_PKT_PCIE_PORT = NPEI's Packet To PCIe Port Assignment  *  * Assigns Packet Ports to PCIe ports.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_pcie_port
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_pcie_port_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
comment|/**< The PCIe port that the Packet ring number is                                                          assigned. Two bits are used per ring (i.e. ring 0                                                          [1:0], ring 1 [3:2], ....). A value of '0 means                                                          that the Packetring is assign to PCIe Port 0, a '1'                                                          PCIe Port 1, '2' and '3' are reserved. */
else|#
directive|else
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_pcie_port_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_pcie_port_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_pcie_port
name|cvmx_npei_pkt_pcie_port_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_port_in_rst  *  * NPEI_PKT_PORT_IN_RST = NPEI Packet Port In Reset  *  * Vector bits related to ring-port for ones that are reset.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_port_in_rst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_port_in_rst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|in_rst
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the inbound Packet-ring is in reset. */
name|uint64_t
name|out_rst
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the outbound Packet-ring is in reset. */
else|#
directive|else
name|uint64_t
name|out_rst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|in_rst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_port_in_rst_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_port_in_rst_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_port_in_rst
name|cvmx_npei_pkt_port_in_rst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_slist_es  *  * NPEI_PKT_SLIST_ES = NPEI's Packet Scatter List Endian Swap  *  * The Endian Swap for Scatter List Read.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_slist_es
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_slist_es_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
comment|/**< The endian swap mode for Packet rings 0 through 31.                                                          Two bits are used per ring (i.e. ring 0 [1:0],                                                          ring 1 [3:2], ....). */
else|#
directive|else
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_slist_es_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_slist_es_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_slist_es
name|cvmx_npei_pkt_slist_es_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_slist_id_size  *  * NPEI_PKT_SLIST_ID_SIZE = NPEI Packet Scatter List Info and Data Size  *  * The Size of the information and data fields pointed to by Scatter List pointers.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_slist_id_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_slist_id_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
comment|/**< Information size. Legal sizes are 0 to 120. */
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
comment|/**< Data size. */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_slist_id_size_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_slist_id_size_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_slist_id_size
name|cvmx_npei_pkt_slist_id_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_slist_ns  *  * NPEI_PKT_SLIST_NS = NPEI's Packet Scatter List No Snoop  *  * The NS field for the TLP when fetching Scatter List.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_slist_ns
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_slist_ns_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will enable NS in TLP header. */
else|#
directive|else
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_slist_ns_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_slist_ns_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_slist_ns
name|cvmx_npei_pkt_slist_ns_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_slist_ror  *  * NPEI_PKT_SLIST_ROR = NPEI's Packet Scatter List Relaxed Ordering  *  * The ROR field for the TLP when fetching Scatter List.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_slist_ror
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_slist_ror_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the Packet-ring will enable ROR in TLP header. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_slist_ror_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_slist_ror_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_slist_ror
name|cvmx_npei_pkt_slist_ror_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_time_int  *  * NPEI_PKT_TIME_INT = NPEI Packet Timer Interrupt  *  * The packets rings that are interrupting because of Packet Timers.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_time_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_time_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector cooresponding to ring number is set when                                                          NPEI_PKT#_CNTS[TIMER] is greater than                                                          NPEI_PKT_INT_LEVELS[TIME]. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_time_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_time_int_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_time_int
name|cvmx_npei_pkt_time_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_pkt_time_int_enb  *  * NPEI_PKT_TIME_INT_ENB = NPEI Packet Timer Interrupt Enable  *  * The packets rings that are interrupting because of Packet Timers.  */
end_comment

begin_union
union|union
name|cvmx_npei_pkt_time_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_pkt_time_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector cooresponding to ring number when set                                                          allows NPEI_PKT_TIME_INT to generate an interrupt. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_pkt_time_int_enb_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_pkt_time_int_enb_s
name|cn56xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_pkt_time_int_enb
name|cvmx_npei_pkt_time_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_rsl_int_blocks  *  * NPEI_RSL_INT_BLOCKS = NPEI RSL Interrupt Blocks Register  *  * Reading this register will return a vector with a bit set '1' for a corresponding RSL block  * that presently has an interrupt pending. The Field Description below supplies the name of the  * register that software should read to find out why that intterupt bit is set.  */
end_comment

begin_union
union|union
name|cvmx_npei_rsl_int_blocks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_rsl_int_blocks_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< IOB_INT_SUM */
name|uint64_t
name|lmc1
range|:
literal|1
decl_stmt|;
comment|/**< LMC1_MEM_CFG0 */
name|uint64_t
name|agl
range|:
literal|1
decl_stmt|;
comment|/**< AGL_GMX_RX0_INT_REG& AGL_GMX_TX_INT_REG */
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|asxpcs1
range|:
literal|1
decl_stmt|;
comment|/**< PCS1_INT*_REG */
name|uint64_t
name|asxpcs0
range|:
literal|1
decl_stmt|;
comment|/**< PCS0_INT*_REG */
name|uint64_t
name|reserved_21_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< PIP_INT_REG. */
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|lmc0
range|:
literal|1
decl_stmt|;
comment|/**< LMC0_MEM_CFG0 */
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
comment|/**< L2C_INT_STAT */
name|uint64_t
name|usb1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|rad
range|:
literal|1
decl_stmt|;
comment|/**< RAD_REG_ERROR */
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
comment|/**< USBN0_INT_SUM */
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
comment|/**< POW_ECC_ERR */
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
comment|/**< TIM_REG_ERROR */
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
comment|/**< PKO_REG_ERROR */
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
comment|/**< IPD_INT_SUM */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
comment|/**< ZIP_ERROR */
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
comment|/**< FPA_INT_SUM */
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
comment|/**< KEY_INT_SUM */
name|uint64_t
name|npei
range|:
literal|1
decl_stmt|;
comment|/**< NPEI_INT_SUM */
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
comment|/**< GMX1_RX*_INT_REG& GMX1_TX_INT_REG */
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
comment|/**< GMX0_RX*_INT_REG& GMX0_TX_INT_REG */
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
comment|/**< MIO_BOOT_ERR */
else|#
directive|else
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usb1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asxpcs0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asxpcs1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|agl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_rsl_int_blocks_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_rsl_int_blocks_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_rsl_int_blocks_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_rsl_int_blocks_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_rsl_int_blocks
name|cvmx_npei_rsl_int_blocks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_scratch_1  *  * NPEI_SCRATCH_1 = NPEI's Scratch 1  *  * A general purpose 64 bit register for SW use.  */
end_comment

begin_union
union|union
name|cvmx_npei_scratch_1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_scratch_1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< The value in this register is totaly SW dependent. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_scratch_1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_scratch_1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_scratch_1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_scratch_1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_scratch_1
name|cvmx_npei_scratch_1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_state1  *  * NPEI_STATE1 = NPEI State 1  *  * State machines in NPEI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_npei_state1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_state1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cpl1
range|:
literal|12
decl_stmt|;
comment|/**< CPL1 State */
name|uint64_t
name|cpl0
range|:
literal|12
decl_stmt|;
comment|/**< CPL0 State */
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
comment|/**< ARB State */
name|uint64_t
name|csr
range|:
literal|39
decl_stmt|;
comment|/**< CSR State */
else|#
directive|else
name|uint64_t
name|csr
range|:
literal|39
decl_stmt|;
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl0
range|:
literal|12
decl_stmt|;
name|uint64_t
name|cpl1
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_state1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_state1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_state1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_state1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_state1
name|cvmx_npei_state1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_state2  *  * NPEI_STATE2 = NPEI State 2  *  * State machines in NPEI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_npei_state2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_state2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|npei
range|:
literal|1
decl_stmt|;
comment|/**< NPEI State */
name|uint64_t
name|rac
range|:
literal|1
decl_stmt|;
comment|/**< RAC State */
name|uint64_t
name|csm1
range|:
literal|15
decl_stmt|;
comment|/**< CSM1 State */
name|uint64_t
name|csm0
range|:
literal|15
decl_stmt|;
comment|/**< CSM0 State */
name|uint64_t
name|nnp0
range|:
literal|8
decl_stmt|;
comment|/**< NNP0 State */
name|uint64_t
name|nnd
range|:
literal|8
decl_stmt|;
comment|/**< NND State */
else|#
directive|else
name|uint64_t
name|nnd
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nnp0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|15
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|15
decl_stmt|;
name|uint64_t
name|rac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_state2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_state2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_state2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_state2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_state2
name|cvmx_npei_state2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_state3  *  * NPEI_STATE3 = NPEI State 3  *  * State machines in NPEI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_npei_state3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_state3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|psm1
range|:
literal|15
decl_stmt|;
comment|/**< PSM1 State */
name|uint64_t
name|psm0
range|:
literal|15
decl_stmt|;
comment|/**< PSM0 State */
name|uint64_t
name|nsm1
range|:
literal|13
decl_stmt|;
comment|/**< NSM1 State */
name|uint64_t
name|nsm0
range|:
literal|13
decl_stmt|;
comment|/**< NSM0 State */
else|#
directive|else
name|uint64_t
name|nsm0
range|:
literal|13
decl_stmt|;
name|uint64_t
name|nsm1
range|:
literal|13
decl_stmt|;
name|uint64_t
name|psm0
range|:
literal|15
decl_stmt|;
name|uint64_t
name|psm1
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_state3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_state3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_state3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_state3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_state3
name|cvmx_npei_state3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_win_rd_addr  *  * NPEI_WIN_RD_ADDR = NPEI Window Read Address Register  *  * The address to be read when the NPEI_WIN_RD_DATA register is read.  */
end_comment

begin_union
union|union
name|cvmx_npei_win_rd_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_win_rd_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|ld_cmd
range|:
literal|2
decl_stmt|;
comment|/**< The load command sent wit hthe read.                                                          0x0 == Load 8-bytes, 0x1 == Load 4-bytes,                                                          0x2 == Load 2-bytes, 0x3 == Load 1-bytes, */
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|rd_addr
range|:
literal|48
decl_stmt|;
comment|/**< The address to be read from. Whenever the LSB of                                                          this register is written, the Read Operation will                                                          take place.                                                          [47:40] = NCB_ID                                                          [39:0]  = Address                                                          When [47:43] == NPI& [42:0] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:27] == RSL_ID                                                               [12:0]  == RSL Register Offset */
else|#
directive|else
name|uint64_t
name|rd_addr
range|:
literal|48
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ld_cmd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_win_rd_addr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_addr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_addr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_addr_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_win_rd_addr
name|cvmx_npei_win_rd_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_win_rd_data  *  * NPEI_WIN_RD_DATA = NPEI Window Read Data Register  *  * Reading this register causes a window read operation to take place. Address read is taht contained in the NPEI_WIN_RD_ADDR  * register.  */
end_comment

begin_union
union|union
name|cvmx_npei_win_rd_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_win_rd_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
comment|/**< The read data. */
else|#
directive|else
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_win_rd_data_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_data_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_data_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_win_rd_data_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_win_rd_data
name|cvmx_npei_win_rd_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_win_wr_addr  *  * NPEI_WIN_WR_ADDR = NPEI Window Write Address Register  *  * Contains the address to be writen to when a write operation is started by writing the  * NPEI_WIN_WR_DATA register (see below).  *  * Notes:  * Even though address bit [2] can be set, it should always be kept to '0'.  *  */
end_comment

begin_union
union|union
name|cvmx_npei_win_wr_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_win_wr_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|wr_addr
range|:
literal|46
decl_stmt|;
comment|/**< The address that will be written to when the                                                          NPEI_WIN_WR_DATA register is written.                                                          [47:40] = NCB_ID                                                          [39:3]  = Address                                                          When [47:43] == NPI& [42:0] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:27] == RSL_ID                                                               [12:2]  == RSL Register Offset                                                               [1:0]   == x, Not Used */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wr_addr
range|:
literal|46
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_win_wr_addr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_addr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_addr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_addr_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_win_wr_addr
name|cvmx_npei_win_wr_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_win_wr_data  *  * NPEI_WIN_WR_DATA = NPEI Window Write Data Register  *  * Contains the data to write to the address located in the NPEI_WIN_WR_ADDR Register.  * Writing the least-significant-byte of this register will cause a write operation to take place.  */
end_comment

begin_union
union|union
name|cvmx_npei_win_wr_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_win_wr_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
comment|/**< The data to be written. Whenever the LSB of this                                                          register is written, the Window Write will take                                                          place. */
else|#
directive|else
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_win_wr_data_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_data_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_data_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_data_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_win_wr_data
name|cvmx_npei_win_wr_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_win_wr_mask  *  * NPEI_WIN_WR_MASK = NPEI Window Write Mask Register  *  * Contains the mask for the data in the NPEI_WIN_WR_DATA Register.  */
end_comment

begin_union
union|union
name|cvmx_npei_win_wr_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_win_wr_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
comment|/**< The data to be written. When a bit is '0'                                                          the corresponding byte will be written. */
else|#
directive|else
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_win_wr_mask_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_mask_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_win_wr_mask_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_win_wr_mask
name|cvmx_npei_win_wr_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npei_window_ctl  *  * NPEI_WINDOW_CTL = NPEI's Window Control  *  * The name of this register is misleading. The timeout value is used for BAR0 access from PCIE0 and PCIE1.  * Any access to the regigisters on the RML will timeout as 0xFFFF clock cycle. At time of timeout the next  * RML access will start, and interrupt will be set, and in the case of reads no data will be returned.  *  * The value of this register should be set to a minimum of 0x200000 to ensure that a timeout to an RML register  * occurs on the RML 0xFFFF timer before the timeout for a BAR0 access from the PCIE#.  */
end_comment

begin_union
union|union
name|cvmx_npei_window_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npei_window_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Time to wait in core clocks to wait for a                                                          BAR0 access to completeon the NCB                                                          before timing out. A value of 0 will cause no                                                          timeouts. A minimum value of 0x200000 should be                                                          used when this register is not set to 0x0. */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npei_window_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_npei_window_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_npei_window_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_npei_window_ctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npei_window_ctl
name|cvmx_npei_window_ctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

