begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pci-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pci.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PCI_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PCI_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_BAR1_INDEXX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_BAR1_INDEXX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000100ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|4
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_BAR1_INDEXX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000100ull + ((offset)& 31) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_BIST_REG
value|CVMX_PCI_BIST_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_BIST_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_BIST_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000001C0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_BIST_REG
value|(0x00000000000001C0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG00
value|CVMX_PCI_CFG00_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG00_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG00 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG00
value|(0x0000000000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG01
value|CVMX_PCI_CFG01_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG01_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG01 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG01
value|(0x0000000000000004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG02
value|CVMX_PCI_CFG02_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG02_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG02 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG02
value|(0x0000000000000008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG03
value|CVMX_PCI_CFG03_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG03_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG03 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000000Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG03
value|(0x000000000000000Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG04
value|CVMX_PCI_CFG04_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG04_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG04 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG04
value|(0x0000000000000010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG05
value|CVMX_PCI_CFG05_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG05_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG05 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000014ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG05
value|(0x0000000000000014ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG06
value|CVMX_PCI_CFG06_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG06_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG06 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000018ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG06
value|(0x0000000000000018ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG07
value|CVMX_PCI_CFG07_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG07_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG07 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000001Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG07
value|(0x000000000000001Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG08
value|CVMX_PCI_CFG08_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG08_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG08 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG08
value|(0x0000000000000020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG09
value|CVMX_PCI_CFG09_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG09_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG09 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000024ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG09
value|(0x0000000000000024ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG10
value|CVMX_PCI_CFG10_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG10_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG10 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000028ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG10
value|(0x0000000000000028ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG11
value|CVMX_PCI_CFG11_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG11_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG11 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000002Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG11
value|(0x000000000000002Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG12
value|CVMX_PCI_CFG12_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG12_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG12 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG12
value|(0x0000000000000030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG13
value|CVMX_PCI_CFG13_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG13_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG13 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000034ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG13
value|(0x0000000000000034ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG15
value|CVMX_PCI_CFG15_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG15_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG15 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000003Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG15
value|(0x000000000000003Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG16
value|CVMX_PCI_CFG16_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG16_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG16 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG16
value|(0x0000000000000040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG17
value|CVMX_PCI_CFG17_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG17_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG17 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000044ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG17
value|(0x0000000000000044ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG18
value|CVMX_PCI_CFG18_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG18_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG18 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000048ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG18
value|(0x0000000000000048ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG19
value|CVMX_PCI_CFG19_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG19_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG19 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000004Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG19
value|(0x000000000000004Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG20
value|CVMX_PCI_CFG20_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG20_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG20 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG20
value|(0x0000000000000050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG21
value|CVMX_PCI_CFG21_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG21_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG21 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000054ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG21
value|(0x0000000000000054ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG22
value|CVMX_PCI_CFG22_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG22_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG22 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000058ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG22
value|(0x0000000000000058ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG56
value|CVMX_PCI_CFG56_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG56_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG56 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000E0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG56
value|(0x00000000000000E0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG57
value|CVMX_PCI_CFG57_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG57_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG57 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000E4ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG57
value|(0x00000000000000E4ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG58
value|CVMX_PCI_CFG58_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG58_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG58 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000E8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG58
value|(0x00000000000000E8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG59
value|CVMX_PCI_CFG59_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG59_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG59 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000ECull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG59
value|(0x00000000000000ECull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG60
value|CVMX_PCI_CFG60_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG60_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG60 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG60
value|(0x00000000000000F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG61
value|CVMX_PCI_CFG61_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG61_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG61 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000F4ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG61
value|(0x00000000000000F4ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG62
value|CVMX_PCI_CFG62_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG62_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG62 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000F8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG62
value|(0x00000000000000F8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CFG63
value|CVMX_PCI_CFG63_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CFG63_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CFG63 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000FCull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CFG63
value|(0x00000000000000FCull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CNT_REG
value|CVMX_PCI_CNT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CNT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CNT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000001B8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CNT_REG
value|(0x00000000000001B8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_CTL_STATUS_2
value|CVMX_PCI_CTL_STATUS_2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_CTL_STATUS_2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_CTL_STATUS_2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000018Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_CTL_STATUS_2
value|(0x000000000000018Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_DBELL_X
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_DBELL_X(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000080ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_DBELL_X
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000080ull + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_CNT0
value|CVMX_PCI_DMA_CNTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_CNT1
value|CVMX_PCI_DMA_CNTX(1)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_DMA_CNTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_DMA_CNTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000A0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_CNTX
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000000A0ull + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_INT_LEV0
value|CVMX_PCI_DMA_INT_LEVX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_INT_LEV1
value|CVMX_PCI_DMA_INT_LEVX(1)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_DMA_INT_LEVX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_DMA_INT_LEVX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000A4ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_INT_LEVX
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000000A4ull + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_TIME0
value|CVMX_PCI_DMA_TIMEX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_TIME1
value|CVMX_PCI_DMA_TIMEX(1)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_DMA_TIMEX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_DMA_TIMEX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000B0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|4
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_DMA_TIMEX
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000000B0ull + ((offset)& 1) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_INSTR_COUNT0
value|CVMX_PCI_INSTR_COUNTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_INSTR_COUNT1
value|CVMX_PCI_INSTR_COUNTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_INSTR_COUNT2
value|CVMX_PCI_INSTR_COUNTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_INSTR_COUNT3
value|CVMX_PCI_INSTR_COUNTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_INSTR_COUNTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_INSTR_COUNTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000084ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_INSTR_COUNTX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000084ull + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_INT_ENB
value|CVMX_PCI_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000038ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_INT_ENB
value|(0x0000000000000038ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_INT_ENB2
value|CVMX_PCI_INT_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_INT_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_INT_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000001A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_INT_ENB2
value|(0x00000000000001A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_INT_SUM
value|CVMX_PCI_INT_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_INT_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_INT_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_INT_SUM
value|(0x0000000000000030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_INT_SUM2
value|CVMX_PCI_INT_SUM2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_INT_SUM2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_INT_SUM2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000198ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_INT_SUM2
value|(0x0000000000000198ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_MSI_RCV
value|CVMX_PCI_MSI_RCV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_MSI_RCV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_MSI_RCV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_MSI_RCV
value|(0x00000000000000F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT0
value|CVMX_PCI_PKTS_SENTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT1
value|CVMX_PCI_PKTS_SENTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT2
value|CVMX_PCI_PKTS_SENTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT3
value|CVMX_PCI_PKTS_SENTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_PKTS_SENTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_PKTS_SENTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000040ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENTX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000040ull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_INT_LEV0
value|CVMX_PCI_PKTS_SENT_INT_LEVX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_INT_LEV1
value|CVMX_PCI_PKTS_SENT_INT_LEVX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_INT_LEV2
value|CVMX_PCI_PKTS_SENT_INT_LEVX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_INT_LEV3
value|CVMX_PCI_PKTS_SENT_INT_LEVX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_PKTS_SENT_INT_LEVX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_PKTS_SENT_INT_LEVX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000048ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_INT_LEVX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000048ull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_TIME0
value|CVMX_PCI_PKTS_SENT_TIMEX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_TIME1
value|CVMX_PCI_PKTS_SENT_TIMEX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_TIME2
value|CVMX_PCI_PKTS_SENT_TIMEX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_TIME3
value|CVMX_PCI_PKTS_SENT_TIMEX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_PKTS_SENT_TIMEX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_PKTS_SENT_TIMEX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000004Cull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_PKTS_SENT_TIMEX
parameter_list|(
name|offset
parameter_list|)
value|(0x000000000000004Cull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PCI_PKT_CREDITS0
value|CVMX_PCI_PKT_CREDITSX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKT_CREDITS1
value|CVMX_PCI_PKT_CREDITSX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKT_CREDITS2
value|CVMX_PCI_PKT_CREDITSX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_PCI_PKT_CREDITS3
value|CVMX_PCI_PKT_CREDITSX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_PKT_CREDITSX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_PKT_CREDITSX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000044ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_PKT_CREDITSX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000044ull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_6
value|CVMX_PCI_READ_CMD_6_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_READ_CMD_6_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_READ_CMD_6 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000180ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_6
value|(0x0000000000000180ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_C
value|CVMX_PCI_READ_CMD_C_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_READ_CMD_C_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_READ_CMD_C not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000184ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_C
value|(0x0000000000000184ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_E
value|CVMX_PCI_READ_CMD_E_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_READ_CMD_E_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_READ_CMD_E not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000188ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_READ_CMD_E
value|(0x0000000000000188ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_READ_TIMEOUT
value|CVMX_PCI_READ_TIMEOUT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_READ_TIMEOUT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_READ_TIMEOUT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000000B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_READ_TIMEOUT
value|(CVMX_ADD_IO_SEG(0x00011F00000000B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_SCM_REG
value|CVMX_PCI_SCM_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_SCM_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_SCM_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000001A8ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_SCM_REG
value|(0x00000000000001A8ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_TSR_REG
value|CVMX_PCI_TSR_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_TSR_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_TSR_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000001B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_TSR_REG
value|(0x00000000000001B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_RD_ADDR
value|CVMX_PCI_WIN_RD_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_WIN_RD_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_WIN_RD_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_RD_ADDR
value|(0x0000000000000008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_RD_DATA
value|CVMX_PCI_WIN_RD_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_WIN_RD_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_WIN_RD_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_RD_DATA
value|(0x0000000000000020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_ADDR
value|CVMX_PCI_WIN_WR_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_WIN_WR_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_WIN_WR_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_ADDR
value|(0x0000000000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_DATA
value|CVMX_PCI_WIN_WR_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_WIN_WR_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_WIN_WR_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_DATA
value|(0x0000000000000010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_MASK
value|CVMX_PCI_WIN_WR_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCI_WIN_WR_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PCI_WIN_WR_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000018ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PCI_WIN_WR_MASK
value|(0x0000000000000018ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pci_bar1_index#  *  * PCI_BAR1_INDEXX = PCI IndexX Register  *  * Contains address index and control bits for access to memory ranges of Bar-1,  * when PCI supplied address-bits [26:22] == X.  */
end_comment

begin_union
union|union
name|cvmx_pci_bar1_indexx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_bar1_indexx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint32_t
name|addr_idx
range|:
literal|14
decl_stmt|;
comment|/**< Address bits [35:22] sent to L2C */
name|uint32_t
name|ca
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when access is not to be cached in L2. */
name|uint32_t
name|end_swp
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode */
name|uint32_t
name|addr_v
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the selected address range is valid. */
else|#
directive|else
name|uint32_t
name|addr_v
range|:
literal|1
decl_stmt|;
name|uint32_t
name|end_swp
range|:
literal|2
decl_stmt|;
name|uint32_t
name|ca
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr_idx
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_bar1_indexx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_bar1_indexx
name|cvmx_pci_bar1_indexx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_bist_reg  *  * PCI_BIST_REG = PCI PNI BIST Status Register  *  * Contains the bist results for the PNI memories.  */
end_comment

begin_union
union|union
name|cvmx_pci_bist_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_bist_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|rsp_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For b12_rsp_fifo_bist                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|dma0_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For dmao_count                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|cmd0_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For npi_cmd0_pni_am0                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|cmd_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For npi_cmd_pni_am1                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|csr2p_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For npi_csr_2_pni_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|csrr_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For npi_csr_rsp_2_pni_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|rsp2p_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For npi_rsp_2_pni_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|csr2n_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For pni_csr_2_npi_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|dat2n_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For pni_data_2_npi_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
name|uint64_t
name|dbg2n_bs
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For pni_dbg_data_2_npi_am                                                          The value of this register is available 100,000                                                          core clocks + 21,000 pclks after:                                                          Host Mode - deassertion of pci_rst_n                                                          Non Host Mode - deassertion of pci_rst_n */
else|#
directive|else
name|uint64_t
name|dbg2n_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dat2n_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr2n_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp2p_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csrr_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr2p_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd0_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_bist_reg_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_bist_reg
name|cvmx_pci_bist_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg00  *  * Registers at address 0x1000 -> 0x17FF are PNI  * Start at 0x100 into range  * these are shifted by 2 to the left to make address  *                Registers at address 0x1800 -> 0x18FF are CFG  * these are shifted by 2 to the left to make address  *  *           PCI_CFG00 = First 32-bits of PCI config space (PCI Vendor + Device)  *  * This register contains the first 32-bits of the PCI config space registers  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg00
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg00_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|devid
range|:
literal|16
decl_stmt|;
comment|/**< This is the device ID for OCTEON (90nm shhrink) */
name|uint32_t
name|vendid
range|:
literal|16
decl_stmt|;
comment|/**< This is the Cavium's vendor ID */
else|#
directive|else
name|uint32_t
name|vendid
range|:
literal|16
decl_stmt|;
name|uint32_t
name|devid
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg00_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg00_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg00
name|cvmx_pci_cfg00_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg01  *  * PCI_CFG01 = Second 32-bits of PCI config space (Command/Status Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg01
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg01_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
comment|/**< Detected Parity Error */
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
comment|/**< Signaled System Error */
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
comment|/**< Received Master Abort */
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
comment|/**< Received Target Abort */
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
comment|/**< Signaled Target Abort */
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
comment|/**< DEVSEL# timing (for PCI only/for PCIX = don't care) */
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
comment|/**< Master Data Parity Error */
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back-to-Back Transactions Capable                                                          Mode Dependent (1 = PCI Mode / 0 = PCIX Mode) */
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
comment|/**< 66MHz Capable */
name|uint32_t
name|cle
range|:
literal|1
decl_stmt|;
comment|/**< Capabilities List Enable */
name|uint32_t
name|i_stat
range|:
literal|1
decl_stmt|;
comment|/**< When INTx# is asserted by OCTEON this bit will be set.                                                          When deasserted by OCTEON this bit will be cleared. */
name|uint32_t
name|reserved_11_18
range|:
literal|8
decl_stmt|;
name|uint32_t
name|i_dis
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' disables the generation of INTx#                                                          by OCTEON. When disabled '0' allows assertion of INTx#                                                          by OCTEON. */
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
comment|/**< Fast Back to Back Transaction Enable */
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
comment|/**< System Error Enable */
name|uint32_t
name|ads
range|:
literal|1
decl_stmt|;
comment|/**< Address/Data Stepping                                                          NOTE: Octeon does NOT support address/data stepping. */
name|uint32_t
name|pee
range|:
literal|1
decl_stmt|;
comment|/**< PERR# Enable */
name|uint32_t
name|vps
range|:
literal|1
decl_stmt|;
comment|/**< VGA Palette Snooping */
name|uint32_t
name|mwice
range|:
literal|1
decl_stmt|;
comment|/**< Memory Write& Invalidate Command Enable */
name|uint32_t
name|scse
range|:
literal|1
decl_stmt|;
comment|/**< Special Cycle Snooping Enable */
name|uint32_t
name|me
range|:
literal|1
decl_stmt|;
comment|/**< Master Enable                                                          Must be set for OCTEON to master a PCI/PCI-X                                                          transaction. This should always be set any time                                                          that OCTEON is connected to a PCI/PCI-X bus. */
name|uint32_t
name|msae
range|:
literal|1
decl_stmt|;
comment|/**< Memory Space Access Enable                                                          Must be set to recieve a PCI/PCI-X memory space                                                          transaction. This must always be set any time that                                                          OCTEON is connected to a PCI/PCI-X bus. */
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
comment|/**< I/O Space Access Enable                                                          NOTE: For OCTEON, this bit MUST NEVER be set                                                          (it is read-only and OCTEON does not respond to I/O                                                          Space accesses). */
else|#
directive|else
name|uint32_t
name|isae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|me
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mwice
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vps
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pee
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ads
range|:
literal|1
decl_stmt|;
name|uint32_t
name|see
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbbe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_11_18
range|:
literal|8
decl_stmt|;
name|uint32_t
name|i_stat
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m66
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_22
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fbb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mdpe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|devt
range|:
literal|2
decl_stmt|;
name|uint32_t
name|sta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rma
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dpe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg01_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg01_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg01
name|cvmx_pci_cfg01_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg02  *  * PCI_CFG02 = Third 32-bits of PCI config space (Class Code / Revision ID)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg02
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg02_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|cc
range|:
literal|24
decl_stmt|;
comment|/**< Class Code (Processor/MIPS)                                                          (was 0x100000 in pass 1 and pass 2) */
name|uint32_t
name|rid
range|:
literal|8
decl_stmt|;
comment|/**< Revision ID                                                          (0 in pass 1, 1 in pass 1.1, 8 in pass 2.0) */
else|#
directive|else
name|uint32_t
name|rid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|cc
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg02_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg02_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg02
name|cvmx_pci_cfg02_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg03  *  * PCI_CFG03 = Fourth 32-bits of PCI config space (BIST, HEADER Type, Latency timer, line size)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg03
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg03_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|bcap
range|:
literal|1
decl_stmt|;
comment|/**< BIST Capable */
name|uint32_t
name|brb
range|:
literal|1
decl_stmt|;
comment|/**< BIST Request/busy bit                                                          Note: OCTEON does not support PCI BIST, therefore                                                          this bit should remain zero. */
name|uint32_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint32_t
name|bcod
range|:
literal|4
decl_stmt|;
comment|/**< BIST Code */
name|uint32_t
name|ht
range|:
literal|8
decl_stmt|;
comment|/**< Header Type (Type 0) */
name|uint32_t
name|lt
range|:
literal|8
decl_stmt|;
comment|/**< Latency Timer                                                          (0=PCI)                 (0=PCI)                                                          (0x40=PCIX)             (0x40=PCIX) */
name|uint32_t
name|cls
range|:
literal|8
decl_stmt|;
comment|/**< Cache Line Size */
else|#
directive|else
name|uint32_t
name|cls
range|:
literal|8
decl_stmt|;
name|uint32_t
name|lt
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ht
range|:
literal|8
decl_stmt|;
name|uint32_t
name|bcod
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint32_t
name|brb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bcap
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg03_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg03_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg03
name|cvmx_pci_cfg03_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg04  *  * PCI_CFG04 = Fifth 32-bits of PCI config space (Base Address Register 0 - Low)  *  * Description: BAR0: 4KB 64-bit Prefetchable Memory Space  *       [0]:     0 (Memory Space)  *       [2:1]:   2 (64bit memory decoder)  *       [3]:     1 (Prefetchable)  *       [11:4]:  RAZ (to imply 4KB space)  *       [31:12]: RW (User may define base address)  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg04
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg04_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lbase
range|:
literal|20
decl_stmt|;
comment|/**< Base Address[31:12]                                                          Base Address[30:12] read as zero if                                                          PCI_CTL_STATUS_2[BB0] is set (in pass 3+) */
name|uint32_t
name|lbasez
range|:
literal|8
decl_stmt|;
comment|/**< Base Address[11:4] (Read as Zero) */
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
comment|/**< Prefetchable Space */
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
comment|/**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
comment|/**< Memory Space Indicator */
else|#
directive|else
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbasez
range|:
literal|8
decl_stmt|;
name|uint32_t
name|lbase
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg04_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg04_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg04
name|cvmx_pci_cfg04_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg05  *  * PCI_CFG05 = Sixth 32-bits of PCI config space (Base Address Register 0 - High)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg05
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg05_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|hbase
range|:
literal|32
decl_stmt|;
comment|/**< Base Address[63:32] */
else|#
directive|else
name|uint32_t
name|hbase
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg05_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg05_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg05
name|cvmx_pci_cfg05_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg06  *  * PCI_CFG06 = Seventh 32-bits of PCI config space (Base Address Register 1 - Low)  *  * Description: BAR1: 128MB 64-bit Prefetchable Memory Space  *       [0]:     0 (Memory Space)  *       [2:1]:   2 (64bit memory decoder)  *       [3]:     1 (Prefetchable)  *       [26:4]:  RAZ (to imply 128MB space)  *       [31:27]: RW (User may define base address)  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg06
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg06_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lbase
range|:
literal|5
decl_stmt|;
comment|/**< Base Address[31:27]                                                          In pass 3+:                                                            Base Address[29:27] read as zero if                                                             PCI_CTL_STATUS_2[BB1] is set                                                            Base Address[30] reads as zero if                                                             PCI_CTL_STATUS_2[BB1] is set and                                                             PCI_CTL_STATUS_2[BB1_SIZE] is set */
name|uint32_t
name|lbasez
range|:
literal|23
decl_stmt|;
comment|/**< Base Address[26:4] (Read as Zero) */
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
comment|/**< Prefetchable Space */
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
comment|/**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
comment|/**< Memory Space Indicator */
else|#
directive|else
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbasez
range|:
literal|23
decl_stmt|;
name|uint32_t
name|lbase
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg06_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg06_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg06
name|cvmx_pci_cfg06_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg07  *  * PCI_CFG07 = Eighth 32-bits of PCI config space (Base Address Register 1 - High)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg07
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg07_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|hbase
range|:
literal|32
decl_stmt|;
comment|/**< Base Address[63:32] */
else|#
directive|else
name|uint32_t
name|hbase
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg07_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg07_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg07
name|cvmx_pci_cfg07_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg08  *  * PCI_CFG08 = Ninth 32-bits of PCI config space (Base Address Register 2 - Low)  *  * Description: BAR1: 2^39 (512GB) 64-bit Prefetchable Memory Space  *       [0]:     0 (Memory Space)  *       [2:1]:   2 (64bit memory decoder)  *       [3]:     1 (Prefetchable)  *       [31:4]:  RAZ  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg08
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg08_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|lbasez
range|:
literal|28
decl_stmt|;
comment|/**< Base Address[31:4] (Read as Zero) */
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
comment|/**< Prefetchable Space */
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
comment|/**< Type (00=32b/01=below 1MB/10=64b/11=RSV) */
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
comment|/**< Memory Space Indicator */
else|#
directive|else
name|uint32_t
name|mspc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|typ
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lbasez
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg08_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg08_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg08
name|cvmx_pci_cfg08_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg09  *  * PCI_CFG09 = Tenth 32-bits of PCI config space (Base Address Register 2 - High)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg09
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg09_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|hbase
range|:
literal|25
decl_stmt|;
comment|/**< Base Address[63:39] */
name|uint32_t
name|hbasez
range|:
literal|7
decl_stmt|;
comment|/**< Base Address[38:31]  (Read as Zero) */
else|#
directive|else
name|uint32_t
name|hbasez
range|:
literal|7
decl_stmt|;
name|uint32_t
name|hbase
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg09_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg09_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg09
name|cvmx_pci_cfg09_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg10  *  * PCI_CFG10 = Eleventh 32-bits of PCI config space (Card Bus CIS Pointer)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg10
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg10_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|cisp
range|:
literal|32
decl_stmt|;
comment|/**< CardBus CIS Pointer (UNUSED) */
else|#
directive|else
name|uint32_t
name|cisp
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg10_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg10_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg10
name|cvmx_pci_cfg10_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg11  *  * PCI_CFG11 = Twelfth 32-bits of PCI config space (SubSystem ID/Subsystem Vendor ID Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg11
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg11_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|ssid
range|:
literal|16
decl_stmt|;
comment|/**< SubSystem ID */
name|uint32_t
name|ssvid
range|:
literal|16
decl_stmt|;
comment|/**< Subsystem Vendor ID */
else|#
directive|else
name|uint32_t
name|ssvid
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ssid
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg11_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg11_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg11
name|cvmx_pci_cfg11_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg12  *  * PCI_CFG12 = Thirteenth 32-bits of PCI config space (Expansion ROM Base Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg12
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg12_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|erbar
range|:
literal|16
decl_stmt|;
comment|/**< Expansion ROM Base Address[31:16] 64KB in size */
name|uint32_t
name|erbarz
range|:
literal|5
decl_stmt|;
comment|/**< Expansion ROM Base Base Address (Read as Zero) */
name|uint32_t
name|reserved_1_10
range|:
literal|10
decl_stmt|;
name|uint32_t
name|erbar_en
range|:
literal|1
decl_stmt|;
comment|/**< Expansion ROM Address Decode Enable */
else|#
directive|else
name|uint32_t
name|erbar_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_10
range|:
literal|10
decl_stmt|;
name|uint32_t
name|erbarz
range|:
literal|5
decl_stmt|;
name|uint32_t
name|erbar
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg12_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg12_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg12
name|cvmx_pci_cfg12_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg13  *  * PCI_CFG13 = Fourteenth 32-bits of PCI config space (Capabilities Pointer Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg13
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg13_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
name|uint32_t
name|cp
range|:
literal|8
decl_stmt|;
comment|/**< Capabilities Pointer */
else|#
directive|else
name|uint32_t
name|cp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg13_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg13_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg13
name|cvmx_pci_cfg13_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg15  *  * PCI_CFG15 = Sixteenth 32-bits of PCI config space (INT/ARB/LATENCY Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg15
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg15_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|ml
range|:
literal|8
decl_stmt|;
comment|/**< Maximum Latency */
name|uint32_t
name|mg
range|:
literal|8
decl_stmt|;
comment|/**< Minimum Grant */
name|uint32_t
name|inta
range|:
literal|8
decl_stmt|;
comment|/**< Interrupt Pin (INTA#) */
name|uint32_t
name|il
range|:
literal|8
decl_stmt|;
comment|/**< Interrupt Line */
else|#
directive|else
name|uint32_t
name|il
range|:
literal|8
decl_stmt|;
name|uint32_t
name|inta
range|:
literal|8
decl_stmt|;
name|uint32_t
name|mg
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ml
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg15_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg15_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg15
name|cvmx_pci_cfg15_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg16  *  * PCI_CFG16 = Seventeenth 32-bits of PCI config space (Target Implementation Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg16
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg16_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|trdnpr
range|:
literal|1
decl_stmt|;
comment|/**< Target Read Delayed Transaction for I/O and                                                          non-prefetchable regions discarded. */
name|uint32_t
name|trdard
range|:
literal|1
decl_stmt|;
comment|/**< Target Read Delayed Transaction for all regions                                                          discarded. */
name|uint32_t
name|rdsati
range|:
literal|1
decl_stmt|;
comment|/**< Target(I/O and Memory) Read Delayed/Split at                                                           timeout/immediately (default timeout).                                                          Note: OCTEON requires that this bit MBZ(must be zero). */
name|uint32_t
name|trdrs
range|:
literal|1
decl_stmt|;
comment|/**< Target(I/O and Memory) Read Delayed/Split or Retry                                                          select (of the application interface is not ready)                                                           0 = Delayed Split Transaction                                                           1 = Retry Transaction (always Immediate Retry, no                                                               AT_REQ to application). */
name|uint32_t
name|trtae
range|:
literal|1
decl_stmt|;
comment|/**< Target(I/O and Memory) Read Target Abort Enable                                                          (if application interface is not ready at the                                                          latency timeout).                                                          Note: OCTEON as target will never target-abort,                                                          therefore this bit should never be set. */
name|uint32_t
name|twsei
range|:
literal|1
decl_stmt|;
comment|/**< Target(I/O) Write Split Enable (at timeout /                                                          immediately; default timeout) */
name|uint32_t
name|twsen
range|:
literal|1
decl_stmt|;
comment|/**< T(I/O) write split Enable (if the application                                                          interface is not ready) */
name|uint32_t
name|twtae
range|:
literal|1
decl_stmt|;
comment|/**< Target(I/O and Memory) Write Target Abort Enable                                                          (if the application interface is not ready at the                                                          start of the cycle).                                                          Note: OCTEON as target will never target-abort,                                                          therefore this bit should never be set. */
name|uint32_t
name|tmae
range|:
literal|1
decl_stmt|;
comment|/**< Target(Read/Write) Master Abort Enable; check                                                          at the start of each transaction.                                                          Note: This bit can be used to force a Master                                                          Abort when OCTEON is acting as the intended target                                                          device. */
name|uint32_t
name|tslte
range|:
literal|3
decl_stmt|;
comment|/**< Target Subsequent(2nd-last) Latency Timeout Enable                                                          Valid range: [1..7] and 0=8. */
name|uint32_t
name|tilt
range|:
literal|4
decl_stmt|;
comment|/**< Target Initial(1st data) Latency Timeout in PCI                                                          ModeValid range: [8..15] and 0=16. */
name|uint32_t
name|pbe
range|:
literal|12
decl_stmt|;
comment|/**< Programmable Boundary Enable to disconnect/prefetch                                                          for target burst read cycles to prefetchable                                                          region in PCI. A value of 1 indicates end of                                                          boundary (64 KB down to 16 Bytes). */
name|uint32_t
name|dppmr
range|:
literal|1
decl_stmt|;
comment|/**< Disconnect/Prefetch to prefetchable memory                                                          regions Enable. Prefetchable memory regions                                                          are always disconnected on a region boundary.                                                          Non-prefetchable regions for PCI are always                                                          disconnected on the first transfer.                                                          Note: OCTEON as target will never target-disconnect,                                                          therefore this bit should never be set. */
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tswc
range|:
literal|1
decl_stmt|;
comment|/**< Target Split Write Control                                                          0 = Blocks all requests except PMW                                                          1 = Blocks all requests including PMW until                                                              split completion occurs. */
name|uint32_t
name|mltd
range|:
literal|1
decl_stmt|;
comment|/**< Master Latency Timer Disable                                                          Note: For OCTEON, it is recommended that this bit                                                          be set(to disable the Master Latency timer). */
else|#
directive|else
name|uint32_t
name|mltd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tswc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dppmr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pbe
range|:
literal|12
decl_stmt|;
name|uint32_t
name|tilt
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tslte
range|:
literal|3
decl_stmt|;
name|uint32_t
name|tmae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|twtae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|twsen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|twsei
range|:
literal|1
decl_stmt|;
name|uint32_t
name|trtae
range|:
literal|1
decl_stmt|;
name|uint32_t
name|trdrs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rdsati
range|:
literal|1
decl_stmt|;
name|uint32_t
name|trdard
range|:
literal|1
decl_stmt|;
name|uint32_t
name|trdnpr
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg16_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg16_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg16
name|cvmx_pci_cfg16_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg17  *  * PCI_CFG17 = Eighteenth 32-bits of PCI config space (Target Split Completion Message  * Enable Register)  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg17
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg17_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|tscme
range|:
literal|32
decl_stmt|;
comment|/**< Target Split Completion Message Enable                                                           [31:30]: 00                                                           [29]: Split Completion Error Indication                                                           [28]: 0                                                           [27:20]: Split Completion Message Index                                                           [19:0]: 0x00000                                                          For OCTEON, this register is intended for debug use                                                          only. (as such, it is recommended NOT to be written                                                          with anything other than ZEROES). */
else|#
directive|else
name|uint32_t
name|tscme
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg17_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg17_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg17
name|cvmx_pci_cfg17_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg18  *  * PCI_CFG18 = Nineteenth 32-bits of PCI config space (Target Delayed/Split Request  * Pending Sequences)  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg18
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg18_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|tdsrps
range|:
literal|32
decl_stmt|;
comment|/**< Target Delayed/Split Request Pending Sequences                                                          The application uses this address to remove a                                                          pending split sequence from the target queue by                                                          clearing the appropriate bit. Example: Clearing [14]                                                          clears the pending sequence \#14. An application                                                          or configuration write to this address can clear this                                                          register.                                                          For OCTEON, this register is intended for debug use                                                          only and MUST NEVER be written with anything other                                                          than ZEROES. */
else|#
directive|else
name|uint32_t
name|tdsrps
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg18_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg18_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg18
name|cvmx_pci_cfg18_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg19  *  * PCI_CFG19 = Twentieth 32-bits of PCI config space (Master/Target Implementation Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg19
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg19_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|mrbcm
range|:
literal|1
decl_stmt|;
comment|/**< Master Request (Memory Read) Byte Count/Byte                                                          Enable select.                                                            0 = Byte Enables valid. In PCI mode, a burst                                                                transaction cannot be performed using                                                                Memory Read command=4'h6.                                                            1 = DWORD Byte Count valid (default). In PCI                                                                Mode, the memory read byte enables are                                                                automatically generated by the core.                                                           NOTE:  For OCTEON, this bit must always be one                                                           for proper operation. */
name|uint32_t
name|mrbci
range|:
literal|1
decl_stmt|;
comment|/**< Master Request (I/O and CR cycles) byte count/byte                                                          enable select.                                                            0 = Byte Enables valid (default)                                                            1 = DWORD byte count valid                                                           NOTE: For OCTEON, this bit must always be zero                                                           for proper operation (in support of                                                           Type0/1 Cfg Space accesses which require byte                                                           enable generation directly from a read mask). */
name|uint32_t
name|mdwe
range|:
literal|1
decl_stmt|;
comment|/**< Master (Retry) Deferred Write Enable (allow                                                          read requests to pass).                                                           NOTE: Applicable to PCI Mode I/O and memory                                                           transactions only.                                                            0 = New read requests are NOT accepted until                                                                the current write cycle completes. [Reads                                                                cannot pass writes]                                                            1 = New read requests are accepted, even when                                                                there is a write cycle pending [Reads can                                                                pass writes].                                                           NOTE: For OCTEON, this bit must always be zero                                                           for proper operation. */
name|uint32_t
name|mdre
range|:
literal|1
decl_stmt|;
comment|/**< Master (Retry) Deferred Read Enable (Allows                                                          read/write requests to pass).                                                           NOTE: Applicable to PCI mode I/O and memory                                                           transactions only.                                                            0 = New read/write requests are NOT accepted                                                                until the current read cycle completes.                                                                [Read/write requests CANNOT pass reads]                                                            1 = New read/write requests are accepted, even                                                                when there is a read cycle pending.                                                                [Read/write requests CAN pass reads]                                                           NOTE: For OCTEON, this bit must always be zero                                                           for proper operation. */
name|uint32_t
name|mdrimc
range|:
literal|1
decl_stmt|;
comment|/**< Master I/O Deferred/Split Request Outstanding                                                          Maximum Count                                                            0 = MDRRMC[26:24]                                                            1 = 1 */
name|uint32_t
name|mdrrmc
range|:
literal|3
decl_stmt|;
comment|/**< Master Deferred Read Request Outstanding Max                                                          Count (PCI only).                                                           CR4C[26:24]  Max SAC cycles   MAX DAC cycles                                                            000              8                4                                                            001              1                0                                                            010              2                1                                                            011              3                1                                                            100              4                2                                                            101              5                2                                                            110              6                3                                                            111              7                3                                                           For example, if these bits are programmed to                                                           100, the core can support 2 DAC cycles, 4 SAC                                                           cycles or a combination of 1 DAC and 2 SAC cycles.                                                           NOTE: For the PCI-X maximum outstanding split                                                           transactions, refer to CRE0[22:20] */
name|uint32_t
name|tmes
range|:
literal|8
decl_stmt|;
comment|/**< Target/Master Error Sequence \# */
name|uint32_t
name|teci
range|:
literal|1
decl_stmt|;
comment|/**< Target Error Command Indication                                                          0 = Delayed/Split                                                          1 = Others */
name|uint32_t
name|tmei
range|:
literal|1
decl_stmt|;
comment|/**< Target/Master Error Indication                                                          0 = Target                                                          1 = Master */
name|uint32_t
name|tmse
range|:
literal|1
decl_stmt|;
comment|/**< Target/Master System Error. This bit is set                                                          whenever ATM_SERR_O is active. */
name|uint32_t
name|tmdpes
range|:
literal|1
decl_stmt|;
comment|/**< Target/Master Data PERR# error status. This                                                          bit is set whenever ATM_DATA_PERR_O is active. */
name|uint32_t
name|tmapes
range|:
literal|1
decl_stmt|;
comment|/**< Target/Master Address PERR# error status. This                                                          bit is set whenever ATM_ADDR_PERR_O is active. */
name|uint32_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint32_t
name|tibcd
range|:
literal|1
decl_stmt|;
comment|/**< Target Illegal I/O DWORD byte combinations detected. */
name|uint32_t
name|tibde
range|:
literal|1
decl_stmt|;
comment|/**< Target Illegal I/O DWORD byte detection enable */
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tidomc
range|:
literal|1
decl_stmt|;
comment|/**< Target I/O Delayed/Split request outstanding                                                          maximum count.                                                           0 = TDOMC[4:0]                                                           1 = 1 */
name|uint32_t
name|tdomc
range|:
literal|5
decl_stmt|;
comment|/**< Target Delayed/Split request outstanding maximum                                                          count. [1..31] and 0=32.                                                          NOTE: If the user programs these bits beyond the                                                          Designed Maximum outstanding count, then the                                                          designed maximum table depth will be used instead.                                                          No additional Deferred/Split transactions will be                                                          accepted if this outstanding maximum count                                                          is reached. Furthermore, no additional                                                          deferred/split transactions will be accepted if                                                          the I/O delay/ I/O Split Request outstanding                                                          maximum is reached.                                                          NOTE: For OCTEON in PCI Mode, this field MUST BE                                                          programmed to 1. (OCTEON can only handle 1 delayed                                                          read at a time).                                                          For OCTEON in PCIX Mode, this field can range from                                                          1-4. (The designed maximum table depth is 4                                                          for PCIX mode splits). */
else|#
directive|else
name|uint32_t
name|tdomc
range|:
literal|5
decl_stmt|;
name|uint32_t
name|tidomc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tibde
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tibcd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint32_t
name|tmapes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tmdpes
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tmse
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tmei
range|:
literal|1
decl_stmt|;
name|uint32_t
name|teci
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tmes
range|:
literal|8
decl_stmt|;
name|uint32_t
name|mdrrmc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mdrimc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mdre
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mdwe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrbci
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mrbcm
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg19_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg19_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg19
name|cvmx_pci_cfg19_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg20  *  * PCI_CFG20 = Twenty-first 32-bits of PCI config space (Master Deferred/Split Sequence Pending)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg20
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg20_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|mdsp
range|:
literal|32
decl_stmt|;
comment|/**< Master Deferred/Split sequence Pending                                                          For OCTEON, this register is intended for debug use                                                          only and MUST NEVER be written with anything other                                                          than ZEROES. */
else|#
directive|else
name|uint32_t
name|mdsp
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg20_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg20_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg20
name|cvmx_pci_cfg20_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg21  *  * PCI_CFG21 = Twenty-second 32-bits of PCI config space (Master Split Completion Message Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg21
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg21_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|scmre
range|:
literal|32
decl_stmt|;
comment|/**< Master Split Completion message received with                                                          error message.                                                          For OCTEON, this register is intended for debug use                                                          only and MUST NEVER be written with anything other                                                          than ZEROES. */
else|#
directive|else
name|uint32_t
name|scmre
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg21_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg21_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg21
name|cvmx_pci_cfg21_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg22  *  * PCI_CFG22 = Twenty-third 32-bits of PCI config space (Master Arbiter Control Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg22
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg22_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|mac
range|:
literal|7
decl_stmt|;
comment|/**< Master Arbiter Control                                                          [31:26]: Used only in Fixed Priority mode                                                                   (when [25]=1)                                                          [31:30]: MSI Request                                                             00 = Highest Priority                                                             01 = Medium Priority                                                             10 = Lowest Priority                                                             11 = RESERVED                                                          [29:28]: Target Split Completion                                                             00 = Highest Priority                                                             01 = Medium Priority                                                             10 = Lowest Priority                                                             11 = RESERVED                                                          [27:26]: New Request; Deferred Read,Deferred Write                                                             00 = Highest Priority                                                             01 = Medium Priority                                                             10 = Lowest Priority                                                             11 = RESERVED                                                          [25]: Fixed/Round Robin Priority Selector                                                             0 = Round Robin                                                             1 = Fixed                                                          NOTE: When [25]=1(fixed priority), the three levels                                                          [31:26] MUST BE programmed to have mutually exclusive                                                          priority levels for proper operation. (Failure to do                                                          so may result in PCI hangs). */
name|uint32_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint32_t
name|flush
range|:
literal|1
decl_stmt|;
comment|/**< AM_DO_FLUSH_I control                                                          NOTE: This bit MUST BE ONE for proper OCTEON operation */
name|uint32_t
name|mra
range|:
literal|1
decl_stmt|;
comment|/**< Master Retry Aborted */
name|uint32_t
name|mtta
range|:
literal|1
decl_stmt|;
comment|/**< Master TRDY timeout aborted */
name|uint32_t
name|mrv
range|:
literal|8
decl_stmt|;
comment|/**< Master Retry Value [1..255] and 0=infinite */
name|uint32_t
name|mttv
range|:
literal|8
decl_stmt|;
comment|/**< Master TRDY timeout value [1..255] and 0=disabled                                                          NOTE: For OCTEON, this bit must always be zero                                                          for proper operation. (OCTEON does not support                                                          master TRDY timeout - target is expected to be                                                          well behaved). */
else|#
directive|else
name|uint32_t
name|mttv
range|:
literal|8
decl_stmt|;
name|uint32_t
name|mrv
range|:
literal|8
decl_stmt|;
name|uint32_t
name|mtta
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mra
range|:
literal|1
decl_stmt|;
name|uint32_t
name|flush
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint32_t
name|mac
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg22_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg22_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg22
name|cvmx_pci_cfg22_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg56  *  * PCI_CFG56 = Fifty-seventh 32-bits of PCI config space (PCIX Capabilities Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg56
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg56_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
name|uint32_t
name|most
range|:
literal|3
decl_stmt|;
comment|/**< Maximum outstanding Split transactions                                                            Encoded Value    \#Max outstanding splits                                                                000                   1                                                                001                   2                                                                010                   3                                                                011                   4                                                                100                   8                                                                101                   8(clamped)                                                                110                   8(clamped)                                                                111                   8(clamped)                                                          NOTE: OCTEON only supports upto a MAXIMUM of 8                                                          outstanding master split transactions. */
name|uint32_t
name|mmbc
range|:
literal|2
decl_stmt|;
comment|/**< Maximum Memory Byte Count                                                                  [0=512B,1=1024B,2=2048B,3=4096B]                                                          NOTE: OCTEON does not support this field and has                                                          no effect on limiting the maximum memory byte count. */
name|uint32_t
name|roe
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable */
name|uint32_t
name|dpere
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error Recovery Enable */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer */
name|uint32_t
name|pxcid
range|:
literal|8
decl_stmt|;
comment|/**< PCI-X Capability ID */
else|#
directive|else
name|uint32_t
name|pxcid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|dpere
range|:
literal|1
decl_stmt|;
name|uint32_t
name|roe
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mmbc
range|:
literal|2
decl_stmt|;
name|uint32_t
name|most
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg56_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg56_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg56
name|cvmx_pci_cfg56_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg57  *  * PCI_CFG57 = Fifty-eigth 32-bits of PCI config space (PCIX Status Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg57
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg57_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|scemr
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Error Message Received */
name|uint32_t
name|mcrsd
range|:
literal|3
decl_stmt|;
comment|/**< Maximum Cumulative Read Size designed */
name|uint32_t
name|mostd
range|:
literal|3
decl_stmt|;
comment|/**< Maximum Outstanding Split transaction designed */
name|uint32_t
name|mmrbcd
range|:
literal|2
decl_stmt|;
comment|/**< Maximum Memory Read byte count designed */
name|uint32_t
name|dc
range|:
literal|1
decl_stmt|;
comment|/**< Device Complexity                                                          0 = Simple Device                                                          1 = Bridge Device */
name|uint32_t
name|usc
range|:
literal|1
decl_stmt|;
comment|/**< Unexpected Split Completion */
name|uint32_t
name|scd
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Discarded */
name|uint32_t
name|m133
range|:
literal|1
decl_stmt|;
comment|/**< 133MHz Capable */
name|uint32_t
name|w64
range|:
literal|1
decl_stmt|;
comment|/**< Indicates a 32b(=0) or 64b(=1) device */
name|uint32_t
name|bn
range|:
literal|8
decl_stmt|;
comment|/**< Bus Number. Updated on all configuration write                                                          (0x11=PCI)             cycles. Its value is dependent upon the PCI/X                                                          (0xFF=PCIX)            mode. */
name|uint32_t
name|dn
range|:
literal|5
decl_stmt|;
comment|/**< Device Number. Updated on all configuration                                                          write cycles. */
name|uint32_t
name|fn
range|:
literal|3
decl_stmt|;
comment|/**< Function Number */
else|#
directive|else
name|uint32_t
name|fn
range|:
literal|3
decl_stmt|;
name|uint32_t
name|dn
range|:
literal|5
decl_stmt|;
name|uint32_t
name|bn
range|:
literal|8
decl_stmt|;
name|uint32_t
name|w64
range|:
literal|1
decl_stmt|;
name|uint32_t
name|m133
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mmrbcd
range|:
literal|2
decl_stmt|;
name|uint32_t
name|mostd
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mcrsd
range|:
literal|3
decl_stmt|;
name|uint32_t
name|scemr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg57_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg57_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg57
name|cvmx_pci_cfg57_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg58  *  * PCI_CFG58 = Fifty-ninth 32-bits of PCI config space (Power Management Capabilities Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg58
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg58_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pmes
range|:
literal|5
decl_stmt|;
comment|/**< PME Support (D0 to D3cold) */
name|uint32_t
name|d2s
range|:
literal|1
decl_stmt|;
comment|/**< D2_Support */
name|uint32_t
name|d1s
range|:
literal|1
decl_stmt|;
comment|/**< D1_Support */
name|uint32_t
name|auxc
range|:
literal|3
decl_stmt|;
comment|/**< AUX_Current (0..375mA) */
name|uint32_t
name|dsi
range|:
literal|1
decl_stmt|;
comment|/**< Device Specific Initialization */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmec
range|:
literal|1
decl_stmt|;
comment|/**< PME Clock */
name|uint32_t
name|pcimiv
range|:
literal|3
decl_stmt|;
comment|/**< Indicates the version of the PCI                                                          Management                                                           Interface Specification with which the core                                                           complies.                                                             010b = Complies with PCI Management Interface                                                             Specification Revision 1.1 */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer */
name|uint32_t
name|pmcid
range|:
literal|8
decl_stmt|;
comment|/**< Power Management Capability ID */
else|#
directive|else
name|uint32_t
name|pmcid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pcimiv
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pmec
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dsi
range|:
literal|1
decl_stmt|;
name|uint32_t
name|auxc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|d1s
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d2s
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmes
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg58_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg58_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg58
name|cvmx_pci_cfg58_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg59  *  * PCI_CFG59 = Sixtieth 32-bits of PCI config space (Power Management Data/PMCSR Register(s))  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg59
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg59_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pmdia
range|:
literal|8
decl_stmt|;
comment|/**< Power Management data input from application                                                          (PME_DATA) */
name|uint32_t
name|bpccen
range|:
literal|1
decl_stmt|;
comment|/**< BPCC_En (bus power/clock control) enable */
name|uint32_t
name|bd3h
range|:
literal|1
decl_stmt|;
comment|/**< B2_B3\#, B2/B3 Support for D3hot */
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|pmess
range|:
literal|1
decl_stmt|;
comment|/**< PME_Status sticky bit */
name|uint32_t
name|pmedsia
range|:
literal|2
decl_stmt|;
comment|/**< PME_Data_Scale input from application                                                          Device                  (PME_DATA_SCALE[1:0])                                                          Specific */
name|uint32_t
name|pmds
range|:
literal|4
decl_stmt|;
comment|/**< Power Management Data_select */
name|uint32_t
name|pmeens
range|:
literal|1
decl_stmt|;
comment|/**< PME_En sticky bit */
name|uint32_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint32_t
name|ps
range|:
literal|2
decl_stmt|;
comment|/**< Power State (D0 to D3)                                                          The N2 DOES NOT support D1/D2 Power Management                                                          states, therefore writing to this register has                                                          no effect (please refer to the PCI Power                                                          Management                                                          Specification v1.1 for further details about                                                          it?s R/W nature. This is not a conventional                                                          R/W style register. */
else|#
directive|else
name|uint32_t
name|ps
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint32_t
name|pmeens
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmds
range|:
literal|4
decl_stmt|;
name|uint32_t
name|pmedsia
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pmess
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|bd3h
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bpccen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pmdia
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg59_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg59_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg59
name|cvmx_pci_cfg59_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg60  *  * PCI_CFG60 = Sixty-first 32-bits of PCI config space (MSI Capabilities Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg60
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg60_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|m64
range|:
literal|1
decl_stmt|;
comment|/**< 32/64 b message */
name|uint32_t
name|mme
range|:
literal|3
decl_stmt|;
comment|/**< Multiple Message Enable(1,2,4,8,16,32) */
name|uint32_t
name|mmc
range|:
literal|3
decl_stmt|;
comment|/**< Multiple Message Capable(0=1,1=2,2=4,3=8,4=16,5=32) */
name|uint32_t
name|msien
range|:
literal|1
decl_stmt|;
comment|/**< MSI Enable */
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
comment|/**< Next Capability Pointer */
name|uint32_t
name|msicid
range|:
literal|8
decl_stmt|;
comment|/**< MSI Capability ID */
else|#
directive|else
name|uint32_t
name|msicid
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ncp
range|:
literal|8
decl_stmt|;
name|uint32_t
name|msien
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mmc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|mme
range|:
literal|3
decl_stmt|;
name|uint32_t
name|m64
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg60_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg60_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg60
name|cvmx_pci_cfg60_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg61  *  * PCI_CFG61 = Sixty-second 32-bits of PCI config space (MSI Lower Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg61
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg61_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|msi31t2
range|:
literal|30
decl_stmt|;
comment|/**< App Specific    MSI Address [31:2] */
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint32_t
name|msi31t2
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg61_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg61_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg61
name|cvmx_pci_cfg61_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg62  *  * PCI_CFG62 = Sixty-third 32-bits of PCI config space (MSI Upper Address Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg62
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg62_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|msi
range|:
literal|32
decl_stmt|;
comment|/**< MSI Address [63:32] */
else|#
directive|else
name|uint32_t
name|msi
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg62_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg62_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg62
name|cvmx_pci_cfg62_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cfg63  *  * PCI_CFG63 = Sixty-fourth 32-bits of PCI config space (MSI Message Data Register)  *  */
end_comment

begin_union
union|union
name|cvmx_pci_cfg63
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_cfg63_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|msimd
range|:
literal|16
decl_stmt|;
comment|/**< MSI Message Data */
else|#
directive|else
name|uint32_t
name|msimd
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cfg63_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cfg63_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cfg63
name|cvmx_pci_cfg63_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_cnt_reg  *  * PCI_CNT_REG = PCI Clock Count Register  *  * This register is provided to software as a means to determine PCI Bus Type/Speed.  */
end_comment

begin_union
union|union
name|cvmx_pci_cnt_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_cnt_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|hm_pcix
range|:
literal|1
decl_stmt|;
comment|/**< PCI Host Mode Sampled Bus Type (0:PCI/1:PCIX)                                                          This field represents what OCTEON(in Host mode)                                                          sampled as the 'intended' PCI Bus Type based on                                                          the PCI_PCIXCAP pin. (see HM_SPEED Bus Type/Speed                                                          encoding table). */
name|uint64_t
name|hm_speed
range|:
literal|2
decl_stmt|;
comment|/**< PCI Host Mode Sampled Bus Speed                                                           This field represents what OCTEON(in Host mode)                                                           sampled as the 'intended' PCI Bus Speed based on                                                           the PCI100, PCI_M66EN and PCI_PCIXCAP pins.                                                           NOTE: This DOES NOT reflect what the actual PCI                                                           Bus Type/Speed values are. They only indicate what                                                           OCTEON sampled as the 'intended' values.                                                           PCI Host Mode Sampled Bus Type/Speed Table:                                                             M66EN | PCIXCAP | PCI100  |  HM_PCIX | HM_SPEED[1:0]                                                          ---------+---------+---------+----------+-------------                                                               0   |    0    |    0    | 0=PCI    |  00=33 MHz                                                               0   |    0    |    1    | 0=PCI    |  00=33 MHz                                                               0   |    Z    |    0    | 0=PCI    |  01=66 MHz                                                               0   |    Z    |    1    | 0=PCI    |  01=66 MHz                                                               1   |    0    |    0    | 0=PCI    |  01=66 MHz                                                               1   |    0    |    1    | 0=PCI    |  01=66 MHz                                                               1   |    Z    |    0    | 0=PCI    |  01=66 MHz                                                               1   |    Z    |    1    | 0=PCI    |  01=66 MHz                                                               0   |    1    |    1    | 1=PCIX   |  10=100 MHz                                                               1   |    1    |    1    | 1=PCIX   |  10=100 MHz                                                               0   |    1    |    0    | 1=PCIX   |  11=133 MHz                                                               1   |    1    |    0    | 1=PCIX   |  11=133 MHz                                                           NOTE: PCIXCAP has tri-level value (0,1,Z). See PCI specification                                                           for more details on board level hookup to achieve these                                                           values.                                                           NOTE: Software can use the NPI_PCI_INT_ARB_CFG[PCI_OVR]                                                           to override the 'sampled' PCI Bus Type/Speed.                                                           NOTE: Software can also use the PCI_CNT_REG[PCICNT] to determine                                                           the exact PCI(X) Bus speed.                                                           Example: PCI_REF_CLKIN=133MHz                                                              PCI_HOST_MODE=1                                                              PCI_M66EN=0                                                              PCI_PCIXCAP=1                                                              PCI_PCI100=1                                                           For this example, OCTEON will generate                                                           PCI_CLK_OUT=100MHz and drive the proper PCI                                                           Initialization sequence (DEVSEL#=Deasserted,                                                           STOP#=Asserted, TRDY#=Asserted) during PCI_RST_N                                                           deassertion.                                                           NOTE: The HM_SPEED field is only valid after                                                           PLL_REF_CLK is active and PLL_DCOK is asserted.                                                           (see HRM description for power-on/reset sequence).                                                           NOTE: PCI_REF_CLKIN input must be 133MHz (and is used                                                           to generate the PCI_CLK_OUT pin in Host Mode). */
name|uint64_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
comment|/**< PCI(X) Bus Type (0:PCI/1:PCIX)                                                          At PCI_RST_N de-assertion, the PCI Initialization                                                          pattern(PCI_DEVSEL_N, PCI_STOP_N, PCI_TRDY_N) is                                                          captured to provide information to software regarding                                                          the PCI Bus Type(PCI/PCIX) and PCI Bus Speed Range. */
name|uint64_t
name|ap_speed
range|:
literal|2
decl_stmt|;
comment|/**< PCI(X) Bus Speed (0:33/1:66/2:100/3:133)                                                                                     At PCI_RST_N de-assertion, the PCI Initialization                                                                                     pattern(PCI_DEVSEL_N, PCI_STOP_N, PCI_TRDY_N) is                                                                                     captured to provide information to software regarding                                                                                     the PCI Bus Type(PCI/PCIX) and PCI Bus Speed Range.                                                                                     PCI-X Initialization Pattern(see PCIX Spec):                                                            PCI_DEVSEL_N PCI_STOP_N PCI_TRDY_N Mode    MaxClk(ns) MinClk(ns) MinClk(MHz) MaxClk(MHz)                                                          -------------+----------+----------+-------+---------+----------+----------+------------------                                                             Deasserted Deasserted Deasserted PCI 33    --         30          0         33                                                                                              PCI 66    30         15         33         66                                                             Deasserted Deasserted Asserted   PCI-X     20         15         50         66                                                             Deasserted Asserted   Deasserted PCI-X     15         10         66        100                                                             Deasserted Asserted   Asserted   PCI-X     10         7.5       100        133                                                             Asserted   Deasserted Deasserted PCI-X   Reserved   Reserved   Reserved   Reserved                                                             Asserted   Deasserted Asserted   PCI-X   Reserved   Reserved   Reserved   Reserved                                                             Asserted   Asserted   Deasserted PCI-X   Reserved   Reserved   Reserved   Reserved                                                             Asserted   Asserted   Asserted   PCI-X   Reserved   Reserved   Reserved   Reserved                                                                                     NOTE: The PCI Bus speed 'assumed' from the initialization                                                                                     pattern is really intended for an operational range.                                                                                     For example: If PINIT=100, this indicates PCI-X in the                                                                                     100-133MHz range. The PCI_CNT field can be used to further                                                                                     determine a more exacting PCI Bus frequency value if                                                                                     required. */
name|uint64_t
name|pcicnt
range|:
literal|32
decl_stmt|;
comment|/**< Free Running PCI Clock counter.                                                          At PCI Reset, the PCICNT=0, and is auto-incremented                                                          on every PCI clock and will auto-wrap back to zero                                                          when saturated.                                                          NOTE: Writes override the auto-increment to allow                                                          software to preload any initial value.                                                          The PCICNT field is provided to software as a means                                                          to determine the PCI Bus Speed.                                                          Assuming software has knowledge of the core frequency                                                          (eclk), this register can be written with a value X,                                                          wait 'n' core clocks(eclk) and then read later(Y) to                                                          determine \#PCI clocks(Y-X) have elapsed within 'n' core                                                          clocks to determine the PCI input Clock frequency. */
else|#
directive|else
name|uint64_t
name|pcicnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ap_speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hm_speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|hm_pcix
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_cnt_reg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_cnt_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_cnt_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_cnt_reg
name|cvmx_pci_cnt_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_ctl_status_2  *  * PCI_CTL_STATUS_2 = PCI Control Status 2 Register  *  * Control status register accessable from both PCI and NCB.  */
end_comment

begin_union
union|union
name|cvmx_pci_ctl_status_2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_ctl_status_2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint32_t
name|bb1_hole
range|:
literal|3
decl_stmt|;
comment|/**< Big BAR 1 Hole                                                          NOT IN PASS 1 NOR PASS 2                                                          When PCI_CTL_STATUS_2[BB1]=1, this field defines                                                          an encoded size of the upper BAR1 region which                                                          OCTEON will mask out (ie: not respond to).                                                          (see definition of BB1_HOLE and BB1_SIZ encodings                                                          in the PCI_CTL_STATUS_2[BB1] definition below). */
name|uint32_t
name|bb1_siz
range|:
literal|1
decl_stmt|;
comment|/**< Big BAR 1 Size                                                          NOT IN PASS 1 NOR PASS 2                                                          When PCI_CTL_STATUS_2[BB1]=1, this field defines                                                          the programmable SIZE of BAR 1.                                                            - 0: 1GB / 1: 2GB */
name|uint32_t
name|bb_ca
range|:
literal|1
decl_stmt|;
comment|/**< Set to '1' for Big Bar Mode to do STT/LDT L2C                                                          operations.                                                          NOT IN PASS 1 NOR PASS 2 */
name|uint32_t
name|bb_es
range|:
literal|2
decl_stmt|;
comment|/**< Big Bar Node Endian Swap Mode                                                            - 0: No Swizzle                                                            - 1: Byte Swizzle (per-QW)                                                            - 2: Byte Swizzle (per-LW)                                                            - 3: LongWord Swizzle                                                          NOT IN PASS 1 NOR PASS 2 */
name|uint32_t
name|bb1
range|:
literal|1
decl_stmt|;
comment|/**< Big Bar 1 Enable                                                          NOT IN PASS 1 NOR PASS 2                                                          When PCI_CTL_STATUS_2[BB1] is set, the following differences                                                          occur:                                                          - OCTEON's BAR1 becomes somewhere in the range 512-2048 MB rather                                                            than the default 128MB.                                                          - The following table indicates the effective size of                                                            BAR1 when BB1 is set:                                                              BB1_SIZ   BB1_HOLE  Effective size    Comment                                                            +++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                                                 0          0         1024 MB      Normal 1GB BAR                                                                 0          1         1008 MB      1 GB, 16 MB hole                                                                 0          2          992 MB      1 GB, 32 MB hole                                                                 0          3          960 MB      1 GB, 64 MB hole                                                                 0          4          896 MB      1 GB,128 MB hole                                                                 0          5          768 MB      1 GB,256 MB hole                                                                 0          6          512 MB      1 GB,512 MB hole                                                                 0          7         Illegal                                                                 1          0         2048 MB      Normal 2GB BAR                                                                 1          1         2032 MB      2 GB, 16 MB hole                                                                 1          2         2016 MB      2 GB, 32 MB hole                                                                 1          3         1984 MB      2 GB, 64 MB hole                                                                 1          4         1920 MB      2 GB,128 MB hole                                                                 1          5         1792 MB      2 GB,256 MB hole                                                                 1          6         1536 MB      2 GB,512 MB hole                                                                 1          7         Illegal                                                          - When BB1_SIZ is 0: PCI_CFG06[LBASE<2:0>] reads as zero                                                            and are ignored on write. BAR1 is an entirely ordinary                                                            1 GB (power-of-two) BAR in all aspects when BB1_HOLE is 0.                                                            When BB1_HOLE is not zero, BAR1 addresses are programmed                                                            as if the BAR were 1GB, but, OCTEON does not respond                                                            to addresses in the programmed holes.                                                          - When BB1_SIZ is 1: PCI_CFG06[LBASE<3:0>] reads as zero                                                            and are ignored on write. BAR1 is an entirely ordinary                                                            2 GB (power-of-two) BAR in all aspects when BB1_HOLE is 0.                                                            When BB1_HOLE is not zero, BAR1 addresses are programmed                                                            as if the BAR were 2GB, but, OCTEON does not respond                                                            to addresses in the programmed holes.                                                          - Note that the BB1_HOLE value has no effect on the                                                            PCI_CFG06[LBASE] behavior. BB1_HOLE only affects whether                                                            OCTEON accepts an address. BB1_SIZ does affect PCI_CFG06[LBASE]                                                            behavior, however.                                                          - The first 128MB, i.e. addresses on the PCI bus in the range                                                              BAR1+0          .. BAR1+0x07FFFFFF                                                            access OCTEON's DRAM addresses with PCI_BAR1_INDEX CSR's                                                            as before                                                          - The remaining address space, i.e. addresses                                                            on the PCI bus in the range                                                               BAR1+0x08000000 .. BAR1+size-1,                                                            where size is the size of BAR1 as selected by the above                                                            table (based on the BB1_SIZ and BB1_HOLE values), are mapped to                                                            OCTEON physical DRAM addresses as follows:                                                                    PCI Address Range         OCTEON Physical Address Range                                                            ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++                                                             BAR1+0x08000000 .. BAR1+size-1 | 0x88000000 .. 0x7FFFFFFF+size                                                            and PCI_CTL_STATUS_2[BB_ES] is the endian-swap and                                                            PCI_CTL_STATUS_2[BB_CA] is the L2 cache allocation bit                                                            for these references.                                                            The consequences of any burst that crosses the end of the PCI                                                            Address Range for BAR1 are unpredicable.                                                          - The consequences of any burst access that crosses the boundary                                                            between BAR1+0x07FFFFFF and BAR1+0x08000000 are unpredictable in PCI-X                                                            mode. OCTEON may disconnect PCI references at this boundary. */
name|uint32_t
name|bb0
range|:
literal|1
decl_stmt|;
comment|/**< Big Bar 0 Enable                                                          NOT IN PASS 1 NOR PASS 2                                                          When PCI_CTL_STATUS_2[BB0] is set, the following                                                          differences occur:                                                          - OCTEON's BAR0 becomes 2GB rather than the default 4KB.                                                            PCI_CFG04[LBASE<18:0>] reads as zero and is ignored on write.                                                          - OCTEON's BAR0 becomes burstable. (When BB0 is clear, OCTEON                                                            single-phase disconnects PCI BAR0 reads and PCI/PCI-X BAR0                                                            writes, and splits (burstably) PCI-X BAR0 reads.)                                                          - The first 4KB, i.e. addresses on the PCI bus in the range                                                                BAR0+0      .. BAR0+0xFFF                                                            access OCTEON's PCI-type CSR's as when BB0 is clear.                                                          - The remaining address space, i.e. addresses on the PCI bus                                                            in the range                                                                BAR0+0x1000 .. BAR0+0x7FFFFFFF                                                            are mapped to OCTEON physical DRAM addresses as follows:                                                               PCI Address Range                  OCTEON Physical Address Range                                                            ------------------------------------+------------------------------                                                             BAR0+0x00001000 .. BAR0+0x0FFFFFFF | 0x000001000 .. 0x00FFFFFFF                                                             BAR0+0x10000000 .. BAR0+0x1FFFFFFF | 0x410000000 .. 0x41FFFFFFF                                                             BAR0+0x20000000 .. BAR0+0x7FFFFFFF | 0x020000000 .. 0x07FFFFFFF                                                            and PCI_CTL_STATUS_2[BB_ES] is the endian-swap and                                                            PCI_CTL_STATUS_2[BB_CA] is the L2 cache allocation bit                                                            for these references.                                                            The consequences of any burst that crosses the end of the PCI                                                            Address Range for BAR0 are unpredicable.                                                          - The consequences of any burst access that crosses the boundary                                                            between BAR0+0xFFF and BAR0+0x1000 are unpredictable in PCI-X                                                            mode. OCTEON may disconnect PCI references at this boundary.                                                          - The results of any burst read that crosses the boundary                                                            between BAR0+0x0FFFFFFF and BAR0+0x10000000 are unpredictable.                                                            The consequences of any burst write that crosses this same                                                            boundary are unpredictable.                                                          - The results of any burst read that crosses the boundary                                                            between BAR0+0x1FFFFFFF and BAR0+0x20000000 are unpredictable.                                                            The consequences of any burst write that crosses this same                                                            boundary are unpredictable. */
name|uint32_t
name|erst_n
range|:
literal|1
decl_stmt|;
comment|/**< Reset active Low. PASS-2 */
name|uint32_t
name|bar2pres
range|:
literal|1
decl_stmt|;
comment|/**< From fuse block. When fuse(MIO_FUS_DAT3[BAR2_EN])                                                          is NOT blown the value of this field is '0' after                                                          reset and BAR2 is NOT present. When the fuse IS                                                          blown the value of this field is '1' after reset                                                          and BAR2 is present. Note that SW can change this                                                          field after reset. This is a PASS-2 field. */
name|uint32_t
name|scmtyp
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Message CMD Type (0=RD/1=WR)                                                          When SCM=1, SCMTYP specifies the CMD intent (R/W) */
name|uint32_t
name|scm
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Message Detected (Read or Write) */
name|uint32_t
name|en_wfilt
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the window-access filter is enabled.                                                          Unfilter writes are:                                                          MIO, SubId0                                                          MIO, SubId7                                                          NPI, SubId0                                                          NPI, SubId7                                                          POW, SubId7                                                          DFA, SubId7                                                          IPD, SubId7                                                          Unfiltered Reads are:                                                          MIO, SubId0                                                          MIO, SubId7                                                          NPI, SubId0                                                          NPI, SubId7                                                          POW, SubId1                                                          POW, SubId2                                                          POW, SubId3                                                          POW, SubId7                                                          DFA, SubId7                                                          IPD, SubId7 */
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
comment|/**< PCX Core Mode status (0=PCI Bus/1=PCIX)                                                          If one or more of PCI_DEVSEL_N, PCI_STOP_N, and                                                          PCI_TRDY_N are asserted at the rising edge of                                                          PCI_RST_N, the device enters PCI-X mode.                                                          Otherwise, the device enters conventional PCI                                                          mode at the rising edge of RST#. */
name|uint32_t
name|ap_64ad
range|:
literal|1
decl_stmt|;
comment|/**< PCX Core Bus status (0=32b Bus/1=64b Bus)                                                          When PCI_RST_N pin is de-asserted, the state                                                          of PCI_REQ64_N(driven by central agent) determines                                                          the width of the PCI/X bus. */
name|uint32_t
name|b12_bist
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For Memeory In B12 */
name|uint32_t
name|pmo_amod
range|:
literal|1
decl_stmt|;
comment|/**< PMO-ARB Mode (0=FP[HP=CMD1,LP=CMD0]/1=RR) */
name|uint32_t
name|pmo_fpc
range|:
literal|3
decl_stmt|;
comment|/**< PMO-ARB Fixed Priority Counter                                                          When PMO_AMOD=0 (FP mode), this field represents                                                          the \# of CMD1 requests that are issued (at higher                                                          priority) before a single lower priority CMD0                                                          is allowed to issue (to ensure foward progress).                                                            - 0: 1 CMD1 Request issued before CMD0 allowed                                                            - ...                                                            - 7: 8 CMD1 Requests issued before CMD0 allowed */
name|uint32_t
name|tsr_hwm
range|:
literal|3
decl_stmt|;
comment|/**< Target Split-Read ADB(allowable disconnect boundary)                                                          High Water Mark.                                                          Specifies the number of ADBs(128 Byte aligned chunks)                                                          that are accumulated(pending) BEFORE the Target Split                                                          completion is attempted on the PCI bus.                                                             - 0: RESERVED/ILLEGAL                                                             - 1: 2 Pending ADBs (129B-256B)                                                             - 2: 3 Pending ADBs (257B-384B)                                                             - 3: 4 Pending ADBs (385B-512B)                                                             - 4: 5 Pending ADBs (513B-640B)                                                             - 5: 6 Pending ADBs (641B-768B)                                                             - 6: 7 Pending ADBs (769B-896B)                                                             - 7: 8 Pending ADBs (897B-1024B)                                                          Example: Suppose a 1KB target memory request with                                                          starting byte offset address[6:0]=0x7F is split by                                                          the OCTEON and the TSR_HWM=1(2 ADBs).                                                          The OCTEON will start the target split completion                                                          on the PCI Bus after 1B(1st ADB)+128B(2nd ADB)=129B                                                          of data have been received from memory (even though                                                          the remaining 895B has not yet been received). The                                                          OCTEON will continue the split completion until it                                                          has consumed all of the pended split data. If the                                                          full transaction length(1KB) of data was NOT entirely                                                          transferred, then OCTEON will terminate the split                                                          completion and again wait for another 2 ADB-aligned data                                                          chunks(256B) of pended split data to be received from                                                          memory before starting another split completion request.                                                          This allows Octeon (as split completer), to send back                                                          multiple split completions for a given large split                                                          transaction without having to wait for the entire                                                          transaction length to be received from memory.                                                          NOTE: For split transaction sizes 'smaller' than the                                                          specified TSR_HWM value, the split completion                                                          is started when the last datum has been received from                                                          memory.                                                          NOTE: It is IMPERATIVE that this field NEVER BE                                                          written to a ZERO value. A value of zero is                                                          reserved/illegal and can result in PCIX bus hangs). */
name|uint32_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BAR2 is enable and will respond when                                                          clear '0' BAR2 access will be target-aborted. */
name|uint32_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
comment|/**< Value will be XORed with pci-address[37:36] to                                                          determine the endian swap mode. */
name|uint32_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
comment|/**< Value will be XORed with pci-address[38] to                                                          determine the L2 cache attribute.                                                          When XOR result is 1, not cached in L2 */
else|#
directive|else
name|uint32_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
name|uint32_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tsr_hwm
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pmo_fpc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pmo_amod
range|:
literal|1
decl_stmt|;
name|uint32_t
name|b12_bist
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_64ad
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|en_wfilt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scmtyp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bar2pres
range|:
literal|1
decl_stmt|;
name|uint32_t
name|erst_n
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bb0
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bb1
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bb_es
range|:
literal|2
decl_stmt|;
name|uint32_t
name|bb_ca
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bb1_siz
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bb1_hole
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_ctl_status_2_s
name|cn30xx
decl_stmt|;
struct|struct
name|cvmx_pci_ctl_status_2_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|erst_n
range|:
literal|1
decl_stmt|;
comment|/**< Reset active Low. */
name|uint32_t
name|bar2pres
range|:
literal|1
decl_stmt|;
comment|/**< From fuse block. When fuse(MIO_FUS_DAT3[BAR2_EN])                                                          is NOT blown the value of this field is '0' after                                                          reset and BAR2 is NOT present. When the fuse IS                                                          blown the value of this field is '1' after reset                                                          and BAR2 is present. Note that SW can change this                                                          field after reset. */
name|uint32_t
name|scmtyp
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Message CMD Type (0=RD/1=WR)                                                          When SCM=1, SCMTYP specifies the CMD intent (R/W) */
name|uint32_t
name|scm
range|:
literal|1
decl_stmt|;
comment|/**< Split Completion Message Detected (Read or Write) */
name|uint32_t
name|en_wfilt
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the window-access filter is enabled.                                                          Unfilter writes are:                                                          MIO,  SubId0                                                          MIO,  SubId7                                                          NPI,  SubId0                                                          NPI,  SubId7                                                          POW,  SubId7                                                          DFA,  SubId7                                                          IPD,  SubId7                                                          USBN, SubId7                                                          Unfiltered Reads are:                                                          MIO,  SubId0                                                          MIO,  SubId7                                                          NPI,  SubId0                                                          NPI,  SubId7                                                          POW,  SubId1                                                          POW,  SubId2                                                          POW,  SubId3                                                          POW,  SubId7                                                          DFA,  SubId7                                                          IPD,  SubId7                                                          USBN, SubId7 */
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
comment|/**< PCX Core Mode status (0=PCI Bus/1=PCIX) */
name|uint32_t
name|ap_64ad
range|:
literal|1
decl_stmt|;
comment|/**< PCX Core Bus status (0=32b Bus/1=64b Bus) */
name|uint32_t
name|b12_bist
range|:
literal|1
decl_stmt|;
comment|/**< Bist Status For Memeory In B12 */
name|uint32_t
name|pmo_amod
range|:
literal|1
decl_stmt|;
comment|/**< PMO-ARB Mode (0=FP[HP=CMD1,LP=CMD0]/1=RR) */
name|uint32_t
name|pmo_fpc
range|:
literal|3
decl_stmt|;
comment|/**< PMO-ARB Fixed Priority Counter                                                          When PMO_AMOD=0 (FP mode), this field represents                                                          the \# of CMD1 requests that are issued (at higher                                                          priority) before a single lower priority CMD0                                                          is allowed to issue (to ensure foward progress).                                                            - 0: 1 CMD1 Request issued before CMD0 allowed                                                            - ...                                                            - 7: 8 CMD1 Requests issued before CMD0 allowed */
name|uint32_t
name|tsr_hwm
range|:
literal|3
decl_stmt|;
comment|/**< Target Split-Read ADB(allowable disconnect boundary)                                                          High Water Mark.                                                          Specifies the number of ADBs(128 Byte aligned chunks)                                                          that are accumulated(pending) BEFORE the Target Split                                                          completion is attempted on the PCI bus.                                                             - 0: RESERVED/ILLEGAL                                                             - 1: 2 Pending ADBs (129B-256B)                                                             - 2: 3 Pending ADBs (257B-384B)                                                             - 3: 4 Pending ADBs (385B-512B)                                                             - 4: 5 Pending ADBs (513B-640B)                                                             - 5: 6 Pending ADBs (641B-768B)                                                             - 6: 7 Pending ADBs (769B-896B)                                                             - 7: 8 Pending ADBs (897B-1024B)                                                          Example: Suppose a 1KB target memory request with                                                          starting byte offset address[6:0]=0x7F is split by                                                          the OCTEON and the TSR_HWM=1(2 ADBs).                                                          The OCTEON will start the target split completion                                                          on the PCI Bus after 1B(1st ADB)+128B(2nd ADB)=129B                                                          of data have been received from memory (even though                                                          the remaining 895B has not yet been received). The                                                          OCTEON will continue the split completion until it                                                          has consumed all of the pended split data. If the                                                          full transaction length(1KB) of data was NOT entirely                                                          transferred, then OCTEON will terminate the split                                                          completion and again wait for another 2 ADB-aligned data                                                          chunks(256B) of pended split data to be received from                                                          memory before starting another split completion request.                                                          This allows Octeon (as split completer), to send back                                                          multiple split completions for a given large split                                                          transaction without having to wait for the entire                                                          transaction length to be received from memory.                                                          NOTE: For split transaction sizes 'smaller' than the                                                          specified TSR_HWM value, the split completion                                                          is started when the last datum has been received from                                                          memory.                                                          NOTE: It is IMPERATIVE that this field NEVER BE                                                          written to a ZERO value. A value of zero is                                                          reserved/illegal and can result in PCIX bus hangs). */
name|uint32_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BAR2 is enable and will respond when                                                          clear '0' BAR2 access will be target-aborted. */
name|uint32_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
comment|/**< Value will be XORed with pci-address[37:36] to                                                          determine the endian swap mode. */
name|uint32_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
comment|/**< Value will be XORed with pci-address[38] to                                                          determine the L2 cache attribute.                                                          When XOR result is 1, not allocated in L2 cache */
else|#
directive|else
name|uint32_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
name|uint32_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tsr_hwm
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pmo_fpc
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pmo_amod
range|:
literal|1
decl_stmt|;
name|uint32_t
name|b12_bist
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_64ad
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ap_pcix
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|en_wfilt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|scmtyp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bar2pres
range|:
literal|1
decl_stmt|;
name|uint32_t
name|erst_n
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pci_ctl_status_2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_ctl_status_2_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_ctl_status_2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_ctl_status_2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_ctl_status_2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_ctl_status_2
name|cvmx_pci_ctl_status_2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_dbell#  *  * PCI_DBELL0 = PCI Doorbell-0  *  * The value to write to the doorbell 0 register. The value in this register is acted upon when the  * least-significant-byte of this register is written.  */
end_comment

begin_union
union|union
name|cvmx_pci_dbellx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_dbellx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|inc_val
range|:
literal|16
decl_stmt|;
comment|/**< Software writes this register with the                                                          number of new Instructions to be processed                                                          on the Instruction Queue. When read this                                                          register contains the last write value. */
else|#
directive|else
name|uint32_t
name|inc_val
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_dbellx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_dbellx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_dbellx
name|cvmx_pci_dbellx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_dma_cnt#  *  * PCI_DMA_CNT0 = PCI DMA Count0  *  * Keeps track of the number of DMAs or bytes sent by DMAs. The value in this register is acted upon when the  * least-significant-byte of this register is written.  */
end_comment

begin_union
union|union
name|cvmx_pci_dma_cntx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_dma_cntx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dma_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Update with the number of DMAs completed or the                                                          number of bytes sent for DMA's associated with                                                          this counter. When this register is written the                                                          value written to [15:0] will be subtracted from                                                          the value in this register. */
else|#
directive|else
name|uint32_t
name|dma_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_cntx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_dma_cntx
name|cvmx_pci_dma_cntx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_dma_int_lev#  *  * PCI_DMA_INT_LEV0 = PCI DMA Sent Interrupt Level For DMA 0  *  * Interrupt when the value in PCI_DMA_CNT0 is equal to or greater than the register value.  */
end_comment

begin_union
union|union
name|cvmx_pci_dma_int_levx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_dma_int_levx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
comment|/**< When PCI_DMA_CNT0 exceeds the value in this                                                          DCNT0 will be set in PCI_INT_SUM and PCI_INT_SUM2. */
else|#
directive|else
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_int_levx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_dma_int_levx
name|cvmx_pci_dma_int_levx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_dma_time#  *  * PCI_DMA_TIME0 = PCI DMA Sent Timer For DMA0  *  * Time to wait from DMA being sent before issuing an interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pci_dma_timex
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_dma_timex_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|dma_time
range|:
literal|32
decl_stmt|;
comment|/**< Number of PCI clock cycle to wait before                                                          setting DTIME0 in PCI_INT_SUM and PCI_INT_SUM2.                                                          After PCI_DMA_CNT0 becomes non-zero.                                                          The timer is reset when the                                                          PCI_INT_SUM[27] register is cleared. */
else|#
directive|else
name|uint32_t
name|dma_time
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_dma_timex_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_dma_timex
name|cvmx_pci_dma_timex_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_instr_count#  *  * PCI_INSTR_COUNT0 = PCI Instructions Outstanding Request Count  *  * The number of instructions to be fetched by the Instruction-0 Engine.  */
end_comment

begin_union
union|union
name|cvmx_pci_instr_countx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_instr_countx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|icnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of Instructions to be fetched by the                                                          Instruction Engine.                                                          A write of any non zero value to this register                                                          will clear the value of this register. */
else|#
directive|else
name|uint32_t
name|icnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_instr_countx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_instr_countx
name|cvmx_pci_instr_countx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_int_enb  *  * PCI_INT_ENB = PCI Interrupt Enable  *  * Enables interrupt bits in the PCI_INT_SUM register.  */
end_comment

begin_union
union|union
name|cvmx_pci_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_int_enb_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[29] */
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[28] */
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[27] */
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[26] */
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[25] */
name|uint64_t
name|iptime3
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[24] */
name|uint64_t
name|iptime2
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[23] */
name|uint64_t
name|iptime1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[22] */
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[21] */
name|uint64_t
name|ipcnt3
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[20] */
name|uint64_t
name|ipcnt2
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[19] */
name|uint64_t
name|ipcnt1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[18] */
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[17] */
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[14] */
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[13] */
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[12] */
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[11] */
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[10] */
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[9] */
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[8] */
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[7] */
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[6] */
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[5] */
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[4] */
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[3] */
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[2] */
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[1] */
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[0] */
else|#
directive|else
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptime2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptime3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pci_int_enb_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[29] */
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[28] */
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[27] */
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[26] */
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[25] */
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[21] */
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[17] */
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[14] */
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[13] */
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[12] */
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[11] */
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[10] */
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[9] */
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[8] */
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[7] */
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[6] */
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[5] */
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[4] */
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[3] */
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[2] */
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[1] */
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[0] */
else|#
directive|else
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pci_int_enb_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[29] */
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[28] */
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[27] */
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[26] */
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[25] */
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iptime1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[22] */
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[21] */
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ipcnt1
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[18] */
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[17] */
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[14] */
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[13] */
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[12] */
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[11] */
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[10] */
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[9] */
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[8] */
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[7] */
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[6] */
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[5] */
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[4] */
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[3] */
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[2] */
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[1] */
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< INTA# Pin Interrupt Enable for PCI_INT_SUM[0] */
else|#
directive|else
name|uint64_t
name|itr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iaperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|idcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pci_int_enb_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_int_enb_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_int_enb
name|cvmx_pci_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_int_enb2  *  * PCI_INT_ENB2 = PCI Interrupt Enable2 Register  *  * Enables interrupt bits in the PCI_INT_SUM2 register.  */
end_comment

begin_union
union|union
name|cvmx_pci_int_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_int_enb2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[29] */
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[28] */
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[27] */
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[26] */
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[25] */
name|uint64_t
name|rptime3
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[24] */
name|uint64_t
name|rptime2
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[23] */
name|uint64_t
name|rptime1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[22] */
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[21] */
name|uint64_t
name|rpcnt3
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[20] */
name|uint64_t
name|rpcnt2
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[19] */
name|uint64_t
name|rpcnt1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[18] */
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[17] */
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[14] */
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[13] */
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[12] */
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[11] */
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[10] */
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[9] */
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[8] */
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[7] */
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[6] */
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[5] */
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[4] */
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[3] */
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[2] */
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[1] */
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[0] */
else|#
directive|else
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptime2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptime3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pci_int_enb2_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[29] */
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[28] */
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[27] */
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[26] */
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[25] */
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[21] */
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[17] */
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[14] */
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[13] */
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[12] */
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[11] */
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[10] */
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[9] */
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[8] */
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[7] */
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[6] */
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[5] */
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[4] */
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[3] */
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[2] */
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[1] */
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[0] */
else|#
directive|else
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pci_int_enb2_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[33] */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[32] */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[31] */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[30] */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[29] */
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[28] */
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[27] */
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[26] */
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[25] */
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rptime1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[22] */
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[21] */
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rpcnt1
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[18] */
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[17] */
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[16] */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[15] */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[14] */
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[13] */
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[12] */
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[11] */
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[10] */
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[9] */
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[8] */
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[7] */
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[6] */
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[5] */
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[4] */
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[3] */
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[2] */
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[1] */
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< RSL Chain Interrupt Enable for PCI_INT_SUM2[0] */
else|#
directive|else
name|uint64_t
name|rtr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmsc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|raperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rrsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rdcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pci_int_enb2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_int_enb2_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_int_enb2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_int_enb2
name|cvmx_pci_int_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_int_sum  *  * PCI_INT_SUM = PCI Interrupt Summary  *  * The PCI Interrupt Summary Register.  */
end_comment

begin_union
union|union
name|cvmx_pci_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_int_sum_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|ptime3
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT3                                                          register is not 0 the Sent-3 timer counts.                                                          When the Sent-3 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME3 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime2
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT2                                                          register is not 0 the Sent-2 timer counts.                                                          When the Sent-2 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME2 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT1                                                          register is not 0 the Sent-1 timer counts.                                                          When the Sent-1 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|pcnt3
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT3                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV3 register. */
name|uint64_t
name|pcnt2
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT2                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV2 register. */
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT1                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV1 register. */
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the mio_pci_inta_dr wire                                                          is asserted by the MIO. */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected                                                          CN58XX (as completer), has encountered an error                                                          which prevents the split transaction from                                                          completing. In this event, the CN58XX (as completer),                                                          sends a SCM (Split Completion Message) to the                                                          initiator. See: PCIX Spec v1.0a Fig 2-40.                                                             [31:28]: Message Class = 2(completer error)                                                             [27:20]: Message Index = 0x80                                                             [18:12]: Remaining Lower Address                                                             [11:0]: Remaining Byte Count */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message (SCM) Detected                                                          for either a Split-Read/Write error case.                                                          Set if:                                                             a) A Split-Write SCM is detected with SCE=1.                                                             b) A Split-Read SCM is detected (regardless                                                                of SCE status).                                                          The Split completion message(SCM)                                                          is also latched into the PCI_SCM_REG[SCM] to                                                          assist SW with error recovery. */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort on Master MSI */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target-Abort on Master MSI */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI Parity Error on Master MSI */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Master-Read */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Master-Read */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Master-Read */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on Master-write */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on Master-write */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on Master-write */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pci_int_sum_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the mio_pci_inta_dr wire                                                          is asserted by the MIO */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected                                                          N3K (as completer), has encountered an error                                                          which prevents the split transaction from                                                          completing. In this event, the N3K (as completer),                                                          sends a SCM (Split Completion Message) to the                                                          initiator. See: PCIX Spec v1.0a Fig 2-40.                                                             [31:28]: Message Class = 2(completer error)                                                             [27:20]: Message Index = 0x80                                                             [18:12]: Remaining Lower Address                                                             [11:0]: Remaining Byte Count */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message (SCM) Detected                                                          for either a Split-Read/Write error case.                                                          Set if:                                                             a) A Split-Write SCM is detected with SCE=1.                                                             b) A Split-Read SCM is detected (regardless                                                                of SCE status).                                                          The Split completion message(SCM)                                                          is also latched into the PCI_SCM_REG[SCM] to                                                          assist SW with error recovery. */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort on Master MSI */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target-Abort on Master MSI */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI Parity Error on Master MSI */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Master-Read */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Master-Read */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Master-Read */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on Master-write */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on Master-write */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on Master-write */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pci_int_sum_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT1                                                          register is not 0 the Sent-1 timer counts.                                                          When the Sent-1 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT1                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV1 register. */
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the mio_pci_inta_dr wire                                                          is asserted by the MIO */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected                                                          N3K (as completer), has encountered an error                                                          which prevents the split transaction from                                                          completing. In this event, the N3K (as completer),                                                          sends a SCM (Split Completion Message) to the                                                          initiator. See: PCIX Spec v1.0a Fig 2-40.                                                             [31:28]: Message Class = 2(completer error)                                                             [27:20]: Message Index = 0x80                                                             [18:12]: Remaining Lower Address                                                             [11:0]: Remaining Byte Count */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message (SCM) Detected                                                          for either a Split-Read/Write error case.                                                          Set if:                                                             a) A Split-Write SCM is detected with SCE=1.                                                             b) A Split-Read SCM is detected (regardless                                                                of SCE status).                                                          The Split completion message(SCM)                                                          is also latched into the PCI_SCM_REG[SCM] to                                                          assist SW with error recovery. */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort on Master MSI */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target-Abort on Master MSI */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI Parity Error on Master MSI */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Master-Read */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Master-Read */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Master-Read */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on Master-write */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on Master-write */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on Master-write */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pci_int_sum_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_int_sum_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_int_sum
name|cvmx_pci_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_int_sum2  *  * PCI_INT_SUM2 = PCI Interrupt Summary2 Register  *  * The PCI Interrupt Summary2 Register copy used for RSL interrupts.  */
end_comment

begin_union
union|union
name|cvmx_pci_int_sum2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_int_sum2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|ptime3
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT3                                                          register is not 0 the Sent-3 timer counts.                                                          When the Sent-3 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME3 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime2
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT2                                                          register is not 0 the Sent-2 timer counts.                                                          When the Sent-2 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME2 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT1                                                          register is not 0 the Sent-1 timer counts.                                                          When the Sent-1 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|pcnt3
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT3                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV3 register. */
name|uint64_t
name|pcnt2
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT2                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV2 register. */
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT1                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV1 register. */
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the RSL Chain has                                                          generated an interrupt. */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message Detected */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Master Abort. */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Target Abort. */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Parity Error. */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Read. */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Read. */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Read. */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on write. */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on write. */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on write. */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pci_int_sum2_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the RSL Chain has                                                          generated an interrupt. */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message Detected */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Master Abort. */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Target Abort. */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Parity Error. */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Read. */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Read. */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Read. */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on write. */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on write. */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on write. */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_20
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_24
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_pci_int_sum2_cn31xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
comment|/**< A read to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to a disabled area of bar1 or bar2,                                                          when the mem area is disabled. */
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled Window Write Data or                                                          Read-Address Register took place. */
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 1. */
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
comment|/**< A DMA operation operation finished that was                                                          required to set the FORCE-INT bit for counter 0. */
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT1                                                          register is not 0 the DMA_CNT1 timer counts.                                                          When the DMA1_CNT timer has a value greater                                                          than the PCI_DMA_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_DMA_CNT0                                                          register is not 0 the DMA_CNT0 timer counts.                                                          When the DMA0_CNT timer has a value greater                                                          than the PCI_DMA_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT1                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV1 register. */
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_DMA_CNT0                                                          value is greater than the value                                                          in the PCI_DMA_INT_LEV0 register. */
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT1                                                          register is not 0 the Sent-1 timer counts.                                                          When the Sent-1 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME1 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
comment|/**< When the value in the PCI_PKTS_SENT0                                                          register is not 0 the Sent-0 timer counts.                                                          When the Sent-0 timer has a value greater                                                          than the PCI_PKTS_SENT_TIME0 register this                                                          bit is set. The timer is reset when bit is                                                          written with a one. */
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT1                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV1 register. */
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
comment|/**< This bit indicates that PCI_PKTS_SENT0                                                          value is greater than the value                                                          in the PCI_PKTS_SENT_INT_LEV0 register. */
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the RSL Chain has                                                          generated an interrupt. */
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
comment|/**< A read  to the disabled PCI registers took place. */
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
comment|/**< A write to the disabled PCI registers took place. */
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
comment|/**< Data Parity Error detected by PCX Core */
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
comment|/**< Address Parity Error detected by PCX Core */
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
comment|/**< SERR# detected by PCX Core */
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
comment|/**< Target Split-Read Abort Detected */
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
comment|/**< Master Split Completion Message Detected */
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Master Abort. */
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Target Abort. */
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
comment|/**< PCI MSI Parity Error. */
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout On Read. */
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort On Read. */
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort On Read. */
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Retry Timeout on write. */
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Master Abort detected on write. */
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
comment|/**< PCI Target Abort detected on write. */
else|#
directive|else
name|uint64_t
name|tr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_wtto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mr_tto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_per
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_tabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi_mabt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msc_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsr_abt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|serr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_20
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_24
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcnt1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtime1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma0_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma1_fi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_pci_int_sum2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_int_sum2_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_int_sum2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_int_sum2
name|cvmx_pci_int_sum2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_msi_rcv  *  * PCI_MSI_RCV = PCI's MSI Received Vector Register  *  * A bit is set in this register relative to the vector received during a MSI. The value in this  * register is acted upon when the least-significant-byte of this register is written.  */
end_comment

begin_union
union|union
name|cvmx_pci_msi_rcv
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_msi_rcv_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_6_31
range|:
literal|26
decl_stmt|;
name|uint32_t
name|intr
range|:
literal|6
decl_stmt|;
comment|/**< When an MSI is received on the PCI the bit selected                                                          by data [5:0] will be set in this register. To                                                          clear this bit a write must take place to the                                                          NPI_MSI_RCV register where any bit set to 1 is                                                          cleared. Reading this address will return an                                                          unpredicatable value. */
else|#
directive|else
name|uint32_t
name|intr
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_6_31
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_msi_rcv_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_msi_rcv
name|cvmx_pci_msi_rcv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_pkt_credits#  *  * PCI_PKT_CREDITS0 = PCI Packet Credits For Output 0  *  * Used to decrease the number of packets to be processed by the host from Output-0 and return  * buffer/info pointer pairs to OCTEON Output-0. The value in this register is acted upon when the  * least-significant-byte of this register is written.  */
end_comment

begin_union
union|union
name|cvmx_pci_pkt_creditsx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_pkt_creditsx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pkt_cnt
range|:
literal|16
decl_stmt|;
comment|/**< The value written to this field will be                                                          subtracted from PCI_PKTS_SENT0[PKT_CNT]. */
name|uint32_t
name|ptr_cnt
range|:
literal|16
decl_stmt|;
comment|/**< This field value is added to the                                                          NPI's internal Buffer/Info Pointer Pair count. */
else|#
directive|else
name|uint32_t
name|ptr_cnt
range|:
literal|16
decl_stmt|;
name|uint32_t
name|pkt_cnt
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_pkt_creditsx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_pkt_creditsx
name|cvmx_pci_pkt_creditsx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_pkts_sent#  *  * PCI_PKTS_SENT0 = PCI Packets Sent 0  *  * Number of packets sent to the host memory from PCI Output 0  */
end_comment

begin_union
union|union
name|cvmx_pci_pkts_sentx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_pkts_sentx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Each time a packet is written to the memory via                                                          PCI from PCI Output 0,  this counter is                                                          incremented by 1 or the byte count of the packet                                                          as set in NPI_OUTPUT_CONTROL[P0_BMODE]. */
else|#
directive|else
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sentx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_pkts_sentx
name|cvmx_pci_pkts_sentx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_pkts_sent_int_lev#  *  * PCI_PKTS_SENT_INT_LEV0 = PCI Packets Sent Interrupt Level For Output 0  *  * Interrupt when number of packets sent is equal to or greater than the register value.  */
end_comment

begin_union
union|union
name|cvmx_pci_pkts_sent_int_levx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_pkts_sent_int_levx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
comment|/**< When corresponding port's PCI_PKTS_SENT0 value                                                          exceeds the value in this register, PCNT0 of the                                                          PCI_INT_SUM and PCI_INT_SUM2 will be set. */
else|#
directive|else
name|uint32_t
name|pkt_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_int_levx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_pkts_sent_int_levx
name|cvmx_pci_pkts_sent_int_levx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_pkts_sent_time#  *  * PCI_PKTS_SENT_TIME0 = PCI Packets Sent Timer For Output-0  *  * Time to wait from packet being sent to host from Output-0 before issuing an interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pci_pkts_sent_timex
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_pkts_sent_timex_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|pkt_time
range|:
literal|32
decl_stmt|;
comment|/**< Number of PCI clock cycle to wait before                                                          issuing an interrupt to the host when a                                                          packet from this port has been sent to the                                                          host.  The timer is reset when the                                                          PCI_INT_SUM[21] register is cleared. */
else|#
directive|else
name|uint32_t
name|pkt_time
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_pkts_sent_timex_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_pkts_sent_timex
name|cvmx_pci_pkts_sent_timex_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_read_cmd_6  *  * PCI_READ_CMD_6 = PCI Read Command 6 Register  *  * Contains control inforamtion related to a received PCI Command 6.  */
end_comment

begin_union
union|union
name|cvmx_pci_read_cmd_6
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_read_cmd_6_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
comment|/**< The number of words to have buffered in the PNI                                                          before informing the PCIX-Core that we have                                                          read data available for the outstanding Delayed                                                          read. 0 is treated as a 64.                                                          For reads to the expansion this value is not used. */
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
comment|/**< Control the amount of data to be preteched when                                                          this type of bhmstREAD command is received.                                                          0 = 1 32/64 bit word.                                                          1 = From address to end of 128B block.                                                          2 = From address to end of 128B block plus 128B.                                                          3 = From address to end of 128B block plus 256B.                                                          4 = From address to end of 128B block plus 384B.                                                          For reads to the expansion this value is not used. */
else|#
directive|else
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_6_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_read_cmd_6
name|cvmx_pci_read_cmd_6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_read_cmd_c  *  * PCI_READ_CMD_C = PCI Read Command C Register  *  * Contains control inforamtion related to a received PCI Command C.  */
end_comment

begin_union
union|union
name|cvmx_pci_read_cmd_c
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_read_cmd_c_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
comment|/**< The number of words to have buffered in the PNI                                                          before informing the PCIX-Core that we have                                                          read data available for the outstanding Delayed                                                          read. 0 is treated as a 64.                                                          For reads to the expansion this value is not used. */
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
comment|/**< Control the amount of data to be preteched when                                                          this type of READ command is received.                                                          0 = 1 32/64 bit word.                                                          1 = From address to end of 128B block.                                                          2 = From address to end of 128B block plus 128B.                                                          3 = From address to end of 128B block plus 256B.                                                          4 = From address to end of 128B block plus 384B.                                                          For reads to the expansion this value is not used. */
else|#
directive|else
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_c_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_read_cmd_c
name|cvmx_pci_read_cmd_c_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_read_cmd_e  *  * PCI_READ_CMD_E = PCI Read Command E Register  *  * Contains control inforamtion related to a received PCI Command 6.  */
end_comment

begin_union
union|union
name|cvmx_pci_read_cmd_e
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_pci_read_cmd_e_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
comment|/**< The number of words to have buffered in the PNI                                                          before informaing the PCIX-Core that we have                                                          read data available for the outstanding Delayed                                                          read. 0 is treated as a 64.                                                          For reads to the expansion this value is not used. */
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
comment|/**< Control the amount of data to be preteched when                                                          this type of READ command is received.                                                          0 = 1 32/64 bit word.                                                          1 = From address to end of 128B block.                                                          2 = From address to end of 128B block plus 128B.                                                          3 = From address to end of 128B block plus 256B.                                                          4 = From address to end of 128B block plus 384B.                                                          For reads to the expansion this value is not used. */
else|#
directive|else
name|uint32_t
name|prefetch
range|:
literal|3
decl_stmt|;
name|uint32_t
name|min_data
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_read_cmd_e_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_read_cmd_e
name|cvmx_pci_read_cmd_e_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_read_timeout  *  * PCI_READ_TIMEOUT = PCI Read Timeour Register  *  * The address to start reading Instructions from for Input-3.  */
end_comment

begin_union
union|union
name|cvmx_pci_read_timeout
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_read_timeout_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
comment|/**< Enable the use of the Timeout function. */
name|uint64_t
name|cnt
range|:
literal|31
decl_stmt|;
comment|/**< The number of eclk cycles to wait after issuing                                                          a read request to the PNI before setting a                                                          timeout and not expecting the data to return.                                                          This is considered a fatal condition by the NPI. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|31
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_read_timeout_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_read_timeout
name|cvmx_pci_read_timeout_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_scm_reg  *  * PCI_SCM_REG = PCI Master Split Completion Message Register  *  * This register contains the Master Split Completion Message(SCM) generated when a master split  * transaction is aborted.  */
end_comment

begin_union
union|union
name|cvmx_pci_scm_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_scm_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|scm
range|:
literal|32
decl_stmt|;
comment|/**< Contains the Split Completion Message (SCM)                                                          driven when a master-split transaction is aborted.                                                             [31:28]: Message Class                                                             [27:20]: Message Index                                                             [19]:    Reserved                                                             [18:12]: Remaining Lower Address                                                             [11:8]:  Upper Remaining Byte Count                                                             [7:0]:   Lower Remaining Byte Count                                                          Refer to the PCIX1.0a specification, Fig 2-40                                                          for additional details for the split completion                                                          message format. */
else|#
directive|else
name|uint64_t
name|scm
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_scm_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_scm_reg
name|cvmx_pci_scm_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_tsr_reg  *  * PCI_TSR_REG = PCI Target Split Attribute Register  *  * This register contains the Attribute field Master Split Completion Message(SCM) generated when a master split  * transaction is aborted.  */
end_comment

begin_union
union|union
name|cvmx_pci_tsr_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_tsr_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|tsr
range|:
literal|36
decl_stmt|;
comment|/**< Contains the Target Split Attribute field when a                                                          target-split transaction is aborted.                                                            [35:32]: Upper Byte Count                                                            [31]:    BCM=Byte Count Modified                                                            [30]:    SCE=Split Completion Error                                                            [29]:    SCM=Split Completion Message                                                            [28:24]: RESERVED                                                            [23:16]: Completer Bus Number                                                            [15:11]: Completer Device Number                                                            [10:8]:  Completer Function Number                                                            [7:0]:   Lower Byte Count                                                          Refer to the PCIX1.0a specification, Fig 2-39                                                          for additional details on the completer attribute                                                          bit assignments. */
else|#
directive|else
name|uint64_t
name|tsr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_tsr_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_tsr_reg
name|cvmx_pci_tsr_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_win_rd_addr  *  * PCI_WIN_RD_ADDR = PCI Window Read Address Register  *  * Writing the least-significant-byte of this register will cause a read operation to take place,  * UNLESS, a read operation is already taking place. A read is consider to end when the PCI_WIN_RD_DATA  * register is read.  */
end_comment

begin_union
union|union
name|cvmx_pci_win_rd_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_win_rd_addr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|reserved_0_47
range|:
literal|48
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_47
range|:
literal|48
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pci_win_rd_addr_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|rd_addr
range|:
literal|46
decl_stmt|;
comment|/**< The address to be read from. Whenever the LSB of                                                          this register is written, the Read Operation will                                                          take place.                                                          [47:40] = NCB_ID                                                          [39:3]  = Address                                                          When [47:43] == NPI& [42:0] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:27] == RSL_ID                                                               [12:2]  == RSL Register Offset                                                               [1:0]   == x, Not Used */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rd_addr
range|:
literal|46
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pci_win_rd_addr_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_pci_win_rd_addr_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|rd_addr
range|:
literal|45
decl_stmt|;
comment|/**< The address to be read from. Whenever the LSB of                                                          this register is written, the Read Operation will                                                          take place.                                                          [47:40] = NCB_ID                                                          [39:3]  = Address                                                          When [47:43] == NPI& [42:0] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:27] == RSL_ID                                                               [12:3]  == RSL Register Offset                                                               [2:0]   == x, Not Used */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rd_addr
range|:
literal|45
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_pci_win_rd_addr_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_addr_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_addr_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_addr_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_win_rd_addr
name|cvmx_pci_win_rd_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_win_rd_data  *  * PCI_WIN_RD_DATA = PCI Window Read Data Register  *  * Contains the result from the read operation that took place when the LSB of the PCI_WIN_RD_ADDR  * register was written.  */
end_comment

begin_union
union|union
name|cvmx_pci_win_rd_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_win_rd_data_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
comment|/**< The read data. */
else|#
directive|else
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_win_rd_data_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_win_rd_data
name|cvmx_pci_win_rd_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_win_wr_addr  *  * PCI_WIN_WR_ADDR = PCI Window Write Address Register  *  * Contains the address to be writen to when a write operation is started by writing the  * PCI_WIN_WR_DATA register (see below).  */
end_comment

begin_union
union|union
name|cvmx_pci_win_wr_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_win_wr_addr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|wr_addr
range|:
literal|45
decl_stmt|;
comment|/**< The address that will be written to when the                                                          PCI_WIN_WR_DATA register is written.                                                          [47:40] = NCB_ID                                                          [39:3]  = Address                                                          When [47:43] == NPI& [42:0] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:27] == RSL_ID                                                               [12:3]  == RSL Register Offset                                                               [2:0]   == x, Not Used */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wr_addr
range|:
literal|45
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_addr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_win_wr_addr
name|cvmx_pci_win_wr_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_win_wr_data  *  * PCI_WIN_WR_DATA = PCI Window Write Data Register  *  * Contains the data to write to the address located in the PCI_WIN_WR_ADDR Register.  * Writing the least-significant-byte of this register will cause a write operation to take place.  */
end_comment

begin_union
union|union
name|cvmx_pci_win_wr_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_win_wr_data_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
comment|/**< The data to be written. Whenever the LSB of this                                                          register is written, the Window Write will take                                                          place. */
else|#
directive|else
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_data_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_win_wr_data
name|cvmx_pci_win_wr_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pci_win_wr_mask  *  * PCI_WIN_WR_MASK = PCI Window Write Mask Register  *  * Contains the mask for the data in the PCI_WIN_WR_DATA Register.  */
end_comment

begin_union
union|union
name|cvmx_pci_win_wr_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pci_win_wr_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
comment|/**< The data to be written. When a bit is set '1'                                                          the corresponding byte will not be written. */
else|#
directive|else
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pci_win_wr_mask_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pci_win_wr_mask
name|cvmx_pci_win_wr_mask_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

