begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Helper utilities for qlm_jtag.  *  *<hr>$Revision: 42480 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-jtag.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-helper-jtag.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Initialize the internal QLM JTAG logic to allow programming  * of the JTAG chain by the cvmx_helper_qlm_jtag_*() functions.  * These functions should only be used at the direction of Cavium  * Networks. Programming incorrect values into the JTAG chain  * can cause chip damage.  */
end_comment

begin_function
name|void
name|cvmx_helper_qlm_jtag_init
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_ciu_qlm_jtgc_t
name|jtgc
decl_stmt|;
name|int
name|clock_div
init|=
literal|0
decl_stmt|;
name|int
name|divisor
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_SCLK
argument_list|)
operator|/
operator|(
literal|25
operator|*
literal|1000000
operator|)
decl_stmt|;
name|divisor
operator|=
operator|(
name|divisor
operator|-
literal|1
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* Convert the divisor into a power of 2 shift */
while|while
condition|(
name|divisor
condition|)
block|{
name|clock_div
operator|++
expr_stmt|;
name|divisor
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Clock divider for QLM JTAG operations.  sclk is divided by 2^(CLK_DIV + 2) */
name|jtgc
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|jtgc
operator|.
name|s
operator|.
name|clk_div
operator|=
name|clock_div
expr_stmt|;
name|jtgc
operator|.
name|s
operator|.
name|mux_sel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|0x3
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|0x7
expr_stmt|;
else|else
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|0xf
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|,
name|jtgc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Write up to 32bits into the QLM jtag chain. Bits are shifted  * into the MSB and out the LSB, so you should shift in the low  * order bits followed by the high order bits. The JTAG chain for  * CN52XX and CN56XX is 4 * 268 bits long, or 1072. The JTAG chain  * for CN63XX is 4 * 300 bits long, or 1200.  *  * @param qlm    QLM to shift value into  * @param bits   Number of bits to shift in (1-32).  * @param data   Data to shift in. Bit 0 enters the chain first, followed by  *               bit 1, etc.  *  * @return The low order bits of the JTAG chain that shifted out of the  *         circle.  */
end_comment

begin_function
name|uint32_t
name|cvmx_helper_qlm_jtag_shift
parameter_list|(
name|int
name|qlm
parameter_list|,
name|int
name|bits
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|cvmx_ciu_qlm_jtgc_t
name|jtgc
decl_stmt|;
name|cvmx_ciu_qlm_jtgd_t
name|jtgd
decl_stmt|;
name|jtgc
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
name|jtgc
operator|.
name|s
operator|.
name|mux_sel
operator|=
name|qlm
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|,
name|jtgc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
name|jtgd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|jtgd
operator|.
name|s
operator|.
name|shift
operator|=
literal|1
expr_stmt|;
name|jtgd
operator|.
name|s
operator|.
name|shft_cnt
operator|=
name|bits
operator|-
literal|1
expr_stmt|;
name|jtgd
operator|.
name|s
operator|.
name|shft_reg
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
condition|)
name|jtgd
operator|.
name|s
operator|.
name|select
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|,
name|jtgd
operator|.
name|u64
argument_list|)
expr_stmt|;
do|do
block|{
name|jtgd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|jtgd
operator|.
name|s
operator|.
name|shift
condition|)
do|;
return|return
name|jtgd
operator|.
name|s
operator|.
name|shft_reg
operator|>>
operator|(
literal|32
operator|-
name|bits
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Shift long sequences of zeros into the QLM JTAG chain. It is  * common to need to shift more than 32 bits of zeros into the  * chain. This function is a convience wrapper around  * cvmx_helper_qlm_jtag_shift() to shift more than 32 bits of  * zeros at a time.  *  * @param qlm    QLM to shift zeros into  * @param bits  */
end_comment

begin_function
name|void
name|cvmx_helper_qlm_jtag_shift_zeros
parameter_list|(
name|int
name|qlm
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
while|while
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|bits
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|32
condition|)
name|n
operator|=
literal|32
expr_stmt|;
name|cvmx_helper_qlm_jtag_shift
argument_list|(
name|qlm
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bits
operator|-=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Program the QLM JTAG chain into all lanes of the QLM. You must  * have already shifted in the proper number of bits into the  * JTAG chain. Updating invalid values can possibly cause chip damage.  *  * @param qlm    QLM to program  */
end_comment

begin_function
name|void
name|cvmx_helper_qlm_jtag_update
parameter_list|(
name|int
name|qlm
parameter_list|)
block|{
name|cvmx_ciu_qlm_jtgc_t
name|jtgc
decl_stmt|;
name|cvmx_ciu_qlm_jtgd_t
name|jtgd
decl_stmt|;
name|jtgc
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
name|jtgc
operator|.
name|s
operator|.
name|mux_sel
operator|=
name|qlm
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|,
name|jtgc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
comment|/* Update the new data */
name|jtgd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|jtgd
operator|.
name|s
operator|.
name|update
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
condition|)
name|jtgd
operator|.
name|s
operator|.
name|select
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|,
name|jtgd
operator|.
name|u64
argument_list|)
expr_stmt|;
do|do
block|{
name|jtgd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|jtgd
operator|.
name|s
operator|.
name|update
condition|)
do|;
block|}
end_function

begin_comment
comment|/**  * Load the QLM JTAG chain with data from all lanes of the QLM.  *  * @param qlm    QLM to program  */
end_comment

begin_function
name|void
name|cvmx_helper_qlm_jtag_capture
parameter_list|(
name|int
name|qlm
parameter_list|)
block|{
name|cvmx_ciu_qlm_jtgc_t
name|jtgc
decl_stmt|;
name|cvmx_ciu_qlm_jtgd_t
name|jtgd
decl_stmt|;
name|jtgc
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
name|jtgc
operator|.
name|s
operator|.
name|mux_sel
operator|=
name|qlm
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|jtgc
operator|.
name|s
operator|.
name|bypass
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|,
name|jtgc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGC
argument_list|)
expr_stmt|;
name|jtgd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|jtgd
operator|.
name|s
operator|.
name|capture
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
condition|)
name|jtgd
operator|.
name|s
operator|.
name|select
operator|=
literal|1
operator|<<
name|qlm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|,
name|jtgd
operator|.
name|u64
argument_list|)
expr_stmt|;
do|do
block|{
name|jtgd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM_JTGD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|jtgd
operator|.
name|s
operator|.
name|capture
condition|)
do|;
block|}
end_function

end_unit

