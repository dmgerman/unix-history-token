begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware Packet Output unit.  *  * Starting with SDK 1.7.0, the PKO output functions now support  * two types of locking. CVMX_PKO_LOCK_ATOMIC_TAG continues to  * function similarly to previous SDKs by using POW atomic tags  * to preserve ordering and exclusivity. As a new option, you  * can now pass CVMX_PKO_LOCK_CMD_QUEUE which uses a ll/sc  * memory based locking instead. This locking has the advantage  * of not affecting the tag state but doesn't preserve packet  * ordering. CVMX_PKO_LOCK_CMD_QUEUE is appropriate in most  * generic code while CVMX_PKO_LOCK_CMD_QUEUE should be used  * with hand tuned fast path code.  *  * Some of other SDK differences visible to the command command  * queuing:  * - PKO indexes are no longer stored in the FAU. A large  *   percentage of the FAU register block used to be tied up  *   maintaining PKO queue pointers. These are now stored in a  *   global named block.  * - The PKO<b>use_locking</b> parameter can now have a global  *   effect. Since all application use the same named block,  *   queue locking correctly applies across all operating  *   systems when using CVMX_PKO_LOCK_CMD_QUEUE.  * - PKO 3 word commands are now supported. Use  *   cvmx_pko_send_packet_finish3().  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PKO_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PKO_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko-defs.h"
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-fau.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-fpa.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pow.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-cmd-queue.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-cfg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_DONT_INCLUDE_CONFIG
end_ifndef

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-fau.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pow.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-cmd-queue.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-cfg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Adjust the command buffer size by 1 word so that in the case of using only ** two word PKO commands no command words stradle buffers.  The useful values ** for this are 0 and 1. */
end_comment

begin_define
define|#
directive|define
name|CVMX_PKO_COMMAND_BUFFER_SIZE_ADJUST
value|(1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|CVMX_PKO_MAX_OUTPUT_QUEUES_STATIC
value|256
define|#
directive|define
name|CVMX_PKO_MAX_OUTPUT_QUEUES
value|((OCTEON_IS_MODEL(OCTEON_CN31XX) || \ 					  OCTEON_IS_MODEL(OCTEON_CN3010) || \ 					  OCTEON_IS_MODEL(OCTEON_CN3005) || \ 					  OCTEON_IS_MODEL(OCTEON_CN50XX)) ? \ 					  32 :				    \ 					 (OCTEON_IS_MODEL(OCTEON_CN58XX) || \ 					  OCTEON_IS_MODEL(OCTEON_CN56XX) || \ 					  OCTEON_IS_MODEL(OCTEON_CN52XX) || \ 					  OCTEON_IS_MODEL(OCTEON_CN6XXX) || \ 					  OCTEON_IS_MODEL(OCTEON_CNF7XXX)) ? \ 					  256 : 128)
define|#
directive|define
name|CVMX_PKO_NUM_OUTPUT_PORTS
value|((OCTEON_IS_MODEL(OCTEON_CN63XX)) ? 44 : (OCTEON_IS_MODEL(OCTEON_CN66XX) ? 46 : 40))
define|#
directive|define
name|CVMX_PKO_MEM_QUEUE_PTRS_ILLEGAL_PID
value|63
comment|/* use this for queues that are not used */
define|#
directive|define
name|CVMX_PKO_QUEUE_STATIC_PRIORITY
value|9
define|#
directive|define
name|CVMX_PKO_ILLEGAL_QUEUE
value|0xFFFF
define|#
directive|define
name|CVMX_PKO_MAX_QUEUE_DEPTH
value|0
typedef|typedef
enum|enum
block|{
name|CVMX_PKO_SUCCESS
block|,
name|CVMX_PKO_INVALID_PORT
block|,
name|CVMX_PKO_INVALID_QUEUE
block|,
name|CVMX_PKO_INVALID_PRIORITY
block|,
name|CVMX_PKO_NO_MEMORY
block|,
name|CVMX_PKO_PORT_ALREADY_SETUP
block|,
name|CVMX_PKO_CMD_QUEUE_INIT_ERROR
block|}
name|cvmx_pko_status_t
typedef|;
comment|/**  * This enumeration represents the differnet locking modes supported by PKO.  */
typedef|typedef
enum|enum
block|{
name|CVMX_PKO_LOCK_NONE
init|=
literal|0
block|,
comment|/**< PKO doesn't do any locking. It is the responsibility                                         of the application to make sure that no other core is                                         accessing the same queue at the same time */
name|CVMX_PKO_LOCK_ATOMIC_TAG
init|=
literal|1
block|,
comment|/**< PKO performs an atomic tagswitch to insure exclusive                                         access to the output queue. This will maintain                                         packet ordering on output */
name|CVMX_PKO_LOCK_CMD_QUEUE
init|=
literal|2
block|,
comment|/**< PKO uses the common command queue locks to insure                                         exclusive access to the output queue. This is a memory                                         based ll/sc. This is the most portable locking                                         mechanism */
block|}
name|cvmx_pko_lock_t
typedef|;
typedef|typedef
struct|struct
block|{
name|uint32_t
name|packets
decl_stmt|;
name|uint64_t
name|octets
decl_stmt|;
name|uint64_t
name|doorbell
decl_stmt|;
block|}
name|cvmx_pko_port_status_t
typedef|;
comment|/**  * This structure defines the address to use on a packet enqueue  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|cvmx_mips_space_t
name|mem_space
range|:
literal|2
decl_stmt|;
comment|/**< Must CVMX_IO_SEG */
name|uint64_t
name|reserved
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< The ID of the device on the non-coherent bus */
name|uint64_t
name|reserved2
range|:
literal|4
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|reserved3
range|:
literal|15
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|port
range|:
literal|9
decl_stmt|;
comment|/**< The hardware must have the output port in addition to the output queue */
name|uint64_t
name|queue
range|:
literal|9
decl_stmt|;
comment|/**< The output queue to send the packet to (0-127 are legal) */
name|uint64_t
name|reserved4
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
block|}
name|s
struct|;
block|}
name|cvmx_pko_doorbell_address_t
typedef|;
comment|/**  * Structure of the first packet output command word.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|cvmx_fau_op_size_t
name|size1
range|:
literal|2
decl_stmt|;
comment|/**< The size of the reg1 operation - could be 8, 16, 32, or 64 bits */
name|cvmx_fau_op_size_t
name|size0
range|:
literal|2
decl_stmt|;
comment|/**< The size of the reg0 operation - could be 8, 16, 32, or 64 bits */
name|uint64_t
name|subone1
range|:
literal|1
decl_stmt|;
comment|/**< If set, subtract 1, if clear, subtract packet size */
name|uint64_t
name|reg1
range|:
literal|11
decl_stmt|;
comment|/**< The register, subtract will be done if reg1 is non-zero */
name|uint64_t
name|subone0
range|:
literal|1
decl_stmt|;
comment|/**< If set, subtract 1, if clear, subtract packet size */
name|uint64_t
name|reg0
range|:
literal|11
decl_stmt|;
comment|/**< The register, subtract will be done if reg0 is non-zero */
name|uint64_t
name|le
range|:
literal|1
decl_stmt|;
comment|/**< When set, interpret segment pointer and segment bytes in little endian order */
name|uint64_t
name|n2
range|:
literal|1
decl_stmt|;
comment|/**< When set, packet data not allocated in L2 cache by PKO */
name|uint64_t
name|wqp
range|:
literal|1
decl_stmt|;
comment|/**< If set and rsp is set, word3 contains a pointer to a work queue entry */
name|uint64_t
name|rsp
range|:
literal|1
decl_stmt|;
comment|/**< If set, the hardware will send a response when done */
name|uint64_t
name|gather
range|:
literal|1
decl_stmt|;
comment|/**< If set, the supplied pkt_ptr is really a pointer to a list of pkt_ptr's */
name|uint64_t
name|ipoffp1
range|:
literal|7
decl_stmt|;
comment|/**< If ipoffp1 is non zero, (ipoffp1-1) is the number of bytes to IP header,                                                 and the hardware will calculate and insert the  UDP/TCP checksum */
name|uint64_t
name|ignore_i
range|:
literal|1
decl_stmt|;
comment|/**< If set, ignore the I bit (force to zero) from all pointer structures */
name|uint64_t
name|dontfree
range|:
literal|1
decl_stmt|;
comment|/**< If clear, the hardware will attempt to free the buffers containing the packet */
name|uint64_t
name|segs
range|:
literal|6
decl_stmt|;
comment|/**< The total number of segs in the packet, if gather set, also gather list length */
name|uint64_t
name|total_bytes
range|:
literal|16
decl_stmt|;
comment|/**< Including L2, but no trailing CRC */
block|}
name|s
struct|;
block|}
name|cvmx_pko_command_word0_t
typedef|;
comment|/* CSR typedefs have been moved to cvmx-pko-defs.h */
comment|/**  * Definition of internal state for Packet output processing  */
typedef|typedef
struct|struct
block|{
name|uint64_t
modifier|*
name|start_ptr
decl_stmt|;
comment|/**< ptr to start of buffer, offset kept in FAU reg */
block|}
name|cvmx_pko_state_elem_t
typedef|;
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
comment|/**  * Call before any other calls to initialize the packet  * output system.  */
specifier|extern
name|void
name|cvmx_pko_initialize_global
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|int
name|cvmx_pko_initialize_local
parameter_list|(
name|void
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/**  * Enables the packet output hardware. It must already be  * configured.  */
specifier|extern
name|void
name|cvmx_pko_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Disables the packet output. Does not affect any configuration.  */
specifier|extern
name|void
name|cvmx_pko_disable
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Shutdown and free resources required by packet output.  */
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
specifier|extern
name|void
name|cvmx_pko_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Configure a output port and the associated queues for use.  *  * @param port       Port to configure.  * @param base_queue First queue number to associate with this port.  * @param num_queues Number of queues t oassociate with this port  * @param priority   Array of priority levels for each queue. Values are  *                   allowed to be 1-8. A value of 8 get 8 times the traffic  *                   of a value of 1. There must be num_queues elements in the  *                   array.  */
specifier|extern
name|cvmx_pko_status_t
name|cvmx_pko_config_port
parameter_list|(
name|uint64_t
name|port
parameter_list|,
name|uint64_t
name|base_queue
parameter_list|,
name|uint64_t
name|num_queues
parameter_list|,
specifier|const
name|uint64_t
name|priority
index|[]
parameter_list|)
function_decl|;
comment|/**  * Ring the packet output doorbell. This tells the packet  * output hardware that "len" command words have been added  * to its pending list.  This command includes the required  * CVMX_SYNCWS before the doorbell ring.  *  * WARNING: This function may have to look up the proper PKO port in  * the IPD port to PKO port map, and is thus slower than calling  * cvmx_pko_doorbell_pkoid() directly if the PKO port identifier is  * known.  *  * @param ipd_port   The IPD port corresponding the to pko port the packet is for  * @param queue  Queue the packet is for  * @param len    Length of the command in 64 bit words  */
specifier|static
specifier|inline
name|void
name|cvmx_pko_doorbell
parameter_list|(
name|uint64_t
name|ipd_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|cvmx_pko_doorbell_address_t
name|ptr
decl_stmt|;
name|uint64_t
name|pko_port
decl_stmt|;
name|pko_port
operator|=
name|ipd_port
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
name|pko_port
operator|=
name|cvmx_helper_cfg_ipd2pko_port_base
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|mem_space
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|did
operator|=
name|CVMX_OCT_DID_PKT_SEND
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|port
operator|=
name|pko_port
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
comment|/* Need to make sure output queue data is in DRAM before doorbell write */
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/**  * Prepare to send a packet.  This may initiate a tag switch to  * get exclusive access to the output queue structure, and  * performs other prep work for the packet send operation.  *  * cvmx_pko_send_packet_finish() MUST be called after this function is called,  * and must be called with the same port/queue/use_locking arguments.  *  * The use_locking parameter allows the caller to use three  * possible locking modes.  * - CVMX_PKO_LOCK_NONE  *      - PKO doesn't do any locking. It is the responsibility  *          of the application to make sure that no other core  *          is accessing the same queue at the same time.  * - CVMX_PKO_LOCK_ATOMIC_TAG  *      - PKO performs an atomic tagswitch to insure exclusive  *          access to the output queue. This will maintain  *          packet ordering on output.  * - CVMX_PKO_LOCK_CMD_QUEUE  *      - PKO uses the common command queue locks to insure  *          exclusive access to the output queue. This is a  *          memory based ll/sc. This is the most portable  *          locking mechanism.  *  * NOTE: If atomic locking is used, the POW entry CANNOT be  * descheduled, as it does not contain a valid WQE pointer.  *  * @param port   Port to send it on, this can be either IPD port or PKO  * 		 port.  * @param queue  Queue to use  * @param use_locking  *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE  */
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
specifier|static
specifier|inline
name|void
name|cvmx_pko_send_packet_prepare
parameter_list|(
name|uint64_t
name|port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|cvmx_pko_lock_t
name|use_locking
parameter_list|)
block|{
if|if
condition|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_ATOMIC_TAG
condition|)
block|{
comment|/* Must do a full switch here to handle all cases.  We use a fake WQE pointer, as the POW does         ** not access this memory.  The WQE pointer and group are only used if this work is descheduled,         ** which is not supported by the cvmx_pko_send_packet_prepare/cvmx_pko_send_packet_finish combination.         ** Note that this is a special case in which these fake values can be used - this is not a general technique.         */
name|uint32_t
name|tag
init|=
name|CVMX_TAG_SW_BITS_INTERNAL
operator|<<
name|CVMX_TAG_SW_SHIFT
operator||
name|CVMX_TAG_SUBGROUP_PKO
operator|<<
name|CVMX_TAG_SUBGROUP_SHIFT
operator||
operator|(
name|CVMX_TAG_SUBGROUP_MASK
operator|&
name|queue
operator|)
decl_stmt|;
name|cvmx_pow_tag_sw_full
argument_list|(
operator|(
name|cvmx_wqe_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
literal|0x80
argument_list|)
argument_list|,
name|tag
argument_list|,
name|CVMX_POW_TAG_TYPE_ATOMIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|cvmx_pko_send_packet_prepare_pkoid
value|cvmx_pko_send_packet_prepare
comment|/**  * Complete packet output. cvmx_pko_send_packet_prepare() must be called exactly once before this,  * and the same parameters must be passed to both cvmx_pko_send_packet_prepare() and  * cvmx_pko_send_packet_finish().  *  * WARNING: This function may have to look up the proper PKO port in  * the IPD port to PKO port map, and is thus slower than calling  * cvmx_pko_send_packet_finish_pkoid() directly if the PKO port  * identifier is known.  *  * @param ipd_port   The IPD port corresponding the to pko port the packet is for  * @param queue  Queue to use  * @param pko_command  *               PKO HW command word  * @param packet Packet to send  * @param use_locking  *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE  *  * @return returns CVMX_PKO_SUCCESS on success, or error code on failure of output  */
specifier|static
specifier|inline
name|cvmx_pko_status_t
name|cvmx_pko_send_packet_finish
parameter_list|(
name|uint64_t
name|ipd_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|cvmx_pko_command_word0_t
name|pko_command
parameter_list|,
name|cvmx_buf_ptr_t
name|packet
parameter_list|,
name|cvmx_pko_lock_t
name|use_locking
parameter_list|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
if|if
condition|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_ATOMIC_TAG
condition|)
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_write2
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|,
operator|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_CMD_QUEUE
operator|)
argument_list|,
name|pko_command
operator|.
name|u64
argument_list|,
name|packet
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|result
operator|==
name|CVMX_CMD_QUEUE_SUCCESS
argument_list|)
condition|)
block|{
name|cvmx_pko_doorbell
argument_list|(
name|ipd_port
argument_list|,
name|queue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|CVMX_PKO_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_NO_MEMORY
operator|)
operator|||
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_FULL
operator|)
condition|)
block|{
return|return
name|CVMX_PKO_NO_MEMORY
return|;
block|}
else|else
block|{
return|return
name|CVMX_PKO_INVALID_QUEUE
return|;
block|}
block|}
comment|/**  * Complete packet output. cvmx_pko_send_packet_prepare() must be called exactly once before this,  * and the same parameters must be passed to both cvmx_pko_send_packet_prepare() and  * cvmx_pko_send_packet_finish().  *  * WARNING: This function may have to look up the proper PKO port in  * the IPD port to PKO port map, and is thus slower than calling  * cvmx_pko_send_packet_finish3_pkoid() directly if the PKO port  * identifier is known.  *  * @param ipd_port   The IPD port corresponding the to pko port the packet is for  * @param queue  Queue to use  * @param pko_command  *               PKO HW command word  * @param packet Packet to send  * @param addr   Plysical address of a work queue entry or physical address to zero on complete.  * @param use_locking  *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE  *  * @return returns CVMX_PKO_SUCCESS on success, or error code on failure of output  */
specifier|static
specifier|inline
name|cvmx_pko_status_t
name|cvmx_pko_send_packet_finish3
parameter_list|(
name|uint64_t
name|ipd_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|cvmx_pko_command_word0_t
name|pko_command
parameter_list|,
name|cvmx_buf_ptr_t
name|packet
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|cvmx_pko_lock_t
name|use_locking
parameter_list|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
if|if
condition|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_ATOMIC_TAG
condition|)
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_write3
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|,
operator|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_CMD_QUEUE
operator|)
argument_list|,
name|pko_command
operator|.
name|u64
argument_list|,
name|packet
operator|.
name|u64
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|result
operator|==
name|CVMX_CMD_QUEUE_SUCCESS
argument_list|)
condition|)
block|{
name|cvmx_pko_doorbell
argument_list|(
name|ipd_port
argument_list|,
name|queue
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|CVMX_PKO_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_NO_MEMORY
operator|)
operator|||
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_FULL
operator|)
condition|)
block|{
return|return
name|CVMX_PKO_NO_MEMORY
return|;
block|}
else|else
block|{
return|return
name|CVMX_PKO_INVALID_QUEUE
return|;
block|}
block|}
comment|/**  * Get the first pko_port for the (interface, index)  *  * @param interface  * @param index  */
specifier|extern
name|int
name|cvmx_pko_get_base_pko_port
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/**  * Get the number of pko_ports for the (interface, index)  *  * @param interface  * @param index  */
specifier|extern
name|int
name|cvmx_pko_get_num_pko_ports
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/**  * Return the pko output queue associated with a port and a specific core.  * In normal mode (PKO lockless operation is disabled), the value returned  * is the base queue.  *  * @param port   Port number  * @param core   Core to get queue for  *  * @return Core-specific output queue and -1 on error.  *  * Note: This function is invalid for o68.  */
specifier|static
specifier|inline
name|int
name|cvmx_pko_get_base_queue_per_core
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|core
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_pko_get_base_queue_per_core() not"
literal|"supported starting from o68!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifndef|#
directive|ifndef
name|CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0
define|#
directive|define
name|CVMX_HELPER_PKO_MAX_PORTS_INTERFACE0
value|16
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1
define|#
directive|define
name|CVMX_HELPER_PKO_MAX_PORTS_INTERFACE1
value|16
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CVMX_PKO_QUEUES_PER_PORT_SRIO0
comment|/* We use two queues per port for SRIO0. Having two queues per         port with two ports gives us four queues, one for each mailbox */
define|#
directive|define
name|CVMX_PKO_QUEUES_PER_PORT_SRIO0
value|2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CVMX_PKO_QUEUES_PER_PORT_SRIO1
comment|/* We use two queues per port for SRIO1. Having two queues per         port with two ports gives us four queues, one for each mailbox */
define|#
directive|define
name|CVMX_PKO_QUEUES_PER_PORT_SRIO1
value|2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CVMX_PKO_QUEUES_PER_PORT_SRIO2
comment|/* We use two queues per port for SRIO2. Having two queues per         port with two ports gives us four queues, one for each mailbox */
define|#
directive|define
name|CVMX_PKO_QUEUES_PER_PORT_SRIO2
value|2
endif|#
directive|endif
if|if
condition|(
name|port
operator|<
name|CVMX_PKO_MAX_PORTS_INTERFACE0
condition|)
return|return
name|port
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|core
return|;
elseif|else
if|if
condition|(
name|port
operator|>=
literal|16
operator|&&
name|port
operator|<
literal|16
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
operator|(
name|port
operator|-
literal|16
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
name|core
return|;
elseif|else
if|if
condition|(
operator|(
name|port
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|port
operator|<
literal|36
operator|)
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
operator|(
name|port
operator|-
literal|32
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_PCI
return|;
elseif|else
if|if
condition|(
operator|(
name|port
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|port
operator|<
literal|40
operator|)
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_PCI
operator|+
operator|(
name|port
operator|-
literal|36
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_LOOP
return|;
elseif|else
if|if
condition|(
operator|(
name|port
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|port
operator|<
literal|42
operator|)
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_PCI
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_LOOP
operator|+
operator|(
name|port
operator|-
literal|40
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_SRIO0
return|;
elseif|else
if|if
condition|(
operator|(
name|port
operator|>=
literal|42
operator|)
operator|&&
operator|(
name|port
operator|<
literal|44
operator|)
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_PCI
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_LOOP
operator|+
literal|2
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_SRIO0
operator|+
operator|(
name|port
operator|-
literal|42
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_SRIO1
return|;
elseif|else
if|if
condition|(
operator|(
name|port
operator|>=
literal|44
operator|)
operator|&&
operator|(
name|port
operator|<
literal|46
operator|)
condition|)
return|return
name|CVMX_PKO_MAX_PORTS_INTERFACE0
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE0
operator|+
name|CVMX_PKO_MAX_PORTS_INTERFACE1
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_INTERFACE1
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_PCI
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_LOOP
operator|+
literal|4
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_SRIO0
operator|+
operator|(
name|port
operator|-
literal|44
operator|)
operator|*
name|CVMX_PKO_QUEUES_PER_PORT_SRIO2
return|;
else|else
comment|/* Given the limit on the number of ports we can map to          * CVMX_MAX_OUTPUT_QUEUES_STATIC queues (currently 256,          * divided among all cores), the remaining unmapped ports          * are assigned an illegal queue number */
return|return
name|CVMX_PKO_ILLEGAL_QUEUE
return|;
block|}
comment|/**  * For a given port number, return the base pko output queue  * for the port.  *  * @param port   IPD port number  * @return Base output queue  */
specifier|extern
name|int
name|cvmx_pko_get_base_queue
parameter_list|(
name|int
name|port
parameter_list|)
function_decl|;
comment|/**  * For a given port number, return the number of pko output queues.  *  * @param port   IPD port number  * @return Number of output queues  */
specifier|extern
name|int
name|cvmx_pko_get_num_queues
parameter_list|(
name|int
name|port
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
comment|/**  * Get the status counters for a port.  *  * @param ipd_port Port number (ipd_port) to get statistics for.  * @param clear    Set to 1 to clear the counters after they are read  * @param status   Where to put the results.  *  * Note:  *     - Only the doorbell for the base queue of the ipd_port is  *       collected.  *     - Retrieving the stats involves writing the index through  *       CVMX_PKO_REG_READ_IDX and reading the stat CSRs, in that  *       order. It is not MP-safe and caller should guarantee  *       atomicity.  */
specifier|static
specifier|inline
name|void
name|cvmx_pko_get_port_status
parameter_list|(
name|uint64_t
name|ipd_port
parameter_list|,
name|uint64_t
name|clear
parameter_list|,
name|cvmx_pko_port_status_t
modifier|*
name|status
parameter_list|)
block|{
name|cvmx_pko_reg_read_idx_t
name|pko_reg_read_idx
decl_stmt|;
name|cvmx_pko_mem_count0_t
name|pko_mem_count0
decl_stmt|;
name|cvmx_pko_mem_count1_t
name|pko_mem_count1
decl_stmt|;
name|int
name|pko_port
decl_stmt|,
name|port_base
decl_stmt|,
name|port_limit
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|port_base
operator|=
name|cvmx_helper_get_pko_port
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_base
operator|==
operator|-
literal|1
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Warning: Invalid port_base\n"
argument_list|)
expr_stmt|;
name|port_limit
operator|=
name|port_base
operator|+
name|cvmx_pko_get_num_pko_ports
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|port_base
operator|=
name|ipd_port
expr_stmt|;
name|port_limit
operator|=
name|port_base
operator|+
literal|1
expr_stmt|;
block|}
comment|/*      * status->packets and status->octets      */
name|status
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|octets
operator|=
literal|0
expr_stmt|;
name|pko_reg_read_idx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pko_port
operator|=
name|port_base
init|;
name|pko_port
operator|<
name|port_limit
condition|;
name|pko_port
operator|++
control|)
block|{
comment|/* 	 * In theory, one doesn't need to write the index csr every 	 * time as he can set pko_reg_read_idx.s.inc to increment 	 * the index automatically. Need to find out exactly how XXX. 	 */
name|pko_reg_read_idx
operator|.
name|s
operator|.
name|index
operator|=
name|pko_port
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|pko_reg_read_idx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pko_mem_count0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_COUNT0
argument_list|)
expr_stmt|;
name|status
operator|->
name|packets
operator|+=
name|pko_mem_count0
operator|.
name|s
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
name|pko_mem_count0
operator|.
name|s
operator|.
name|count
operator|=
name|pko_port
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_COUNT0
argument_list|,
name|pko_mem_count0
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|pko_mem_count1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_COUNT1
argument_list|)
expr_stmt|;
name|status
operator|->
name|octets
operator|+=
name|pko_mem_count1
operator|.
name|s
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
name|pko_mem_count1
operator|.
name|s
operator|.
name|count
operator|=
name|pko_port
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_COUNT1
argument_list|,
name|pko_mem_count1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * status->doorbell      */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|cvmx_pko_mem_debug9_t
name|debug9
decl_stmt|;
name|pko_reg_read_idx
operator|.
name|s
operator|.
name|index
operator|=
name|cvmx_pko_get_base_queue
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|pko_reg_read_idx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|debug9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_DEBUG9
argument_list|)
expr_stmt|;
name|status
operator|->
name|doorbell
operator|=
name|debug9
operator|.
name|cn38xx
operator|.
name|doorbell
expr_stmt|;
block|}
else|else
block|{
name|cvmx_pko_mem_debug8_t
name|debug8
decl_stmt|;
name|pko_reg_read_idx
operator|.
name|s
operator|.
name|index
operator|=
name|cvmx_pko_get_base_queue
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|pko_reg_read_idx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|debug8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_DEBUG8
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|status
operator|->
name|doorbell
operator|=
name|debug8
operator|.
name|cn68xx
operator|.
name|doorbell
expr_stmt|;
else|else
name|status
operator|->
name|doorbell
operator|=
name|debug8
operator|.
name|cn58xx
operator|.
name|doorbell
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CVMX_ENABLE_PKO_FUNCTION */
comment|/**  * Rate limit a PKO port to a max packets/sec. This function is only  * supported on CN57XX, CN56XX, CN55XX, and CN54XX.  *  * @param port      Port to rate limit  * @param packets_s Maximum packet/sec  * @param burst     Maximum number of packets to burst in a row before rate  *                  limiting cuts in.  *  * @return Zero on success, negative on failure  */
specifier|extern
name|int
name|cvmx_pko_rate_limit_packets
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|packets_s
parameter_list|,
name|int
name|burst
parameter_list|)
function_decl|;
comment|/**  * Rate limit a PKO port to a max bits/sec. This function is only  * supported on CN57XX, CN56XX, CN55XX, and CN54XX.  *  * @param port   Port to rate limit  * @param bits_s PKO rate limit in bits/sec  * @param burst  Maximum number of bits to burst before rate  *               limiting cuts in.  *  * @return Zero on success, negative on failure  */
specifier|extern
name|int
name|cvmx_pko_rate_limit_bits
parameter_list|(
name|int
name|port
parameter_list|,
name|uint64_t
name|bits_s
parameter_list|,
name|int
name|burst
parameter_list|)
function_decl|;
comment|/**  * @INTERNAL  *   * Retrieve the PKO pipe number for a port  *  * @param interface  * @param index  *  * @return negative on error.  *  * This applies only to the non-loopback interfaces.  *  */
specifier|extern
name|int
name|__cvmx_pko_get_pipe
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
comment|/**  * For a given PKO port number, return the base output queue  * for the port.  *  * @param pko_port   PKO port number  * @return           Base output queue  */
specifier|extern
name|int
name|cvmx_pko_get_base_queue_pkoid
parameter_list|(
name|int
name|pko_port
parameter_list|)
function_decl|;
comment|/**  * For a given PKO port number, return the number of output queues  * for the port.  *  * @param pko_port	PKO port number  * @return		the number of output queues  */
specifier|extern
name|int
name|cvmx_pko_get_num_queues_pkoid
parameter_list|(
name|int
name|pko_port
parameter_list|)
function_decl|;
comment|/**  * Ring the packet output doorbell. This tells the packet  * output hardware that "len" command words have been added  * to its pending list.  This command includes the required  * CVMX_SYNCWS before the doorbell ring.  *  * @param pko_port   Port the packet is for  * @param queue  Queue the packet is for  * @param len    Length of the command in 64 bit words  */
specifier|static
specifier|inline
name|void
name|cvmx_pko_doorbell_pkoid
parameter_list|(
name|uint64_t
name|pko_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|cvmx_pko_doorbell_address_t
name|ptr
decl_stmt|;
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|mem_space
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|did
operator|=
name|CVMX_OCT_DID_PKT_SEND
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|port
operator|=
name|pko_port
expr_stmt|;
name|ptr
operator|.
name|s
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
comment|/* Need to make sure output queue data is in DRAM before doorbell write */
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**  * Complete packet output. cvmx_pko_send_packet_prepare() must be called exactly once before this,  * and the same parameters must be passed to both cvmx_pko_send_packet_prepare() and  * cvmx_pko_send_packet_finish_pkoid().  *  * @param pko_port   Port to send it on  * @param queue  Queue to use  * @param pko_command  *               PKO HW command word  * @param packet Packet to send  * @param use_locking  *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE  *  * @return returns CVMX_PKO_SUCCESS on success, or error code on failure of output  */
specifier|static
specifier|inline
name|cvmx_pko_status_t
name|cvmx_pko_send_packet_finish_pkoid
parameter_list|(
name|int
name|pko_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|cvmx_pko_command_word0_t
name|pko_command
parameter_list|,
name|cvmx_buf_ptr_t
name|packet
parameter_list|,
name|cvmx_pko_lock_t
name|use_locking
parameter_list|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
if|if
condition|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_ATOMIC_TAG
condition|)
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_write2
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|,
operator|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_CMD_QUEUE
operator|)
argument_list|,
name|pko_command
operator|.
name|u64
argument_list|,
name|packet
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|result
operator|==
name|CVMX_CMD_QUEUE_SUCCESS
argument_list|)
condition|)
block|{
name|cvmx_pko_doorbell_pkoid
argument_list|(
name|pko_port
argument_list|,
name|queue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|CVMX_PKO_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_NO_MEMORY
operator|)
operator|||
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_FULL
operator|)
condition|)
block|{
return|return
name|CVMX_PKO_NO_MEMORY
return|;
block|}
else|else
block|{
return|return
name|CVMX_PKO_INVALID_QUEUE
return|;
block|}
block|}
comment|/**  * Complete packet output. cvmx_pko_send_packet_prepare() must be called exactly once before this,  * and the same parameters must be passed to both cvmx_pko_send_packet_prepare() and  * cvmx_pko_send_packet_finish_pkoid().  *  * @param pko_port   The PKO port the packet is for  * @param queue  Queue to use  * @param pko_command  *               PKO HW command word  * @param packet Packet to send  * @param addr   Plysical address of a work queue entry or physical address to zero on complete.  * @param use_locking  *               CVMX_PKO_LOCK_NONE, CVMX_PKO_LOCK_ATOMIC_TAG, or CVMX_PKO_LOCK_CMD_QUEUE  *  * @return returns CVMX_PKO_SUCCESS on success, or error code on failure of output  */
specifier|static
specifier|inline
name|cvmx_pko_status_t
name|cvmx_pko_send_packet_finish3_pkoid
parameter_list|(
name|uint64_t
name|pko_port
parameter_list|,
name|uint64_t
name|queue
parameter_list|,
name|cvmx_pko_command_word0_t
name|pko_command
parameter_list|,
name|cvmx_buf_ptr_t
name|packet
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|cvmx_pko_lock_t
name|use_locking
parameter_list|)
block|{
name|cvmx_cmd_queue_result_t
name|result
decl_stmt|;
if|if
condition|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_ATOMIC_TAG
condition|)
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|result
operator|=
name|cvmx_cmd_queue_write3
argument_list|(
name|CVMX_CMD_QUEUE_PKO
argument_list|(
name|queue
argument_list|)
argument_list|,
operator|(
name|use_locking
operator|==
name|CVMX_PKO_LOCK_CMD_QUEUE
operator|)
argument_list|,
name|pko_command
operator|.
name|u64
argument_list|,
name|packet
operator|.
name|u64
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|result
operator|==
name|CVMX_CMD_QUEUE_SUCCESS
argument_list|)
condition|)
block|{
name|cvmx_pko_doorbell_pkoid
argument_list|(
name|pko_port
argument_list|,
name|queue
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|CVMX_PKO_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_NO_MEMORY
operator|)
operator|||
operator|(
name|result
operator|==
name|CVMX_CMD_QUEUE_FULL
operator|)
condition|)
block|{
return|return
name|CVMX_PKO_NO_MEMORY
return|;
block|}
else|else
block|{
return|return
name|CVMX_PKO_INVALID_QUEUE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_PKO_H__ */
end_comment

end_unit

