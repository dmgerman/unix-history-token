begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Functions for RGMII/GMII/MII initialization, configuration,  * and monitoring.  *  *<hr>$Revision: 42417 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-mdio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * @INTERNAL  * Probe RGMII ports and determine the number present  *  * @param interface Interface to probe  *  * @return Number of RGMII/GMII/MII ports (0-4).  */
end_comment

begin_function
name|int
name|__cvmx_helper_rgmii_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|num_ports
init|=
literal|0
decl_stmt|;
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: RGMII initialize called in SPI interface\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
comment|/* On these chips "type" says we're in GMII/MII mode. This                 limits us to 2 ports */
name|num_ports
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unsupported Octeon model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
name|num_ports
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|num_ports
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unsupported Octeon model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|num_ports
return|;
block|}
end_function

begin_comment
comment|/**  * Put an RGMII interface in loopback mode. Internal packets sent  * out will be received back again on the same port. Externally  * received packets will echo back out.  *  * @param port   IPD port number to loop.  */
end_comment

begin_function
name|void
name|cvmx_helper_rgmii_internal_loopback
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|interface
init|=
operator|(
name|port
operator|>>
literal|4
operator|)
operator|&
literal|1
decl_stmt|;
name|int
name|index
init|=
name|port
operator|&
literal|0xf
decl_stmt|;
name|uint64_t
name|tmp
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|gmx_cfg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_PRT_LOOP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_PRT_LOOP
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|index
operator|)
operator||
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|index
operator|)
operator||
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|index
operator|)
operator||
name|tmp
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure all of the ASX, GMX, and PKO regsiters required  * to get RGMII to function on the supplied interface.  *  * @param interface PKO Interface to configure (0 or 1)  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|__cvmx_helper_rgmii_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|num_ports
init|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|int
name|port
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
name|cvmx_asxx_tx_prt_en_t
name|asx_tx
decl_stmt|;
name|cvmx_asxx_rx_prt_en_t
name|asx_rx
decl_stmt|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|s
operator|.
name|en
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
operator|&&
name|mode
operator|.
name|s
operator|.
name|type
operator|==
literal|1
condition|)
comment|/* Ignore SPI interfaces */
return|return
operator|-
literal|1
return|;
comment|/* Configure the ASX registers needed to use the RGMII ports */
name|asx_tx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|asx_tx
operator|.
name|s
operator|.
name|prt_en
operator|=
name|cvmx_build_mask
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|asx_tx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|asx_rx
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|asx_rx
operator|.
name|s
operator|.
name|prt_en
operator|=
name|cvmx_build_mask
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|asx_rx
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Configure the GMX registers needed to use the RGMII ports */
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* Setting of CVMX_GMXX_TXX_THRESH has been moved to             __cvmx_helper_setup_gmx() */
if|if
condition|(
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|__cvmx_helper_errata_asx_pass1
argument_list|(
name|interface
argument_list|,
name|port
argument_list|,
name|sys_info_ptr
operator|->
name|cpu_clock_hz
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Configure more flexible RGMII preamble checking. Pass 1 doesn't                 support this feature. */
name|cvmx_gmxx_rxx_frm_ctl_t
name|frm_ctl
decl_stmt|;
name|frm_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|frm_ctl
operator|.
name|s
operator|.
name|pre_free
operator|=
literal|1
expr_stmt|;
comment|/* New field, so must be compile time */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_FRM_CTL
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
name|frm_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Each pause frame transmitted will ask for about 10M bit times             before resume.  If buffer space comes available before that time             has expired, an XON pause frame (0 time) will be transmitted to             restart the flow. */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_PAUSE_PKT_TIME
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|20000
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_PAUSE_PKT_INTERVAL
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|19000
argument_list|)
expr_stmt|;
comment|/*          * Board types we have to know at compile-time.          */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_BOARD_CAPK_0100ND
argument_list|)
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|26
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Vendor-defined board types. 	 */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/*          * For board types we can determine at runtime.          */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
name|__cvmx_helper_setup_gmx
argument_list|(
name|interface
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
comment|/* enable the ports now */
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|cvmx_helper_link_autoconf
argument_list|(
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|port
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_rgmii_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_asxx_prt_loop_t
name|asxx_prt_loop
decl_stmt|;
name|asxx_prt_loop
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_PRT_LOOP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asxx_prt_loop
operator|.
name|s
operator|.
name|int_loop
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
block|{
comment|/* Force 1Gbps full duplex on internal loopback */
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
name|__cvmx_helper_board_link_get
argument_list|(
name|ipd_port
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_rgmii_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|original_gmx_cfg
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|new_gmx_cfg
decl_stmt|;
name|cvmx_pko_mem_queue_qos_t
name|pko_mem_queue_qos
decl_stmt|;
name|cvmx_pko_mem_queue_qos_t
name|pko_mem_queue_qos_save
index|[
literal|16
index|]
decl_stmt|;
name|cvmx_gmxx_tx_ovr_bp_t
name|gmx_tx_ovr_bp
decl_stmt|;
name|cvmx_gmxx_tx_ovr_bp_t
name|gmx_tx_ovr_bp_save
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Ignore speed sets in the simulator */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
return|return
literal|0
return|;
comment|/* Read the current settings so we know the current enable state */
name|original_gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|new_gmx_cfg
operator|=
name|original_gmx_cfg
expr_stmt|;
comment|/* Disable the lowest level RX */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable all queues so that TX should become idle */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cvmx_pko_get_num_queues
argument_list|(
name|ipd_port
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|queue
init|=
name|cvmx_pko_get_base_queue
argument_list|(
name|ipd_port
argument_list|)
operator|+
name|i
decl_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|pko_mem_queue_qos
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_QUEUE_QOS
argument_list|)
expr_stmt|;
name|pko_mem_queue_qos
operator|.
name|s
operator|.
name|pid
operator|=
name|ipd_port
expr_stmt|;
name|pko_mem_queue_qos
operator|.
name|s
operator|.
name|qid
operator|=
name|queue
expr_stmt|;
name|pko_mem_queue_qos_save
index|[
name|i
index|]
operator|=
name|pko_mem_queue_qos
expr_stmt|;
name|pko_mem_queue_qos
operator|.
name|s
operator|.
name|qos_mask
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_QUEUE_QOS
argument_list|,
name|pko_mem_queue_qos
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Disable backpressure */
name|gmx_tx_ovr_bp
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_OVR_BP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_tx_ovr_bp_save
operator|=
name|gmx_tx_ovr_bp
expr_stmt|;
name|gmx_tx_ovr_bp
operator|.
name|s
operator|.
name|bp
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
name|gmx_tx_ovr_bp
operator|.
name|s
operator|.
name|en
operator||=
literal|1
operator|<<
name|index
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_OVR_BP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_tx_ovr_bp
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_OVR_BP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Poll the GMX state machine waiting for it to become idle. Preferably we         should only change speed when it is idle. If it doesn't become idle we         will still do the speed change, but there is a slight chance that GMX         will lockup */
name|cvmx_write_csr
argument_list|(
name|CVMX_NPI_DBG_SELECT
argument_list|,
name|interface
operator|*
literal|0x800
operator|+
name|index
operator|*
literal|0x100
operator|+
literal|0x880
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_DBG_DATA
argument_list|,
name|cvmx_dbg_data_t
argument_list|,
name|data
operator|&
literal|7
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_DBG_DATA
argument_list|,
name|cvmx_dbg_data_t
argument_list|,
name|data
operator|&
literal|0xf
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
comment|/* Disable the port before we make any changes */
name|new_gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|new_gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set full/half duplex */
if|if
condition|(
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|new_gmx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Half duplex is broken for 38XX Pass 1 */
elseif|else
if|if
condition|(
operator|!
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
name|new_gmx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Force full duplex on down links */
else|else
name|new_gmx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
comment|/* Set the link speed. Anything unknown is set to 1Gbps */
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
condition|)
block|{
name|new_gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|new_gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|100
condition|)
block|{
name|new_gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|new_gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|new_gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|new_gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Adjust the clocks */
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|100
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
operator|)
operator|||
operator|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|100
operator|)
condition|)
block|{
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/*             ** Port  .en  .type  .p0mii  Configuration             ** ----  ---  -----  ------  -----------------------------------------             **  X      0     X      X    All links are disabled.             **  0      1     X      0    Port 0 is RGMII             **  0      1     X      1    Port 0 is MII             **  1      1     0      X    Ports 1 and 2 are configured as RGMII ports.             **  1      1     1      X    Port 1: GMII/MII; Port 2: disabled. GMII or             **                           MII port is selected by GMX_PRT1_CFG[SPEED].             */
comment|/* In MII mode, CLK_CNT = 1. */
if|if
condition|(
operator|(
operator|(
name|index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mode
operator|.
name|s
operator|.
name|p0mii
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|index
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|mode
operator|.
name|s
operator|.
name|type
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do a read to make sure all setup stuff is complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the new GMX setting without enabling the port */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|new_gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Enable the lowest level RX */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|index
operator|)
argument_list|)
expr_stmt|;
comment|/* Re-enable the TX path */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cvmx_pko_get_num_queues
argument_list|(
name|ipd_port
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|queue
init|=
name|cvmx_pko_get_base_queue
argument_list|(
name|ipd_port
argument_list|)
operator|+
name|i
decl_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_QUEUE_QOS
argument_list|,
name|pko_mem_queue_qos_save
index|[
name|i
index|]
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Restore backpressure */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_OVR_BP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_tx_ovr_bp_save
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Restore the GMX enable state. Port config is complete */
name|new_gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
name|original_gmx_cfg
operator|.
name|s
operator|.
name|en
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|new_gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|__cvmx_helper_rgmii_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|original_enable
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|cvmx_asxx_prt_loop_t
name|asxx_prt_loop
decl_stmt|;
comment|/* Read the current enable state and save it */
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|original_enable
operator|=
name|gmx_cfg
operator|.
name|s
operator|.
name|en
expr_stmt|;
comment|/* Force port to be disabled */
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|enable_internal
condition|)
block|{
comment|/* Force speed if we're doing internal loopback */
name|gmx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_CLK
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Set the loopback bits */
name|asxx_prt_loop
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_PRT_LOOP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_internal
condition|)
name|asxx_prt_loop
operator|.
name|s
operator|.
name|int_loop
operator||=
literal|1
operator|<<
name|index
expr_stmt|;
else|else
name|asxx_prt_loop
operator|.
name|s
operator|.
name|int_loop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
if|if
condition|(
name|enable_external
condition|)
name|asxx_prt_loop
operator|.
name|s
operator|.
name|ext_loop
operator||=
literal|1
operator|<<
name|index
expr_stmt|;
else|else
name|asxx_prt_loop
operator|.
name|s
operator|.
name|ext_loop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_PRT_LOOP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|asxx_prt_loop
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Force enables in internal loopback */
if|if
condition|(
name|enable_internal
condition|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|index
operator|)
operator||
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_PRT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|index
operator|)
operator||
name|tmp
argument_list|)
expr_stmt|;
name|original_enable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Restore the enable state */
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
name|original_enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

