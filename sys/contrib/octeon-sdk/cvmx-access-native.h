begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  * Functions for accessing memory and CSRs on Octeon when we are compiling  * natively.  *  *<hr>$Revision: 38306 $<hr> */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_ACCESS_NATIVE_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_ACCESS_NATIVE_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * Returns the Octeon processor ID.  *  * @return Octeon processor ID from COP0  */
specifier|static
specifier|inline
name|uint32_t
name|cvmx_get_proc_id
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
specifier|extern
name|uint32_t
name|cvmx_app_init_processor_id
decl_stmt|;
return|return
name|cvmx_app_init_processor_id
return|;
else|#
directive|else
name|uint32_t
name|id
decl_stmt|;
asm|asm ("mfc0 %0, $15,0" : "=r" (id));
return|return
name|id
return|;
endif|#
directive|endif
block|}
comment|/**  * Convert a memory pointer (void*) into a hardware compatable  * memory address (uint64_t). Octeon hardware widgets don't  * understand logical addresses.  *  * @param ptr    C style memory pointer  * @return Hardware physical address  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_ptr_to_phys
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
name|cvmx_warn_if
argument_list|(
name|ptr
operator|==
name|NULL
argument_list|,
literal|"cvmx_ptr_to_phys() passed a NULL pointer\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_UBOOT
name|uint64_t
name|uboot_tlb_ptr_to_phys
argument_list|(
name|void
operator|*
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|uint32_t
operator|)
name|ptr
operator|)
operator|<
literal|0x80000000
condition|)
block|{
comment|/* Handle useg (unmapped due to ERL) here*/
return|return
operator|(
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0x7FFFFFFF
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|uint32_t
operator|)
name|ptr
operator|)
operator|<
literal|0xC0000000
condition|)
block|{
comment|/* Here we handle KSEG0/KSEG1 _pointers_.  We know we are dealing         ** with 32 bit only values, so we treat them that way.  Note that         ** a cvmx_phys_to_ptr(cvmx_ptr_to_phys(X)) will not return X in this case,         ** but the physical address of the KSEG0/KSEG1 address. */
return|return
operator|(
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0x1FFFFFFF
operator|)
return|;
block|}
else|else
return|return
operator|(
name|uboot_tlb_ptr_to_phys
argument_list|(
name|ptr
argument_list|)
operator|)
return|;
comment|/* Should not get get here in !TLB case */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|8
condition|)
block|{
comment|/* We're running in 64 bit mode. Normally this means that we can use             40 bits of address space (the hardware limit). Unfortunately there             is one case were we need to limit this to 30 bits, sign extended             32 bit. Although these are 64 bits wide, only 30 bits can be used */
if|if
condition|(
operator|(
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|>>
literal|62
operator|)
operator|==
literal|3
condition|)
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
name|cvmx_build_mask
argument_list|(
literal|30
argument_list|)
return|;
else|else
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
name|cvmx_build_mask
argument_list|(
literal|40
argument_list|)
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
return|return
call|(
name|long
call|)
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0x1fffffff
return|;
else|#
directive|else
specifier|extern
name|uint64_t
name|linux_mem32_offset
decl_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|ptr
argument_list|)
condition|)
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|-
name|linux_mem32_offset
return|;
else|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
return|return
call|(
name|long
call|)
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0x7fffffff
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|VXWORKS_USER_MAPPINGS
argument_list|)
comment|/* This mapping mode is used in vxWorks 5.5 to support 2GB of ram. The         2nd 256MB is mapped at 0x10000000 and the rest of memory is 1:1 */
name|uint64_t
name|address
init|=
operator|(
name|long
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|address
operator|&
literal|0x80000000
condition|)
return|return
name|address
operator|&
literal|0x1fffffff
return|;
comment|/* KSEG pointers directly map the lower 256MB and bootbus */
elseif|else
if|if
condition|(
operator|(
name|address
operator|>=
literal|0x10000000
operator|)
operator|&&
operator|(
name|address
operator|<
literal|0x20000000
operator|)
condition|)
return|return
name|address
operator|+
literal|0x400000000ull
return|;
comment|/* 256MB-512MB is a virtual mapping for the 2nd 256MB */
else|else
return|return
name|address
return|;
comment|/* Looks to be a 1:1 mapped userspace pointer */
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
return|return
operator|(
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|ptr
argument_list|)
operator|)
return|;
else|#
directive|else
if|#
directive|if
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
comment|/* We are assumung we're running the Simple Executive standalone. In this         mode the TLB is setup to perform 1:1 mapping and 32 bit sign extended         addresses are never used. Since we know all this, save the masking         cycles and do nothing */
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|8
condition|)
block|{
comment|/* We're running in 64 bit mode. Normally this means that we can use             40 bits of address space (the hardware limit). Unfortunately there             is one case were we need to limit this to 30 bits, sign extended             32 bit. Although these are 64 bits wide, only 30 bits can be used */
if|if
condition|(
operator|(
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|>>
literal|62
operator|)
operator|==
literal|3
condition|)
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
name|cvmx_build_mask
argument_list|(
literal|30
argument_list|)
return|;
else|else
return|return
name|CAST64
argument_list|(
name|ptr
argument_list|)
operator|&
name|cvmx_build_mask
argument_list|(
literal|40
argument_list|)
return|;
block|}
else|else
return|return
call|(
name|long
call|)
argument_list|(
name|ptr
argument_list|)
operator|&
literal|0x7fffffff
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/**  * Convert a hardware physical address (uint64_t) into a  * memory pointer (void *).  *  * @param physical_address  *               Hardware physical address to memory  * @return Pointer to memory  */
specifier|static
specifier|inline
name|void
modifier|*
name|cvmx_phys_to_ptr
parameter_list|(
name|uint64_t
name|physical_address
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
name|cvmx_warn_if
argument_list|(
name|physical_address
operator|==
literal|0
argument_list|,
literal|"cvmx_phys_to_ptr() passed a zero address\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_UBOOT
comment|/* U-boot is a special case, as it is running in 32 bit mode, using the TLB to map code/data     ** which can have a physical address above the 32 bit address space.  1-1 mappings are used     ** to allow the low 2 GBytes to be accessed as in error level.     **     ** NOTE:  This conversion can cause problems in u-boot, as users may want to enter addresses     ** like 0xBFC00000 (kseg1 boot bus address), which is a valid 64 bit physical address,     ** but is likely intended to be a boot bus address. */
if|if
condition|(
name|physical_address
operator|<
literal|0x80000000
condition|)
block|{
comment|/* Handle useg here.  ERL is set, so useg is unmapped.  This is the only physical         ** address range that is directly addressable by u-boot. */
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|physical_address
argument_list|)
return|;
block|}
else|else
block|{
name|DECLARE_GLOBAL_DATA_PTR
expr_stmt|;
specifier|extern
name|char
name|uboot_start
decl_stmt|;
comment|/* Above 0x80000000 we can only support one case - a physical address         ** that is mapped for u-boot code/data.  We check against the u-boot mem range,         ** and return NULL if it is out of this range.         */
if|if
condition|(
name|physical_address
operator|>=
name|gd
operator|->
name|bd
operator|->
name|bi_uboot_ram_addr
operator|&&
name|physical_address
operator|<
name|gd
operator|->
name|bd
operator|->
name|bi_uboot_ram_addr
operator|+
name|gd
operator|->
name|bd
operator|->
name|bi_uboot_ram_used_size
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uboot_start
operator|+
operator|(
name|physical_address
operator|-
name|gd
operator|->
name|bd
operator|->
name|bi_uboot_ram_addr
operator|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|physical_address
operator|>=
literal|0x80000000
condition|)
return|return
name|NULL
return|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|8
condition|)
block|{
comment|/* Just set the top bit, avoiding any TLB uglyness */
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
else|#
directive|else
specifier|extern
name|uint64_t
name|linux_mem32_offset
decl_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|physical_address
argument_list|)
condition|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|physical_address
operator|+
name|linux_mem32_offset
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|_WRS_KERNEL
argument_list|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|VXWORKS_USER_MAPPINGS
argument_list|)
comment|/* This mapping mode is used in vxWorks 5.5 to support 2GB of ram. The         2nd 256MB is mapped at 0x10000000 and the rest of memory is 1:1 */
if|if
condition|(
operator|(
name|physical_address
operator|>=
literal|0x10000000
operator|)
operator|&&
operator|(
name|physical_address
operator|<
literal|0x20000000
operator|)
condition|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
operator|&&
operator|(
name|physical_address
operator|>=
literal|0x410000000ull
operator|)
operator|&&
operator|(
name|physical_address
operator|<
literal|0x420000000ull
operator|)
condition|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|physical_address
operator|-
literal|0x400000000ull
argument_list|)
return|;
else|else
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|physical_address
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|physical_address
operator|<
literal|0x20000000
condition|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
else|else
name|panic
argument_list|(
literal|"%s: mapping high address (%#jx) not yet supported.\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|physical_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
comment|/* We are assumung we're running the Simple Executive standalone. In this             mode the TLB is setup to perform 1:1 mapping and 32 bit sign extended             addresses are never used. Since we know all this, save bit insert             cycles and do nothing */
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|physical_address
argument_list|)
return|;
else|#
directive|else
comment|/* Set the XKPHYS/KSEG0 bit as appropriate based on ABI */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|8
condition|)
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
else|else
return|return
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|physical_address
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* The following #if controls the definition of the macro     CVMX_BUILD_WRITE64. This macro is used to build a store operation to     a full 64bit address. With a 64bit ABI, this can be done with a simple     pointer access. 32bit ABIs require more complicated assembly */
if|#
directive|if
name|defined
argument_list|(
name|CVMX_ABI_N64
argument_list|)
operator|||
name|defined
argument_list|(
name|CVMX_ABI_EABI
argument_list|)
comment|/* We have a full 64bit ABI. Writing to a 64bit address can be done with     a simple volatile pointer */
define|#
directive|define
name|CVMX_BUILD_WRITE64
parameter_list|(
name|TYPE
parameter_list|,
name|ST
parameter_list|)
define|\
value|static inline void cvmx_write64_##TYPE(uint64_t addr, TYPE##_t val)     \ {                                                                       \     *CASTPTR(volatile TYPE##_t, addr) = val;                            \ }
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
comment|/* The N32 ABI passes all 64bit quantities in a single register, so it is     possible to use the arguments directly. We have to use inline assembly     for the actual store since a pointer would truncate the address */
define|#
directive|define
name|CVMX_BUILD_WRITE64
parameter_list|(
name|TYPE
parameter_list|,
name|ST
parameter_list|)
define|\
value|static inline void cvmx_write64_##TYPE(uint64_t addr, TYPE##_t val)     \ {                                                                       \     asm volatile (ST " %[v], 0(%[c])" ::[v] "r" (val), [c] "r" (addr)); \ }
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_O32
argument_list|)
ifdef|#
directive|ifdef
name|__KERNEL__
define|#
directive|define
name|CVMX_BUILD_WRITE64
parameter_list|(
name|TYPE
parameter_list|,
name|LT
parameter_list|)
value|extern void cvmx_write64_##TYPE(uint64_t csr_addr, TYPE##_t val);
else|#
directive|else
comment|/* Ok, now the ugly stuff starts. O32 splits 64bit quantities into two     separate registers. Assembly must be used to put them back together     before they're used. What should be a simple store becomes a     convoluted mess of shifts and ors */
define|#
directive|define
name|CVMX_BUILD_WRITE64
parameter_list|(
name|TYPE
parameter_list|,
name|ST
parameter_list|)
define|\
value|static inline void cvmx_write64_##TYPE(uint64_t csr_addr, TYPE##_t val) \ {                                                                       \     if (sizeof(TYPE##_t) == 8)                                          \     {                                                                   \         uint32_t csr_addrh = csr_addr>>32;                              \         uint32_t csr_addrl = csr_addr;                                  \         uint32_t valh = (uint64_t)val>>32;                              \         uint32_t vall = val;                                            \         uint32_t tmp1;                                                  \         uint32_t tmp2;                                                  \         uint32_t tmp3;                                                  \                                                                         \         asm volatile (                                                  \             ".set push\n"                                             \             ".set mips64\n"                                             \             "dsll   %[tmp1], %[valh], 32\n"                             \             "dsll   %[tmp2], %[csrh], 32\n"                             \             "dsll   %[tmp3], %[vall], 32\n"                             \             "dsrl   %[tmp3], %[tmp3], 32\n"                             \             "or     %[tmp1], %[tmp1], %[tmp3]\n"                        \             "dsll   %[tmp3], %[csrl], 32\n"                             \             "dsrl   %[tmp3], %[tmp3], 32\n"                             \             "or     %[tmp2], %[tmp2], %[tmp3]\n"                        \             ST "    %[tmp1], 0(%[tmp2])\n"                              \             ".set pop\n"                                             \             : [tmp1] "=&r" (tmp1), [tmp2] "=&r" (tmp2), [tmp3] "=&r" (tmp3)\             : [valh] "r" (valh), [vall] "r" (vall),                     \               [csrh] "r" (csr_addrh), [csrl] "r" (csr_addrl)            \         );                                                              \     }                                                                   \     else                                                                \     {                                                                   \         uint32_t csr_addrh = csr_addr>>32;                              \         uint32_t csr_addrl = csr_addr;                                  \         uint32_t tmp1;                                                  \         uint32_t tmp2;                                                  \                                                                         \         asm volatile (                                                  \             ".set push\n"                                             \             ".set mips64\n"                                             \             "dsll   %[tmp1], %[csrh], 32\n"                             \             "dsll   %[tmp2], %[csrl], 32\n"                             \             "dsrl   %[tmp2], %[tmp2], 32\n"                             \             "or     %[tmp1], %[tmp1], %[tmp2]\n"                        \             ST "    %[val], 0(%[tmp1])\n"                               \             ".set pop\n"                                             \             : [tmp1] "=&r" (tmp1), [tmp2] "=&r" (tmp2)                  \             : [val] "r" (val), [csrh] "r" (csr_addrh),                  \               [csrl] "r" (csr_addrl)                                    \         );                                                              \     }                                                                   \ }
endif|#
directive|endif
else|#
directive|else
comment|/* cvmx-abi.h didn't recognize the ABI. Force the compile to fail. */
error|#
directive|error
error|: Unsupported ABI
endif|#
directive|endif
comment|/* The following #if controls the definition of the macro     CVMX_BUILD_READ64. This macro is used to build a load operation from     a full 64bit address. With a 64bit ABI, this can be done with a simple     pointer access. 32bit ABIs require more complicated assembly */
if|#
directive|if
name|defined
argument_list|(
name|CVMX_ABI_N64
argument_list|)
operator|||
name|defined
argument_list|(
name|CVMX_ABI_EABI
argument_list|)
comment|/* We have a full 64bit ABI. Writing to a 64bit address can be done with     a simple volatile pointer */
define|#
directive|define
name|CVMX_BUILD_READ64
parameter_list|(
name|TYPE
parameter_list|,
name|LT
parameter_list|)
define|\
value|static inline TYPE##_t cvmx_read64_##TYPE(uint64_t addr)                \ {                                                                       \     return *CASTPTR(volatile TYPE##_t, addr);                           \ }
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
comment|/* The N32 ABI passes all 64bit quantities in a single register, so it is     possible to use the arguments directly. We have to use inline assembly     for the actual store since a pointer would truncate the address */
define|#
directive|define
name|CVMX_BUILD_READ64
parameter_list|(
name|TYPE
parameter_list|,
name|LT
parameter_list|)
define|\
value|static inline TYPE##_t cvmx_read64_##TYPE(uint64_t addr)                \ {                                                                       \     TYPE##_t val;                                                       \     asm volatile (LT " %[v], 0(%[c])": [v] "=r" (val) : [c] "r" (addr));\     return val;                                                         \ }
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_O32
argument_list|)
ifdef|#
directive|ifdef
name|__KERNEL__
define|#
directive|define
name|CVMX_BUILD_READ64
parameter_list|(
name|TYPE
parameter_list|,
name|LT
parameter_list|)
value|extern TYPE##_t cvmx_read64_##TYPE(uint64_t csr_addr);
else|#
directive|else
comment|/* Ok, now the ugly stuff starts. O32 splits 64bit quantities into two     separate registers. Assembly must be used to put them back together     before they're used. What should be a simple load becomes a     convoluted mess of shifts and ors */
define|#
directive|define
name|CVMX_BUILD_READ64
parameter_list|(
name|TYPE
parameter_list|,
name|LT
parameter_list|)
define|\
value|static inline TYPE##_t cvmx_read64_##TYPE(uint64_t csr_addr)            \ {                                                                       \     if (sizeof(TYPE##_t) == 8)                                          \     {                                                                   \         uint32_t csr_addrh = csr_addr>>32;                              \         uint32_t csr_addrl = csr_addr;                                  \         uint32_t valh;                                                  \         uint32_t vall;                                                  \                                                                         \         asm volatile (                                                  \             ".set push\n"                                               \             ".set mips64\n"                                             \             "dsll   %[valh], %[csrh], 32\n"                             \             "dsll   %[vall], %[csrl], 32\n"                             \             "dsrl   %[vall], %[vall], 32\n"                             \             "or     %[valh], %[valh], %[vall]\n"                        \             LT "    %[vall], 0(%[valh])\n"                              \             "dsrl   %[valh], %[vall], 32\n"                             \             "sll    %[vall], 0\n"                                       \             "sll    %[valh], 0\n"                                       \             ".set pop\n"                                                \             : [valh] "=&r" (valh), [vall] "=&r" (vall)                  \             : [csrh] "r" (csr_addrh), [csrl] "r" (csr_addrl)            \         );                                                              \         return ((uint64_t)valh<<32) | vall;                             \     }                                                                   \     else                                                                \     {                                                                   \         uint32_t csr_addrh = csr_addr>>32;                              \         uint32_t csr_addrl = csr_addr;                                  \         TYPE##_t val;                                                   \         uint32_t tmp;                                                   \                                                                         \         asm volatile (                                                  \             ".set push\n"                                             \             ".set mips64\n"                                             \             "dsll   %[val], %[csrh], 32\n"                              \             "dsll   %[tmp], %[csrl], 32\n"                              \             "dsrl   %[tmp], %[tmp], 32\n"                               \             "or     %[val], %[val], %[tmp]\n"                           \             LT "    %[val], 0(%[val])\n"                                \             ".set pop\n"                                             \             : [val] "=&r" (val), [tmp] "=&r" (tmp)                      \             : [csrh] "r" (csr_addrh), [csrl] "r" (csr_addrl)            \         );                                                              \         return val;                                                     \     }                                                                   \ }
endif|#
directive|endif
comment|/* __KERNEL__ */
else|#
directive|else
comment|/* cvmx-abi.h didn't recognize the ABI. Force the compile to fail. */
error|#
directive|error
error|: Unsupported ABI
endif|#
directive|endif
comment|/* The following defines 8 functions for writing to a 64bit address. Each     takes two arguments, the address and the value to write.     cvmx_write64_int64      cvmx_write64_uint64     cvmx_write64_int32      cvmx_write64_uint32     cvmx_write64_int16      cvmx_write64_uint16     cvmx_write64_int8       cvmx_write64_uint8 */
name|CVMX_BUILD_WRITE64
argument_list|(
name|int64
argument_list|,
literal|"sd"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|int32
argument_list|,
literal|"sw"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|int16
argument_list|,
literal|"sh"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|int8
argument_list|,
literal|"sb"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|uint64
argument_list|,
literal|"sd"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|uint32
argument_list|,
literal|"sw"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|uint16
argument_list|,
literal|"sh"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_WRITE64
argument_list|(
name|uint8
argument_list|,
literal|"sb"
argument_list|)
expr_stmt|;
comment|/* The following defines 8 functions for reading from a 64bit address. Each     takes the address as the only argument     cvmx_read64_int64       cvmx_read64_uint64     cvmx_read64_int32       cvmx_read64_uint32     cvmx_read64_int16       cvmx_read64_uint16     cvmx_read64_int8        cvmx_read64_uint8 */
name|CVMX_BUILD_READ64
argument_list|(
name|int64
argument_list|,
literal|"ld"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|int32
argument_list|,
literal|"lw"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|int16
argument_list|,
literal|"lh"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|int8
argument_list|,
literal|"lb"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|uint64
argument_list|,
literal|"ld"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|uint32
argument_list|,
literal|"lw"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|uint16
argument_list|,
literal|"lhu"
argument_list|)
expr_stmt|;
name|CVMX_BUILD_READ64
argument_list|(
name|uint8
argument_list|,
literal|"lbu"
argument_list|)
expr_stmt|;
specifier|static
specifier|inline
name|void
name|cvmx_write_csr
parameter_list|(
name|uint64_t
name|csr_addr
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
name|csr_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Perform an immediate read after every write to an RSL register to force         the write to complete. It doesn't matter what RSL read we do, so we         choose CVMX_MIO_BOOT_BIST_STAT because it is fast and harmless */
if|if
condition|(
operator|(
operator|(
name|csr_addr
operator|>>
literal|40
operator|)
operator|&
literal|0x7ffff
operator|)
operator|==
operator|(
literal|0x118
operator|)
condition|)
name|cvmx_read64_uint64
argument_list|(
name|CVMX_MIO_BOOT_BIST_STAT
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|cvmx_write_io
parameter_list|(
name|uint64_t
name|io_addr
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
name|io_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|uint64_t
name|cvmx_read_csr
parameter_list|(
name|uint64_t
name|csr_addr
parameter_list|)
block|{
return|return
name|cvmx_read64_uint64
argument_list|(
name|csr_addr
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|cvmx_send_single
parameter_list|(
name|uint64_t
name|data
parameter_list|)
block|{
specifier|const
name|uint64_t
name|CVMX_IOBDMA_SENDSINGLE
init|=
literal|0xffffffffffffa200ull
decl_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_IOBDMA_SENDSINGLE
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|cvmx_read_csr_async
parameter_list|(
name|uint64_t
name|scraddr
parameter_list|,
name|uint64_t
name|csr_addr
parameter_list|)
block|{
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|scraddr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|len
range|:
literal|8
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|48
decl_stmt|;
block|}
name|s
struct|;
block|}
name|addr
union|;
name|addr
operator|.
name|u64
operator|=
name|csr_addr
expr_stmt|;
name|addr
operator|.
name|s
operator|.
name|scraddr
operator|=
name|scraddr
operator|>>
literal|3
expr_stmt|;
name|addr
operator|.
name|s
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|cvmx_send_single
argument_list|(
name|addr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Number of the Core on which the program is currently running.  *  * @return Number of cores  */
specifier|static
specifier|inline
name|unsigned
name|int
name|cvmx_get_core_num
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|core_num
decl_stmt|;
name|CVMX_RDHWRNV
argument_list|(
name|core_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|core_num
return|;
block|}
comment|/**  * Returns the number of bits set in the provided value.  * Simple wrapper for POP instruction.  *  * @param val    32 bit value to count set bits in  *  * @return Number of bits set  */
specifier|static
specifier|inline
name|uint32_t
name|cvmx_pop
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|pop
decl_stmt|;
name|CVMX_POP
argument_list|(
name|pop
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|pop
return|;
block|}
comment|/**  * Returns the number of bits set in the provided value.  * Simple wrapper for DPOP instruction.  *  * @param val    64 bit value to count set bits in  *  * @return Number of bits set  */
specifier|static
specifier|inline
name|int
name|cvmx_dpop
parameter_list|(
name|uint64_t
name|val
parameter_list|)
block|{
name|int
name|pop
decl_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|pop
return|;
block|}
comment|/**  * @deprecated  * Provide current cycle counter as a return value. Deprecated, use  * cvmx_clock_get_count(CVMX_CLOCK_CORE) to get cycle counter.  *  * @return current cycle counter  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_get_cycle
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
return|;
block|}
comment|/**  * @deprecated  * Reads a chip global cycle counter.  This counts SCLK cycles since  * chip reset.  The counter is 64 bit. This function is deprecated as the rate  * of the global cycle counter is different between Octeon+ and Octeon2, use  * cvmx_clock_get_count(CVMX_CLOCK_SCLK) instead. For Octeon2, the clock rate  * of SCLK may be differnet than the core clock.  *  * @return Global chip cycle count since chip reset.  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_get_cycle_global
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_IPD
argument_list|)
return|;
block|}
comment|/**  * Wait for the specified number of core clock cycles  *  * @param cycles  */
specifier|static
specifier|inline
name|void
name|cvmx_wait
parameter_list|(
name|uint64_t
name|cycles
parameter_list|)
block|{
name|uint64_t
name|done
init|=
name|cvmx_get_cycle
argument_list|()
operator|+
name|cycles
decl_stmt|;
while|while
condition|(
name|cvmx_get_cycle
argument_list|()
operator|<
name|done
condition|)
block|{
comment|/* Spin */
block|}
block|}
comment|/**  * Wait for the specified number of micro seconds  *  * @param usec   micro seconds to wait  */
specifier|static
specifier|inline
name|void
name|cvmx_wait_usec
parameter_list|(
name|uint64_t
name|usec
parameter_list|)
block|{
name|uint64_t
name|done
init|=
name|cvmx_get_cycle
argument_list|()
operator|+
name|usec
operator|*
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000000
decl_stmt|;
while|while
condition|(
name|cvmx_get_cycle
argument_list|()
operator|<
name|done
condition|)
block|{
comment|/* Spin */
block|}
block|}
comment|/**  * Wait for the specified number of io clock cycles  *  * @param cycles  */
specifier|static
specifier|inline
name|void
name|cvmx_wait_io
parameter_list|(
name|uint64_t
name|cycles
parameter_list|)
block|{
name|uint64_t
name|done
init|=
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_SCLK
argument_list|)
operator|+
name|cycles
decl_stmt|;
while|while
condition|(
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_SCLK
argument_list|)
operator|<
name|done
condition|)
block|{
comment|/* Spin */
block|}
block|}
comment|/**  * Perform a soft reset of Octeon  *  * @return  */
specifier|static
specifier|inline
name|void
name|cvmx_reset_octeon
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_ciu_soft_rst_t
name|ciu_soft_rst
decl_stmt|;
name|ciu_soft_rst
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ciu_soft_rst
operator|.
name|s
operator|.
name|soft_rst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_RST
argument_list|,
name|ciu_soft_rst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Read a byte of fuse data  * @param byte_addr   address to read  *  * @return fuse value: 0 or 1  */
specifier|static
specifier|inline
name|uint8_t
name|cvmx_fuse_read_byte
parameter_list|(
name|int
name|byte_addr
parameter_list|)
block|{
name|cvmx_mio_fus_rcmd_t
name|read_cmd
decl_stmt|;
name|read_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|read_cmd
operator|.
name|s
operator|.
name|addr
operator|=
name|byte_addr
expr_stmt|;
name|read_cmd
operator|.
name|s
operator|.
name|pend
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_FUS_RCMD
argument_list|,
name|read_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|read_cmd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_FUS_RCMD
argument_list|)
operator|)
operator|&&
name|read_cmd
operator|.
name|s
operator|.
name|pend
condition|)
empty_stmt|;
return|return
operator|(
name|read_cmd
operator|.
name|s
operator|.
name|dat
operator|)
return|;
block|}
comment|/**  * Read a single fuse bit  *  * @param fuse   Fuse number (0-1024)  *  * @return fuse value: 0 or 1  */
specifier|static
specifier|inline
name|int
name|cvmx_fuse_read
parameter_list|(
name|int
name|fuse
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cvmx_fuse_read_byte
argument_list|(
name|fuse
operator|>>
literal|3
argument_list|)
operator|>>
operator|(
name|fuse
operator|&
literal|0x7
operator|)
operator|)
operator|&
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_ACCESS_NATIVE_H__ */
end_comment

end_unit

