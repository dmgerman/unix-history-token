begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-zip-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon zip.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_ZIP_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_ZIP_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_BIST_RESULT
value|CVMX_ZIP_CMD_BIST_RESULT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CMD_BIST_RESULT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CMD_BIST_RESULT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_BIST_RESULT
value|(CVMX_ADD_IO_SEG(0x0001180038000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_BUF
value|CVMX_ZIP_CMD_BUF_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CMD_BUF_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CMD_BUF not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_BUF
value|(CVMX_ADD_IO_SEG(0x0001180038000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_CTL
value|CVMX_ZIP_CMD_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CMD_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CMD_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CMD_CTL
value|(CVMX_ADD_IO_SEG(0x0001180038000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CONSTANTS
value|CVMX_ZIP_CONSTANTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CONSTANTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CONSTANTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800380000A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CONSTANTS
value|(CVMX_ADD_IO_SEG(0x00011800380000A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_COREX_BIST_STATUS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_COREX_BIST_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000520ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_COREX_BIST_STATUS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000520ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CTL_BIST_STATUS
value|CVMX_ZIP_CTL_BIST_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CTL_BIST_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CTL_BIST_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000510ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CTL_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x0001180038000510ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_CTL_CFG
value|CVMX_ZIP_CTL_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_CTL_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_CTL_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000560ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_CTL_CFG
value|(CVMX_ADD_IO_SEG(0x0001180038000560ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_DBG_COREX_INST
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_DBG_COREX_INST(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000640ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_DBG_COREX_INST
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000640ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_DBG_COREX_STA
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_DBG_COREX_STA(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000680ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_DBG_COREX_STA
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000680ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_DBG_QUEX_STA
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_DBG_QUEX_STA(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000600ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_DBG_QUEX_STA
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000600ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_DEBUG0
value|CVMX_ZIP_DEBUG0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_DEBUG0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_DEBUG0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000098ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180038000098ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_ECC_CTL
value|CVMX_ZIP_ECC_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_ECC_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_ECC_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000568ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_ECC_CTL
value|(CVMX_ADD_IO_SEG(0x0001180038000568ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_ERROR
value|CVMX_ZIP_ERROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_ERROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_ERROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180038000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_ENA
value|CVMX_ZIP_INT_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_INT_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_INT_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000580ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_ENA
value|(CVMX_ADD_IO_SEG(0x0001180038000580ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_MASK
value|CVMX_ZIP_INT_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_INT_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_INT_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_MASK
value|(CVMX_ADD_IO_SEG(0x0001180038000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_REG
value|CVMX_ZIP_INT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_INT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_INT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000570ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_INT_REG
value|(CVMX_ADD_IO_SEG(0x0001180038000570ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_QUEX_BUF
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_QUEX_BUF(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_QUEX_BUF
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000100ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_QUEX_ECC_ERR_STA
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_QUEX_ECC_ERR_STA(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000590ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_QUEX_ECC_ERR_STA
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000590ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_QUEX_MAP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_QUEX_MAP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000300ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_QUEX_MAP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180038000300ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_QUE_ENA
value|CVMX_ZIP_QUE_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_QUE_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_QUE_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000500ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_QUE_ENA
value|(CVMX_ADD_IO_SEG(0x0001180038000500ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_QUE_PRI
value|CVMX_ZIP_QUE_PRI_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_QUE_PRI_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_QUE_PRI not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000508ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_QUE_PRI
value|(CVMX_ADD_IO_SEG(0x0001180038000508ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ZIP_THROTTLE
value|CVMX_ZIP_THROTTLE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ZIP_THROTTLE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ZIP_THROTTLE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180038000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ZIP_THROTTLE
value|(CVMX_ADD_IO_SEG(0x0001180038000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_zip_cmd_bist_result  *  * ZIP_CMD_BIST_RESULT =  ZIP Command BIST Result Register  *  * Description:  * This register is a reformatted register with same fields as O63 2.x.  * The purpose of this register is for software backward compatibility.  * Some bits are the bist result of combined status of memories (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_zip_cmd_bist_result
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_cmd_bist_result_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|53
decl_stmt|;
comment|/**< BiST result of the ZIP_CORE memories */
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of the ZIP_CTL  memories */
else|#
directive|else
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|53
decl_stmt|;
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_zip_cmd_bist_result_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|27
decl_stmt|;
comment|/**< BiST result of the ZIP_CORE memories */
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of the ZIP_CTL  memories */
else|#
directive|else
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_cn31xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_zip_cmd_bist_result_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|39
decl_stmt|;
comment|/**< BiST result of the ZIP_CORE memories */
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
comment|/**< BiST result of the ZIP_CTL  memories */
else|#
directive|else
name|uint64_t
name|zip_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|zip_core
range|:
literal|39
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_zip_cmd_bist_result_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_bist_result_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_cmd_bist_result
name|cvmx_zip_cmd_bist_result_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_cmd_buf  *  * ZIP_CMD_BUF =  ZIP Command Buffer Parameter Register  *  * Description:  * This is an alias to ZIP_QUE0_BUF. The purpose of this register is for software backward compatibility.  * This register set the buffer parameters for the instruction queue 0.  */
end_comment

begin_union
union|union
name|cvmx_zip_cmd_buf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_cmd_buf_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
comment|/**< Number of DontWriteBacks */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free command buffer segments */
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
comment|/**< Number of uint64s per command buffer segment */
name|uint64_t
name|ptr
range|:
literal|33
decl_stmt|;
comment|/**< Initial command buffer pointer[39:7] (128B-aligned) */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_buf_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_cmd_buf
name|cvmx_zip_cmd_buf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_cmd_ctl  *  * ZIP_CMD_CTL = ZIP Clock/Reset Control Register  *  * Description:  *       This register controls clock and reset.  */
end_comment

begin_union
union|union
name|cvmx_zip_cmd_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_cmd_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|forceclk
range|:
literal|1
decl_stmt|;
comment|/**< Force zip_ctl__zip<0|1>_clock_on_b == 1 when set */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset one-shot pulse for zip cores */
else|#
directive|else
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|forceclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_cmd_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_cmd_ctl
name|cvmx_zip_cmd_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_constants  *  * ZIP_CONSTANTS =  ZIP Constants Register  *  * Description:  *   This contains all the current implementation related parameters of the zip core in this chip.  */
end_comment

begin_union
union|union
name|cvmx_zip_constants
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_constants_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nexec
range|:
literal|8
decl_stmt|;
comment|/**< Number of available ZIP Exec Units */
name|uint64_t
name|reserved_49_55
range|:
literal|7
decl_stmt|;
name|uint64_t
name|syncflush_capable
range|:
literal|1
decl_stmt|;
comment|/**< 1: SYNCFLUSH is supported                                                          - 0: SYNCFLUSH is not supported.                                                           Note: for O68 1.0, SYNCFLUSH is supported                                                                 although this field is 0. */
name|uint64_t
name|depth
range|:
literal|16
decl_stmt|;
comment|/**< Maximum search depth for compression */
name|uint64_t
name|onfsize
range|:
literal|12
decl_stmt|;
comment|/**< Output near full threshold in bytes */
name|uint64_t
name|ctxsize
range|:
literal|12
decl_stmt|;
comment|/**< Decompression Context size in bytes */
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|disabled
range|:
literal|1
decl_stmt|;
comment|/**< 1=zip is disabled, 0=zip is enabled */
else|#
directive|else
name|uint64_t
name|disabled
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ctxsize
range|:
literal|12
decl_stmt|;
name|uint64_t
name|onfsize
range|:
literal|12
decl_stmt|;
name|uint64_t
name|depth
range|:
literal|16
decl_stmt|;
name|uint64_t
name|syncflush_capable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_55
range|:
literal|7
decl_stmt|;
name|uint64_t
name|nexec
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_zip_constants_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|depth
range|:
literal|16
decl_stmt|;
comment|/**< Maximum search depth for compression */
name|uint64_t
name|onfsize
range|:
literal|12
decl_stmt|;
comment|/**< Output near full threshhold in bytes */
name|uint64_t
name|ctxsize
range|:
literal|12
decl_stmt|;
comment|/**< Context size in bytes */
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|disabled
range|:
literal|1
decl_stmt|;
comment|/**< 1=zip unit isdisabled, 0=zip unit not disabled */
else|#
directive|else
name|uint64_t
name|disabled
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ctxsize
range|:
literal|12
decl_stmt|;
name|uint64_t
name|onfsize
range|:
literal|12
decl_stmt|;
name|uint64_t
name|depth
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_constants_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_constants_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_constants_cn31xx
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_constants
name|cvmx_zip_constants_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_core#_bist_status  *  * ZIP_CORE_BIST_STATUS =  ZIP CORE Bist Status Registers  *  * Description:  *   Those register have the bist status of memories in zip cores.  *   Each bit is the bist result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_zip_corex_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_corex_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
name|uint64_t
name|bstatus
range|:
literal|53
decl_stmt|;
comment|/**< BIST result of the ZIP_CORE memories */
else|#
directive|else
name|uint64_t
name|bstatus
range|:
literal|53
decl_stmt|;
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_corex_bist_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_corex_bist_status_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_corex_bist_status
name|cvmx_zip_corex_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_ctl_bist_status  *  * ZIP_CTL_BIST_STATUS =  ZIP CONTROL Bist Status Register  *  * Description:  *   This register has the bist status of memories in zip_ctl (Instruction Buffer, G/S Pointer Fifo, Input Data Buffer,  *   Output Data Buffers).  *   Each bit is the bist result of an individual memory (per bit, 0=pass and 1=fail).  */
end_comment

begin_union
union|union
name|cvmx_zip_ctl_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_ctl_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|bstatus
range|:
literal|7
decl_stmt|;
comment|/**< BIST result of the memories */
else|#
directive|else
name|uint64_t
name|bstatus
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_ctl_bist_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_ctl_bist_status_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_ctl_bist_status
name|cvmx_zip_ctl_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_ctl_cfg  *  * ZIP_CTL_CFG =  ZIP Controller Configuration Register  *  * Description:  * This register controls the behavior zip dma engine. It is recommended to kept those field in the default values for normal  * operation. Changing the values of the fields may be useful for diagnostics.  */
end_comment

begin_union
union|union
name|cvmx_zip_ctl_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_ctl_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|ildf
range|:
literal|3
decl_stmt|;
comment|/**< Instruction Load Command FIFO Credits<= 4 */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iprf
range|:
literal|2
decl_stmt|;
comment|/**< Instruction Page Return Cmd FIFO Credits<= 2 */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gstf
range|:
literal|3
decl_stmt|;
comment|/**< G/S Tag FIFO Credits<= 4 */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcf
range|:
literal|3
decl_stmt|;
comment|/**< Store Command FIFO Credits<= 4 */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ldf
range|:
literal|3
decl_stmt|;
comment|/**< Load Cmd FIFO Credits<= 4 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wkqf
range|:
literal|2
decl_stmt|;
comment|/**< WorkQueue FIFO Credits<= 2 */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< 1: ZIP system is busy; 0: ZIP system is idle. */
name|uint64_t
name|lmod
range|:
literal|1
decl_stmt|;
comment|/**< Legacy Mode. */
else|#
directive|else
name|uint64_t
name|lmod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wkqf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ldf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gstf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iprf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ildf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_ctl_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_ctl_cfg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_ctl_cfg
name|cvmx_zip_ctl_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_dbg_core#_inst  *  * ZIP_DBG_COREX_INST =  ZIP Core Current Instruction Registers  *  * Description:  * This register reflects the status of the current instruction that zip core is executing/ has executed.  * This register is only for debug use.  */
end_comment

begin_union
union|union
name|cvmx_zip_dbg_corex_inst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_dbg_corex_inst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< Core State: 1 - Core is busy; 0 - Core is idle */
name|uint64_t
name|reserved_33_62
range|:
literal|30
decl_stmt|;
name|uint64_t
name|qid
range|:
literal|1
decl_stmt|;
comment|/**< Queue Index of instruction executed (BUSY=0) or                                                          being executed (BUSY=1) on this core */
name|uint64_t
name|iid
range|:
literal|32
decl_stmt|;
comment|/**< Instruction Index executed (BUSY=0) or being                                                          executed (BUSY=1) on this core */
else|#
directive|else
name|uint64_t
name|iid
range|:
literal|32
decl_stmt|;
name|uint64_t
name|qid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_62
range|:
literal|30
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_dbg_corex_inst_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_dbg_corex_inst_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_dbg_corex_inst
name|cvmx_zip_dbg_corex_inst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_dbg_core#_sta  *  * ZIP_DBG_COREX_STA =  ZIP Core Status Registers  *  * Description:  * These register reflect the status of the zip cores.  * This register is only for debug use.  */
end_comment

begin_union
union|union
name|cvmx_zip_dbg_corex_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_dbg_corex_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< Core State: 1 - Core is busy; 0 - Core is idle */
name|uint64_t
name|reserved_37_62
range|:
literal|26
decl_stmt|;
name|uint64_t
name|ist
range|:
literal|5
decl_stmt|;
comment|/**< State of current instruction is executing */
name|uint64_t
name|nie
range|:
literal|32
decl_stmt|;
comment|/**< Number of instructions executed on this core */
else|#
directive|else
name|uint64_t
name|nie
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ist
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_62
range|:
literal|26
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_dbg_corex_sta_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_dbg_corex_sta_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_dbg_corex_sta
name|cvmx_zip_dbg_corex_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_dbg_que#_sta  *  * ZIP_DBG_QUEX_STA =  ZIP Queue Status Registers  *  * Description:  * This register reflects status of the zip instruction queue.  * This register is only for debug use.  */
end_comment

begin_union
union|union
name|cvmx_zip_dbg_quex_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_dbg_quex_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< Queue State: 1 - Queue is busy; 0 - Queue is idle */
name|uint64_t
name|reserved_52_62
range|:
literal|11
decl_stmt|;
name|uint64_t
name|cdbc
range|:
literal|20
decl_stmt|;
comment|/**< Current DoorBell Counter */
name|uint64_t
name|nii
range|:
literal|32
decl_stmt|;
comment|/**< Number of instructions issued from this queue.                                                          Reset to 0 when ZIP_QUEn_BUF is written. */
else|#
directive|else
name|uint64_t
name|nii
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cdbc
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_52_62
range|:
literal|11
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_dbg_quex_sta_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_dbg_quex_sta_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_dbg_quex_sta
name|cvmx_zip_dbg_quex_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_debug0  *  * ZIP_DEBUG0 =  ZIP DEBUG Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_zip_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_debug0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|asserts
range|:
literal|30
decl_stmt|;
comment|/**< FIFO assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|30
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_zip_debug0_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|asserts
range|:
literal|14
decl_stmt|;
comment|/**< FIFO assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn31xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_zip_debug0_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|asserts
range|:
literal|17
decl_stmt|;
comment|/**< FIFO assertion checks */
else|#
directive|else
name|uint64_t
name|asserts
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_zip_debug0_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_debug0_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_debug0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_debug0
name|cvmx_zip_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_ecc_ctl  *  * ZIP_ECC_CTL =  ZIP ECC Control Register  *  * Description:  *   This register enables ECC for each individual internal memory that requires ECC. For debug purpose, it can also  *   control 1 or 2 bits be flipped in the ECC data.  */
end_comment

begin_union
union|union
name|cvmx_zip_ecc_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_ecc_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ibge
range|:
literal|2
decl_stmt|;
comment|/**< controls instruction buffer flip syndrome                                                          2'b00       : No Error Generation                                                          2'b10, 2'b01: Flip 1 bit                                                          2'b11       : Flip 2 bits */
name|uint64_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
name|uint64_t
name|iben
range|:
literal|1
decl_stmt|;
comment|/**< 1: ECC Enabled for instruction buffer                                                          - 0: ECC Disabled for instruction buffer */
else|#
directive|else
name|uint64_t
name|iben
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
name|uint64_t
name|ibge
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_ecc_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_ecc_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_ecc_ctl
name|cvmx_zip_ecc_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_error  *  * ZIP_ERROR =  ZIP ERROR Register  *  * Description:  * This register is an alias to ZIP_INT_REG[DOORBELL0].  * The purpose of this register is for software backward compatibility.  */
end_comment

begin_union
union|union
name|cvmx_zip_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_error_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< A doorbell count has overflowed */
else|#
directive|else
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_error_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_error_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_error
name|cvmx_zip_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_int_ena  *  * ZIP_INT_ENA =  ZIP Interrupt Enable Register  *  * Description:  *   Only when an interrupt source is enabled, an interrupt can be fired.  *   When a bit is set to 1, the corresponding interrupt is enabled.  */
end_comment

begin_union
union|union
name|cvmx_zip_int_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_int_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|doorbell1
range|:
literal|1
decl_stmt|;
comment|/**< Enable for Doorbell 1 count overflow */
name|uint64_t
name|doorbell0
range|:
literal|1
decl_stmt|;
comment|/**< Enable for Doorbell 0 count overflow */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ibdbe
range|:
literal|1
decl_stmt|;
comment|/**< Enable for IBUF Double Bit Error */
name|uint64_t
name|ibsbe
range|:
literal|1
decl_stmt|;
comment|/**< Enable for IBUF Single Bit Error */
name|uint64_t
name|fife
range|:
literal|1
decl_stmt|;
comment|/**< Enable for FIFO errors */
else|#
directive|else
name|uint64_t
name|fife
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ibsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ibdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|doorbell0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_int_ena_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_int_ena_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_int_ena
name|cvmx_zip_int_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_int_mask  *  * ZIP_INT_MASK =  ZIP Interrupt Mask Register  *  * Description:  * This register is an alias to ZIP_INT_ENA[DOORBELL0].  * The purpose of this register is for software backward compatibility.  */
end_comment

begin_union
union|union
name|cvmx_zip_int_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_int_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< Bit mask corresponding to ZIP_ERROR[0] above */
else|#
directive|else
name|uint64_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_int_mask_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_int_mask_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_int_mask
name|cvmx_zip_int_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_int_reg  *  * ZIP_INT_REG =  ZIP Interrupt Status Register  *  * Description:  *   This registers contains the status of all the interrupt source. An interrupt will be generated only when  *   the corresponding interrupt source is enabled in ZIP_INT_ENA.  */
end_comment

begin_union
union|union
name|cvmx_zip_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|doorbell1
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell 1 count has overflowed */
name|uint64_t
name|doorbell0
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell 0 count has overflowed */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ibdbe
range|:
literal|1
decl_stmt|;
comment|/**< IBUF Double Bit Error */
name|uint64_t
name|ibsbe
range|:
literal|1
decl_stmt|;
comment|/**< IBUF Single Bit Error */
name|uint64_t
name|fife
range|:
literal|1
decl_stmt|;
comment|/**< FIFO errors and the detailed status is in                                                          ZIP_DEBUG0 */
else|#
directive|else
name|uint64_t
name|fife
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ibsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ibdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|doorbell0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|doorbell1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_int_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_int_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_int_reg
name|cvmx_zip_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_que#_buf  *  * NOTE: Fields NEXEC and SYNCFLUSH_CAPABLE are only valid for chips after O68 2.0 (including O68 2.0).  *  *  *                  ZIP_QUEX_BUF =  ZIP Queue Buffer Parameter Registers  *  * Description:  * These registers set the buffer parameters for the instruction queues . The size of the instruction buffer  * segments is measured in uint64s.  The pool specifies (1 of 8 free lists to be used when freeing command  * buffer segments).  The PTR field is overwritten with the next pointer each time that the command  * buffer segment is exhausted. When quiescent (i.e. outstanding doorbell count is 0), it is safe  * to rewrite this register to effectively reset the command buffer state machine.  New commands  * will then be read from the newly specified command buffer pointer.  */
end_comment

begin_union
union|union
name|cvmx_zip_quex_buf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_quex_buf_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
comment|/**< Number of DontWriteBacks */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Free list used to free command buffer segments */
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
comment|/**< Number of uint64s per command buffer segment */
name|uint64_t
name|ptr
range|:
literal|33
decl_stmt|;
comment|/**< Initial command buffer pointer[39:7] (128B-aligned) */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|size
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_quex_buf_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_quex_buf_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_quex_buf
name|cvmx_zip_quex_buf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_que#_ecc_err_sta  *  * ZIP_QUEX_ECC_ERR_STA =  ZIP Queue ECC ERROR STATUS Register  *  * Description:  *   This register contains the first ECC SBE/DBE status for the instruction buffer of a given zip instruction queue.  */
end_comment

begin_union
union|union
name|cvmx_zip_quex_ecc_err_sta
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_quex_ecc_err_sta_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|wnum
range|:
literal|3
decl_stmt|;
comment|/**< Index of the first IWORD that DBE happened                                                          (Valid when ZIP_INT_REG[IBDBE] or [IBSBE] is set). */
name|uint64_t
name|inum
range|:
literal|32
decl_stmt|;
comment|/**< Index of the first instruction that DBE happened                                                          (Valid when ZIP_INT_REG[IBDBE] or [IBSBE] is set). */
else|#
directive|else
name|uint64_t
name|inum
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_quex_ecc_err_sta_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_quex_ecc_err_sta_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_quex_ecc_err_sta
name|cvmx_zip_quex_ecc_err_sta_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_que#_map  *  * ZIP_QUEX_MAP =  ZIP Queue Mapping Registers  *  * Description:  *  These registers control how each instruction queue maps to 2 zip cores.  *  Bit[0] corresponds to zip core 0 and bit[1] corresponds to zip core 1.  *  A "1" means instructions from the queue can be served by the corresponding zip core.  */
end_comment

begin_union
union|union
name|cvmx_zip_quex_map
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_quex_map_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|zce
range|:
literal|2
decl_stmt|;
comment|/**< Zip Core Enable                                                          Controls the logical instruction queue can be                                                          serviced by which zip core. Setting ZCE==0                                                          effectively disables the queue from being served                                                          (however the instruction can still be fetched).                                                          ZCE[1]=1, zip core 1 can serve the queue.                                                          ZCE[0]=1, zip core 0 can serve the queue. */
else|#
directive|else
name|uint64_t
name|zce
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_quex_map_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_quex_map_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_quex_map
name|cvmx_zip_quex_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_que_ena  *  * ZIP_QUE_ENA =  ZIP Queue Enable Register  *  * Description:  *    If a queue is disabled, ZIP_CTL will stop fetching instructions from the queue.  */
end_comment

begin_union
union|union
name|cvmx_zip_que_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_que_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|ena
range|:
literal|2
decl_stmt|;
comment|/**< Enables the logical instruction queues.                                                          - 1: Queue is enabled. 0: Queue is disabled                                                           ENA[1]=1 enables queue 1                                                           ENA[0]=1 enables queue 0 */
else|#
directive|else
name|uint64_t
name|ena
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_que_ena_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_que_ena_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_que_ena
name|cvmx_zip_que_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_que_pri  *  * ZIP_QUE_PRI =  ZIP Queue Priority Register  *  * Description:  *   This registers defines the priority between instruction queue 1 and instruction queue 0.  *   Bit[0] corresponds to queue 0 and bit[1] corresponds to queue 1. A "1" means high priority.  */
end_comment

begin_union
union|union
name|cvmx_zip_que_pri
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_que_pri_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|pri
range|:
literal|2
decl_stmt|;
comment|/**< Priority                                                          2'b10: Queue 1 has higher priority.                                                          2'b01: Queue 0 has higher priority.                                                          2'b11,2'b00: round robin */
else|#
directive|else
name|uint64_t
name|pri
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_zip_que_pri_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_que_pri_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_que_pri
name|cvmx_zip_que_pri_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_zip_throttle  *  * ZIP_THROTTLE =  ZIP Throttle Register  *  * Description:  * This register controls the maximum number of in-flight X2I data fetch transactions.  Values> 16 are illegal.  * Writing 0 to this register causes the ZIP module to temporarily suspend NCB accesses; it is not recommended  * for normal operation, but may be useful for diagnostics.  */
end_comment

begin_union
union|union
name|cvmx_zip_throttle
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_zip_throttle_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|max_infl
range|:
literal|5
decl_stmt|;
comment|/**< Maximum number of in-flight data fetch transactions on                                                          NCB. */
else|#
directive|else
name|uint64_t
name|max_infl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_zip_throttle_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|max_infl
range|:
literal|4
decl_stmt|;
comment|/**< Maximum number of inflight data fetch transactions                                                          on NCB. */
else|#
directive|else
name|uint64_t
name|max_infl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_zip_throttle_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_zip_throttle_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_zip_throttle_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_zip_throttle_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_zip_throttle_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_zip_throttle
name|cvmx_zip_throttle_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

