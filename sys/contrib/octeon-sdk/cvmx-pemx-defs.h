begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pemx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pemx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PEMX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PEMX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_BAR1_INDEXX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_BAR1_INDEXX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C00000A8ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x200000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_BAR1_INDEXX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C00000A8ull) + (((offset)& 15) + ((block_id)& 1) * 0x200000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_BAR_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_BAR_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000128ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_BAR_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000128ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_BIST_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_BIST_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_BIST_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000018ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_BIST_STATUS2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_BIST_STATUS2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000420ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_BIST_STATUS2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000420ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_CFG_RD
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_CFG_RD(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000030ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_CFG_RD
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000030ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_CFG_WR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_CFG_WR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000028ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_CFG_WR
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000028ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_CPL_LUT_VALID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_CPL_LUT_VALID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000098ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_CPL_LUT_VALID
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000098ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_CTL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_CTL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000000ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_DBG_INFO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_DBG_INFO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_DBG_INFO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000008ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_DBG_INFO_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_DBG_INFO_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C00000A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_DBG_INFO_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C00000A0ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_DIAG_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_DIAG_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_DIAG_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000020ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_INT_ENB
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_INT_ENB(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_INT_ENB
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000410ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_INT_ENB_INT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_INT_ENB_INT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000418ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_INT_ENB_INT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000418ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_INT_SUM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_INT_SUM(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000408ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_INT_SUM
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000408ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_P2N_BAR0_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_P2N_BAR0_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000080ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_P2N_BAR0_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000080ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_P2N_BAR1_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_P2N_BAR1_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000088ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_P2N_BAR1_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000088ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_P2N_BAR2_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_P2N_BAR2_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000090ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_P2N_BAR2_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000090ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_P2P_BARX_END
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000ull
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_P2P_BARX_END
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000048ull) + (((offset)& 3) + ((block_id)& 1) * 0x100000ull) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_P2P_BARX_START
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000ull
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_P2P_BARX_START
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000040ull) + (((offset)& 3) + ((block_id)& 1) * 0x100000ull) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PEMX_TLP_CREDITS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PEMX_TLP_CREDITS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C0000038ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PEMX_TLP_CREDITS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C0000038ull) + ((block_id)& 1) * 0x1000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pem#_bar1_index#  *  * PEM_BAR1_INDEXX = PEM BAR1 IndexX Register  *  * Contains address index and control bits for access to memory ranges of BAR-1. Index is build from supplied address [25:22].  */
end_comment

begin_union
union|union
name|cvmx_pemx_bar1_indexx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_bar1_indexx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|addr_idx
range|:
literal|16
decl_stmt|;
comment|/**< Address bits [37:22] sent to L2C */
name|uint64_t
name|ca
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when access is not to be cached in L2. */
name|uint64_t
name|end_swp
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode */
name|uint64_t
name|addr_v
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the selected address range is valid. */
else|#
directive|else
name|uint64_t
name|addr_v
range|:
literal|1
decl_stmt|;
name|uint64_t
name|end_swp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ca
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addr_idx
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_bar1_indexx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_bar1_indexx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_bar1_indexx
name|cvmx_pemx_bar1_indexx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_bar_ctl  *  * PEM_BAR_CTUS = PEM BAR Control  *  * Contains control for BAR accesses.  */
end_comment

begin_union
union|union
name|cvmx_pemx_bar_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_bar_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|bar1_siz
range|:
literal|3
decl_stmt|;
comment|/**< Pcie-Port0, Bar1 Size. 1 == 64MB, 2 == 128MB,                                                          3 == 256MB, 4 == 512MB, 5 == 1024MB, 6 == 2048MB,                                                          0 and 7 are reserved. */
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BAR2 is enable and will respond when                                                          clear '0' BAR2 access will cause UR responses. */
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
comment|/**< Value will be XORed with pci-address[39:38] to                                                          determine the endian swap mode. */
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
comment|/**< Value will be XORed with pcie-address[40] to                                                          determine the L2 cache attribute.                                                          Not cached in L2 if XOR result is 1 */
else|#
directive|else
name|uint64_t
name|bar2_cax
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_esx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bar2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar1_siz
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_bar_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_bar_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_bar_ctl
name|cvmx_pemx_bar_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_bist_status  *  * PEM_BIST_STATUS = PEM Bist Status  *  * Contains the diffrent interrupt summary bits of the PEM.  */
end_comment

begin_union
union|union
name|cvmx_pemx_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
comment|/**< Retry Buffer. */
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory0. */
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory1. */
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory2. */
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory3. */
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header1. */
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header0. */
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
comment|/**< SOT Buffer. */
else|#
directive|else
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_bist_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_bist_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_bist_status
name|cvmx_pemx_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_bist_status2  *  * PEM(0..1)_BIST_STATUS2 = PEM BIST Status Register  *  * Results from BIST runs of PEM's memories.  */
end_comment

begin_union
union|union
name|cvmx_pemx_bist_status2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_bist_status2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|e2p_cpl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_cpl_fifo */
name|uint64_t
name|e2p_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_n_fifo */
name|uint64_t
name|e2p_p
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_p_fifo */
name|uint64_t
name|peai_p2e
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the peai__pesc_fifo */
name|uint64_t
name|pef_tpf1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_p_fifo1 */
name|uint64_t
name|pef_tpf0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_p_fifo0 */
name|uint64_t
name|pef_tnf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_n_fifo */
name|uint64_t
name|pef_tcf1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_cpl_fifo1 */
name|uint64_t
name|pef_tc0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_cpl_fifo0 */
name|uint64_t
name|ppf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the ppf_fifo */
else|#
directive|else
name|uint64_t
name|ppf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tc0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tcf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tnf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tpf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tpf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|peai_p2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_bist_status2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_bist_status2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_bist_status2
name|cvmx_pemx_bist_status2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_cfg_rd  *  * PEM_CFG_RD = PEM Configuration Read  *  * Allows read access to the configuration in the PCIe Core.  */
end_comment

begin_union
union|union
name|cvmx_pemx_cfg_rd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_cfg_rd_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Data. */
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
comment|/**< Address to read. A write to this register                                                          starts a read operation. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_cfg_rd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_cfg_rd_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_cfg_rd
name|cvmx_pemx_cfg_rd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_cfg_wr  *  * PEM_CFG_WR = PEM Configuration Write  *  * Allows write access to the configuration in the PCIe Core.  */
end_comment

begin_union
union|union
name|cvmx_pemx_cfg_wr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_cfg_wr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Data to write. A write to this register starts                                                          a write operation. */
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
comment|/**< Address to write. A write to this register starts                                                          a write operation. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_cfg_wr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_cfg_wr_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_cfg_wr
name|cvmx_pemx_cfg_wr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_cpl_lut_valid  *  * PEM_CPL_LUT_VALID = PEM Cmpletion Lookup Table Valid  *  * Bit set for outstanding tag read.  */
end_comment

begin_union
union|union
name|cvmx_pemx_cpl_lut_valid
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_cpl_lut_valid_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector set cooresponds to an outstanding tag                                                          expecting a completion. */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_cpl_lut_valid_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_cpl_lut_valid_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_cpl_lut_valid
name|cvmx_pemx_cpl_lut_valid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_ctl_status  *  * PEM_CTL_STATUS = PEM Control Status  *  * General control and status of the PEM.  */
end_comment

begin_union
union|union
name|cvmx_pemx_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|auto_sd
range|:
literal|1
decl_stmt|;
comment|/**< Link Hardware Autonomous Speed Disable. */
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
comment|/**< Primary bus device number. */
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
comment|/**< Primary bus number. */
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
comment|/**< The time x 0x10000 in core clocks to wait for a                                                          CPL to a CFG RD that does not carry a Retry Status.                                                          Until such time that the timeout occurs and Retry                                                          Status is received for a CFG RD, the Read CFG Read                                                          will be resent. A value of 0 disables retries and                                                          treats a CPL Retry as a CPL UR.                                                          When enabled only one CFG RD may be issued until                                                          either successful completion or CPL UR. */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_turnoff port. RC mode. */
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_pme port. EP mode. */
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core outband_pwrup_cmd port. EP mode. */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< Do not forward peer-to-peer ECRC TLPs. */
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
comment|/**< When set the output client state machines will                                                          wait one cycle before starting a new TLP out. */
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the link is enabled when '0' the                                                          link is disabled. This bit only is active when in                                                          RC mode. */
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' C-TLPs that have the RO bit set will                                                          not wait for P-TLPs that normaly would be sent                                                          first. */
name|uint64_t
name|fast_lm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' forces fast link mode. */
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the ECRC to be inverted. */
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the LCRC to be inverted. */
else|#
directive|else
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fast_lm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cfg_rtry
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|auto_sd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_ctl_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_ctl_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_ctl_status
name|cvmx_pemx_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_dbg_info  *  * PEM(0..1)_DBG_INFO = PEM Debug Information  *  * General debug info.  */
end_comment

begin_union
union|union
name|cvmx_pemx_dbg_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_dbg_info_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
comment|/**< Received a ECRC error.                                                          radm_ecrc_err */
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
comment|/**< Received a write with poisoned payload                                                          radm_rcvd_wreq_poisoned */
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with poisoned payload                                                          radm_rcvd_cpl_poisoned */
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
comment|/**< Received a malformed TLP                                                          radm_mlf_tlp_err */
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
comment|/**< Recieved a request which device does not support                                                          radm_rcvd_ur_req */
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
comment|/**< Completer aborted a request                                                          radm_rcvd_ca_req                                                          This bit will never be set because Octeon does                                                          not generate Completer Aborts. */
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with CA status                                                          radm_rcvd_cpl_ca */
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with UR status                                                          radm_rcvd_cpl_ur */
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
comment|/**< Received an unexpected completion                                                          radm_unexp_cpl_err */
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
comment|/**< Receive queue overflow. Normally happens only when                                                          flow control advertisements are ignored                                                          radm_qoverflow */
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Update Violation (opt. checks)                                                          int_xadm_fc_prot_err */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< When the PHY reports 8B/10B decode error                                                          (RxStatus = 3b100) or disparity error                                                          (RxStatus = 3b111), the signal rmlh_rcvd_err will                                                          be asserted.                                                          rmlh_rcvd_err */
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Protocol Violation (Watchdog Timer)                                                          rtlh_fc_prot_err */
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
comment|/**< DLLP protocol error (out of sequence DLLP)                                                          rdlh_prot_err */
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP with DataLink Layer Error                                                          rdlh_bad_tlp_err */
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
comment|/**< Received DLLP with DataLink Layer Error                                                          rdlh_bad_dllp_err */
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
comment|/**< Max Retries Exceeded                                                          xdlh_replay_num_rlover_err */
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
comment|/**< Replay Timer Expired                                                          xdlh_replay_timeout_err                                                          This bit is set when the REPLAY_TIMER expires in                                                          the PCIE core. The probability of this bit being                                                          set will increase with the traffic load. */
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
comment|/**< A Completion Timeout Occured                                                          pedc_radm_cpl_timeout */
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
comment|/**< Received Vendor-Defined Message                                                          pedc_radm_vendor_msg */
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
comment|/**< Received Unlock Message (EP Mode Only)                                                          pedc_radm_msg_unlock */
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
comment|/**< Received PME Turnoff Acknowledge Message                                                          (RC Mode only)                                                          pedc_radm_pm_to_ack */
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
comment|/**< Received PME Message (RC Mode only)                                                          pedc_radm_pm_pme */
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Fatal Error Message (RC Mode only)                                                          pedc_radm_fatal_err                                                          Bit set when a message with ERR_FATAL is set. */
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Non-Fatal Error Message (RC Mode only)                                                          pedc_radm_nonfatal_err */
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Correctable Error Message (RC Mode only)                                                          pedc_radm_correctable_err */
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
comment|/**< Received Poisoned TLP                                                          pedc__radm_trgt1_poisoned& pedc__radm_trgt1_hv */
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
comment|/**< Received ECRC Error                                                          pedc_radm_trgt1_ecrc_err& pedc__radm_trgt1_eot */
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP has link layer error                                                          pedc_radm_trgt1_dllp_abort& pedc__radm_trgt1_eot */
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP is malformed or a message.                                                          pedc_radm_trgt1_tlp_abort& pedc__radm_trgt1_eot                                                          If the core receives a MSG (or Vendor Message)                                                          this bit will be set. */
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
comment|/**< Poisoned TLP sent                                                          peai__client0_tlp_ep& peai__client0_tlp_hv */
else|#
directive|else
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_dbg_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_dbg_info_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_dbg_info
name|cvmx_pemx_dbg_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_dbg_info_en  *  * PEM(0..1)_DBG_INFO_EN = PEM Debug Information Enable  *  * Allows PEM_DBG_INFO to generate interrupts when cooresponding enable bit is set.  */
end_comment

begin_union
union|union
name|cvmx_pemx_dbg_info_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_dbg_info_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[30] to generate an interrupt. */
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[29] to generate an interrupt. */
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[28] to generate an interrupt. */
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[27] to generate an interrupt. */
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[26] to generate an interrupt. */
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[25] to generate an interrupt. */
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[24] to generate an interrupt. */
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[23] to generate an interrupt. */
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[22] to generate an interrupt. */
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[21] to generate an interrupt. */
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[20] to generate an interrupt. */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[19] to generate an interrupt. */
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[18] to generate an interrupt. */
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[17] to generate an interrupt. */
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[16] to generate an interrupt. */
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[15] to generate an interrupt. */
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[14] to generate an interrupt. */
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[13] to generate an interrupt. */
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[12] to generate an interrupt. */
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[11] to generate an interrupt. */
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[10] to generate an interrupt. */
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[9] to generate an interrupt. */
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[8] to generate an interrupt. */
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[7] to generate an interrupt. */
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[6] to generate an interrupt. */
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[5] to generate an interrupt. */
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[4] to generate an interrupt. */
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[3] to generate an interrupt. */
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[2] to generate an interrupt. */
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[1] to generate an interrupt. */
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
comment|/**< Allows PEM_DBG_INFO[0] to generate an interrupt. */
else|#
directive|else
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_dbg_info_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_dbg_info_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_dbg_info_en
name|cvmx_pemx_dbg_info_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_diag_status  *  * PEM_DIAG_STATUS = PEM Diagnostic Status  *  * Selection control for the cores diagnostic bus.  */
end_comment

begin_union
union|union
name|cvmx_pemx_diag_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_diag_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|pm_dst
range|:
literal|1
decl_stmt|;
comment|/**< Current power management DSTATE. */
name|uint64_t
name|pm_stat
range|:
literal|1
decl_stmt|;
comment|/**< Power Management Status. */
name|uint64_t
name|pm_en
range|:
literal|1
decl_stmt|;
comment|/**< Power Management Event Enable. */
name|uint64_t
name|aux_en
range|:
literal|1
decl_stmt|;
comment|/**< Auxilary Power Enable. */
else|#
directive|else
name|uint64_t
name|aux_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_dst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_diag_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_diag_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_diag_status
name|cvmx_pemx_diag_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_int_enb  *  * PEM(0..1)_INT_ENB = PEM Interrupt Enable  *  * Enables interrupt conditions for the PEM to generate an RSL interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pemx_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_int_enb_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[13] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[12] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[11] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[10] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[9] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[8] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[7] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[6] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[5] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[4] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[3] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[2] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[1] to generate an                                                          interrupt to the MIO. */
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[0] to generate an                                                          interrupt to the MIO. */
else|#
directive|else
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_int_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_int_enb_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_int_enb
name|cvmx_pemx_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_int_enb_int  *  * PEM(0..1)_INT_ENB_INT = PEM Interrupt Enable  *  * Enables interrupt conditions for the PEM to generate an RSL interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pemx_int_enb_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_int_enb_int_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[13] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[12] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[11] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[10] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[9] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[8] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[7] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[6] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[5] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[4] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[3] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[2] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[1] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
comment|/**< Enables PEM_INT_SUM[0] to generate an                                                          interrupt to the SLI as SLI_INT_SUM[MAC#_INT]. */
else|#
directive|else
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_int_enb_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_int_enb_int_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_int_enb_int
name|cvmx_pemx_int_enb_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_int_sum  *  * Below are in pesc_csr  *  *                  PEM(0..1)_INT_SUM = PEM Interrupt Summary  *  * Interrupt conditions for the PEM.  */
end_comment

begin_union
union|union
name|cvmx_pemx_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_int_sum_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were disabled. */
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
comment|/**< Had a CRS Timeout when Retries were enabled. */
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
comment|/**< Received Read Lock TLP. */
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
comment|/**< Set when the PEM_DBG_INFO register has a bit                                                          set and its cooresponding PEM_DBG_INFO_EN bit                                                          is set. */
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received N-TLP for an unknown Bar. */
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received N-TLP for Bar2 when bar2 is disabled. */
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received N-TLP for Bar1 when bar1 index valid                                                          is not set. */
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
comment|/**< Received P-TLP for an unknown Bar. */
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
comment|/**< Received P-TLP for Bar2 when bar2 is disabeld. */
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
comment|/**< Received P-TLP for Bar1 when bar1 index valid                                                          is not set. */
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
comment|/**< Recived PME MSG.                                                          (radm_pm_pme) */
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
comment|/**< PME Interrupt.                                                          (cfg_pme_int) */
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
comment|/**< System Error, RC Mode Only.                                                          (cfg_sys_err_rc) */
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
comment|/**< Advanced Error Reporting Interrupt, RC Mode Only.                                                          (cfg_aer_rc_err_int). */
else|#
directive|else
name|uint64_t
name|aeri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|se
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_b2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|un_bx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|exc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdlk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_er
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crs_dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_int_sum_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_int_sum_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_int_sum
name|cvmx_pemx_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_p2n_bar0_start  *  * PEM_P2N_BAR0_START = PEM PCIe to Npei BAR0 Start  *  * The starting address for addresses to forwarded to the SLI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pemx_p2n_bar0_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_p2n_bar0_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|50
decl_stmt|;
comment|/**< The starting address of the 16KB address space that                                                          is the BAR0 address space. */
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_p2n_bar0_start_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_p2n_bar0_start_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_p2n_bar0_start
name|cvmx_pemx_p2n_bar0_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_p2n_bar1_start  *  * PEM_P2N_BAR1_START = PEM PCIe to Npei BAR1 Start  *  * The starting address for addresses to forwarded to the SLI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pemx_p2n_bar1_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_p2n_bar1_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< The starting address of the 64KB address space                                                          that is the BAR1 address space. */
name|uint64_t
name|reserved_0_25
range|:
literal|26
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_25
range|:
literal|26
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_p2n_bar1_start_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_p2n_bar1_start_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_p2n_bar1_start
name|cvmx_pemx_p2n_bar1_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_p2n_bar2_start  *  * PEM_P2N_BAR2_START = PEM PCIe to Npei BAR2 Start  *  * The starting address for addresses to forwarded to the SLI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pemx_p2n_bar2_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_p2n_bar2_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|23
decl_stmt|;
comment|/**< The starting address of the 2^41 address space                                                          that is the BAR2 address space. */
name|uint64_t
name|reserved_0_40
range|:
literal|41
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_40
range|:
literal|41
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_p2n_bar2_start_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_p2n_bar2_start_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_p2n_bar2_start
name|cvmx_pemx_p2n_bar2_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_p2p_bar#_end  *  * PEM_P2P_BAR#_END = PEM Peer-To-Peer BAR0 End  *  * The ending address for addresses to forwarded to the PCIe peer port.  */
end_comment

begin_union
union|union
name|cvmx_pemx_p2p_barx_end
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_p2p_barx_end_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
comment|/**< The ending address of the address window created                                                          this field and the PEM_P2P_BAR0_START[63:12]                                                          field. The full 64-bits of address are created by:                                                          [ADDR[63:12], 12'b0]. */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_p2p_barx_end_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_p2p_barx_end_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_p2p_barx_end
name|cvmx_pemx_p2p_barx_end_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_p2p_bar#_start  *  * PEM_P2P_BAR#_START = PEM Peer-To-Peer BAR0 Start  *  * The starting address and enable for addresses to forwarded to the PCIe peer port.  */
end_comment

begin_union
union|union
name|cvmx_pemx_p2p_barx_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_p2p_barx_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
comment|/**< The starting address of the address window created                                                          by this field and the PEM_P2P_BAR0_END[63:12]                                                          field. The full 64-bits of address are created by:                                                          [ADDR[63:12], 12'b0]. */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_p2p_barx_start_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_p2p_barx_start_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_p2p_barx_start
name|cvmx_pemx_p2p_barx_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pem#_tlp_credits  *  * PEM_TLP_CREDITS = PEM TLP Credits  *  * Specifies the number of credits the PEM for use in moving TLPs. When this register is written the credit values are  * reset to the register value. A write to this register should take place BEFORE traffic flow starts.  */
end_comment

begin_union
union|union
name|cvmx_pemx_tlp_credits
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pemx_tlp_credits_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|pem_cpl
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|pem_np
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the Peer.                                                          Legal values are 0x4 to 0x10. */
name|uint64_t
name|pem_p
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|sli_cpl
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the SLI.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|sli_np
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the SLI.                                                          Legal values are 0x4 to 0x10. */
name|uint64_t
name|sli_p
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the SLI.                                                          Legal values are 0x24 to 0x80. */
else|#
directive|else
name|uint64_t
name|sli_p
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sli_np
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sli_cpl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pem_p
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pem_np
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pem_cpl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pemx_tlp_credits_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pemx_tlp_credits_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pemx_tlp_credits
name|cvmx_pemx_tlp_credits_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

