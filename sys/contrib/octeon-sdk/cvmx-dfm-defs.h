begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-dfm-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon dfm.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_DFM_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_DFM_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_CTL
value|CVMX_DFM_CHAR_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CHAR_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CHAR_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000220ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D4000220ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK0
value|CVMX_DFM_CHAR_MASK0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CHAR_MASK0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CHAR_MASK0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000228ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK0
value|(CVMX_ADD_IO_SEG(0x00011800D4000228ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK2
value|CVMX_DFM_CHAR_MASK2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CHAR_MASK2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CHAR_MASK2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000238ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK2
value|(CVMX_ADD_IO_SEG(0x00011800D4000238ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK4
value|CVMX_DFM_CHAR_MASK4_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CHAR_MASK4_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CHAR_MASK4 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000318ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CHAR_MASK4
value|(CVMX_ADD_IO_SEG(0x00011800D4000318ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_COMP_CTL2
value|CVMX_DFM_COMP_CTL2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_COMP_CTL2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_COMP_CTL2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_COMP_CTL2
value|(CVMX_ADD_IO_SEG(0x00011800D40001B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CONFIG
value|CVMX_DFM_CONFIG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CONFIG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CONFIG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000188ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CONFIG
value|(CVMX_ADD_IO_SEG(0x00011800D4000188ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_CONTROL
value|CVMX_DFM_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000190ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_CONTROL
value|(CVMX_ADD_IO_SEG(0x00011800D4000190ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_DLL_CTL2
value|CVMX_DFM_DLL_CTL2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_DLL_CTL2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_DLL_CTL2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001C8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_DLL_CTL2
value|(CVMX_ADD_IO_SEG(0x00011800D40001C8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_DLL_CTL3
value|CVMX_DFM_DLL_CTL3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_DLL_CTL3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_DLL_CTL3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000218ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_DLL_CTL3
value|(CVMX_ADD_IO_SEG(0x00011800D4000218ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FCLK_CNT
value|CVMX_DFM_FCLK_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FCLK_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FCLK_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FCLK_CNT
value|(CVMX_ADD_IO_SEG(0x00011800D40001E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_BIST
value|CVMX_DFM_FNT_BIST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FNT_BIST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FNT_BIST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_BIST
value|(CVMX_ADD_IO_SEG(0x00011800D40007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_CTL
value|CVMX_DFM_FNT_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FNT_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FNT_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000400ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D4000400ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_IENA
value|CVMX_DFM_FNT_IENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FNT_IENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FNT_IENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000410ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_IENA
value|(CVMX_ADD_IO_SEG(0x00011800D4000410ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_SCLK
value|CVMX_DFM_FNT_SCLK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FNT_SCLK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FNT_SCLK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000418ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_SCLK
value|(CVMX_ADD_IO_SEG(0x00011800D4000418ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_STAT
value|CVMX_DFM_FNT_STAT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_FNT_STAT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_FNT_STAT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000408ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_FNT_STAT
value|(CVMX_ADD_IO_SEG(0x00011800D4000408ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_IFB_CNT
value|CVMX_DFM_IFB_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_IFB_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_IFB_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001D0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_IFB_CNT
value|(CVMX_ADD_IO_SEG(0x00011800D40001D0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_MODEREG_PARAMS0
value|CVMX_DFM_MODEREG_PARAMS0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_MODEREG_PARAMS0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_MODEREG_PARAMS0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_MODEREG_PARAMS0
value|(CVMX_ADD_IO_SEG(0x00011800D40001A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_MODEREG_PARAMS1
value|CVMX_DFM_MODEREG_PARAMS1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_MODEREG_PARAMS1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_MODEREG_PARAMS1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000260ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_MODEREG_PARAMS1
value|(CVMX_ADD_IO_SEG(0x00011800D4000260ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_OPS_CNT
value|CVMX_DFM_OPS_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_OPS_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_OPS_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_OPS_CNT
value|(CVMX_ADD_IO_SEG(0x00011800D40001D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_PHY_CTL
value|CVMX_DFM_PHY_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_PHY_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_PHY_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000210ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_PHY_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D4000210ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_RESET_CTL
value|CVMX_DFM_RESET_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_RESET_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_RESET_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000180ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_RESET_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D4000180ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_RLEVEL_CTL
value|CVMX_DFM_RLEVEL_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_RLEVEL_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_RLEVEL_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40002A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_RLEVEL_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D40002A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_RLEVEL_DBG
value|CVMX_DFM_RLEVEL_DBG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_RLEVEL_DBG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_RLEVEL_DBG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40002A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_RLEVEL_DBG
value|(CVMX_ADD_IO_SEG(0x00011800D40002A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_RLEVEL_RANKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_RLEVEL_RANKX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000280ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_RLEVEL_RANKX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800D4000280ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_RODT_MASK
value|CVMX_DFM_RODT_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_RODT_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_RODT_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000268ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_RODT_MASK
value|(CVMX_ADD_IO_SEG(0x00011800D4000268ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_SLOT_CTL0
value|CVMX_DFM_SLOT_CTL0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_SLOT_CTL0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_SLOT_CTL0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_SLOT_CTL0
value|(CVMX_ADD_IO_SEG(0x00011800D40001F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_SLOT_CTL1
value|CVMX_DFM_SLOT_CTL1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_SLOT_CTL1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_SLOT_CTL1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000200ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_SLOT_CTL1
value|(CVMX_ADD_IO_SEG(0x00011800D4000200ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_TIMING_PARAMS0
value|CVMX_DFM_TIMING_PARAMS0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_TIMING_PARAMS0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_TIMING_PARAMS0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000198ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_TIMING_PARAMS0
value|(CVMX_ADD_IO_SEG(0x00011800D4000198ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_TIMING_PARAMS1
value|CVMX_DFM_TIMING_PARAMS1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_TIMING_PARAMS1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_TIMING_PARAMS1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_TIMING_PARAMS1
value|(CVMX_ADD_IO_SEG(0x00011800D40001A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_WLEVEL_CTL
value|CVMX_DFM_WLEVEL_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_WLEVEL_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_WLEVEL_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000300ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_WLEVEL_CTL
value|(CVMX_ADD_IO_SEG(0x00011800D4000300ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_WLEVEL_DBG
value|CVMX_DFM_WLEVEL_DBG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_WLEVEL_DBG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_WLEVEL_DBG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D4000308ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_WLEVEL_DBG
value|(CVMX_ADD_IO_SEG(0x00011800D4000308ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_WLEVEL_RANKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_WLEVEL_RANKX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40002B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_WLEVEL_RANKX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800D40002B0ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFM_WODT_MASK
value|CVMX_DFM_WODT_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFM_WODT_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFM_WODT_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800D40001B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFM_WODT_MASK
value|(CVMX_ADD_IO_SEG(0x00011800D40001B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_dfm_char_ctl  *  * DFM_CHAR_CTL = DFM Characterization Control  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  *  * Notes:  * DR bit applies on the DQ port  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_char_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_char_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
comment|/**< Pattern at Data Rate (not Clock Rate) */
name|uint64_t
name|skew_on
range|:
literal|1
decl_stmt|;
comment|/**< Skew adjacent bits */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Enable characterization */
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
comment|/**< Pattern select                                                          0 = PRBS                                                          1 = Programmable pattern */
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
comment|/**< Programmable pattern */
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
comment|/**< PRBS Polynomial */
else|#
directive|else
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skew_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfm_char_ctl_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Enable characterization */
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
comment|/**< Pattern select                                                          0 = PRBS                                                          1 = Programmable pattern */
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
comment|/**< Programmable pattern */
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
comment|/**< PRBS Polynomial */
else|#
directive|else
name|uint64_t
name|prbs
range|:
literal|32
decl_stmt|;
name|uint64_t
name|prog
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dfm_char_ctl_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_char_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_char_ctl
name|cvmx_dfm_char_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_char_mask0  *  * DFM_CHAR_MASK0 = DFM Characterization Control Mask0  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_dfm_char_mask0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_char_mask0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask for DQ0[15:0] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_char_mask0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_char_mask0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_char_mask0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_char_mask0
name|cvmx_dfm_char_mask0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_char_mask2  *  * DFM_CHAR_MASK2 = DFM Characterization Control Mask2  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_dfm_char_mask2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_char_mask2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask for DQ1[15:0] */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_char_mask2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_char_mask2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_char_mask2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_char_mask2
name|cvmx_dfm_char_mask2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_char_mask4  *  * DFM_CHAR_MASK4 = DFM Characterization Mask4  * This register is an assortment of various control fields needed to charecterize the DDR3 interface  */
end_comment

begin_union
union|union
name|cvmx_dfm_char_mask4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_char_mask4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reset_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for RESET_N */
name|uint64_t
name|a_mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask for A[15:0] */
name|uint64_t
name|ba_mask
range|:
literal|3
decl_stmt|;
comment|/**< Mask for BA[2:0] */
name|uint64_t
name|we_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for WE_N */
name|uint64_t
name|cas_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for CAS_N */
name|uint64_t
name|ras_n_mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask for RAS_N */
name|uint64_t
name|odt1_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for ODT1                                                          For DFM, ODT1 is reserved. */
name|uint64_t
name|odt0_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for ODT0 */
name|uint64_t
name|cs1_n_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CS1_N                                                          For DFM, CS1_N is reserved. */
name|uint64_t
name|cs0_n_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CS0_N */
name|uint64_t
name|cke_mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask for CKE                                                          For DFM, CKE_MASK[1] is reserved. */
else|#
directive|else
name|uint64_t
name|cke_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cs0_n_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cs1_n_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|odt0_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|odt1_mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ras_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cas_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|we_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ba_mask
range|:
literal|3
decl_stmt|;
name|uint64_t
name|a_mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reset_n_mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_char_mask4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_char_mask4_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_char_mask4
name|cvmx_dfm_char_mask4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_comp_ctl2  *  * DFM_COMP_CTL2 = DFM Compensation control2  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_comp_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_comp_ctl2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ddr__ptune
range|:
literal|4
decl_stmt|;
comment|/**< DDR pctl from compensation circuit                                                          The encoded value provides debug information for the                                                          compensation impedance on P-pullup */
name|uint64_t
name|ddr__ntune
range|:
literal|4
decl_stmt|;
comment|/**< DDR nctl from compensation circuit                                                          The encoded value provides debug information for the                                                          compensation impedance on N-pulldown */
name|uint64_t
name|m180
range|:
literal|1
decl_stmt|;
comment|/**< Cap impedance at 180 ohm (instead of 240 ohm) */
name|uint64_t
name|byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass mode                                                          Use compensation setting from PTUNE,NTUNE */
name|uint64_t
name|ptune
range|:
literal|4
decl_stmt|;
comment|/**< PCTL impedance control in bypass mode */
name|uint64_t
name|ntune
range|:
literal|4
decl_stmt|;
comment|/**< NCTL impedance control in bypass mode */
name|uint64_t
name|rodt_ctl
range|:
literal|4
decl_stmt|;
comment|/**< NCTL RODT impedance control bits                                                          0000 = No ODT                                                          0001 = 20 ohm                                                          0010 = 30 ohm                                                          0011 = 40 ohm                                                          0100 = 60 ohm                                                          0101 = 120 ohm                                                          0110-1111 = Reserved */
name|uint64_t
name|cmd_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for CMD/A/RESET_N/CKE drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
name|uint64_t
name|ck_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for CK/CS_N/ODT drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
name|uint64_t
name|dqx_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Drive strength control for DQ/DQS drivers                                                          0001 = 24 ohm                                                          0010 = 26.67 ohm                                                          0011 = 30 ohm                                                          0100 = 34.3 ohm                                                          0101 = 40 ohm                                                          0110 = 48 ohm                                                          0111 = 60 ohm                                                          0000,1000-1111 = Reserved */
else|#
directive|else
name|uint64_t
name|dqx_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cmd_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rodt_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ntune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m180
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr__ntune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ddr__ptune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_comp_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_comp_ctl2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_comp_ctl2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_comp_ctl2
name|cvmx_dfm_comp_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_config  *  * DFM_CONFIG = DFM Memory Configuration Register  *  * This register controls certain parameters of  Memory Configuration  *  * Notes:  * a. The self refresh entry sequence(s) power the DLL up/down (depending on DFM_MODEREG_PARAMS[DLL])  * when DFM_CONFIG[SREF_WITH_DLL] is set  * b. Prior to the self-refresh exit sequence, DFM_MODEREG_PARAMS should be re-programmed (if needed) to the  * appropriate values  *  * DFM Bringup Sequence:  * 1. SW must ensure there are no pending DRAM transactions and that the DDR PLL and the DLL have been initialized.  * 2. Write DFM_COMP_CTL2, DFM_CONTROL, DFM_WODT_MASK, DFM_RODT_MASK, DFM_DUAL_MEMCFG, DFM_TIMING_PARAMS0, DFM_TIMING_PARAMS1,  *    DFM_MODEREG_PARAMS0, DFM_MODEREG_PARAMS1, DFM_RESET_CTL (with DDR3RST=0), DFM_CONFIG (with INIT_START=0)  *    with appropriate values, if necessary.  * 3. Wait 200us, then write DFM_RESET_CTL[DDR3RST] = 1.  * 4. Initialize all ranks at once by writing DFM_CONFIG[RANKMASK][n] = 1, DFM_CONFIG[INIT_STATUS][n] = 1, and DFM_CONFIG[INIT_START] = 1  *    where n is a valid rank index for the specific board configuration.  * 5. for each rank n to be write-leveled [  *       if auto write-leveling is desired [  *           write DFM_CONFIG[RANKMASK][n] = 1, DFM_WLEVEL_CTL appropriately and DFM_CONFIG[INIT_START] = 1  *           wait until DFM_WLEVEL_RANKn[STATUS] = 3  *       ] else [  *           write DFM_WLEVEL_RANKn with appropriate values  *       ]  *    ]  * 6. for each rank n to be read-leveled [  *       if auto read-leveling is desired [  *           write DFM_CONFIG[RANKMASK][n] = 1, DFM_RLEVEL_CTL appropriately and DFM_CONFIG[INIT_START] = 1  *           wait until DFM_RLEVEL_RANKn[STATUS] = 3  *       ] else [  *           write DFM_RLEVEL_RANKn with appropriate values  *       ]  *    ]  */
end_comment

begin_union
union|union
name|cvmx_dfm_config
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_config_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|early_unload_d1_r1
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|early_unload_d1_r0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|early_unload_d0_r1
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 1                                                          reads.                                                          The recommended EARLY_UNLOAD_D0_R1 value can be calculated                                                          after the final DFM_RLEVEL_RANK1[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 1 (i.e. calculate maxset=MAX(DFM_RLEVEL_RANK1[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D0_R1                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>!=3)). */
name|uint64_t
name|early_unload_d0_r0
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle early for Rank 0                                                          reads.                                                          The recommended EARLY_UNLOAD_D0_R0 value can be calculated                                                          after the final DFM_RLEVEL_RANK0[BYTE*] values are                                                          selected (as part of read-leveling initialization).                                                          Then, determine the largest read-leveling setting                                                          for rank 0 (i.e. calculate maxset=MAX(DFM_RLEVEL_RANK0[BYTEi])                                                          across all i), then set EARLY_UNLOAD_D0_R0                                                          when the low two bits of this largest setting is not                                                          3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>!=3)). */
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
comment|/**< Indicates status of initialization                                                          INIT_STATUS[n] = 1 implies rank n has been initialized                                                          SW must set necessary INIT_STATUS bits with the                                                          same DFM_CONFIG write that initiates                                                          power-up/init and self-refresh exit sequences                                                          (if the required INIT_STATUS bits are not already                                                          set before DFM initiates the sequence).                                                          INIT_STATUS determines the chip-selects that assert                                                          during refresh, ZQCS, and precharge power-down and                                                          self-refresh entry/exit SEQUENCE's.                                                          INIT_STATUS<3:2> must be zero. */
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask determining which ranks are address-mirrored.                                                          MIRRMASK<n> = 1 means Rank n addresses are mirrored                                                          for 0<= n<= 1                                                          A mirrored read/write has these differences:                                                           - DDR_BA<1> is swapped with DDR_BA<0>                                                           - DDR_A<8> is swapped with DDR_A<7>                                                           - DDR_A<6> is swapped with DDR_A<5>                                                           - DDR_A<4> is swapped with DDR_A<3>                                                          MIRRMASK<3:2> must be zero.                                                          When RANK_ENA=0, MIRRMASK<1> MBZ */
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask to select rank to be leveled/initialized.                                                          To write-level/read-level/initialize rank i, set RANKMASK<i>                                                                          RANK_ENA=1               RANK_ENA=0                                                            RANKMASK<0> =    CS0                  CS0 and CS1                                                            RANKMASK<1> =    CS1                      MBZ                                                          For read/write leveling, each rank has to be leveled separately,                                                          so RANKMASK should only have one bit set.                                                          RANKMASK is not used during self-refresh entry/exit and                                                          precharge power-down entry/exit instruction sequences.                                                          RANKMASK<3:2> must be zero.                                                          When RANK_ENA=0, RANKMASK<1> MBZ */
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
comment|/**< RANK enable (for use with multiple ranks)                                                          The RANK_ENA bit enables                                                          the drive of the CS_N[1:0] and ODT_<1:0> pins differently based on the                                                          (PBANK_LSB-1) address bit. */
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh entry/exit write MR1 and MR2                                                          When set, self-refresh entry and exit instruction sequences                                                          write MR1 and MR2 (in all ranks). (The writes occur before                                                          self-refresh entry, and after self-refresh exit.)                                                          When clear, self-refresh entry and exit instruction sequences                                                          do not write any registers in the DDR3 parts. */
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
comment|/**< Send DQx signals one CK cycle earlier for the case when                                                          the shortest DQx lines have a larger delay than the CK line */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Instruction sequence that is run after a 0->1                                                          transition on DFM_CONFIG[INIT_START]. Self-refresh entry and                                                          precharge power-down entry and exit SEQUENCE's can also                                                          be initiated automatically by hardware.                                                          0=power-up/init                  (RANKMASK used, MR0, MR1, MR2, and MR3 written)                                                          1=read-leveling                  (RANKMASK used, MR3 written)                                                          2=self-refresh entry             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)                                                          3=self-refresh exit,             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)                                                          4=precharge power-down entry     (all ranks participate)                                                          5=precharge power-down exit      (all ranks participate)                                                          6=write-leveling                 (RANKMASK used, MR1 written)                                                          7=illegal                                                          Precharge power-down entry and exit SEQUENCE's may                                                          be automatically generated by the HW when IDLEPOWER!=0.                                                          Self-refresh entry SEQUENCE's may be automatically                                                          generated by hardware upon a chip warm or soft reset                                                          sequence when DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.                                                          DFM writes the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 CSR field values                                                          to the Mode registers in the DRAM parts (MR0, MR1, MR2, and MR3) as part of some of these sequences.                                                          Refer to the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 descriptions for more details.                                                          The DFR_CKE pin gets activated as part of power-up/init,                                                          self-refresh exit, and precharge power-down exit sequences.                                                          The DFR_CKE pin gets de-activated as part of self-refresh entry,                                                          precharge power-down entry, or DRESET assertion.                                                          If there are two consecutive power-up/init's without                                                          a DRESET assertion between them, DFM asserts DFR_CKE as part of                                                          the first power-up/init, and continues to assert DFR_CKE                                                          through the remainder of the first and the second power-up/init.                                                          If DFR_CKE deactivation and reactivation is needed for                                                          a second power-up/init, a DRESET assertion is required                                                          between the first and the second. */
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
comment|/**< Refresh& ZQCS interval represented in \#of 512 fclk                                                          increments. A Refresh sequence is triggered when bits                                                          [24:18] are equal to 0, and a ZQCS sequence is triggered                                                          when [36:18] are equal to 0.                                                          Program [24:18] to RND-DN(tREFI/clkPeriod/512)                                                          Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note                                                          that this value should always be greater than 32, to account for                                                          resistor calibration delays.                                                          000_00000000_00000000: RESERVED                                                          Max Refresh interval = 127 * 512           = 65024 fclks                                                          Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 fclks ~ 335ms for a 1.25 ns clock                                                          DFM_CONFIG[INIT_STATUS] determines which ranks receive                                                          the REF / ZQCS. DFM does not send any refreshes / ZQCS's                                                          when DFM_CONFIG[INIT_STATUS]=0. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter,                                                          and DFM_OPS_CNT, DFM_IFB_CNT, and DFM_FCLK_CNT                                                          CSR's. SW should write this to a one, then re-write                                                          it to a zero to cause the reset. */
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter precharge power-down mode after the memory                                                          controller has been idle for 2^(2+IDLEPOWER) cycles.                                                          0=disabled.                                                          This field should only be programmed after initialization.                                                          DFM_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL                                                          is disabled during the precharge power-down. */
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
comment|/**< Physical bank address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the rank(or bunk) bit used to enable 1(of 2)                                                          ranks(via chip enables) supported by the DFM DDR3 interface.                                                          Reverting to the explanation for ROW_LSB, PBANK_LSB would be ROW_LSB bit +                                                          \#rowbits + \#rankbits.                                                          PBANK_LSB                                                              - 0: rank = mem_adr[24]                                                              - 1: rank = mem_adr[25]                                                              - 2: rank = mem_adr[26]                                                              - 3: rank = mem_adr[27]                                                              - 4: rank = mem_adr[28]                                                              - 5: rank = mem_adr[29]                                                              - 6: rank = mem_adr[30]                                                              - 7: rank = mem_adr[31]                                                           - 8-15:  RESERVED                                                          DESIGN NOTE: The DFM DDR3 memory bus is 16b wide, therefore DOES NOT                                                          support standard 64b/72b DDR3 DIMM modules. The board designer should                                                          populate the DFM DDR3 interface using either TWO x8bit DDR3 devices                                                          (or a single x16bit device if available) to fully populate the 16b                                                          DFM DDR3 data bus.                                                          The DFM DDR3 memory controller supports either 1(or 2) rank(s) based                                                          on how much total memory is desired for the DFA application. See                                                          RANK_ENA CSR bit when enabling for dual-ranks.                                                          SW NOTE:                                                              1) When RANK_ENA=0, SW must properly configure the PBANK_LSB to                                                                 reference upper unused memory address bits.                                                              2) When RANK_ENA=1 (dual ranks), SW must configure PBANK_LSB to                                                                 reference the upper most address bit based on the total size                                                                 of the rank.                                                          For example, for a DFM DDR3 memory populated using Samsung's k4b1g0846c-f7                                                          1Gb(256MB) (16M x 8 bit x 8 bank) DDR3 parts, the column address width = 10 and                                                          the device row address width = 14b.  The single x8bit device contains 128MB, and                                                          requires TWO such parts to populate the DFM 16b DDR3 interface. This then yields                                                          a total rank size = 256MB = 2^28.                                                          For a single-rank configuration (RANK_ENA=0), SW would program PBANK_LSB>=3 to                                                          select mem_adr[x] bits above the legal DFM address range for mem_adr[27:0]=256MB.                                                          For a dual-rank configuration (RANK_ENA=1), SW would program PBANK_LSB=4 to select                                                          rank=mem_adr[28] as the bit used to determine which 256MB rank (of 512MB total) to                                                          access (via rank chip enables - see: DFM DDR3 CS0[1:0] pins for connection to                                                          upper and lower rank). */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< Row Address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the low order DDR ROW address.                                                          The DFM memory address [31:4] which references octawords                                                          needs to be translated to DRAM addresses (bnk,row,col,bunk)                                                          mem_adr[31:4]:                                                            3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1                                                            1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4                                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                           |       ROW[m:n]            |     COL[13:3]       | BA                                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                          See:                                                            BA[2:0]:   mem_adr[6:4]                                                            COL[13:0]: [mem_adr[17:7],3'd0]                                                                NOTE: The extracted COL address is always 14b fixed size width,                                                                and upper unused bits are ignored by the DRAM device.                                                            ROW[15:0]: Extraction of ROW starting address bit is programmable,                                                            and is dependent on the \#column bits supported by the DRAM device.                                                            The actual starting bit of the ROW can actually span into the                                                            high order bits of the COL[13:3] field described above.                                                                   ROW_LSB    ROW[15:0]                                                                 --------------------------                                                                    - 0:      mem_adr[26:11]                                                                    - 1:      mem_adr[27:12]                                                                    - 2:      mem_adr[28:13]                                                                    - 3:      mem_adr[29:14]                                                                    - 4:      mem_adr[30:15]                                                                    - 5:      mem_adr[31:16]                                                                   6,7:     [1'b0, mem_adr[31:17]]  For current DDR3 Jedec spec - UNSUPPORTED                                                          For example, for Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10. Therefore,                                                               BA[3:0] = mem_adr[6:4] / COL[9:0] = [mem_adr[13:7],3'd0], and                                                          we would want the row starting address to be extracted from mem_adr[14].                                                          Therefore, a ROW_LSB=3, will extract the row from mem_adr[29:14]. */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition starts the DDR memory sequence that is                                                          selected by DFM_CONFIG[SEQUENCE].  This register is a                                                          oneshot and clears itself each time it is set. */
else|#
directive|else
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
name|uint64_t
name|early_unload_d0_r0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d0_r1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d1_r0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|early_unload_d1_r1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_config_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_config_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
comment|/**< Indicates status of initialization                                                          INIT_STATUS[n] = 1 implies rank n has been initialized                                                          SW must set necessary INIT_STATUS bits with the                                                          same DFM_CONFIG write that initiates                                                          power-up/init and self-refresh exit sequences                                                          (if the required INIT_STATUS bits are not already                                                          set before DFM initiates the sequence).                                                          INIT_STATUS determines the chip-selects that assert                                                          during refresh, ZQCS, and precharge power-down and                                                          self-refresh entry/exit SEQUENCE's.                                                          INIT_STATUS<3:2> must be zero. */
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask determining which ranks are address-mirrored.                                                          MIRRMASK<n> = 1 means Rank n addresses are mirrored                                                          for 0<= n<= 1                                                          A mirrored read/write has these differences:                                                           - DDR_BA<1> is swapped with DDR_BA<0>                                                           - DDR_A<8> is swapped with DDR_A<7>                                                           - DDR_A<6> is swapped with DDR_A<5>                                                           - DDR_A<4> is swapped with DDR_A<3>                                                          MIRRMASK<3:2> must be zero.                                                          When RANK_ENA=0, MIRRMASK<1> MBZ */
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
comment|/**< Mask to select rank to be leveled/initialized.                                                          To write-level/read-level/initialize rank i, set RANKMASK<i>                                                                          RANK_ENA=1               RANK_ENA=0                                                            RANKMASK<0> =    CS0                  CS0 and CS1                                                            RANKMASK<1> =    CS1                      MBZ                                                          For read/write leveling, each rank has to be leveled separately,                                                          so RANKMASK should only have one bit set.                                                          RANKMASK is not used during self-refresh entry/exit and                                                          precharge power-down entry/exit instruction sequences.                                                          RANKMASK<3:2> must be zero.                                                          When RANK_ENA=0, RANKMASK<1> MBZ */
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
comment|/**< RANK enable (for use with multiple ranks)                                                          The RANK_ENA bit enables                                                          the drive of the CS_N[1:0] and ODT_<1:0> pins differently based on the                                                          (PBANK_LSB-1) address bit. */
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh entry/exit write MR1 and MR2                                                          When set, self-refresh entry and exit instruction sequences                                                          write MR1 and MR2 (in all ranks). (The writes occur before                                                          self-refresh entry, and after self-refresh exit.)                                                          When clear, self-refresh entry and exit instruction sequences                                                          do not write any registers in the DDR3 parts. */
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
comment|/**< Send DQx signals one CK cycle earlier for the case when                                                          the shortest DQx lines have a larger delay than the CK line */
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
comment|/**< Instruction sequence that is run after a 0->1                                                          transition on DFM_CONFIG[INIT_START]. Self-refresh entry and                                                          precharge power-down entry and exit SEQUENCE's can also                                                          be initiated automatically by hardware.                                                          0=power-up/init                  (RANKMASK used, MR0, MR1, MR2, and MR3 written)                                                          1=read-leveling                  (RANKMASK used, MR3 written)                                                          2=self-refresh entry             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)                                                          3=self-refresh exit,             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)                                                          4=precharge power-down entry     (all ranks participate)                                                          5=precharge power-down exit      (all ranks participate)                                                          6=write-leveling                 (RANKMASK used, MR1 written)                                                          7=illegal                                                          Precharge power-down entry and exit SEQUENCE's may                                                          be automatically generated by the HW when IDLEPOWER!=0.                                                          Self-refresh entry SEQUENCE's may be automatically                                                          generated by hardware upon a chip warm or soft reset                                                          sequence when DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.                                                          DFM writes the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 CSR field values                                                          to the Mode registers in the DRAM parts (MR0, MR1, MR2, and MR3) as part of some of these sequences.                                                          Refer to the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 descriptions for more details.                                                          The DFR_CKE pin gets activated as part of power-up/init,                                                          self-refresh exit, and precharge power-down exit sequences.                                                          The DFR_CKE pin gets de-activated as part of self-refresh entry,                                                          precharge power-down entry, or DRESET assertion.                                                          If there are two consecutive power-up/init's without                                                          a DRESET assertion between them, DFM asserts DFR_CKE as part of                                                          the first power-up/init, and continues to assert DFR_CKE                                                          through the remainder of the first and the second power-up/init.                                                          If DFR_CKE deactivation and reactivation is needed for                                                          a second power-up/init, a DRESET assertion is required                                                          between the first and the second. */
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
comment|/**< Refresh& ZQCS interval represented in \#of 512 fclk                                                          increments. A Refresh sequence is triggered when bits                                                          [24:18] are equal to 0, and a ZQCS sequence is triggered                                                          when [36:18] are equal to 0.                                                          Program [24:18] to RND-DN(tREFI/clkPeriod/512)                                                          Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note                                                          that this value should always be greater than 32, to account for                                                          resistor calibration delays.                                                          000_00000000_00000000: RESERVED                                                          Max Refresh interval = 127 * 512           = 65024 fclks                                                          Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 fclks ~ 335ms for a 1.25 ns clock                                                          DFM_CONFIG[INIT_STATUS] determines which ranks receive                                                          the REF / ZQCS. DFM does not send any refreshes / ZQCS's                                                          when DFM_CONFIG[INIT_STATUS]=0. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter,                                                          and DFM_OPS_CNT, DFM_IFB_CNT, and DFM_FCLK_CNT                                                          CSR's. SW should write this to a one, then re-write                                                          it to a zero to cause the reset. */
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
comment|/**< Force the oldest outstanding write to complete after                                                          having waited for 2^FORCEWRITE cycles.  0=disabled. */
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
comment|/**< Enter precharge power-down mode after the memory                                                          controller has been idle for 2^(2+IDLEPOWER) cycles.                                                          0=disabled.                                                          This field should only be programmed after initialization.                                                          DFM_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL                                                          is disabled during the precharge power-down. */
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
comment|/**< Physical bank address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the rank(or bunk) bit used to enable 1(of 2)                                                          ranks(via chip enables) supported by the DFM DDR3 interface.                                                          Reverting to the explanation for ROW_LSB, PBANK_LSB would be ROW_LSB bit +                                                          \#rowbits + \#rankbits.                                                          PBANK_LSB                                                              - 0: rank = mem_adr[24]                                                              - 1: rank = mem_adr[25]                                                              - 2: rank = mem_adr[26]                                                              - 3: rank = mem_adr[27]                                                              - 4: rank = mem_adr[28]                                                              - 5: rank = mem_adr[29]                                                              - 6: rank = mem_adr[30]                                                              - 7: rank = mem_adr[31]                                                           - 8-15:  RESERVED                                                          DESIGN NOTE: The DFM DDR3 memory bus is 16b wide, therefore DOES NOT                                                          support standard 64b/72b DDR3 DIMM modules. The board designer should                                                          populate the DFM DDR3 interface using either TWO x8bit DDR3 devices                                                          (or a single x16bit device if available) to fully populate the 16b                                                          DFM DDR3 data bus.                                                          The DFM DDR3 memory controller supports either 1(or 2) rank(s) based                                                          on how much total memory is desired for the DFA application. See                                                          RANK_ENA CSR bit when enabling for dual-ranks.                                                          SW NOTE:                                                              1) When RANK_ENA=0, SW must properly configure the PBANK_LSB to                                                                 reference upper unused memory address bits.                                                              2) When RANK_ENA=1 (dual ranks), SW must configure PBANK_LSB to                                                                 reference the upper most address bit based on the total size                                                                 of the rank.                                                          For example, for a DFM DDR3 memory populated using Samsung's k4b1g0846c-f7                                                          1Gb(256MB) (16M x 8 bit x 8 bank) DDR3 parts, the column address width = 10 and                                                          the device row address width = 14b.  The single x8bit device contains 128MB, and                                                          requires TWO such parts to populate the DFM 16b DDR3 interface. This then yields                                                          a total rank size = 256MB = 2^28.                                                          For a single-rank configuration (RANK_ENA=0), SW would program PBANK_LSB>=3 to                                                          select mem_adr[x] bits above the legal DFM address range for mem_adr[27:0]=256MB.                                                          For a dual-rank configuration (RANK_ENA=1), SW would program PBANK_LSB=4 to select                                                          rank=mem_adr[28] as the bit used to determine which 256MB rank (of 512MB total) to                                                          access (via rank chip enables - see: DFM DDR3 CS0[1:0] pins for connection to                                                          upper and lower rank). */
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
comment|/**< Row Address bit select                                                          Encoding used to determine which memory address                                                          bit position represents the low order DDR ROW address.                                                          The DFM memory address [31:4] which references octawords                                                          needs to be translated to DRAM addresses (bnk,row,col,bunk)                                                          mem_adr[31:4]:                                                            3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1                                                            1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4                                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                           |       ROW[m:n]            |     COL[13:3]       | BA                                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                          See:                                                            BA[2:0]:   mem_adr[6:4]                                                            COL[13:0]: [mem_adr[17:7],3'd0]                                                                NOTE: The extracted COL address is always 14b fixed size width,                                                                and upper unused bits are ignored by the DRAM device.                                                            ROW[15:0]: Extraction of ROW starting address bit is programmable,                                                            and is dependent on the \#column bits supported by the DRAM device.                                                            The actual starting bit of the ROW can actually span into the                                                            high order bits of the COL[13:3] field described above.                                                                   ROW_LSB    ROW[15:0]                                                                 --------------------------                                                                    - 0:      mem_adr[26:11]                                                                    - 1:      mem_adr[27:12]                                                                    - 2:      mem_adr[28:13]                                                                    - 3:      mem_adr[29:14]                                                                    - 4:      mem_adr[30:15]                                                                    - 5:      mem_adr[31:16]                                                                   6,7:     [1'b0, mem_adr[31:17]]  For current DDR3 Jedec spec - UNSUPPORTED                                                          For example, for Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)                                                          DDR3 parts, the column address width = 10. Therefore,                                                               BA[3:0] = mem_adr[6:4] / COL[9:0] = [mem_adr[13:7],3'd0], and                                                          we would want the row starting address to be extracted from mem_adr[14].                                                          Therefore, a ROW_LSB=3, will extract the row from mem_adr[29:14]. */
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition starts the DDR memory sequence that is                                                          selected by DFM_CONFIG[SEQUENCE].  This register is a                                                          oneshot and clears itself each time it is set. */
else|#
directive|else
name|uint64_t
name|init_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|row_lsb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pbank_lsb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idlepower
range|:
literal|3
decl_stmt|;
name|uint64_t
name|forcewrite
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc_adr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ref_zqcs_int
range|:
literal|19
decl_stmt|;
name|uint64_t
name|sequence
range|:
literal|3
decl_stmt|;
name|uint64_t
name|early_dqx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sref_with_dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rank_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rankmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mirrmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|init_status
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_config_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_config
name|cvmx_dfm_config_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_control  *  * DFM_CONTROL = DFM Control  * This register is an assortment of various control fields needed by the memory controller  */
end_comment

begin_union
union|union
name|cvmx_dfm_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|rodt_bprch
range|:
literal|1
decl_stmt|;
comment|/**< When set, the turn-off time for the ODT pin during a                                                          RD cmd is delayed an additional DCLK cycle. */
name|uint64_t
name|wodt_bprch
range|:
literal|1
decl_stmt|;
comment|/**< When set, the turn-off time for the ODT pin during a                                                          WR cmd is delayed an additional DCLK cycle. */
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the default DDR_DQ/DQS drivers is delayed an additional BPRCH FCLK                                                          cycles.                                                          00 = 0 fclks                                                          01 = 1 fclks                                                          10 = 2 fclks                                                          11 = 3 fclks */
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (external) auto-zqcs calibration                                                          When clear, DFM runs external ZQ calibration */
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (internal) auto-zqcs calibration                                                          When counter is re-enabled, ZQCS is run immediately,                                                          and then every DFM_CONFIG[REF_ZQCS_INT] fclk cycles. */
name|uint64_t
name|auto_fclkdis
range|:
literal|1
decl_stmt|;
comment|/**< When 1, DFM will automatically shut off its internal                                                          clock to conserve power when there is no traffic. Note                                                          that this has no effect on the DDR3 PHY and pads clocks. */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Must be set to value 8 */
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for writes                                                          THROTTLE_RD and THROTTLE_WR must be the same value. */
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for reads                                                          THROTTLE_RD and THROTTLE_WR must be the same value. */
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the default DDR_DQ/DQS drivers is FPRCH2 fclks earlier.                                                          00 = 0 fclks                                                          01 = 1 fclks                                                          10 = 2 fclks                                                          11 = RESERVED */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Enable the Posted CAS feature of DDR3.                                                          This bit should be set in conjunction with DFM_MODEREG_PARAMS[AL] */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< Turn on the DDR 2T mode. 2 cycle window for CMD and                                                          address. This mode helps relieve setup time pressure                                                          on the Address and command bus which nominally have                                                          a very large fanout. Please refer to Micron's tech                                                          note tn_47_01 titled "DDR2-533 Memory Design Guide                                                          for Two Dimm Unbuffered Systems" for physical details. */
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
comment|/**< Bus utilization counter Clear.                                                          Clears the DFM_OPS_CNT, DFM_IFB_CNT, and                                                          DFM_FCLK_CNT registers. SW should first write this                                                          field to a one, then write this field to a zero to                                                          clear the CSR's. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
else|#
directive|else
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|auto_fclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wodt_bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rodt_bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_control_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_control_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Back Porch Enable: When set, the turn-on time for                                                          the default DDR_DQ/DQS drivers is delayed an additional BPRCH FCLK                                                          cycles.                                                          00 = 0 fclks                                                          01 = 1 fclks                                                          10 = 2 fclks                                                          11 = 3 fclks */
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (external) auto-zqcs calibration                                                          When clear, DFM runs external ZQ calibration */
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable (internal) auto-zqcs calibration                                                          When counter is re-enabled, ZQCS is run immediately,                                                          and then every DFM_CONFIG[REF_ZQCS_INT] fclk cycles. */
name|uint64_t
name|auto_fclkdis
range|:
literal|1
decl_stmt|;
comment|/**< When 1, DFM will automatically shut off its internal                                                          clock to conserve power when there is no traffic. Note                                                          that this has no effect on the DDR3 PHY and pads clocks. */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
comment|/**< Must be set to value 8 */
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for writes                                                          THROTTLE_RD and THROTTLE_WR must be the same value. */
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
comment|/**< When set, use at most one IFB for reads                                                          THROTTLE_RD and THROTTLE_WR must be the same value. */
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
comment|/**< Front Porch Enable: When set, the turn-off                                                          time for the default DDR_DQ/DQS drivers is FPRCH2 fclks earlier.                                                          00 = 0 fclks                                                          01 = 1 fclks                                                          10 = 2 fclks                                                          11 = RESERVED */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Enable the Posted CAS feature of DDR3.                                                          This bit should be set in conjunction with DFM_MODEREG_PARAMS[AL] */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< Turn on the DDR 2T mode. 2 cycle window for CMD and                                                          address. This mode helps relieve setup time pressure                                                          on the Address and command bus which nominally have                                                          a very large fanout. Please refer to Micron's tech                                                          note tn_47_01 titled "DDR2-533 Memory Design Guide                                                          for Two Dimm Unbuffered Systems" for physical details. */
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
comment|/**< Bus utilization counter Clear.                                                          Clears the DFM_OPS_CNT, DFM_IFB_CNT, and                                                          DFM_FCLK_CNT registers. SW should first write this                                                          field to a one, then write this field to a zero to                                                          clear the CSR's. */
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero. */
else|#
directive|else
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bwcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|throttle_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|throttle_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inorder_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|elev_prio_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nxm_write_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|max_write_batch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|auto_fclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_zqcs_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_control_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_control
name|cvmx_dfm_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_dll_ctl2  *  * DFM_DLL_CTL2 = DFM (Octeon) DLL control and FCLK reset  *  *  * Notes:  * DLL Bringup sequence:  * 1. If not done already, set DFM_DLL_CTL2 = 0, except when DFM_DLL_CTL2[DRESET] = 1.  * 2. Write 1 to DFM_DLL_CTL2[DLL_BRINGUP]  * 3. Wait for 10 FCLK cycles, then write 1 to DFM_DLL_CTL2[QUAD_DLL_ENA]. It may not be feasible to count 10 FCLK cycles, but the  *    idea is to configure the delay line into DLL mode by asserting DLL_BRING_UP earlier than [QUAD_DLL_ENA], even if it is one  *    cycle early. DFM_DLL_CTL2[QUAD_DLL_ENA] must not change after this point without restarting the DFM and/or DRESET initialization  *    sequence.  * 4. Read L2D_BST0 and wait for the result. (L2D_BST0 is subject to change depending on how it called in o63. It is still ok to go  *    without step 4, since step 5 has enough time)  * 5. Wait 10 us.  * 6. Write 0 to DFM_DLL_CTL2[DLL_BRINGUP]. DFM_DLL_CTL2[DLL_BRINGUP] must not change after this point without restarting the DFM  *    and/or DRESET initialization sequence.  * 7. Read L2D_BST0 and wait for the result. (same as step 4, but the idea here is the wait some time before going to step 8, even it  *    is one cycle is fine)  * 8. Write 0 to DFM_DLL_CTL2[DRESET].  DFM_DLL_CTL2[DRESET] must not change after this point without restarting the DFM and/or  *    DRESET initialization sequence.  */
end_comment

begin_union
union|union
name|cvmx_dfm_dll_ctl2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_dll_ctl2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|dll_bringup
range|:
literal|1
decl_stmt|;
comment|/**< DLL Bringup */
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
comment|/**< Fclk domain reset.  The reset signal that is used by the                                                          Fclk domain is (DRESET || ECLK_RESET). */
name|uint64_t
name|quad_dll_ena
range|:
literal|1
decl_stmt|;
comment|/**< DLL Enable */
name|uint64_t
name|byp_sel
range|:
literal|4
decl_stmt|;
comment|/**< Bypass select                                                          0000 : no byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          1010 : all bytes                                                          1011-1111 : Reserved */
name|uint64_t
name|byp_setting
range|:
literal|8
decl_stmt|;
comment|/**< Bypass setting                                                          DDR3-1600: 00100010                                                          DDR3-1333: 00110010                                                          DDR3-1066: 01001011                                                          DDR3-800 : 01110101                                                          DDR3-667 : 10010110                                                          DDR3-600 : 10101100 */
else|#
directive|else
name|uint64_t
name|byp_setting
range|:
literal|8
decl_stmt|;
name|uint64_t
name|byp_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|quad_dll_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll_bringup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_dll_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_dll_ctl2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_dll_ctl2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_dll_ctl2
name|cvmx_dfm_dll_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_dll_ctl3  *  * DFM_DLL_CTL3 = DFM DLL control and FCLK reset  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_dll_ctl3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_dll_ctl3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|dll_fast
range|:
literal|1
decl_stmt|;
comment|/**< DLL lock                                                          0 = DLL locked */
name|uint64_t
name|dll90_setting
range|:
literal|8
decl_stmt|;
comment|/**< Encoded DLL settings. Works in conjuction with                                                          DLL90_BYTE_SEL */
name|uint64_t
name|fine_tune_mode
range|:
literal|1
decl_stmt|;
comment|/**< Fine Tune Mode */
name|uint64_t
name|dll_mode
range|:
literal|1
decl_stmt|;
comment|/**< DLL Mode */
name|uint64_t
name|dll90_byte_sel
range|:
literal|4
decl_stmt|;
comment|/**< Observe DLL settings for selected byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          0000,1010-1111 : Reserved */
name|uint64_t
name|offset_ena
range|:
literal|1
decl_stmt|;
comment|/**< Offset enable                                                          0 = disable                                                          1 = enable */
name|uint64_t
name|load_offset
range|:
literal|1
decl_stmt|;
comment|/**< Load offset                                                          0 : disable                                                          1 : load (generates a 1 cycle pulse to the PHY)                                                          This register is oneshot and clears itself each time                                                          it is set */
name|uint64_t
name|mode_sel
range|:
literal|2
decl_stmt|;
comment|/**< Mode select                                                          00 : reset                                                          01 : write                                                          10 : read                                                          11 : write& read */
name|uint64_t
name|byte_sel
range|:
literal|4
decl_stmt|;
comment|/**< Byte select                                                          0000 : no byte                                                          0001 : byte 0                                                          - ...                                                          1001 : byte 8                                                          1010 : all bytes                                                          1011-1111 : Reserved */
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
comment|/**< Write/read offset setting                                                          [4:0] : offset                                                          [5]   : 0 = increment, 1 = decrement                                                          Not a 2's complement value */
else|#
directive|else
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mode_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|load_offset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|offset_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_byte_sel
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dll_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fine_tune_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll90_setting
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dll_fast
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_dll_ctl3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_dll_ctl3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_dll_ctl3_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_dll_ctl3
name|cvmx_dfm_dll_ctl3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fclk_cnt  *  * DFM_FCLK_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_fclk_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fclk_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|fclkcnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter that counts fclks                                                          64-bit counter. */
else|#
directive|else
name|uint64_t
name|fclkcnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fclk_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_fclk_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_fclk_cnt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fclk_cnt
name|cvmx_dfm_fclk_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fnt_bist  *  * DFM_FNT_BIST = DFM Front BIST Status  *  * This register contains Bist Status for DFM Front  */
end_comment

begin_union
union|union
name|cvmx_dfm_fnt_bist
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_bist_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|cab
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CAB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mrq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mff
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MFF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rpb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RPB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cab
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fnt_bist_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_bist_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|mrq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mff
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MFF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rpb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RPB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_fnt_bist_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fnt_bist
name|cvmx_dfm_fnt_bist_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fnt_ctl  *  * Specify the RSL base addresses for the block  *  *                  DFM_FNT_CTL = DFM Front Control Register  *  * This register contains control registers for the DFM Front Section of Logic.  */
end_comment

begin_union
union|union
name|cvmx_dfm_fnt_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|sbe_ena
range|:
literal|1
decl_stmt|;
comment|/**< If SBE_ENA=1& RECC_ENA=1 then all single bit errors                                                          which have been detected/corrected during GWALK reads,                                                          will be reported through RWORD0[REA]=ERR code in system                                                          memory at the conclusion of the DFA instruction.                                                          SWNOTE: The application user may wish to report single                                                          bit errors that were corrected through the                                                          RWORD0[REA]=ERR codeword.                                                          NOTE: This DOES NOT effect the reporting of SBEs in                                                          DFM_FNT_STAT[SBE] (which were corrected if RECC_ENA=1).                                                          This bit is only here for applications which 'MAY' want                                                          to be alerted with an ERR completion code if there were                                                          SBEs that were auto-corrected during GWALK instructions.                                                          Recap: If there is a SBE and SBE_ENA==1, the "err" field                                                          in the data returned to DFA will be set.  If SBE_ENA==0,                                                          the "err" is always 0 when there is a SBE; however,                                                          regardless of SBE_ENA, DBE will cause "err" to be 1. */
name|uint64_t
name|wecc_ena
range|:
literal|1
decl_stmt|;
comment|/**< If WECC_ENA=1, HW will auto-generate(overwrite) the 10b                                                          OWECC codeword during Memory Writes sourced by                                                          1) DFA MLOAD instructions, or by 2) NCB-Direct CSR                                                          mode writes to DFA memory space. The HW will insert                                                          the 10b OWECC inband into OW-DATA[127:118].                                                          If WECC_ENA=0, SW is responsible for generating the                                                          10b OWECC codeword inband in the upper OW-data[127:118]                                                          during Memory writes (to provide SEC/DED coverage for                                                          the data during subsequent Memory reads-see RECC_ENA). */
name|uint64_t
name|recc_ena
range|:
literal|1
decl_stmt|;
comment|/**< If RECC_ENA=1, all DFA memory reads sourced by 1) DFA                                                          GWALK instructions or by 2) NCB-Direct CSR mode reads                                                          to DFA memory space, will be protected by an inband 10b                                                          OWECC SEC/DED codeword. The inband OW-DATA[127:118]                                                          represents the inband OWECC codeword which offers single                                                          bit error correction(SEC)/double bit error detection(DED).                                                          [see also DFM_FNT_STAT[SBE,DBE,FADR,FSYN] status fields].                                                          The FSYN field contains an encoded value which determines                                                          which bit was corrected(for SBE) or detected(for DBE) to                                                          help in bit isolation of the error.                                                          SW NOTE: If RECC_ENA=1: An NCB-Direct CSR mode read of the                                                          upper QW in memory will return ZEROES in the upper 10b of the                                                          data word.                                                          If RECC_ENA=0: An NCB-Direct CSR mode read of the upper QW in                                                          memory will return the RAW 64bits from memory. During memory                                                          debug, writing RECC_ENA=0 provides visibility into the raw ECC                                                          stored in memory at that time. */
name|uint64_t
name|dfr_ena
range|:
literal|1
decl_stmt|;
comment|/**< DFM Memory Interface Enable                                                          The DFM powers up with the DDR3 interface disabled.                                                          If the DFA function is required, then after poweron                                                          software configures a stable DFM DDR3 memory clock                                                          (see: LMCx_DDR_PLL_CTL[DFM_PS_EN, DFM_DIV_RESET]),                                                          the DFM DDR3 memory interface can be enabled.                                                          When disabled (DFR_ENA=0), all DFM DDR3 memory                                                          output and bidirectional pins will be tristated.                                                          SW NOTE: The DFR_ENA=1 write MUST occur sometime after                                                          the DFM is brought out of reset (ie: after the                                                          DFM_DLL_CTL2[DRESET]=0 write). */
else|#
directive|else
name|uint64_t
name|dfr_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|recc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wecc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fnt_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fnt_ctl
name|cvmx_dfm_fnt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fnt_iena  *  * DFM_FNT_IENA = DFM Front Interrupt Enable Mask  *  * This register contains error interrupt enable information for the DFM Front Section of Logic.  */
end_comment

begin_union
union|union
name|cvmx_dfm_fnt_iena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_iena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dbe_intena
range|:
literal|1
decl_stmt|;
comment|/**< OWECC Double Error Detected(DED) Interrupt Enable                                                          When set, the memory controller raises a processor                                                          interrupt on detecting an uncorrectable double bit                                                          OWECC during a memory read. */
name|uint64_t
name|sbe_intena
range|:
literal|1
decl_stmt|;
comment|/**< OWECC Single Error Corrected(SEC) Interrupt Enable                                                          When set, the memory controller raises a processor                                                          interrupt on detecting a correctable single bit                                                          OWECC error which was corrected during a memory                                                          read. */
else|#
directive|else
name|uint64_t
name|sbe_intena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe_intena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fnt_iena_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_iena_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_iena_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fnt_iena
name|cvmx_dfm_fnt_iena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fnt_sclk  *  * DFM_FNT_SCLK = DFM Front SCLK Control Register  *  * This register contains control registers for the DFM Front Section of Logic.  * NOTE: This register is in USCLK domain and is ised to enable the conditional SCLK grid, as well as  * to start a software BiST sequence for the DFM sub-block. (note: the DFM has conditional clocks which  * prevent BiST to run under reset automatically).  */
end_comment

begin_union
union|union
name|cvmx_dfm_fnt_sclk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_sclk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
comment|/**< When START_BIST is written 0->1, if CLEAR_BIST=1, all                                                          previous BiST state is cleared.                                                          NOTES:                                                          1) CLEAR_BIST must be written to 1 before START_BIST                                                          is written to 1 using a separate CSR write.                                                          2) CLEAR_BIST must not be changed after writing START_BIST                                                          0->1 until the BIST operation completes. */
name|uint64_t
name|bist_start
range|:
literal|1
decl_stmt|;
comment|/**< When software writes BIST_START=0->1, a BiST is executed                                                          for the DFM sub-block.                                                          NOTES:                                                          1) This bit should only be written after BOTH sclk                                                          and fclk have been enabled by software and are stable                                                          (see: DFM_FNT_SCLK[SCLKDIS] and instructions on how to                                                          enable the DFM DDR3 memory (fclk) - which requires LMC                                                          PLL init, DFM clock divider and proper DFM DLL                                                          initialization sequence). */
name|uint64_t
name|sclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFM sclk disable Source                                                          When SET, the DFM sclk are disabled (to conserve overall                                                          chip clocking power when the DFM function is not used).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|sclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_start
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fnt_sclk_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_sclk_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_sclk_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fnt_sclk
name|cvmx_dfm_fnt_sclk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_fnt_stat  *  * DFM_FNT_STAT = DFM Front Status Register  *  * This register contains error status information for the DFM Front Section of Logic.  */
end_comment

begin_union
union|union
name|cvmx_dfm_fnt_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_fnt_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|fsyn
range|:
literal|10
decl_stmt|;
comment|/**< Failing Syndrome                                                          If SBE_ERR=1, the FSYN code determines which bit was                                                          corrected during the OWECC check/correct.                                                          NOTE: If both DBE_ERR/SBE_ERR are set, the DBE_ERR has                                                          higher priority and FSYN captured will always be for the                                                          DBE_ERR detected.                                                          The FSYN is "locked down" when either DBE_ERR/SBE_ERR                                                          are detected (until these bits are cleared (W1C)).                                                          However, if an SBE_ERR occurs first, followed by a                                                          DBE_ERR, the higher priority DBE_ERR will re-capture                                                          the FSYN for the higher priority error case. */
name|uint64_t
name|fadr
range|:
literal|28
decl_stmt|;
comment|/**< Failing Memory octaword address                                                          If either SBE_ERR or DBE_ERR are set, the FADR                                                          represents the failing octaword address.                                                          NOTE: If both DBE_ERR/SBE_ERR are set, the DBE_ERR has                                                          higher priority and the FADR captured will always be                                                          with the DBE_ERR detected.                                                          The FADR is "locked down" when either DBE_ERR/SBE_ERR                                                          are detected (until these bits are cleared (W1C)).                                                          However, if an SBE_ERR occurs first, followed by a                                                          DBE_ERR, the higher priority DBE_ERR will re-capture                                                          the FADR for the higher priority error case. */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dbe_err
range|:
literal|1
decl_stmt|;
comment|/**< Double bit error detected(uncorrectable) during                                                          Memory Read.                                                          Write of 1 will clear the corresponding error bit */
name|uint64_t
name|sbe_err
range|:
literal|1
decl_stmt|;
comment|/**< Single bit error detected(corrected) during                                                          Memory Read.                                                          Write of 1 will clear the corresponding error bit */
else|#
directive|else
name|uint64_t
name|sbe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|28
decl_stmt|;
name|uint64_t
name|fsyn
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_fnt_stat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_stat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_fnt_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_fnt_stat
name|cvmx_dfm_fnt_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_ifb_cnt  *  * DFM_IFB_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_ifb_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_ifb_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|ifbcnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter                                                          64-bit counter that increments every                                                          cycle there is something in the in-flight buffer.                                                          Before using, clear counter via DFM_CONTROL.BWCNT. */
else|#
directive|else
name|uint64_t
name|ifbcnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_ifb_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_ifb_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_ifb_cnt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_ifb_cnt
name|cvmx_dfm_ifb_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_modereg_params0  *  * Notes:  * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_modereg_params0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_modereg_params0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|ppd
range|:
literal|1
decl_stmt|;
comment|/**< DLL Control for precharge powerdown                                                          0 = Slow exit (DLL off)                                                          1 = Fast exit (DLL on)                                                          DFM writes this value to MR0[PPD] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[PPD] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|wrp
range|:
literal|3
decl_stmt|;
comment|/**< Write recovery for auto precharge                                                          Should be programmed to be equal to or greater than                                                          RNDUP[tWR(ns)/tCYC(ns)]                                                          000 = 5                                                          001 = 5                                                          010 = 6                                                          011 = 7                                                          100 = 8                                                          101 = 10                                                          110 = 12                                                          111 = 14                                                          DFM writes this value to MR0[WR] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[WR] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|dllr
range|:
literal|1
decl_stmt|;
comment|/**< DLL Reset                                                          DFM writes this value to MR0[DLL] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[DLL] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|tm
range|:
literal|1
decl_stmt|;
comment|/**< Test Mode                                                          DFM writes this value to MR0[TM] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[TM] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|rbt
range|:
literal|1
decl_stmt|;
comment|/**< Read Burst Type                                                          1 = interleaved (fixed)                                                          DFM writes this value to MR0[RBT] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[RBT] value must be 1 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|cl
range|:
literal|4
decl_stmt|;
comment|/**< CAS Latency                                                          0010 = 5                                                          0100 = 6                                                          0110 = 7                                                          1000 = 8                                                          1010 = 9                                                          1100 = 10                                                          1110 = 11                                                          0001 = 12                                                          0011 = 13                                                          0101 = 14                                                          0111 = 15                                                          1001 = 16                                                          0000, 1011, 1101, 1111 = Reserved                                                          DFM writes this value to MR0[CAS Latency / CL] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          This value must equal the MR0[CAS Latency / CL] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|bl
range|:
literal|2
decl_stmt|;
comment|/**< Burst Length                                                          0 = 8 (fixed)                                                          DFM writes this value to MR0[BL] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR0[BL] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|qoff
range|:
literal|1
decl_stmt|;
comment|/**< Qoff Enable                                                          0 = enable                                                          DFM writes this value to MR1[Qoff] in the selected DDR3 parts                                                          during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[Qoff] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          The MR1[Qoff] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|tdqs
range|:
literal|1
decl_stmt|;
comment|/**< TDQS Enable                                                          0 = disable                                                          DFM writes this value to MR1[TDQS] in the selected DDR3 parts                                                          during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[TDQS] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|wlev
range|:
literal|1
decl_stmt|;
comment|/**< Write Leveling Enable                                                          0 = disable                                                          DFM writes MR1[Level]=0 in the selected DDR3 parts                                                          during power-up/init and write-leveling instruction sequencing.                                                          (DFM also writes MR1[Level]=1 at the beginning of a                                                          write-leveling instruction sequence. Write-leveling can only be initiated via the                                                          write-leveling instruction sequence.)                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          MR1[Level]=0 in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|al
range|:
literal|2
decl_stmt|;
comment|/**< Additive Latency                                                          00 = 0                                                          01 = CL-1                                                          10 = CL-2                                                          11 = Reserved                                                          DFM writes this value to MR1[AL] in the selected DDR3 parts                                                          during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[AL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR1[AL] value in all the DDR3                                                          parts attached to all ranks during normal operation.                                                          See also DFM_CONTROL[POCAS]. */
name|uint64_t
name|dll
range|:
literal|1
decl_stmt|;
comment|/**< DLL Enable                                                          0 = enable                                                          1 = disable                                                          DFM writes this value to MR1[DLL] in the selected DDR3 parts                                                          during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[DLL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR1[DLL] value in all the DDR3                                                          parts attached to all ranks during normal operation.                                                          In dll-off mode, CL/CWL must be programmed                                                          equal to 6/6, respectively, as per the DDR3 specifications. */
name|uint64_t
name|mpr
range|:
literal|1
decl_stmt|;
comment|/**< MPR                                                          DFM writes this value to MR3[MPR] in the selected DDR3 parts                                                          during power-up/init and read-leveling instruction sequencing.                                                          (DFM also writes MR3[MPR]=1 at the beginning of a                                                          read-leveling instruction sequence. Read-leveling can only be initiated via the                                                          read-leveling instruction sequence.)                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR3[MPR] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|mprloc
range|:
literal|2
decl_stmt|;
comment|/**< MPR Location                                                          DFM writes this value to MR3[MPRLoc] in the selected DDR3 parts                                                          during power-up/init and read-leveling instruction sequencing.                                                          (DFM also writes MR3[MPRLoc]=0 at the beginning of the                                                          read-leveling instruction sequence.)                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].                                                          The MR3[MPRLoc] value must be 0 in all the DDR3                                                          parts attached to all ranks during normal operation. */
name|uint64_t
name|cwl
range|:
literal|3
decl_stmt|;
comment|/**< CAS Write Latency                                                          - 000: 5                                                          - 001: 6                                                          - 010: 7                                                          - 011: 8                                                          - 100: 9                                                          - 101: 10                                                          - 110: 11                                                          - 111: 12                                                          DFM writes this value to MR2[CWL] in the selected DDR3 parts                                                          during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[CWL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh                                                          entry and exit instruction sequences.                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].                                                          This value must equal the MR2[CWL] value in all the DDR3                                                          parts attached to all ranks during normal operation. */
else|#
directive|else
name|uint64_t
name|cwl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mprloc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mpr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|al
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wlev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdqs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qoff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rbt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dllr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wrp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_modereg_params0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_modereg_params0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_modereg_params0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_modereg_params0
name|cvmx_dfm_modereg_params0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_modereg_params1  *  * Notes:  * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_modereg_params1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_modereg_params1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rtt_nom_11
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|dic_11
range|:
literal|2
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|rtt_wr_11
range|:
literal|2
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|srt_11
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|asr_11
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|pasr_11
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|rtt_nom_10
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|dic_10
range|:
literal|2
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|rtt_wr_10
range|:
literal|2
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|srt_10
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|asr_10
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|pasr_10
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|rtt_nom_01
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 1                                                          DFM writes this value to MR1[Rtt_Nom] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[Rtt_Nom] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|dic_01
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 1                                                          DFM writes this value to MR1[D.I.C.] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[D.I.C.] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_01
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 1                                                          DFM writes this value to MR2[Rtt_WR] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[Rtt_WR] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_01
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 1                                                          DFM writes this value to MR2[SRT] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[SRT] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_01
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 1                                                          DFM writes this value to MR2[ASR] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[ASR] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_01
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 1                                                          DFM writes this value to MR2[PASR] in the rank 1 (i.e. CS1) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[PASR] in all DRAM parts in rank 1 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_nom_00
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM Rank 0                                                          DFM writes this value to MR1[Rtt_Nom] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[Rtt_Nom] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|dic_00
range|:
literal|2
decl_stmt|;
comment|/**< Output Driver Impedance Control Rank 0                                                          DFM writes this value to MR1[D.I.C.] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init and write-leveling instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR1[D.I.C.] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|rtt_wr_00
range|:
literal|2
decl_stmt|;
comment|/**< RTT_WR Rank 0                                                          DFM writes this value to MR2[Rtt_WR] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[Rtt_WR] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|srt_00
range|:
literal|1
decl_stmt|;
comment|/**< Self-refresh temperature range Rank 0                                                          DFM writes this value to MR2[SRT] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[SRT] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|asr_00
range|:
literal|1
decl_stmt|;
comment|/**< Auto self-refresh Rank 0                                                          DFM writes this value to MR2[ASR] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[ASR] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
name|uint64_t
name|pasr_00
range|:
literal|3
decl_stmt|;
comment|/**< Partial array self-refresh Rank 0                                                          DFM writes this value to MR2[PASR] in the rank 0 (i.e. CS0) DDR3 parts                                                          when selected during power-up/init instruction sequencing.                                                          If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes                                                          this value to MR2[PASR] in all DRAM parts in rank 0 during self-refresh                                                          entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).                                                          See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and                                                          DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
else|#
directive|else
name|uint64_t
name|pasr_00
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_00
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_00
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_00
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_00
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_00
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_01
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_01
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_01
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_01
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_01
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_01
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pasr_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|asr_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srt_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtt_wr_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dic_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rtt_nom_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_modereg_params1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_modereg_params1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_modereg_params1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_modereg_params1
name|cvmx_dfm_modereg_params1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_ops_cnt  *  * DFM_OPS_CNT  = Performance Counters  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_ops_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_ops_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|opscnt
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter                                                          64-bit counter that increments when the DDR3 data bus                                                          is being used.  Before using, clear counter via                                                          DFM_CONTROL.BWCNT                                                            DRAM bus utilization = DFM_OPS_CNT/DFM_FCLK_CNT */
else|#
directive|else
name|uint64_t
name|opscnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_ops_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_ops_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_ops_cnt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_ops_cnt
name|cvmx_dfm_ops_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_phy_ctl  *  * DFM_PHY_CTL = DFM PHY Control  *  */
end_comment

begin_union
union|union
name|cvmx_dfm_phy_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_phy_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|rx_always_on
range|:
literal|1
decl_stmt|;
comment|/**< Disable dynamic DDR3 IO Rx power gating */
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
comment|/**< Low Voltage Mode (1.35V) */
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune                                                           NOTE: DFM UNUSED */
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting                                                           NOTE: DFM UNUSED */
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
comment|/**< Loopback enable */
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
comment|/**< Loopback pos mode */
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
comment|/**< TS Staggermode                                                          This mode configures output drivers with 2-stage drive                                                          strength to avoid undershoot issues on the bus when strong                                                          drivers are suddenly turned on. When this mode is asserted,                                                          Octeon will configure output drivers to be weak drivers                                                          (60 ohm output impedance) at the first FCLK cycle, and                                                          change drivers to the designated drive strengths specified                                                          in DFM_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting                                                          at the following cycle */
else|#
directive|else
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_always_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_phy_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_phy_ctl_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
comment|/**< Low Voltage Mode (1.35V) */
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune                                                           NOTE: DFM UNUSED */
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting                                                           NOTE: DFM UNUSED */
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tune */
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
comment|/**< Clock delay out setting */
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
comment|/**< Loopback enable */
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
comment|/**< Loopback pos mode */
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
comment|/**< TS Staggermode                                                          This mode configures output drivers with 2-stage drive                                                          strength to avoid undershoot issues on the bus when strong                                                          drivers are suddenly turned on. When this mode is asserted,                                                          Octeon will configure output drivers to be weak drivers                                                          (60 ohm output impedance) at the first FCLK cycle, and                                                          change drivers to the designated drive strengths specified                                                          in DFM_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting                                                          at the following cycle */
else|#
directive|else
name|uint64_t
name|ts_stagger
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback_pos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopback
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ck_dlyout1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ck_tune1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lv_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_phy_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_phy_ctl
name|cvmx_dfm_phy_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_reset_ctl  *  * Specify the RSL base addresses for the block  *  *  * Notes:  * DDR3RST - DDR3 DRAM parts have a new RESET#  * pin that wasn't present in DDR2 parts. The  * DDR3RST CSR field controls the assertion of  * the new 6xxx pin that attaches to RESET#.  * When DDR3RST is set, 6xxx asserts RESET#.  * When DDR3RST is clear, 6xxx de-asserts  * RESET#.  *  * DDR3RST is set on a cold reset. Warm and  * soft chip resets do not affect the DDR3RST  * value. Outside of cold reset, only software  * CSR writes change the DDR3RST value.  */
end_comment

begin_union
union|union
name|cvmx_dfm_reset_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_reset_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ddr3psv
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|ddr3psoft
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|ddr3pwarm
range|:
literal|1
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|ddr3rst
range|:
literal|1
decl_stmt|;
comment|/**< Memory Reset                                                          0 = Reset asserted                                                          1 = Reset de-asserted */
else|#
directive|else
name|uint64_t
name|ddr3rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3pwarm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3psoft
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr3psv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_reset_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_reset_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_reset_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_reset_ctl
name|cvmx_dfm_reset_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_rlevel_ctl  */
end_comment

begin_union
union|union
name|cvmx_dfm_rlevel_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_rlevel_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|delay_unload_3
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 3                                                          DELAY_UNLOAD_3 should normally be set, particularly at higher speeds. */
name|uint64_t
name|delay_unload_2
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 2                                                          DELAY_UNLOAD_2 should normally not be set. */
name|uint64_t
name|delay_unload_1
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 1                                                          DELAY_UNLOAD_1 should normally not be set. */
name|uint64_t
name|delay_unload_0
range|:
literal|1
decl_stmt|;
comment|/**< When set, unload the PHY silo one cycle later                                                          during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 0                                                          DELAY_UNLOAD_0 should normally not be set. */
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to select bit lanes on which read-leveling                                                          feedback is returned when OR_DIS is set to 1 */
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable or'ing of bits in a byte lane when computing                                                          the read-leveling bitmask                                                          OR_DIS should normally not be set. */
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
comment|/**< Use DFM_RLEVEL_CTL[OFFSET] to calibrate read                                                          level dskew settings */
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
comment|/**< Pick final_setting-offset (if set) for the read level                                                          deskew setting instead of the middle of the largest                                                          contiguous sequence of 1's in the bitmask */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 1                                                          Byte index for which bitmask results are saved                                                          in DFM_RLEVEL_DBG */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|delay_unload_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|delay_unload_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_rlevel_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_rlevel_ctl_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
comment|/**< Use DFM_RLEVEL_CTL[OFFSET] to calibrate read                                                          level dskew settings */
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
comment|/**< Pick final_setting-offset (if set) for the read level                                                          deskew setting instead of the middle of the largest                                                          contiguous sequence of 1's in the bitmask */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 1                                                          Byte index for which bitmask results are saved                                                          in DFM_RLEVEL_DBG */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|4
decl_stmt|;
name|uint64_t
name|offset_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_rlevel_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_rlevel_ctl
name|cvmx_dfm_rlevel_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_rlevel_dbg  *  * Notes:  * A given read of DFM_RLEVEL_DBG returns the read-leveling pass/fail results for all possible  * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW read-leveled.  * DFM_RLEVEL_CTL[BYTE] selects the particular byte.  * To get these pass/fail results for another different rank, you must run the hardware read-leveling  * again. For example, it is possible to get the BITMASK results for every byte of every rank  * if you run read-leveling separately for each rank, probing DFM_RLEVEL_DBG between each  * read-leveling.  */
end_comment

begin_union
union|union
name|cvmx_dfm_rlevel_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_rlevel_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|bitmask
range|:
literal|64
decl_stmt|;
comment|/**< Bitmask generated during deskew settings sweep                                                          BITMASK[n]=0 means deskew setting n failed                                                          BITMASK[n]=1 means deskew setting n passed                                                          for 0<= n<= 63 */
else|#
directive|else
name|uint64_t
name|bitmask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_rlevel_dbg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_rlevel_dbg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_rlevel_dbg_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_rlevel_dbg
name|cvmx_dfm_rlevel_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_rlevel_rank#  *  * Notes:  * This is TWO CSRs per DFM, one per each rank.  *  * Deskew setting is measured in units of 1/4 FCLK, so the above BYTE* values can range over 16 FCLKs.  *  * Each CSR is written by HW during a read-leveling sequence for the rank. (HW sets STATUS==3 after HW read-leveling completes for the rank.)  * If HW is unable to find a match per DFM_RLEVEL_CTL[OFFSET_EN] and DFM_RLEVEL_CTL[OFFSET], then HW will set DFM_RLEVEL_RANKn[BYTE*<5:0>]  * to 0.  *  * Each CSR may also be written by SW, but not while a read-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)  *  * SW initiates a HW read-leveling sequence by programming DFM_RLEVEL_CTL and writing INIT_START=1 with SEQUENCE=1 in DFM_CONFIG.  * See DFM_RLEVEL_CTL.  */
end_comment

begin_union
union|union
name|cvmx_dfm_rlevel_rankx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_rlevel_rankx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Indicates status of the read-levelling and where                                                          the BYTE* programmings in<35:0> came from:                                                          0 = BYTE* values are their reset value                                                          1 = BYTE* values were set via a CSR write to this register                                                          2 = read-leveling sequence currently in progress (BYTE* values are unpredictable)                                                          3 = BYTE* values came from a complete read-leveling sequence */
name|uint64_t
name|reserved_12_53
range|:
literal|42
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
name|uint64_t
name|byte0
range|:
literal|6
decl_stmt|;
comment|/**< Deskew setting */
else|#
directive|else
name|uint64_t
name|byte0
range|:
literal|6
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_12_53
range|:
literal|42
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_rlevel_rankx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_rlevel_rankx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_rlevel_rankx_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_rlevel_rankx
name|cvmx_dfm_rlevel_rankx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_rodt_mask  *  * DFM_RODT_MASK = DFM Read OnDieTermination mask  * System designers may desire to terminate DQ/DQS/DM lines for higher frequency DDR operations  * especially on a multi-rank system. DDR3 DQ/DM/DQS I/O's have built in  * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF  * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts  * in that rank. System designers may prefer different combinations of ODT ON's for reads  * into different ranks. Octeon supports full programmability by way of the mask register below.  * Each Rank position has its own 8-bit programmable field.  * When the controller does a read to that rank, it sets the 4 ODT pins to the MASK pins below.  * For eg., When doing a read into Rank0, a system designer may desire to terminate the lines  * with the resistor on Dimm0/Rank1. The mask RODT_D0_R0 would then be [00000010].  * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not  * required, write 0 in this register. Note that, as per the DDR3 specifications, the ODT pin  * for the rank that is being read should always be 0.  *  * Notes:  * - Notice that when there is only one rank, all valid fields must be zero.  This is because there is no  * "other" rank to terminate lines for.  Read ODT is meant for multirank systems.  * - For a two rank system and a read op to rank0: use RODT_D0_R0<1> to terminate lines on rank1.  * - For a two rank system and a read op to rank1: use RODT_D0_R1<0> to terminate lines on rank0.  * - Therefore, when a given RANK is selected, the RODT mask for that RANK is used.  *  * DFM always reads 128-bit words independently via one read CAS operation per word.  * When a RODT mask bit is set, DFM asserts the OCTEON ODT output  * pin(s) starting (CL - CWL) CK's after the read CAS operation. Then, OCTEON  * normally continues to assert the ODT output pin(s) for 5+DFM_CONTROL[RODT_BPRCH] more CK's  * - for a total of 6+DFM_CONTROL[RODT_BPRCH] CK's for the entire 128-bit read -  * satisfying the 6 CK DDR3 ODTH8 requirements.  *  * But it is possible for OCTEON to issue two 128-bit reads separated by as few as  * RtR = 4 or 5 (6 if DFM_CONTROL[RODT_BPRCH]=1) CK's. In that case, OCTEON asserts the ODT output pin(s)  * for the RODT mask of the first 128-bit read for RtR CK's, then asserts  * the ODT output pin(s) for the RODT mask of the second 128-bit read for 6+DFM_CONTROL[RODT_BPRCH] CK's  * (or less if a third 128-bit read follows within 4 or 5 (or 6) CK's of this second 128-bit read).  * Note that it may be necessary to force DFM to space back-to-back 128-bit reads  * to different ranks apart by at least 6+DFM_CONTROL[RODT_BPRCH] CK's to prevent DDR3 ODTH8 violations.  */
end_comment

begin_union
union|union
name|cvmx_dfm_rodt_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_rodt_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rodt_d3_r1
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d3_r0
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d2_r1
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d2_r0
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d1_r1
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d1_r0
range|:
literal|8
decl_stmt|;
comment|/**< Must be zero. */
name|uint64_t
name|rodt_d0_r1
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask RANK1                                                          RODT_D0_R1<7:1> must be zero in all cases.                                                          RODT_D0_R1<0> must also be zero if RANK_ENA is not set. */
name|uint64_t
name|rodt_d0_r0
range|:
literal|8
decl_stmt|;
comment|/**< Read ODT mask RANK0                                                          RODT_D0_R0<7:2,0> must be zero in all cases.                                                          RODT_D0_R0<1> must also be zero if RANK_ENA is not set. */
else|#
directive|else
name|uint64_t
name|rodt_d0_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d0_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d1_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d1_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d2_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d2_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d3_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rodt_d3_r1
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_rodt_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_rodt_mask_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_rodt_mask_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_rodt_mask
name|cvmx_dfm_rodt_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_slot_ctl0  *  * DFM_SLOT_CTL0 = DFM Slot Control0  * This register is an assortment of various control fields needed by the memory controller  *  * Notes:  * HW will update this register if SW has not previously written to it and when any of DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn, DFM_CONTROL and  * DFM_MODEREG_PARAMS0 change.Ideally, this register should only be read after DFM has been initialized and DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn  * have valid data.  * R2W_INIT has 1 extra CK cycle built in for odt settling/channel turnaround time.  */
end_comment

begin_union
union|union
name|cvmx_dfm_slot_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_slot_ctl0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|w2w_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-write spacing control                                                          for back to back accesses to the same rank and dimm */
name|uint64_t
name|w2r_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-read spacing control                                                          for back to back accesses to the same rank and dimm */
name|uint64_t
name|r2w_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-write spacing control                                                          for back to back accesses to the same rank and dimm */
name|uint64_t
name|r2r_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-read spacing control                                                          for back to back accesses to the same rank and dimm */
else|#
directive|else
name|uint64_t
name|r2r_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|r2w_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2r_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2w_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_slot_ctl0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_slot_ctl0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_slot_ctl0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_slot_ctl0
name|cvmx_dfm_slot_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_slot_ctl1  *  * DFM_SLOT_CTL1 = DFM Slot Control1  * This register is an assortment of various control fields needed by the memory controller  *  * Notes:  * HW will update this register if SW has not previously written to it and when any of DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn, DFM_CONTROL and  * DFM_MODEREG_PARAMS0 change.Ideally, this register should only be read after DFM has been initialized and DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn  * have valid data.  * R2W_XRANK_INIT, W2R_XRANK_INIT have 1 extra CK cycle built in for odt settling/channel turnaround time.  */
end_comment

begin_union
union|union
name|cvmx_dfm_slot_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_slot_ctl1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|w2w_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-write spacing control                                                          for back to back accesses across ranks of the same dimm */
name|uint64_t
name|w2r_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Write-to-read spacing control                                                          for back to back accesses across ranks of the same dimm */
name|uint64_t
name|r2w_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-write spacing control                                                          for back to back accesses across ranks of the same dimm */
name|uint64_t
name|r2r_xrank_init
range|:
literal|6
decl_stmt|;
comment|/**< Read-to-read spacing control                                                          for back to back accesses across ranks of the same dimm */
else|#
directive|else
name|uint64_t
name|r2r_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|r2w_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2r_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|w2w_xrank_init
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_slot_ctl1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_slot_ctl1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_slot_ctl1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_slot_ctl1
name|cvmx_dfm_slot_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_timing_params0  */
end_comment

begin_union
union|union
name|cvmx_dfm_timing_params0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_timing_params0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLk constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],                                                          where tDLLk is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
comment|/**< Reserved. Should be written to zero. */
else|#
directive|else
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfm_timing_params0_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLk constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],                                                          where tDLLk is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|reserved_0_9
range|:
literal|10
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_9
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_dfm_timing_params0_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKSRE constraints.                                                          Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,                                                          where tCKSRE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, 10ns) */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRP constraints.                                                          Set TRP (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]                                                          + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,                                                          where tRP, tRTP are from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP tRP=10-15ns                                                          TYP tRTP=max(4nCK, 7.5ns) */
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQINIT constraints.                                                          Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],                                                          where tZQINIT is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512) */
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tDLLk constraints.                                                          Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],                                                          where tDLLk is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=2 (equivalent to 512)                                                          This parameter is used in self-refresh exit                                                          and assumed to be greater than tRFC */
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMOD constraints.                                                          Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,                                                          where tMOD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(12nCK, 15ns) */
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMRD constraints.                                                          Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,                                                          where tMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4nCK */
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tXPR constraints.                                                          Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],                                                          where tXPR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(5nCK, tRFC+10ns) */
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tCKE constraints.                                                          Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,                                                          where tCKE is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tZQCS constraints.                                                          Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],                                                          where tZQCS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=4 (equivalent to 64) */
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
comment|/**< Reserved. Should be written to zero. */
else|#
directive|else
name|uint64_t
name|tckeon
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tzqcs
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcke
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdllk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tzqinit
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tcksre
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_timing_params0_cn63xx
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_timing_params0
name|cvmx_dfm_timing_params0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_timing_params1  */
end_comment

begin_union
union|union
name|cvmx_dfm_timing_params1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_timing_params1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|tras_ext
range|:
literal|1
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set [TRAS_EXT[0:0], TRAS[4:0]] (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 000000: RESERVED                                                              - 000001: 2 tCYC                                                              - 000010: 3 tCYC                                                              - ...                                                              - 111111: 64 tCYC */
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tXPDLL constraints.                                                          Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,                                                          where tXPDLL is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(10nCK, 24ns) */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tFAW constraints.                                                          Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],                                                          where tFAW is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=30-40ns */
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLDQSEN constraints.                                                          Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],                                                          where tWLDQSEN is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(25nCK) */
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLMRD constraints.                                                          Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],                                                          where tWLMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(40nCK) */
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tXP constraints.                                                          Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,                                                          where tXP is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5ns) */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tRRD constraints.                                                          Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,                                                          where tRRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 10ns)                                                             - 000: RESERVED                                                             - 001: 3 tCYC                                                             - ...                                                             - 110: 8 tCYC                                                             - 111: 9 tCYC */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],                                                          where tRFC is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=90-350ns                                                               - 00000: RESERVED                                                               - 00001: 8 tCYC                                                               - 00010: 16 tCYC                                                               - 00011: 24 tCYC                                                               - 00100: 32 tCYC                                                               - ...                                                               - 11110: 240 tCYC                                                               - 11111: 248 tCYC */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWTR constraints.                                                          Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,                                                          where tWTR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 7.5ns)                                                              - 0000: RESERVED                                                              - 0001: 2                                                              - ...                                                              - 0111: 8                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRCD constraints.                                                          Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],                                                          where tRCD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=10-15ns                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set [TRAS_EXT[0:0], TRAS[4:0]] (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 000000: RESERVED                                                              - 000001: 2 tCYC                                                              - 000010: 3 tCYC                                                              - ...                                                              - 111111: 64 tCYC */
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMPRR constraints.                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=1nCK */
else|#
directive|else
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tras_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_timing_params1_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_timing_params1_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tXPDLL constraints.                                                          Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,                                                          where tXPDLL is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(10nCK, 24ns) */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tFAW constraints.                                                          Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],                                                          where tFAW is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=30-40ns */
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLDQSEN constraints.                                                          Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],                                                          where tWLDQSEN is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(25nCK) */
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWLMRD constraints.                                                          Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],                                                          where tWLMRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(40nCK) */
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tXP constraints.                                                          Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,                                                          where tXP is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(3nCK, 7.5ns) */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< Indicates tRRD constraints.                                                          Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,                                                          where tRRD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 10ns)                                                             - 000: RESERVED                                                             - 001: 3 tCYC                                                             - ...                                                             - 110: 8 tCYC                                                             - 111: 9 tCYC */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRFC constraints.                                                          Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],                                                          where tRFC is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=90-350ns                                                               - 00000: RESERVED                                                               - 00001: 8 tCYC                                                               - 00010: 16 tCYC                                                               - 00011: 24 tCYC                                                               - 00100: 32 tCYC                                                               - ...                                                               - 11110: 240 tCYC                                                               - 11111: 248 tCYC */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tWTR constraints.                                                          Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,                                                          where tWTR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=max(4nCK, 7.5ns)                                                              - 0000: RESERVED                                                              - 0001: 2                                                              - ...                                                              - 0111: 8                                                              - 1000-1111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tRCD constraints.                                                          Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],                                                          where tRCD is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=10-15ns                                                              - 0000: RESERVED                                                              - 0001: 2 (2 is the smallest value allowed)                                                              - 0002: 2                                                              - ...                                                              - 1001: 9                                                              - 1010-1111: RESERVED                                                          In 2T mode, make this register TRCD-1, not going                                                          below 2. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< Indicates tRAS constraints.                                                          Set TRAS (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,                                                          where tRAS is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=35ns-9*tREFI                                                              - 00000: RESERVED                                                              - 00001: 2 tCYC                                                              - 00010: 3 tCYC                                                              - ...                                                              - 11111: 32 tCYC */
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
comment|/**< Indicates tMPRR constraints.                                                          Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,                                                          where tMPRR is from the DDR3 spec, and tCYC(ns)                                                          is the DDR clock frequency (not data rate).                                                          TYP=1nCK */
else|#
directive|else
name|uint64_t
name|tmprr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|twlmrd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twldqsen
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|txpdll
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_timing_params1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_timing_params1
name|cvmx_dfm_timing_params1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_wlevel_ctl  */
end_comment

begin_union
union|union
name|cvmx_dfm_wlevel_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_wlevel_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|rtt_nom
range|:
literal|3
decl_stmt|;
comment|/**< RTT_NOM                                                          DFM writes a decoded value to MR1[Rtt_Nom] of the rank during                                                          write leveling. Per JEDEC DDR3 specifications,                                                          only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6)                                                          are allowed during write leveling with output buffer enabled.                                                          000 : DFM writes 001 (RZQ/4)   to MR1[Rtt_Nom]                                                          001 : DFM writes 010 (RZQ/2)   to MR1[Rtt_Nom]                                                          010 : DFM writes 011 (RZQ/6)   to MR1[Rtt_Nom]                                                          011 : DFM writes 100 (RZQ/12)  to MR1[Rtt_Nom]                                                          100 : DFM writes 101 (RZQ/8)   to MR1[Rtt_Nom]                                                          101 : DFM writes 110 (Rsvd)    to MR1[Rtt_Nom]                                                          110 : DFM writes 111 (Rsvd)    to  MR1[Rtt_Nom]                                                          111 : DFM writes 000 (Disabled) to MR1[Rtt_Nom] */
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Mask to select bit lanes on which write-leveling                                                          feedback is returned when OR_DIS is set to 1 */
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable or'ing of bits in a byte lane when computing                                                          the write-leveling bitmask */
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
comment|/**< Run write-leveling on the current setting only. */
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
comment|/**< One-hot mask to select byte lane to be leveled by                                                          the write-leveling sequence                                                          Used with x16 parts where the upper and lower byte                                                          lanes need to be leveled independently                                                          LANEMASK<8:2> must be zero. */
else|#
directive|else
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rtt_nom
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_wlevel_ctl_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dfm_wlevel_ctl_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
comment|/**< Run write-leveling on the current setting only. */
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
comment|/**< One-hot mask to select byte lane to be leveled by                                                          the write-leveling sequence                                                          Used with x16 parts where the upper and lower byte                                                          lanes need to be leveled independently                                                          LANEMASK<8:2> must be zero. */
else|#
directive|else
name|uint64_t
name|lanemask
range|:
literal|9
decl_stmt|;
name|uint64_t
name|sset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfm_wlevel_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_wlevel_ctl
name|cvmx_dfm_wlevel_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_wlevel_dbg  *  * Notes:  * A given write of DFM_WLEVEL_DBG returns the write-leveling pass/fail results for all possible  * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW write-leveled.  * DFM_WLEVEL_DBG[BYTE] selects the particular byte.  * To get these pass/fail results for another different rank, you must run the hardware write-leveling  * again. For example, it is possible to get the BITMASK results for every byte of every rank  * if you run write-leveling separately for each rank, probing DFM_WLEVEL_DBG between each  * write-leveling.  */
end_comment

begin_union
union|union
name|cvmx_dfm_wlevel_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_wlevel_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
comment|/**< Bitmask generated during deskew settings sweep                                                          if DFM_WLEVEL_CTL[SSET]=0                                                            BITMASK[n]=0 means deskew setting n failed                                                            BITMASK[n]=1 means deskew setting n passed                                                            for 0<= n<= 7                                                            BITMASK contains the first 8 results of the total 16                                                            collected by DFM during the write-leveling sequence                                                          else if DFM_WLEVEL_CTL[SSET]=1                                                            BITMASK[0]=0 means curr deskew setting failed                                                            BITMASK[0]=1 means curr deskew setting passed */
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
comment|/**< 0<= BYTE<= 8 */
else|#
directive|else
name|uint64_t
name|byte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bitmask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_wlevel_dbg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_wlevel_dbg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_wlevel_dbg_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_wlevel_dbg
name|cvmx_dfm_wlevel_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_wlevel_rank#  *  * Notes:  * This is TWO CSRs per DFM, one per each rank. (front bunk/back bunk)  *  * Deskew setting is measured in units of 1/8 FCLK, so the above BYTE* values can range over 4 FCLKs.  *  * Assuming DFM_WLEVEL_CTL[SSET]=0, the BYTE*<2:0> values are not used during write-leveling, and  * they are over-written by the hardware as part of the write-leveling sequence. (HW sets STATUS==3  * after HW write-leveling completes for the rank). SW needs to set BYTE*<4:3> bits.  *  * Each CSR may also be written by SW, but not while a write-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)  *  * SW initiates a HW write-leveling sequence by programming DFM_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with SEQUENCE=6 in DFM_CONFIG.  * DFM will then step through and accumulate write leveling results for 8 unique delay settings (twice), starting at a delay of  * DFM_WLEVEL_RANKn[BYTE*<4:3>]*8 CK increasing by 1/8 CK each setting. HW will then set DFM_WLEVEL_RANKn[BYTE*<2:0>] to indicate the  * first write leveling result of '1' that followed a reslt of '0' during the sequence by searching for a '1100' pattern in the generated  * bitmask, except that DFM will always write DFM_WLEVEL_RANKn[BYTE*<0>]=0. If HW is unable to find a match for a '1100' pattern, then HW will  * set DFM_WLEVEL_RANKn[BYTE*<2:0>] to 4.  * See DFM_WLEVEL_CTL.  */
end_comment

begin_union
union|union
name|cvmx_dfm_wlevel_rankx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_wlevel_rankx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
comment|/**< Indicates status of the write-leveling and where                                                          the BYTE* programmings in<44:0> came from:                                                          0 = BYTE* values are their reset value                                                          1 = BYTE* values were set via a CSR write to this register                                                          2 = write-leveling sequence currently in progress (BYTE* values are unpredictable)                                                          3 = BYTE* values came from a complete write-leveling sequence, irrespective of                                                              which lanes are masked via DFM_WLEVEL_CTL[LANEMASK] */
name|uint64_t
name|reserved_10_44
range|:
literal|35
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE1 must be zero during normal operation */
name|uint64_t
name|byte0
range|:
literal|5
decl_stmt|;
comment|/**< Deskew setting                                                          Bit 0 of BYTE0 must be zero during normal operation */
else|#
directive|else
name|uint64_t
name|byte0
range|:
literal|5
decl_stmt|;
name|uint64_t
name|byte1
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_10_44
range|:
literal|35
decl_stmt|;
name|uint64_t
name|status
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_wlevel_rankx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_wlevel_rankx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_wlevel_rankx_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_wlevel_rankx
name|cvmx_dfm_wlevel_rankx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfm_wodt_mask  *  * DFM_WODT_MASK = DFM Write OnDieTermination mask  * System designers may desire to terminate DQ/DQS/DM lines for higher frequency DDR operations  * especially on a multi-rank system. DDR3 DQ/DM/DQS I/O's have built in  * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF  * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts  * in that rank. System designers may prefer different combinations of ODT ON's for writes  * into different ranks. Octeon supports full programmability by way of the mask register below.  * Each Rank position has its own 8-bit programmable field.  * When the controller does a write to that rank, it sets the 4 ODT pins to the MASK pins below.  * For eg., When doing a write into Rank0, a system designer may desire to terminate the lines  * with the resistor on Dimm0/Rank1. The mask WODT_D0_R0 would then be [00000010].  * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not  * required, write 0 in this register.  *  * Notes:  * - DFM_WODT_MASK functions a little differently than DFM_RODT_MASK.  While, in DFM_RODT_MASK, the other  * rank(s) are ODT-ed, in DFM_WODT_MASK, the rank in which the write CAS is issued can be ODT-ed as well.  * - For a two rank system and a write op to rank0: use RODT_D0_R0<1:0> to terminate lines on rank1 and/or rank0.  * - For a two rank system and a write op to rank1: use RODT_D0_R1<1:0> to terminate lines on rank1 and/or rank0.  * - When a given RANK is selected, the WODT mask for that RANK is used.  *  * DFM always writes 128-bit words independently via one write CAS operation per word.  * When a WODT mask bit is set, DFM asserts the OCTEON ODT output pin(s) starting the same cycle  * as the write CAS operation. Then, OCTEON normally continues to assert the ODT output pin(s) for five  * more cycles - for a total of 6 cycles for the entire word write - satisfying the 6 cycle DDR3  * ODTH8 requirements. But it is possible for DFM to issue two word writes  separated by as few  * as WtW = 4 or 5 cycles. In that case, DFM asserts the ODT output pin(s) for the WODT mask of the  * first word write for WtW cycles, then asserts the ODT output pin(s) for the WODT mask of the  * second write for 6 cycles (or less if a third word write follows within 4 or 5  * cycles of this second word write). Note that it may be necessary to force DFM to space back-to-back  * word writes to different ranks apart by at least 6 cycles to prevent DDR3 ODTH8 violations.  */
end_comment

begin_union
union|union
name|cvmx_dfm_wodt_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfm_wodt_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
comment|/**< Not used by DFM. */
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask RANK1                                                          WODT_D0_R1<7:2> not used by DFM.                                                          WODT_D0_R1<1:0> is also not used by DFM when RANK_ENA is not set. */
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
comment|/**< Write ODT mask RANK0                                                          WODT_D0_R0<7:2> not used by DFM. */
else|#
directive|else
name|uint64_t
name|wodt_d0_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d0_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d1_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d2_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d2_r1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wodt_d3_r1
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfm_wodt_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfm_wodt_mask_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfm_wodt_mask_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfm_wodt_mask
name|cvmx_dfm_wodt_mask_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

