begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the SMI/MDIO hardware, including support for both IEEE 802.3  * clause 22 and clause 45 operations.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_MIO_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_MIO_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/octeon.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * PHY register 0 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_CONTROL
value|0
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint16_t
name|loopback
range|:
literal|1
decl_stmt|;
name|uint16_t
name|speed_lsb
range|:
literal|1
decl_stmt|;
name|uint16_t
name|autoneg_enable
range|:
literal|1
decl_stmt|;
name|uint16_t
name|power_down
range|:
literal|1
decl_stmt|;
name|uint16_t
name|isolate
range|:
literal|1
decl_stmt|;
name|uint16_t
name|restart_autoneg
range|:
literal|1
decl_stmt|;
name|uint16_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint16_t
name|collision_test
range|:
literal|1
decl_stmt|;
name|uint16_t
name|speed_msb
range|:
literal|1
decl_stmt|;
name|uint16_t
name|unidirectional_enable
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_control_t
typedef|;
comment|/**  * PHY register 1 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_STATUS
value|1
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|capable_100base_t4
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_100base_x_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_100base_x_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_10_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_10_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_100base_t2_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_100base_t2_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_extended_status
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_unidirectional
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_mf_preamble_suppression
range|:
literal|1
decl_stmt|;
name|uint16_t
name|autoneg_complete
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_fault
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_autoneg
range|:
literal|1
decl_stmt|;
name|uint16_t
name|link_status
range|:
literal|1
decl_stmt|;
name|uint16_t
name|jabber_detect
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_extended_registers
range|:
literal|1
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_status_t
typedef|;
comment|/**  * PHY register 2 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_ID1
value|2
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|oui_bits_3_18
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_id1_t
typedef|;
comment|/**  * PHY register 3 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_ID2
value|3
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|oui_bits_19_24
range|:
literal|6
decl_stmt|;
name|uint16_t
name|model
range|:
literal|6
decl_stmt|;
name|uint16_t
name|revision
range|:
literal|4
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_id2_t
typedef|;
comment|/**  * PHY register 4 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
value|4
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|next_page
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_14
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_fault
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_12
range|:
literal|1
decl_stmt|;
name|uint16_t
name|asymmetric_pause
range|:
literal|1
decl_stmt|;
name|uint16_t
name|pause
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_t4
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_tx_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_tx_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_10base_tx_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_10base_tx_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|selector
range|:
literal|5
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_autoneg_adver_t
typedef|;
comment|/**  * PHY register 5 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_LINK_PARTNER_ABILITY
value|5
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|next_page
range|:
literal|1
decl_stmt|;
name|uint16_t
name|ack
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_fault
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_12
range|:
literal|1
decl_stmt|;
name|uint16_t
name|asymmetric_pause
range|:
literal|1
decl_stmt|;
name|uint16_t
name|pause
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_t4
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_tx_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_100base_tx_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_10base_tx_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_10base_tx_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|selector
range|:
literal|5
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_link_partner_ability_t
typedef|;
comment|/**  * PHY register 6 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_AUTONEG_EXPANSION
value|6
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|reserved_5_15
range|:
literal|11
decl_stmt|;
name|uint16_t
name|parallel_detection_fault
range|:
literal|1
decl_stmt|;
name|uint16_t
name|link_partner_next_page_capable
range|:
literal|1
decl_stmt|;
name|uint16_t
name|local_next_page_capable
range|:
literal|1
decl_stmt|;
name|uint16_t
name|page_received
range|:
literal|1
decl_stmt|;
name|uint16_t
name|link_partner_autoneg_capable
range|:
literal|1
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_autoneg_expansion_t
typedef|;
comment|/**  * PHY register 9 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_CONTROL_1000
value|9
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|test_mode
range|:
literal|3
decl_stmt|;
name|uint16_t
name|manual_master_slave
range|:
literal|1
decl_stmt|;
name|uint16_t
name|master
range|:
literal|1
decl_stmt|;
name|uint16_t
name|port_type
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_1000base_t_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|advert_1000base_t_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_control_1000_t
typedef|;
comment|/**  * PHY register 10 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_STATUS_1000
value|10
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|master_slave_fault
range|:
literal|1
decl_stmt|;
name|uint16_t
name|is_master
range|:
literal|1
decl_stmt|;
name|uint16_t
name|local_receiver_ok
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_receiver_ok
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_capable_1000base_t_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|remote_capable_1000base_t_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_8_9
range|:
literal|2
decl_stmt|;
name|uint16_t
name|idle_error_count
range|:
literal|8
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_status_1000_t
typedef|;
comment|/**  * PHY register 15 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_EXTENDED_STATUS
value|15
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|capable_1000base_x_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_1000base_x_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_1000base_t_full
range|:
literal|1
decl_stmt|;
name|uint16_t
name|capable_1000base_t_half
range|:
literal|1
decl_stmt|;
name|uint16_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_extended_status_t
typedef|;
comment|/**  * PHY register 13 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_MMD_CONTROL
value|13
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|function
range|:
literal|2
decl_stmt|;
name|uint16_t
name|reserved_5_13
range|:
literal|9
decl_stmt|;
name|uint16_t
name|devad
range|:
literal|5
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_mmd_control_t
typedef|;
comment|/**  * PHY register 14 from the 802.3 spec  */
define|#
directive|define
name|CVMX_MDIO_PHY_REG_MMD_ADDRESS_DATA
value|14
typedef|typedef
union|union
block|{
name|uint16_t
name|u16
decl_stmt|;
struct|struct
block|{
name|uint16_t
name|address_data
range|:
literal|16
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_mdio_phy_reg_mmd_address_data_t
typedef|;
comment|/* Operating request encodings. */
define|#
directive|define
name|MDIO_CLAUSE_22_WRITE
value|0
define|#
directive|define
name|MDIO_CLAUSE_22_READ
value|1
define|#
directive|define
name|MDIO_CLAUSE_45_ADDRESS
value|0
define|#
directive|define
name|MDIO_CLAUSE_45_WRITE
value|1
define|#
directive|define
name|MDIO_CLAUSE_45_READ_INC
value|2
define|#
directive|define
name|MDIO_CLAUSE_45_READ
value|3
comment|/* MMD identifiers, mostly for accessing devices within XENPAK modules. */
define|#
directive|define
name|CVMX_MMD_DEVICE_PMA_PMD
value|1
define|#
directive|define
name|CVMX_MMD_DEVICE_WIS
value|2
define|#
directive|define
name|CVMX_MMD_DEVICE_PCS
value|3
define|#
directive|define
name|CVMX_MMD_DEVICE_PHY_XS
value|4
define|#
directive|define
name|CVMX_MMD_DEVICE_DTS_XS
value|5
define|#
directive|define
name|CVMX_MMD_DEVICE_TC
value|6
define|#
directive|define
name|CVMX_MMD_DEVICE_CL22_EXT
value|29
define|#
directive|define
name|CVMX_MMD_DEVICE_VENDOR_1
value|30
define|#
directive|define
name|CVMX_MMD_DEVICE_VENDOR_2
value|31
define|#
directive|define
name|CVMX_MDIO_TIMEOUT
value|100000
comment|/* 100 millisec */
comment|/* Helper function to put MDIO interface into clause 45 mode */
specifier|static
specifier|inline
name|void
name|__cvmx_mdio_set_clause45_mode
parameter_list|(
name|int
name|bus_id
parameter_list|)
block|{
name|cvmx_smix_clk_t
name|smi_clk
decl_stmt|;
comment|/* Put bus into clause 45 mode */
name|smi_clk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_CLK
argument_list|(
name|bus_id
argument_list|)
argument_list|)
expr_stmt|;
name|smi_clk
operator|.
name|s
operator|.
name|mode
operator|=
literal|1
expr_stmt|;
name|smi_clk
operator|.
name|s
operator|.
name|preamble
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CLK
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_clk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Helper function to put MDIO interface into clause 22 mode */
specifier|static
specifier|inline
name|void
name|__cvmx_mdio_set_clause22_mode
parameter_list|(
name|int
name|bus_id
parameter_list|)
block|{
name|cvmx_smix_clk_t
name|smi_clk
decl_stmt|;
comment|/* Put bus into clause 22 mode */
name|smi_clk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_CLK
argument_list|(
name|bus_id
argument_list|)
argument_list|)
expr_stmt|;
name|smi_clk
operator|.
name|s
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CLK
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_clk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * @INTERNAL  * Function to read SMIX_RD_DAT and check for timeouts. This  * code sequence is done fairly often, so put in in one spot.  *  * @param bus_id SMI/MDIO bus to read  *  * @return Value of SMIX_RD_DAT. pending will be set on  *         a timeout.  */
specifier|static
specifier|inline
name|cvmx_smix_rd_dat_t
name|__cvmx_mdio_read_rd_dat
parameter_list|(
name|int
name|bus_id
parameter_list|)
block|{
name|cvmx_smix_rd_dat_t
name|smi_rd
decl_stmt|;
name|uint64_t
name|done
init|=
name|cvmx_get_cycle
argument_list|()
operator|+
operator|(
name|uint64_t
operator|)
name|CVMX_MDIO_TIMEOUT
operator|*
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|1000000
decl_stmt|;
do|do
block|{
name|cvmx_wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|smi_rd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SMIX_RD_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|smi_rd
operator|.
name|s
operator|.
name|pending
operator|&&
operator|(
name|cvmx_get_cycle
argument_list|()
operator|<
name|done
operator|)
condition|)
do|;
return|return
name|smi_rd
return|;
block|}
comment|/**  * Perform an MII read. This function is used to read PHY  * registers controlling auto negotiation.  *  * @param bus_id   MDIO bus number. Zero on most chips, but some chips (ex CN56XX)  *                 support multiple busses.  * @param phy_id   The MII phy id  * @param location Register location to read  *  * @return Result from the read or -1 on failure  */
specifier|static
specifier|inline
name|int
name|cvmx_mdio_read
parameter_list|(
name|int
name|bus_id
parameter_list|,
name|int
name|phy_id
parameter_list|,
name|int
name|location
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_PHYLIB
argument_list|)
name|struct
name|mii_bus
modifier|*
name|bus
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|BUG_ON
argument_list|(
name|bus_id
operator|>
literal|3
operator|||
name|bus_id
operator|<
literal|0
argument_list|)
expr_stmt|;
name|bus
operator|=
name|octeon_mdiobuses
index|[
name|bus_id
index|]
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|rv
operator|=
name|mdiobus_read
argument_list|(
name|bus
argument_list|,
name|phy_id
argument_list|,
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|rv
return|;
else|#
directive|else
name|cvmx_smix_cmd_t
name|smi_cmd
decl_stmt|;
name|cvmx_smix_rd_dat_t
name|smi_rd
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_MDIO_CLAUSE_45
argument_list|)
condition|)
name|__cvmx_mdio_set_clause22_mode
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_22_READ
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|location
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_rd
operator|=
name|__cvmx_mdio_read_rd_dat
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|smi_rd
operator|.
name|s
operator|.
name|val
condition|)
return|return
name|smi_rd
operator|.
name|s
operator|.
name|dat
return|;
else|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
comment|/**  * Perform an MII write. This function is used to write PHY  * registers controlling auto negotiation.  *  * @param bus_id   MDIO bus number. Zero on most chips, but some chips (ex CN56XX)  *                 support multiple busses.  * @param phy_id   The MII phy id  * @param location Register location to write  * @param val      Value to write  *  * @return -1 on error  *         0 on success  */
specifier|static
specifier|inline
name|int
name|cvmx_mdio_write
parameter_list|(
name|int
name|bus_id
parameter_list|,
name|int
name|phy_id
parameter_list|,
name|int
name|location
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_PHYLIB
argument_list|)
name|struct
name|mii_bus
modifier|*
name|bus
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|BUG_ON
argument_list|(
name|bus_id
operator|>
literal|3
operator|||
name|bus_id
operator|<
literal|0
argument_list|)
expr_stmt|;
name|bus
operator|=
name|octeon_mdiobuses
index|[
name|bus_id
index|]
expr_stmt|;
if|if
condition|(
name|bus
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|rv
operator|=
name|mdiobus_write
argument_list|(
name|bus
argument_list|,
name|phy_id
argument_list|,
name|location
argument_list|,
operator|(
name|u16
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
else|#
directive|else
name|cvmx_smix_cmd_t
name|smi_cmd
decl_stmt|;
name|cvmx_smix_wr_dat_t
name|smi_wr
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_MDIO_CLAUSE_45
argument_list|)
condition|)
name|__cvmx_mdio_set_clause22_mode
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
name|smi_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_wr
operator|.
name|s
operator|.
name|dat
operator|=
name|val
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_22_WRITE
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|location
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|cvmx_smix_wr_dat_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_MDIO_TIMEOUT
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
comment|/**  * Perform an IEEE 802.3 clause 45 MII read. This function is used to read PHY  * registers controlling auto negotiation.  *  * @param bus_id   MDIO bus number. Zero on most chips, but some chips (ex CN56XX)  *                 support multiple busses.  * @param phy_id   The MII phy id  * @param device   MDIO Managable Device (MMD) id  * @param location Register location to read  *  * @return Result from the read or -1 on failure  */
specifier|static
specifier|inline
name|int
name|cvmx_mdio_45_read
parameter_list|(
name|int
name|bus_id
parameter_list|,
name|int
name|phy_id
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|cvmx_smix_cmd_t
name|smi_cmd
decl_stmt|;
name|cvmx_smix_rd_dat_t
name|smi_rd
decl_stmt|;
name|cvmx_smix_wr_dat_t
name|smi_wr
decl_stmt|;
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_MDIO_CLAUSE_45
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|__cvmx_mdio_set_clause45_mode
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
name|smi_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_wr
operator|.
name|s
operator|.
name|dat
operator|=
name|location
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_45_ADDRESS
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|device
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|cvmx_smix_wr_dat_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_MDIO_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_mdio_45_read: bus_id %d phy_id %2d device %2d register %2d   TIME OUT(address)\n"
argument_list|,
name|bus_id
argument_list|,
name|phy_id
argument_list|,
name|device
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_45_READ
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|device
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_rd
operator|=
name|__cvmx_mdio_read_rd_dat
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|smi_rd
operator|.
name|s
operator|.
name|pending
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_mdio_45_read: bus_id %d phy_id %2d device %2d register %2d   TIME OUT(data)\n"
argument_list|,
name|bus_id
argument_list|,
name|phy_id
argument_list|,
name|device
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|smi_rd
operator|.
name|s
operator|.
name|val
condition|)
return|return
name|smi_rd
operator|.
name|s
operator|.
name|dat
return|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_mdio_45_read: bus_id %d phy_id %2d device %2d register %2d   INVALID READ\n"
argument_list|,
name|bus_id
argument_list|,
name|phy_id
argument_list|,
name|device
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**  * Perform an IEEE 802.3 clause 45 MII write. This function is used to write PHY  * registers controlling auto negotiation.  *  * @param bus_id   MDIO bus number. Zero on most chips, but some chips (ex CN56XX)  *                 support multiple busses.  * @param phy_id   The MII phy id  * @param device   MDIO Managable Device (MMD) id  * @param location Register location to write  * @param val      Value to write  *  * @return -1 on error  *         0 on success  */
specifier|static
specifier|inline
name|int
name|cvmx_mdio_45_write
parameter_list|(
name|int
name|bus_id
parameter_list|,
name|int
name|phy_id
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|location
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|cvmx_smix_cmd_t
name|smi_cmd
decl_stmt|;
name|cvmx_smix_wr_dat_t
name|smi_wr
decl_stmt|;
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_MDIO_CLAUSE_45
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|__cvmx_mdio_set_clause45_mode
argument_list|(
name|bus_id
argument_list|)
expr_stmt|;
name|smi_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_wr
operator|.
name|s
operator|.
name|dat
operator|=
name|location
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_45_ADDRESS
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|device
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|cvmx_smix_wr_dat_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_MDIO_TIMEOUT
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|smi_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_wr
operator|.
name|s
operator|.
name|dat
operator|=
name|val
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|smi_cmd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_op
operator|=
name|MDIO_CLAUSE_45_WRITE
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|phy_adr
operator|=
name|phy_id
expr_stmt|;
name|smi_cmd
operator|.
name|s
operator|.
name|reg_adr
operator|=
name|device
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SMIX_CMD
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|smi_cmd
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SMIX_WR_DAT
argument_list|(
name|bus_id
argument_list|)
argument_list|,
name|cvmx_smix_wr_dat_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_MDIO_TIMEOUT
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

