begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2011  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware Packet Order / Work unit.  *  * New, starting with SDK 1.7.0, cvmx-pow supports a number of  * extended consistency checks. The define  * CVMX_ENABLE_POW_CHECKS controls the runtime insertion of POW  * internal state checks to find common programming errors. If  * CVMX_ENABLE_POW_CHECKS is not defined, checks are by default  * enabled. For example, cvmx-pow will check for the following  * program errors or POW state inconsistency.  * - Requesting a POW operation with an active tag switch in  *   progress.  * - Waiting for a tag switch to complete for an excessively  *   long period. This is normally a sign of an error in locking  *   causing deadlock.  * - Illegal tag switches from NULL_NULL.  * - Illegal tag switches from NULL.  * - Illegal deschedule request.  * - WQE pointer not matching the one attached to the core by  *   the POW.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_POW_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_POW_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-scratch.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sso-defs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx-warn.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Default to having all POW constancy checks turned on */
ifndef|#
directive|ifndef
name|CVMX_ENABLE_POW_CHECKS
define|#
directive|define
name|CVMX_ENABLE_POW_CHECKS
value|1
endif|#
directive|endif
comment|/**  * Wait flag values for pow functions.  */
typedef|typedef
enum|enum
block|{
name|CVMX_POW_WAIT
init|=
literal|1
block|,
name|CVMX_POW_NO_WAIT
init|=
literal|0
block|, }
name|cvmx_pow_wait_t
typedef|;
comment|/**  *  POW tag operations.  These are used in the data stored to the POW.  */
typedef|typedef
enum|enum
block|{
name|CVMX_POW_TAG_OP_SWTAG
init|=
literal|0L
block|,
comment|/**< switch the tag (only) for this PP                                             - the previous tag should be non-NULL in this case                                             - tag switch response required                                             - fields used: op, type, tag */
name|CVMX_POW_TAG_OP_SWTAG_FULL
init|=
literal|1L
block|,
comment|/**< switch the tag for this PP, with full information                                             - this should be used when the previous tag is NULL                                             - tag switch response required                                             - fields used: address, op, grp, type, tag */
name|CVMX_POW_TAG_OP_SWTAG_DESCH
init|=
literal|2L
block|,
comment|/**< switch the tag (and/or group) for this PP and de-schedule                                             - OK to keep the tag the same and only change the group                                             - fields used: op, no_sched, grp, type, tag */
name|CVMX_POW_TAG_OP_DESCH
init|=
literal|3L
block|,
comment|/**< just de-schedule                                             - fields used: op, no_sched */
name|CVMX_POW_TAG_OP_ADDWQ
init|=
literal|4L
block|,
comment|/**< create an entirely new work queue entry                                             - fields used: address, op, qos, grp, type, tag */
name|CVMX_POW_TAG_OP_UPDATE_WQP_GRP
init|=
literal|5L
block|,
comment|/**< just update the work queue pointer and grp for this PP                                             - fields used: address, op, grp */
name|CVMX_POW_TAG_OP_SET_NSCHED
init|=
literal|6L
block|,
comment|/**< set the no_sched bit on the de-schedule list                                             - does nothing if the selected entry is not on the de-schedule list                                             - does nothing if the stored work queue pointer does not match the address field                                             - fields used: address, index, op                                             Before issuing a *_NSCHED operation, SW must guarantee that all                                             prior deschedules and set/clr NSCHED operations are complete and all                                             prior switches are complete. The hardware provides the opsdone bit                                             and swdone bit for SW polling. After issuing a *_NSCHED operation,                                             SW must guarantee that the set/clr NSCHED is complete before                                             any subsequent operations. */
name|CVMX_POW_TAG_OP_CLR_NSCHED
init|=
literal|7L
block|,
comment|/**< clears the no_sched bit on the de-schedule list                                             - does nothing if the selected entry is not on the de-schedule list                                             - does nothing if the stored work queue pointer does not match the address field                                             - fields used: address, index, op                                             Before issuing a *_NSCHED operation, SW must guarantee that all                                             prior deschedules and set/clr NSCHED operations are complete and all                                             prior switches are complete. The hardware provides the opsdone bit                                             and swdone bit for SW polling. After issuing a *_NSCHED operation,                                             SW must guarantee that the set/clr NSCHED is complete before                                             any subsequent operations. */
name|CVMX_POW_TAG_OP_NOP
init|=
literal|15L
comment|/**< do nothing */
block|}
name|cvmx_pow_tag_op_t
typedef|;
comment|/**  * This structure defines the store data on a store to POW  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
comment|/**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
name|uint64_t
name|unused
range|:
literal|2
decl_stmt|;
name|uint64_t
name|index
range|:
literal|13
decl_stmt|;
comment|/**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
comment|/**< the operation to perform */
name|uint64_t
name|unused2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< the QOS level for the packet. qos is only used for CVMX_POW_TAG_OP_ADDWQ */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
name|cvmx_pow_tag_type_t
name|type
range|:
literal|3
decl_stmt|;
comment|/**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|3
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|unused2
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|13
decl_stmt|;
name|uint64_t
name|unused
range|:
literal|2
decl_stmt|;
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_cn38xx
struct|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
comment|/**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
comment|/**< the operation to perform */
name|uint64_t
name|unused1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|unused2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|unused2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|unused1
range|:
literal|4
decl_stmt|;
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_cn68xx_clr
struct|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
comment|/**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
comment|/**< the operation to perform */
name|uint64_t
name|unused1
range|:
literal|12
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< contains index of entry for a CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|unused2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|unused2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|unused1
range|:
literal|12
decl_stmt|;
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_cn68xx_add
struct|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
comment|/**< don't reschedule this entry. no_sched is used for CVMX_POW_TAG_OP_SWTAG_DESCH and CVMX_POW_TAG_OP_DESCH */
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
comment|/**< the operation to perform */
name|uint64_t
name|unused1
range|:
literal|16
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< the group that the work queue entry will be scheduled to grp is used for CVMX_POW_TAG_OP_ADDWQ, CVMX_POW_TAG_OP_SWTAG_FULL, CVMX_POW_TAG_OP_SWTAG_DESCH, and CVMX_POW_TAG_OP_UPDATE_WQP_GRP */
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< the type of the tag. type is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< the actual tag. tag is used for everything except CVMX_POW_TAG_OP_DESCH, CVMX_POW_TAG_OP_UPDATE_WQP_GRP, and CVMX_POW_TAG_OP_*_NSCHED */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|cvmx_pow_tag_type_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|unused3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|unused1
range|:
literal|16
decl_stmt|;
name|cvmx_pow_tag_op_t
name|op
range|:
literal|4
decl_stmt|;
name|uint64_t
name|no_sched
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_cn68xx_other
struct|;
block|}
name|cvmx_pow_tag_req_t
typedef|;
typedef|typedef
struct|struct
block|{
name|uint32_t
name|tag
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|;
name|uint8_t
name|tag_type
decl_stmt|;
block|}
name|cvmx_pow_tag_info_t
typedef|;
comment|/**  * This structure describes the address to load stuff from POW  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
comment|/**      * Address for new work request loads (did<2:0> == 0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 0 in this case */
name|uint64_t
name|reserved_4_39
range|:
literal|36
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
comment|/**< If set, don't return load response until work is available */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_39
range|:
literal|36
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|swork
struct|;
comment|/**      * Address for loads to get POW internal status      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 1 in this case */
name|uint64_t
name|reserved_10_39
range|:
literal|30
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|coreid
range|:
literal|4
decl_stmt|;
comment|/**< The core id to get status for */
name|uint64_t
name|get_rev
range|:
literal|1
decl_stmt|;
comment|/**< If set and get_cur is set, return reverse tag-list pointer rather than forward tag-list pointer */
name|uint64_t
name|get_cur
range|:
literal|1
decl_stmt|;
comment|/**< If set, return current status rather than pending status */
name|uint64_t
name|get_wqp
range|:
literal|1
decl_stmt|;
comment|/**< If set, get the work-queue pointer rather than tag/type */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|get_wqp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|get_cur
range|:
literal|1
decl_stmt|;
name|uint64_t
name|get_rev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coreid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_10_39
range|:
literal|30
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|sstatus
struct|;
comment|/**      * Address for loads to get 68XX SS0 internal status      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 1 in this case */
name|uint64_t
name|reserved_14_39
range|:
literal|26
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|coreid
range|:
literal|5
decl_stmt|;
comment|/**< The core id to get status for */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
comment|/**< Status operation */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|coreid
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_14_39
range|:
literal|26
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|sstatus_cn68xx
struct|;
comment|/**      * Address for memory loads to get POW internal state      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 2 in this case */
name|uint64_t
name|reserved_16_39
range|:
literal|24
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< POW memory index */
name|uint64_t
name|get_des
range|:
literal|1
decl_stmt|;
comment|/**< If set, return deschedule information rather than the standard                                                 response for work-queue index (invalid if the work-queue entry is not on the                                                 deschedule list). */
name|uint64_t
name|get_wqp
range|:
literal|1
decl_stmt|;
comment|/**< If set, get the work-queue pointer rather than tag/type (no effect when get_des set). */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|get_wqp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|get_des
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_16_39
range|:
literal|24
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|smemload
struct|;
comment|/**      * Address for memory loads to get SSO internal state      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of SSO - did<2:0> == 2 in this case */
name|uint64_t
name|reserved_20_39
range|:
literal|20
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< SSO memory index */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
comment|/**< Read TAG/WQ pointer/pending tag/next potr */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_5
range|:
literal|3
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_20_39
range|:
literal|20
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|smemload_cn68xx
struct|;
comment|/**      * Address for index/pointer loads      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 3 in this case */
name|uint64_t
name|reserved_9_39
range|:
literal|31
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|qosgrp
range|:
literal|4
decl_stmt|;
comment|/**< when {get_rmt ==0 AND get_des_get_tail == 0}, this field selects one of                                                 eight POW internal-input queues (0-7), one per QOS level; values 8-15 are                                                 illegal in this case;                                                 when {get_rmt ==0 AND get_des_get_tail == 1}, this field selects one of                                                 16 deschedule lists (per group);                                                 when get_rmt ==1, this field selects one of 16 memory-input queue lists.                                                 The two memory-input queue lists associated with each QOS level are:                                                 - qosgrp = 0, qosgrp = 8:      QOS0                                                 - qosgrp = 1, qosgrp = 9:      QOS1                                                 - qosgrp = 2, qosgrp = 10:     QOS2                                                 - qosgrp = 3, qosgrp = 11:     QOS3                                                 - qosgrp = 4, qosgrp = 12:     QOS4                                                 - qosgrp = 5, qosgrp = 13:     QOS5                                                 - qosgrp = 6, qosgrp = 14:     QOS6                                                 - qosgrp = 7, qosgrp = 15:     QOS7 */
name|uint64_t
name|get_des_get_tail
range|:
literal|1
decl_stmt|;
comment|/**< If set and get_rmt is clear, return deschedule list indexes                                                 rather than indexes for the specified qos level; if set and get_rmt is set, return                                                 the tail pointer rather than the head pointer for the specified qos level. */
name|uint64_t
name|get_rmt
range|:
literal|1
decl_stmt|;
comment|/**< If set, return remote pointers rather than the local indexes for the specified qos level. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|get_rmt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|get_des_get_tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qosgrp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_9_39
range|:
literal|31
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload
struct|;
comment|/**      * Address for a Index/Pointer loads to get SSO internal state      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of SSO - did<2:0> == 2 in this case */
name|uint64_t
name|reserved_15_39
range|:
literal|25
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|qos_grp
range|:
literal|6
decl_stmt|;
comment|/**< When opcode = IPL_IQ, this field specifies IQ (or QOS).                                                  When opcode = IPL_DESCHED, this field specifies the group.                                                  This field is reserved for all other opcodes. */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
comment|/**< Read TAG/WQ pointer/pending tag/next potr */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|opcode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_5
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_15_39
range|:
literal|25
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload_cn68xx
struct|;
comment|/**      * address for NULL_RD request (did<2:0> == 4)      * when this is read, HW attempts to change the state to NULL if it is NULL_NULL      * (the hardware cannot switch from NULL_NULL to NULL if a POW entry is not available -      * software may need to recover by finishing another piece of work before a POW      * entry can ever become available.)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
comment|/**< Mips64 address region. Should be CVMX_IO_SEG */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of POW -- did<2:0> == 4 in this case */
name|uint64_t
name|reserved_0_39
range|:
literal|40
decl_stmt|;
comment|/**< Must be zero */
else|#
directive|else
name|uint64_t
name|reserved_0_39
range|:
literal|40
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_region
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|snull_rd
struct|;
block|}
name|cvmx_pow_load_addr_t
typedef|;
comment|/**  * This structure defines the response to a load/SENDSINGLE to POW (except CSR reads)  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
comment|/**      * Response to new work request loads      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|no_work
range|:
literal|1
decl_stmt|;
comment|/**< Set when no new work queue entry was returned.                                                 If there was de-scheduled work, the HW will definitely                                                 return it. When this bit is set, it could mean                                                 either mean:                                                 - There was no work, or                                                 - There was no work that the HW could find. This                                                     case can happen, regardless of the wait bit value                                                     in the original request, when there is work                                                     in the IQ's that is too deep down the list. */
name|uint64_t
name|reserved_40_62
range|:
literal|23
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|addr
range|:
literal|40
decl_stmt|;
comment|/**< 36 in O1 -- the work queue pointer */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|reserved_40_62
range|:
literal|23
decl_stmt|;
name|uint64_t
name|no_work
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_work
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==0 and get_wqp==0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending non-NULL SWTAG or                                                 SWTAG_FULL, and the POW entry has not left the list for the original tag. */
name|uint64_t
name|pend_switch_full
range|:
literal|1
decl_stmt|;
comment|/**< Set when SWTAG_FULL and pend_switch is set. */
name|uint64_t
name|pend_switch_null
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
name|uint64_t
name|pend_desched_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
comment|/**< Set when nosched is desired and pend_desched is set. */
name|uint64_t
name|pend_new_work
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending GET_WORK. */
name|uint64_t
name|pend_new_work_wait
range|:
literal|1
decl_stmt|;
comment|/**< When pend_new_work is set, this bit indicates that the wait bit was set. */
name|uint64_t
name|pend_null_rd
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending NULL_RD. */
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending CLR_NSCHED. */
name|uint64_t
name|reserved_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
comment|/**< This is the index when pend_nosched_clr is set. */
name|uint64_t
name|pend_grp
range|:
literal|4
decl_stmt|;
comment|/**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
comment|/**< This is the tag type when pend_switch or (pend_desched AND pend_desched_switch) are set. */
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
comment|/**< - this is the tag when pend_switch or (pend_desched AND pend_desched_switch) are set. */
else|#
directive|else
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_null_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_new_work_wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_new_work
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch_null
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus0
struct|;
comment|/**      * Result for a SSO Status Load (when opcode is SL_PENDTAG)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending non-UNSCHEDULED SWTAG or                                                 SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
name|uint64_t
name|pend_get_work
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending GET_WORK */
name|uint64_t
name|pend_get_work_wait
range|:
literal|1
decl_stmt|;
comment|/**< when pend_get_work is set, this biit indicates that the                                                   wait bit was set. */
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
comment|/**< Set when nosched is desired and pend_desched is set. */
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending CLR_NSCHED. */
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
name|uint64_t
name|pend_alloc_we
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending ALLOC_WE. */
name|uint64_t
name|reserved_48_56
range|:
literal|9
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
comment|/**< This is the index when pend_nosched_clr is set. */
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
comment|/**< This is the tag type when pend_switch is set. */
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
comment|/**< This is the tag when pend_switch is set. */
else|#
directive|else
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_48_56
range|:
literal|9
decl_stmt|;
name|uint64_t
name|pend_alloc_we
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_get_work_wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_get_work
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus0_cn68xx
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==0 and get_wqp==1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending non-NULL SWTAG or                                                 SWTAG_FULL, and the POW entry has not left the list for the original tag. */
name|uint64_t
name|pend_switch_full
range|:
literal|1
decl_stmt|;
comment|/**< Set when SWTAG_FULL and pend_switch is set. */
name|uint64_t
name|pend_switch_null
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending NULL SWTAG, or an implicit switch to NULL. */
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
name|uint64_t
name|pend_desched_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending SWTAG_DESCHED and pend_desched is set. */
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
comment|/**< Set when nosched is desired and pend_desched is set. */
name|uint64_t
name|pend_new_work
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending GET_WORK. */
name|uint64_t
name|pend_new_work_wait
range|:
literal|1
decl_stmt|;
comment|/**< When pend_new_work is set, this bit indicates that the wait bit was set. */
name|uint64_t
name|pend_null_rd
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending NULL_RD. */
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending CLR_NSCHED. */
name|uint64_t
name|reserved_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
comment|/**< This is the index when pend_nosched_clr is set. */
name|uint64_t
name|pend_grp
range|:
literal|4
decl_stmt|;
comment|/**< This is the new_grp when (pend_desched AND pend_desched_switch) is set. */
name|uint64_t
name|pend_wqp
range|:
literal|36
decl_stmt|;
comment|/**< This is the wqp when pend_nosched_clr is set. */
else|#
directive|else
name|uint64_t
name|pend_wqp
range|:
literal|36
decl_stmt|;
name|uint64_t
name|pend_grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_null_rd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_new_work_wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_new_work
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch_null
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus1
struct|;
comment|/**      * Result for a SSO Status Load (when opcode is SL_PENDWQP)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending non-UNSCHEDULED SWTAG or                                                 SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
name|uint64_t
name|pend_get_work
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending GET_WORK */
name|uint64_t
name|pend_get_work_wait
range|:
literal|1
decl_stmt|;
comment|/**< when pend_get_work is set, this biit indicates that the                                                   wait bit was set. */
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
comment|/**< Set when nosched is desired and pend_desched is set. */
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending CLR_NSCHED. */
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending DESCHED or SWTAG_DESCHED. */
name|uint64_t
name|pend_alloc_we
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending ALLOC_WE. */
name|uint64_t
name|reserved_51_56
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
comment|/**< This is the index when pend_nosched_clr is set. */
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_wqp
range|:
literal|38
decl_stmt|;
comment|/**< This is the wqp when pend_nosched_clr is set. */
else|#
directive|else
name|uint64_t
name|pend_wqp
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51_56
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pend_alloc_we
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_desched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_get_work_wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_get_work
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus1_cn68xx
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the next POW entry in the tag list when tail == 0 (and                                                 tag_type is not NULL or NULL_NULL). */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The POW entry attached to the core. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
comment|/**< Set when this POW entry is at the head of its tag list (also set when in                                                 the NULL or NULL_NULL state). */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this POW entry is at the tail of its tag list (also set when in the                                                 NULL or NULL_NULL state). */
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< The tag type attached to the core (updated when new tag list                                                 entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< The tag attached to the core (updated when new tag list entered on                                                 SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus2
struct|;
comment|/**      * Result for a SSO Status Load (when opcode is SL_TAG)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The SSO entry attached to the core. */
name|uint64_t
name|reserved_45
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on                                                  SWTAG_FULL). */
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
comment|/**< Set when this SSO entry is at the head of its tag list (also set when in the                                                  UNSCHEDULED or EMPTY state). */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this SSO entry is at the tail of its tag list (also set when in the                                                  UNSCHEDULED or EMPTY state). */
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< The tag type attached to the core (updated when new tag list entered                                                  on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< The tag attached to the core (updated when new tag list entered on SWTAG,                                                  SWTAG_FULL, or SWTAG_DESCHED). */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_45
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus2_cn68xx
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==1, get_wqp==0, and get_rev==1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the prior POW entry in the tag list when head == 0                                                 (and tag_type is not NULL or NULL_NULL). This field is unpredictable                                                 when the core's state is NULL or NULL_NULL. */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The POW entry attached to the core. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
comment|/**< Set when this POW entry is at the head of its tag list (also set when in                                                 the NULL or NULL_NULL state). */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this POW entry is at the tail of its tag list (also set when in the                                                 NULL or NULL_NULL state). */
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< The tag type attached to the core (updated when new tag list                                                 entered on SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< The tag attached to the core (updated when new tag list entered on                                                 SWTAG, SWTAG_FULL, or SWTAG_DESCHED). */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus3
struct|;
comment|/**      * Result for a SSO Status Load (when opcode is SL_WQP)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The SSO entry attached to the core. */
name|uint64_t
name|reserved_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on                                                  SWTAG_FULL). */
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wqp
range|:
literal|38
decl_stmt|;
comment|/**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
else|#
directive|else
name|uint64_t
name|wqp
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus3_cn68xx
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the next POW entry in the tag list when tail == 0 (and                                                 tag_type is not NULL or NULL_NULL). */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The POW entry attached to the core. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
comment|/**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
else|#
directive|else
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus4
struct|;
comment|/**      * Result for a SSO Status Load (when opcode is SL_LINKS)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The SSO entry attached to the core. */
name|uint64_t
name|reserved_34
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on                                                  SWTAG_FULL). */
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
comment|/**< Set when this SSO entry is at the head of its tag list (also set when in the                                                  UNSCHEDULED or EMPTY state). */
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this SSO entry is at the tail of its tag list (also set when in the                                                  UNSCHEDULED or EMPTY state). */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the prior SSO entry in the tag list when head==0 (and tag_type is not UNSCHEDULED or EMPTY). */
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the next SSO entry in the tag list when tail==0 (and tag_type is not UNSCHEDULDED or EMPTY). */
else|#
directive|else
name|uint64_t
name|link_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_34
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus4_cn68xx
struct|;
comment|/**      * Result for a POW Status Load (when get_cur==1, get_wqp==1, and get_rev==1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
comment|/**< Points to the prior POW entry in the tag list when head == 0                                                 (and tag_type is not NULL or NULL_NULL). This field is unpredictable                                                 when the core's state is NULL or NULL_NULL. */
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
comment|/**< The POW entry attached to the core. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group attached to the core (updated when new tag list entered on SWTAG_FULL). */
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
comment|/**< The wqp attached to the core (updated when new tag list entered on SWTAG_FULL). */
else|#
directive|else
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|revlink_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s_sstatus5
struct|;
comment|/**      * Result For POW Memory Load (get_des == 0 and get_wqp == 0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
comment|/**< The next entry in the input, free, descheduled_head list                                                 (unpredictable if entry is the tail of the list). */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group of the POW entry. */
name|uint64_t
name|reserved_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this POW entry is at the tail of its tag list (also set when in the                                                 NULL or NULL_NULL state). */
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< The tag type of the POW entry. */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< The tag of the POW entry. */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload0
struct|;
comment|/**      * Result For SSO Memory Load (opcode is ML_TAG)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
comment|/**< Set when this SSO entry is at the tail of its tag list (also set when in the                                                 NULL or NULL_NULL state). */
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
comment|/**< The tag type of the SSO entry. */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< The tag of the SSO entry. */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload0_cn68xx
struct|;
comment|/**      * Result For POW Memory Load (get_des == 0 and get_wqp == 1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
comment|/**< The next entry in the input, free, descheduled_head list                                                 (unpredictable if entry is the tail of the list). */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group of the POW entry. */
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
comment|/**< The WQP held in the POW entry. */
else|#
directive|else
name|uint64_t
name|wqp
range|:
literal|36
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload1
struct|;
comment|/**      * Result For SSO Memory Load (opcode is ML_WQPGRP)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|nosched
range|:
literal|1
decl_stmt|;
comment|/**< The nosched bit for the SSO entry. */
name|uint64_t
name|reserved_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
comment|/**< The group of the SSO entry. */
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wqp
range|:
literal|38
decl_stmt|;
comment|/**< The WQP held in the SSO entry. */
else|#
directive|else
name|uint64_t
name|wqp
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_46
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload1_cn68xx
struct|;
comment|/**      * Result For POW Memory Load (get_des == 1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|fwd_index
range|:
literal|11
decl_stmt|;
comment|/**< The next entry in the tag list connected to the descheduled head. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The group of the POW entry. */
name|uint64_t
name|nosched
range|:
literal|1
decl_stmt|;
comment|/**< The nosched bit for the POW entry. */
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< There is a pending tag switch */
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
comment|/**< The next tag type for the new tag list when pend_switch is set. */
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
comment|/**< The next tag for the new tag list when pend_switch is set. */
else|#
directive|else
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fwd_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload2
struct|;
comment|/**      * Result For SSO Memory Load (opcode is ML_PENTAG)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
comment|/**< Set when there is a pending non-UNSCHEDULED SWTAG or                                                  SWTAG_FULL, and the SSO entry has not left the list for the original tag. */
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
comment|/**< The next tag type for the new tag list when pend_switch is set. */
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
comment|/**< The next tag for the new tag list when pend_switch is set. */
else|#
directive|else
name|uint64_t
name|pend_tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pend_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend_switch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload2_cn68xx
struct|;
comment|/**      * Result For SSO Memory Load (opcode is ML_LINKS)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|fwd_index
range|:
literal|11
decl_stmt|;
comment|/**< The next entry in the tag list connected to the descheduled head. */
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
comment|/**< The next entry in the input, free, descheduled_head list                                                  (unpredicatble if entry is the tail of the list). */
else|#
directive|else
name|uint64_t
name|next_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fwd_index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s_smemload3_cn68xx
struct|;
comment|/**      * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|free_val
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is one or more POW entries on the free list. */
name|uint64_t
name|free_one
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is exactly one POW entry on the free list. */
name|uint64_t
name|reserved_49
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_head
range|:
literal|11
decl_stmt|;
comment|/**< - when free_val is set, indicates the first entry on the free list. */
name|uint64_t
name|reserved_37
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_tail
range|:
literal|11
decl_stmt|;
comment|/**< - when free_val is set, indicates the last entry on the free list. */
name|uint64_t
name|loc_val
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is one or more POW entries on the input Q list selected by qosgrp. */
name|uint64_t
name|loc_one
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is exactly one POW entry on the input Q list selected by qosgrp. */
name|uint64_t
name|reserved_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_head
range|:
literal|11
decl_stmt|;
comment|/**< - when loc_val is set, indicates the first entry on the input Q list selected by qosgrp. */
name|uint64_t
name|reserved_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_tail
range|:
literal|11
decl_stmt|;
comment|/**< - when loc_val is set, indicates the last entry on the input Q list selected by qosgrp. */
else|#
directive|else
name|uint64_t
name|loc_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_37
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_49
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|free_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload0
struct|;
comment|/**      * Result for SSO Index/Pointer Load(opcode == IPL_IQ/IPL_DESCHED/IPL_NOSCHED)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|queue_val
range|:
literal|1
decl_stmt|;
comment|/**< - If set, one or more valid entries are in the queue. */
name|uint64_t
name|queue_one
range|:
literal|1
decl_stmt|;
comment|/**< - If set, exactly one valid entry is in the queue. */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_head
range|:
literal|11
decl_stmt|;
comment|/**< - Index of entry at the head of the queue. */
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_tail
range|:
literal|11
decl_stmt|;
comment|/**< - Index of entry at the tail of the queue. */
else|#
directive|else
name|uint64_t
name|queue_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|queue_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload0_cn68xx
struct|;
comment|/**      * Result For POW Index/Pointer Load (get_rmt == 0/get_des_get_tail == 1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|nosched_val
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is one or more POW entries on the nosched list. */
name|uint64_t
name|nosched_one
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is exactly one POW entry on the nosched list. */
name|uint64_t
name|reserved_49
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_head
range|:
literal|11
decl_stmt|;
comment|/**< - when nosched_val is set, indicates the first entry on the nosched list. */
name|uint64_t
name|reserved_37
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_tail
range|:
literal|11
decl_stmt|;
comment|/**< - when nosched_val is set, indicates the last entry on the nosched list. */
name|uint64_t
name|des_val
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is one or more descheduled heads on the descheduled list selected by qosgrp. */
name|uint64_t
name|des_one
range|:
literal|1
decl_stmt|;
comment|/**< - set when there is exactly one descheduled head on the descheduled list selected by qosgrp. */
name|uint64_t
name|reserved_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_head
range|:
literal|11
decl_stmt|;
comment|/**< - when des_val is set, indicates the first descheduled head on the descheduled list selected by qosgrp. */
name|uint64_t
name|reserved_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_tail
range|:
literal|11
decl_stmt|;
comment|/**< - when des_val is set, indicates the last descheduled head on the descheduled list selected by qosgrp. */
else|#
directive|else
name|uint64_t
name|des_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|des_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_37
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_49
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nosched_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload1
struct|;
comment|/**      * Result for SSO Index/Pointer Load(opcode == IPL_FREE0/IPL_FREE1/IPL_FREE2)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qnum_head
range|:
literal|2
decl_stmt|;
comment|/**< - Subqueue with current head */
name|uint64_t
name|qnum_tail
range|:
literal|2
decl_stmt|;
comment|/**< - Subqueue with current tail */
name|uint64_t
name|reserved_28_55
range|:
literal|28
decl_stmt|;
name|uint64_t
name|queue_val
range|:
literal|1
decl_stmt|;
comment|/**< - If set, one or more valid entries are in the queue. */
name|uint64_t
name|queue_one
range|:
literal|1
decl_stmt|;
comment|/**< - If set, exactly one valid entry is in the queue. */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_head
range|:
literal|11
decl_stmt|;
comment|/**< - Index of entry at the head of the queue. */
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_tail
range|:
literal|11
decl_stmt|;
comment|/**< - Index of entry at the tail of the queue. */
else|#
directive|else
name|uint64_t
name|queue_tail
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_12
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_head
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|queue_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|queue_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_55
range|:
literal|28
decl_stmt|;
name|uint64_t
name|qnum_tail
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qnum_head
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload1_cn68xx
struct|;
comment|/**      * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 0)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|rmt_is_head
range|:
literal|1
decl_stmt|;
comment|/**< Set when this DRAM list is the current head (i.e. is the next to                                                 be reloaded when the POW hardware reloads a POW entry from DRAM). The                                                 POW hardware alternates between the two DRAM lists associated with a QOS                                                 level when it reloads work from DRAM into the POW unit. */
name|uint64_t
name|rmt_val
range|:
literal|1
decl_stmt|;
comment|/**< Set when the DRAM portion of the input Q list selected by qosgrp                                                 contains one or more pieces of work. */
name|uint64_t
name|rmt_one
range|:
literal|1
decl_stmt|;
comment|/**< Set when the DRAM portion of the input Q list selected by qosgrp                                                 contains exactly one piece of work. */
name|uint64_t
name|rmt_head
range|:
literal|36
decl_stmt|;
comment|/**< When rmt_val is set, indicates the first piece of work on the                                                 DRAM input Q list selected by qosgrp. */
else|#
directive|else
name|uint64_t
name|rmt_head
range|:
literal|36
decl_stmt|;
name|uint64_t
name|rmt_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmt_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmt_is_head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload2
struct|;
comment|/**      * Result For POW Index/Pointer Load (get_rmt == 1/get_des_get_tail == 1)      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|rmt_is_head
range|:
literal|1
decl_stmt|;
comment|/**< - set when this DRAM list is the current head (i.e. is the next to                                                 be reloaded when the POW hardware reloads a POW entry from DRAM). The                                                 POW hardware alternates between the two DRAM lists associated with a QOS                                                 level when it reloads work from DRAM into the POW unit. */
name|uint64_t
name|rmt_val
range|:
literal|1
decl_stmt|;
comment|/**< - set when the DRAM portion of the input Q list selected by qosgrp                                                 contains one or more pieces of work. */
name|uint64_t
name|rmt_one
range|:
literal|1
decl_stmt|;
comment|/**< - set when the DRAM portion of the input Q list selected by qosgrp                                                 contains exactly one piece of work. */
name|uint64_t
name|rmt_tail
range|:
literal|36
decl_stmt|;
comment|/**< - when rmt_val is set, indicates the last piece of work on the DRAM                                                 input Q list selected by qosgrp. */
else|#
directive|else
name|uint64_t
name|rmt_tail
range|:
literal|36
decl_stmt|;
name|uint64_t
name|rmt_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmt_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rmt_is_head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|sindexload3
struct|;
comment|/**      * Response to NULL_RD request loads      */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|unused
range|:
literal|62
decl_stmt|;
name|uint64_t
name|state
range|:
literal|2
decl_stmt|;
comment|/**< of type cvmx_pow_tag_type_t. state is one of the following:                                         - CVMX_POW_TAG_TYPE_ORDERED                                         - CVMX_POW_TAG_TYPE_ATOMIC                                         - CVMX_POW_TAG_TYPE_NULL                                         - CVMX_POW_TAG_TYPE_NULL_NULL */
else|#
directive|else
name|uint64_t
name|state
range|:
literal|2
decl_stmt|;
name|uint64_t
name|unused
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s_null_rd
struct|;
block|}
name|cvmx_pow_tag_load_resp_t
typedef|;
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_45
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_34_36
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|head
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_45
range|:
literal|1
decl_stmt|;
name|uint64_t
name|index
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
block|}
name|cvmx_pow_sl_tag_resp_t
typedef|;
comment|/**  * This structure describes the address used for stores to the POW.  *  The store address is meaningful on stores to the POW.  The hardware assumes that an aligned  *  64-bit store was used for all these stores.  *  Note the assumption that the work queue entry is aligned on an 8-byte  *  boundary (since the low-order 3 address bits must be zero).  *  Note that not all fields are used by all operations.  *  *  NOTE: The following is the behavior of the pending switch bit at the PP  *       for POW stores (i.e. when did<7:3> == 0xc)  *     - did<2:0> == 0      => pending switch bit is set  *     - did<2:0> == 1      => no affect on the pending switch bit  *     - did<2:0> == 3      => pending switch bit is cleared  *     - did<2:0> == 7      => no affect on the pending switch bit  *     - did<2:0> == others => must not be used  *     - No other loads/stores have an affect on the pending switch bit  *     - The switch bus from POW can clear the pending switch bit  *  *  NOTE: did<2:0> == 2 is used by the HW for a special single-cycle ADDWQ command  *  that only contains the pointer). SW must never use did<2:0> == 2.  */
typedef|typedef
union|union
block|{
comment|/**      * Unsigned 64 bit integer representation of store address      */
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mem_reg
range|:
literal|2
decl_stmt|;
comment|/**< Memory region.  Should be CVMX_IO_SEG in most cases */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
comment|/**< Must be one */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< Device ID of POW.  Note that different sub-dids are used. */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
comment|/**< Must be zero */
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< Address field. addr<2:0> must be zero */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|is_io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|mem_reg
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|stag
struct|;
block|}
name|cvmx_pow_tag_store_addr_t
typedef|;
comment|/**  * decode of the store data when an IOBDMA SENDSINGLE is sent to POW  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|scraddr
range|:
literal|8
decl_stmt|;
comment|/**< the (64-bit word) location in scratchpad to write to (if len != 0) */
name|uint64_t
name|len
range|:
literal|8
decl_stmt|;
comment|/**< the number of words in the response (0 => no response) */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of the device on the non-coherent bus */
name|uint64_t
name|unused
range|:
literal|36
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
comment|/**< if set, don't return load response until work is available */
name|uint64_t
name|unused2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|unused2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|1
decl_stmt|;
name|uint64_t
name|unused
range|:
literal|36
decl_stmt|;
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
name|uint64_t
name|len
range|:
literal|8
decl_stmt|;
name|uint64_t
name|scraddr
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
block|}
name|cvmx_pow_iobdma_store_t
typedef|;
comment|/* CSR typedefs have been moved to cvmx-pow-defs.h */
comment|/**  * Get the POW tag for this core. This returns the current  * tag type, tag, group, and POW entry index associated with  * this core. Index is only valid if the tag type isn't NULL_NULL.  * If a tag switch is pending this routine returns the tag before  * the tag switch, not after.  *  * @return Current tag  */
specifier|static
specifier|inline
name|cvmx_pow_tag_info_t
name|cvmx_pow_get_current_tag
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_pow_load_addr_t
name|load_addr
decl_stmt|;
name|cvmx_pow_tag_info_t
name|result
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|cvmx_pow_sl_tag_resp_t
name|load_resp
decl_stmt|;
name|load_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG5
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|coreid
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|opcode
operator|=
literal|3
expr_stmt|;
name|load_resp
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|load_addr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|result
operator|.
name|grp
operator|=
name|load_resp
operator|.
name|s
operator|.
name|grp
expr_stmt|;
name|result
operator|.
name|index
operator|=
name|load_resp
operator|.
name|s
operator|.
name|index
expr_stmt|;
name|result
operator|.
name|tag_type
operator|=
name|load_resp
operator|.
name|s
operator|.
name|tag_type
expr_stmt|;
name|result
operator|.
name|tag
operator|=
name|load_resp
operator|.
name|s
operator|.
name|tag
expr_stmt|;
block|}
else|else
block|{
name|cvmx_pow_tag_load_resp_t
name|load_resp
decl_stmt|;
name|load_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG1
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|coreid
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|get_cur
operator|=
literal|1
expr_stmt|;
name|load_resp
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|load_addr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|result
operator|.
name|grp
operator|=
name|load_resp
operator|.
name|s_sstatus2
operator|.
name|grp
expr_stmt|;
name|result
operator|.
name|index
operator|=
name|load_resp
operator|.
name|s_sstatus2
operator|.
name|index
expr_stmt|;
name|result
operator|.
name|tag_type
operator|=
name|load_resp
operator|.
name|s_sstatus2
operator|.
name|tag_type
expr_stmt|;
name|result
operator|.
name|tag
operator|=
name|load_resp
operator|.
name|s_sstatus2
operator|.
name|tag
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**  * Get the POW WQE for this core. This returns the work queue  * entry currently associated with this core.  *  * @return WQE pointer  */
specifier|static
specifier|inline
name|cvmx_wqe_t
modifier|*
name|cvmx_pow_get_current_wqp
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_pow_load_addr_t
name|load_addr
decl_stmt|;
name|cvmx_pow_tag_load_resp_t
name|load_resp
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|load_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG5
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|coreid
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|load_addr
operator|.
name|sstatus_cn68xx
operator|.
name|opcode
operator|=
literal|3
expr_stmt|;
name|load_resp
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|load_addr
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_resp
operator|.
name|s_sstatus3_cn68xx
operator|.
name|wqp
condition|)
return|return
operator|(
name|cvmx_wqe_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|load_resp
operator|.
name|s_sstatus3_cn68xx
operator|.
name|wqp
argument_list|)
return|;
else|else
return|return
operator|(
name|cvmx_wqe_t
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|load_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG1
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|coreid
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|get_cur
operator|=
literal|1
expr_stmt|;
name|load_addr
operator|.
name|sstatus
operator|.
name|get_wqp
operator|=
literal|1
expr_stmt|;
name|load_resp
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|load_addr
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
operator|(
name|cvmx_wqe_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|load_resp
operator|.
name|s_sstatus4
operator|.
name|wqp
argument_list|)
return|;
block|}
block|}
comment|/**  * @INTERNAL  * Print a warning if a tag switch is pending for this core  *  * @param function Function name checking for a pending tag switch  */
specifier|static
specifier|inline
name|void
name|__cvmx_pow_warn_if_pending_switch
parameter_list|(
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|uint64_t
name|switch_complete
decl_stmt|;
name|CVMX_MF_CHORD
argument_list|(
name|switch_complete
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
operator|!
name|switch_complete
argument_list|,
literal|"%s called with tag switch in progress\n"
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
comment|/**  * Waits for a tag switch to complete by polling the completion bit.  * Note that switches to NULL complete immediately and do not need  * to be waited for.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_wait
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|uint64_t
name|MAX_CYCLES
init|=
literal|1ull
operator|<<
literal|31
decl_stmt|;
name|uint64_t
name|switch_complete
decl_stmt|;
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|CVMX_MF_CHORD
argument_list|(
name|switch_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|switch_complete
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|start_cycle
operator|+
name|MAX_CYCLES
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Tag switch is taking a long time, possible deadlock\n"
argument_list|)
expr_stmt|;
name|start_cycle
operator|=
operator|-
name|MAX_CYCLES
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/**  * Synchronous work request.  Requests work from the POW.  * This function does NOT wait for previous tag switches to complete,  * so the caller must ensure that there is not a pending tag switch.  *  * @param wait   When set, call stalls until work becomes avaiable, or times out.  *               If not set, returns immediately.  *  * @return Returns the WQE pointer from POW. Returns NULL if no work was available.  */
specifier|static
specifier|inline
name|cvmx_wqe_t
modifier|*
name|cvmx_pow_work_request_sync_nocheck
parameter_list|(
name|cvmx_pow_wait_t
name|wait
parameter_list|)
block|{
name|cvmx_pow_load_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_load_resp_t
name|result
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|swork
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|swork
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|swork
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_SWTAG
expr_stmt|;
name|ptr
operator|.
name|swork
operator|.
name|wait
operator|=
name|wait
expr_stmt|;
name|result
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|ptr
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|s_work
operator|.
name|no_work
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|cvmx_wqe_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|result
operator|.
name|s_work
operator|.
name|addr
argument_list|)
return|;
block|}
comment|/**  * Synchronous work request.  Requests work from the POW.  * This function waits for any previous tag switch to complete before  * requesting the new work.  *  * @param wait   When set, call stalls until work becomes avaiable, or times out.  *               If not set, returns immediately.  *  * @return Returns the WQE pointer from POW. Returns NULL if no work was available.  */
specifier|static
specifier|inline
name|cvmx_wqe_t
modifier|*
name|cvmx_pow_work_request_sync
parameter_list|(
name|cvmx_pow_wait_t
name|wait
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Must not have a switch pending when requesting work */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
return|return
operator|(
name|cvmx_pow_work_request_sync_nocheck
argument_list|(
name|wait
argument_list|)
operator|)
return|;
block|}
comment|/**  * Synchronous null_rd request.  Requests a switch out of NULL_NULL POW state.  * This function waits for any previous tag switch to complete before  * requesting the null_rd.  *  * @return Returns the POW state of type cvmx_pow_tag_type_t.  */
specifier|static
specifier|inline
name|cvmx_pow_tag_type_t
name|cvmx_pow_work_request_null_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_pow_load_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_load_resp_t
name|result
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Must not have a switch pending when requesting work */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|snull_rd
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|snull_rd
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|snull_rd
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_NULL_RD
expr_stmt|;
name|result
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|ptr
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
operator|(
name|cvmx_pow_tag_type_t
operator|)
name|result
operator|.
name|s_null_rd
operator|.
name|state
return|;
block|}
comment|/**  * Asynchronous work request.  Work is requested from the POW unit, and should later  * be checked with function cvmx_pow_work_response_async.  * This function does NOT wait for previous tag switches to complete,  * so the caller must ensure that there is not a pending tag switch.  *  * @param scr_addr Scratch memory address that response will be returned to,  *                  which is either a valid WQE, or a response with the invalid bit set.  *                  Byte address, must be 8 byte aligned.  * @param wait      1 to cause response to wait for work to become available (or timeout)  *                  0 to cause response to return immediately  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_work_request_async_nocheck
parameter_list|(
name|int
name|scr_addr
parameter_list|,
name|cvmx_pow_wait_t
name|wait
parameter_list|)
block|{
name|cvmx_pow_iobdma_store_t
name|data
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* scr_addr must be 8 byte aligned */
name|data
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|scraddr
operator|=
name|scr_addr
operator|>>
literal|3
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_SWTAG
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|wait
operator|=
name|wait
expr_stmt|;
name|cvmx_send_single
argument_list|(
name|data
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Asynchronous work request.  Work is requested from the POW unit, and should later  * be checked with function cvmx_pow_work_response_async.  * This function waits for any previous tag switch to complete before  * requesting the new work.  *  * @param scr_addr Scratch memory address that response will be returned to,  *                  which is either a valid WQE, or a response with the invalid bit set.  *                  Byte address, must be 8 byte aligned.  * @param wait      1 to cause response to wait for work to become available (or timeout)  *                  0 to cause response to return immediately  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_work_request_async
parameter_list|(
name|int
name|scr_addr
parameter_list|,
name|cvmx_pow_wait_t
name|wait
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Must not have a switch pending when requesting work */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|cvmx_pow_work_request_async_nocheck
argument_list|(
name|scr_addr
argument_list|,
name|wait
argument_list|)
expr_stmt|;
block|}
comment|/**  * Gets result of asynchronous work request.  Performs a IOBDMA sync  * to wait for the response.  *  * @param scr_addr Scratch memory address to get result from  *                  Byte address, must be 8 byte aligned.  * @return Returns the WQE from the scratch register, or NULL if no work was available.  */
specifier|static
specifier|inline
name|cvmx_wqe_t
modifier|*
name|cvmx_pow_work_response_async
parameter_list|(
name|int
name|scr_addr
parameter_list|)
block|{
name|cvmx_pow_tag_load_resp_t
name|result
decl_stmt|;
name|CVMX_SYNCIOBDMA
expr_stmt|;
name|result
operator|.
name|u64
operator|=
name|cvmx_scratch_read64
argument_list|(
name|scr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|s_work
operator|.
name|no_work
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|cvmx_wqe_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|result
operator|.
name|s_work
operator|.
name|addr
argument_list|)
return|;
block|}
comment|/**  * Checks if a work queue entry pointer returned by a work  * request is valid.  It may be invalid due to no work  * being available or due to a timeout.  *  * @param wqe_ptr pointer to a work queue entry returned by the POW  *  * @return 0 if pointer is valid  *         1 if invalid (no work was returned)  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_pow_work_invalid
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|wqe_ptr
parameter_list|)
block|{
return|return
operator|(
name|wqe_ptr
operator|==
name|NULL
operator|)
return|;
block|}
comment|/**  * Starts a tag switch to the provided tag value and tag type.  Completion for  * the tag switch must be checked for separately.  * This function does NOT update the  * work queue entry in dram to match tag value and type, so the application must  * keep track of these if they are important to the application.  * This tag switch command must not be used for switches to NULL, as the tag  * switch pending bit will be set by the switch request, but never cleared by the  * hardware.  *  * NOTE: This should not be used when switching from a NULL tag.  Use  * cvmx_pow_tag_sw_full() instead.  *  * This function does no checks, so the caller must ensure that any previous tag  * switch has completed.  *  * @param tag      new tag value  * @param tag_type new tag type (ordered or atomic)  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_nocheck
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
block|{
name|cvmx_pow_tag_info_t
name|current_tag
decl_stmt|;
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|current_tag
operator|=
name|cvmx_pow_get_current_tag
argument_list|()
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL_NULL
argument_list|,
literal|"%s called with NULL_NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called with NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
operator|(
name|current_tag
operator|.
name|tag_type
operator|==
name|tag_type
operator|)
operator|&&
operator|(
name|current_tag
operator|.
name|tag
operator|==
name|tag
operator|)
argument_list|,
literal|"%s called to perform a tag switch to the same tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called to perform a tag switch to NULL. Use cvmx_pow_tag_sw_null() instead\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM     ** once the WQE is in flight.  See hardware manual for complete details.     ** It is the application's responsibility to keep track of the current tag     ** value if that is important.     */
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
block|}
else|else
block|{
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_SWTAG
expr_stmt|;
comment|/* once this store arrives at POW, it will attempt the switch        software must wait for the switch to complete separately */
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Starts a tag switch to the provided tag value and tag type.  Completion for  * the tag switch must be checked for separately.  * This function does NOT update the  * work queue entry in dram to match tag value and type, so the application must  * keep track of these if they are important to the application.  * This tag switch command must not be used for switches to NULL, as the tag  * switch pending bit will be set by the switch request, but never cleared by the  * hardware.  *  * NOTE: This should not be used when switching from a NULL tag.  Use  * cvmx_pow_tag_sw_full() instead.  *  * This function waits for any previous tag switch to complete, and also  * displays an error on tag switches to NULL.  *  * @param tag      new tag value  * @param tag_type new tag type (ordered or atomic)  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM     ** once the WQE is in flight.  See hardware manual for complete details.     ** It is the application's responsibility to keep track of the current tag     ** value if that is important.     */
comment|/* Ensure that there is not a pending tag switch, as a tag switch cannot be started     ** if a previous switch is still pending.  */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|cvmx_pow_tag_sw_nocheck
argument_list|(
name|tag
argument_list|,
name|tag_type
argument_list|)
expr_stmt|;
block|}
comment|/**  * Starts a tag switch to the provided tag value and tag type.  Completion for  * the tag switch must be checked for separately.  * This function does NOT update the  * work queue entry in dram to match tag value and type, so the application must  * keep track of these if they are important to the application.  * This tag switch command must not be used for switches to NULL, as the tag  * switch pending bit will be set by the switch request, but never cleared by the  * hardware.  *  * This function must be used for tag switches from NULL.  *  * This function does no checks, so the caller must ensure that any previous tag  * switch has completed.  *  * @param wqp      pointer to work queue entry to submit.  This entry is updated to match the other parameters  * @param tag      tag value to be assigned to work queue entry  * @param tag_type type of tag  * @param group      group value for the work queue entry.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_full_nocheck
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|wqp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|,
name|uint64_t
name|group
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
block|{
name|cvmx_pow_tag_info_t
name|current_tag
decl_stmt|;
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|current_tag
operator|=
name|cvmx_pow_get_current_tag
argument_list|()
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL_NULL
argument_list|,
literal|"%s called with NULL_NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
operator|(
name|current_tag
operator|.
name|tag_type
operator|==
name|tag_type
operator|)
operator|&&
operator|(
name|current_tag
operator|.
name|tag
operator|==
name|tag
operator|)
argument_list|,
literal|"%s called to perform a tag switch to the same tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called to perform a tag switch to NULL. Use cvmx_pow_tag_sw_null() instead\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wqp
operator|!=
name|cvmx_phys_to_ptr
argument_list|(
literal|0x80
argument_list|)
operator|)
operator|&&
name|cvmx_pow_get_current_wqp
argument_list|()
condition|)
name|cvmx_warn_if
argument_list|(
name|wqp
operator|!=
name|cvmx_pow_get_current_wqp
argument_list|()
argument_list|,
literal|"%s passed WQE(%p) doesn't match the address in the POW(%p)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|wqp
argument_list|,
name|cvmx_pow_get_current_wqp
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Note that WQE in DRAM is not updated here, as the POW does not read from DRAM     ** once the WQE is in flight.  See hardware manual for complete details.     ** It is the application's responsibility to keep track of the current tag     ** value if that is important.     */
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG_FULL
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|grp
operator|=
name|group
expr_stmt|;
block|}
else|else
block|{
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG_FULL
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|grp
operator|=
name|group
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_SWTAG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|offset
operator|=
name|CAST64
argument_list|(
name|wqp
argument_list|)
expr_stmt|;
comment|/* once this store arrives at POW, it will attempt the switch        software must wait for the switch to complete separately */
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Starts a tag switch to the provided tag value and tag type.  Completion for  * the tag switch must be checked for separately.  * This function does NOT update the  * work queue entry in dram to match tag value and type, so the application must  * keep track of these if they are important to the application.  * This tag switch command must not be used for switches to NULL, as the tag  * switch pending bit will be set by the switch request, but never cleared by the  * hardware.  *  * This function must be used for tag switches from NULL.  *  * This function waits for any pending tag switches to complete  * before requesting the tag switch.  *  * @param wqp      pointer to work queue entry to submit.  This entry is updated to match the other parameters  * @param tag      tag value to be assigned to work queue entry  * @param tag_type type of tag  * @param group      group value for the work queue entry.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_full
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|wqp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|,
name|uint64_t
name|group
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Ensure that there is not a pending tag switch, as a tag switch cannot be started     ** if a previous switch is still pending.  */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|cvmx_pow_tag_sw_full_nocheck
argument_list|(
name|wqp
argument_list|,
name|tag
argument_list|,
name|tag_type
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
comment|/**  * Switch to a NULL tag, which ends any ordering or  * synchronization provided by the POW for the current  * work queue entry.  This operation completes immediately,  * so completion should not be waited for.  * This function does NOT wait for previous tag switches to complete,  * so the caller must ensure that any previous tag switches have completed.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_null_nocheck
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
block|{
name|cvmx_pow_tag_info_t
name|current_tag
decl_stmt|;
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|current_tag
operator|=
name|cvmx_pow_get_current_tag
argument_list|()
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL_NULL
argument_list|,
literal|"%s called with NULL_NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called when we already have a NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|type
operator|=
name|CVMX_POW_TAG_TYPE_NULL
expr_stmt|;
block|}
else|else
block|{
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|type
operator|=
name|CVMX_POW_TAG_TYPE_NULL
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG1
expr_stmt|;
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* switch to NULL completes immediately */
block|}
comment|/**  * Switch to a NULL tag, which ends any ordering or  * synchronization provided by the POW for the current  * work queue entry.  This operation completes immediatly,  * so completion should not be waited for.  * This function waits for any pending tag switches to complete  * before requesting the switch to NULL.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_null
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Ensure that there is not a pending tag switch, as a tag switch cannot be started     ** if a previous switch is still pending.  */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|cvmx_pow_tag_sw_null_nocheck
argument_list|()
expr_stmt|;
comment|/* switch to NULL completes immediately */
block|}
comment|/**  * Submits work to an input queue.  This function updates the work queue entry in DRAM to match  * the arguments given.  * Note that the tag provided is for the work queue entry submitted, and is unrelated to the tag that  * the core currently holds.  *  * @param wqp      pointer to work queue entry to submit.  This entry is updated to match the other parameters  * @param tag      tag value to be assigned to work queue entry  * @param tag_type type of tag  * @param qos      Input queue to add to.  * @param grp      group value for the work queue entry.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_work_submit
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|wqp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|,
name|uint64_t
name|qos
parameter_list|,
name|uint64_t
name|grp
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|s
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|s
operator|.
name|tag_type
operator|=
name|tag_type
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
comment|/* Reset all reserved bits */
name|wqp
operator|->
name|word1
operator|.
name|cn68xx
operator|.
name|zero_0
operator|=
literal|0
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn68xx
operator|.
name|zero_1
operator|=
literal|0
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn68xx
operator|.
name|zero_2
operator|=
literal|0
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn68xx
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn68xx
operator|.
name|grp
operator|=
name|grp
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_add
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_ADDWQ
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_add
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_add
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_add
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_add
operator|.
name|grp
operator|=
name|grp
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset all reserved bits */
name|wqp
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|zero_2
operator|=
literal|0
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|wqp
operator|->
name|word1
operator|.
name|cn38xx
operator|.
name|grp
operator|=
name|grp
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_ADDWQ
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|qos
operator|=
name|qos
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|grp
operator|=
name|grp
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|offset
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|wqp
argument_list|)
expr_stmt|;
comment|/* SYNC write to memory before the work submit.  This is necessary     ** as POW may read values from DRAM at this time */
name|CVMX_SYNCWS
expr_stmt|;
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * This function sets the group mask for a core.  The group mask  * indicates which groups each core will accept work from. There are  * 16 groups.  *  * @param core_num   core to apply mask to  * @param mask   Group mask. There are 16 groups, so only bits 0-15 are valid,  *               representing groups 0-15.  *               Each 1 bit in the mask enables the core to accept work from  *               the corresponding group.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_set_group_mask
parameter_list|(
name|uint64_t
name|core_num
parameter_list|,
name|uint64_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|cvmx_sso_ppx_grp_msk_t
name|grp_msk
decl_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|grp_msk
operator|=
name|mask
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SSO_PPX_GRP_MSK
argument_list|(
name|core_num
argument_list|)
argument_list|,
name|grp_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_pow_pp_grp_mskx_t
name|grp_msk
decl_stmt|;
name|grp_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|core_num
argument_list|)
argument_list|)
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|grp_msk
operator|=
name|mask
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|core_num
argument_list|)
argument_list|,
name|grp_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * This function sets POW static priorities for a core. Each input queue has  * an associated priority value.  *  * @param core_num   core to apply priorities to  * @param priority   Vector of 8 priorities, one per POW Input Queue (0-7).  *                   Highest priority is 0 and lowest is 7. A priority value  *                   of 0xF instructs POW to skip the Input Queue when  *                   scheduling to this specific core.  *                   NOTE: priorities should not have gaps in values, meaning  *                         {0,1,1,1,1,1,1,1} is a valid configuration while  *                         {0,2,2,2,2,2,2,2} is not.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_set_priority
parameter_list|(
name|uint64_t
name|core_num
parameter_list|,
specifier|const
name|uint8_t
name|priority
index|[]
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return;
comment|/* Detect gaps between priorities and flag error */
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|prio_mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|priority
index|[
name|i
index|]
operator|!=
literal|0xF
condition|)
name|prio_mask
operator||=
literal|1
operator|<<
name|priority
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|prio_mask
operator|^
operator|(
operator|(
literal|1
operator|<<
name|cvmx_pop
argument_list|(
name|prio_mask
argument_list|)
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: POW static priorities should be contiguous (0x%llx)\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|prio_mask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* POW priorities are supported on CN5xxx and later */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|cvmx_sso_ppx_qos_pri_t
name|qos_pri
decl_stmt|;
name|qos_pri
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SSO_PPX_QOS_PRI
argument_list|(
name|core_num
argument_list|)
argument_list|)
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos0_pri
operator|=
name|priority
index|[
literal|0
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos1_pri
operator|=
name|priority
index|[
literal|1
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos2_pri
operator|=
name|priority
index|[
literal|2
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos3_pri
operator|=
name|priority
index|[
literal|3
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos4_pri
operator|=
name|priority
index|[
literal|4
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos5_pri
operator|=
name|priority
index|[
literal|5
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos6_pri
operator|=
name|priority
index|[
literal|6
index|]
expr_stmt|;
name|qos_pri
operator|.
name|s
operator|.
name|qos7_pri
operator|=
name|priority
index|[
literal|7
index|]
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SSO_PPX_QOS_PRI
argument_list|(
name|core_num
argument_list|)
argument_list|,
name|qos_pri
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_pow_pp_grp_mskx_t
name|grp_msk
decl_stmt|;
name|grp_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|core_num
argument_list|)
argument_list|)
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos0_pri
operator|=
name|priority
index|[
literal|0
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos1_pri
operator|=
name|priority
index|[
literal|1
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos2_pri
operator|=
name|priority
index|[
literal|2
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos3_pri
operator|=
name|priority
index|[
literal|3
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos4_pri
operator|=
name|priority
index|[
literal|4
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos5_pri
operator|=
name|priority
index|[
literal|5
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos6_pri
operator|=
name|priority
index|[
literal|6
index|]
expr_stmt|;
name|grp_msk
operator|.
name|s
operator|.
name|qos7_pri
operator|=
name|priority
index|[
literal|7
index|]
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_PP_GRP_MSKX
argument_list|(
name|core_num
argument_list|)
argument_list|,
name|grp_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Performs a tag switch and then an immediate deschedule. This completes  * immediately, so completion must not be waited for.  This function does NOT  * update the wqe in DRAM to match arguments.  *  * This function does NOT wait for any prior tag switches to complete, so the  * calling code must do this.  *  * Note the following CAVEAT of the Octeon HW behavior when  * re-scheduling DE-SCHEDULEd items whose (next) state is  * ORDERED:  *   - If there are no switches pending at the time that the  *     HW executes the de-schedule, the HW will only re-schedule  *     the head of the FIFO associated with the given tag. This  *     means that in many respects, the HW treats this ORDERED  *     tag as an ATOMIC tag. Note that in the SWTAG_DESCH  *     case (to an ORDERED tag), the HW will do the switch  *     before the deschedule whenever it is possible to do  *     the switch immediately, so it may often look like  *     this case.  *   - If there is a pending switch to ORDERED at the time  *     the HW executes the de-schedule, the HW will perform  *     the switch at the time it re-schedules, and will be  *     able to reschedule any/all of the entries with the  *     same tag.  * Due to this behavior, the RECOMMENDATION to software is  * that they have a (next) state of ATOMIC when they  * DE-SCHEDULE. If an ORDERED tag is what was really desired,  * SW can choose to immediately switch to an ORDERED tag  * after the work (that has an ATOMIC tag) is re-scheduled.  * Note that since there are never any tag switches pending  * when the HW re-schedules, this switch can be IMMEDIATE upon  * the reception of the pointer during the re-schedule.  *  * @param tag      New tag value  * @param tag_type New tag type  * @param group    New group value  * @param no_sched Control whether this work queue entry will be rescheduled.  *                 - 1 : don't schedule this work  *                 - 0 : allow this work to be scheduled.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_desched_nocheck
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|,
name|uint64_t
name|group
parameter_list|,
name|uint64_t
name|no_sched
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
block|{
name|cvmx_pow_tag_info_t
name|current_tag
decl_stmt|;
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|current_tag
operator|=
name|cvmx_pow_get_current_tag
argument_list|()
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL_NULL
argument_list|,
literal|"%s called with NULL_NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called with NULL tag. Deschedule not allowed from NULL state\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
operator|(
name|current_tag
operator|.
name|tag_type
operator|!=
name|CVMX_POW_TAG_TYPE_ATOMIC
operator|)
operator|&&
operator|(
name|tag_type
operator|!=
name|CVMX_POW_TAG_TYPE_ATOMIC
operator|)
argument_list|,
literal|"%s called where neither the before or after tag is ATOMIC\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG_DESCH
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|grp
operator|=
name|group
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|no_sched
operator|=
name|no_sched
expr_stmt|;
block|}
else|else
block|{
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_SWTAG_DESCH
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|type
operator|=
name|tag_type
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|grp
operator|=
name|group
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|no_sched
operator|=
name|no_sched
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG3
expr_stmt|;
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* since TAG3 is used, this store will clear the local pending switch bit */
block|}
comment|/**  * Performs a tag switch and then an immediate deschedule. This completes  * immediately, so completion must not be waited for.  This function does NOT  * update the wqe in DRAM to match arguments.  *  * This function waits for any prior tag switches to complete, so the  * calling code may call this function with a pending tag switch.  *  * Note the following CAVEAT of the Octeon HW behavior when  * re-scheduling DE-SCHEDULEd items whose (next) state is  * ORDERED:  *   - If there are no switches pending at the time that the  *     HW executes the de-schedule, the HW will only re-schedule  *     the head of the FIFO associated with the given tag. This  *     means that in many respects, the HW treats this ORDERED  *     tag as an ATOMIC tag. Note that in the SWTAG_DESCH  *     case (to an ORDERED tag), the HW will do the switch  *     before the deschedule whenever it is possible to do  *     the switch immediately, so it may often look like  *     this case.  *   - If there is a pending switch to ORDERED at the time  *     the HW executes the de-schedule, the HW will perform  *     the switch at the time it re-schedules, and will be  *     able to reschedule any/all of the entries with the  *     same tag.  * Due to this behavior, the RECOMMENDATION to software is  * that they have a (next) state of ATOMIC when they  * DE-SCHEDULE. If an ORDERED tag is what was really desired,  * SW can choose to immediately switch to an ORDERED tag  * after the work (that has an ATOMIC tag) is re-scheduled.  * Note that since there are never any tag switches pending  * when the HW re-schedules, this switch can be IMMEDIATE upon  * the reception of the pointer during the re-schedule.  *  * @param tag      New tag value  * @param tag_type New tag type  * @param group    New group value  * @param no_sched Control whether this work queue entry will be rescheduled.  *                 - 1 : don't schedule this work  *                 - 0 : allow this work to be scheduled.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_tag_sw_desched
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|cvmx_pow_tag_type_t
name|tag_type
parameter_list|,
name|uint64_t
name|group
parameter_list|,
name|uint64_t
name|no_sched
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Need to make sure any writes to the work queue entry are complete */
name|CVMX_SYNCWS
expr_stmt|;
comment|/* Ensure that there is not a pending tag switch, as a tag switch cannot be started     ** if a previous switch is still pending.  */
name|cvmx_pow_tag_sw_wait
argument_list|()
expr_stmt|;
name|cvmx_pow_tag_sw_desched_nocheck
argument_list|(
name|tag
argument_list|,
name|tag_type
argument_list|,
name|group
argument_list|,
name|no_sched
argument_list|)
expr_stmt|;
block|}
comment|/**  * Descchedules the current work queue entry.  *  * @param no_sched no schedule flag value to be set on the work queue entry.  If this is set  *                 the entry will not be rescheduled.  */
specifier|static
specifier|inline
name|void
name|cvmx_pow_desched
parameter_list|(
name|uint64_t
name|no_sched
parameter_list|)
block|{
name|cvmx_addr_t
name|ptr
decl_stmt|;
name|cvmx_pow_tag_req_t
name|tag_req
decl_stmt|;
if|if
condition|(
name|CVMX_ENABLE_POW_CHECKS
condition|)
block|{
name|cvmx_pow_tag_info_t
name|current_tag
decl_stmt|;
name|__cvmx_pow_warn_if_pending_switch
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|current_tag
operator|=
name|cvmx_pow_get_current_tag
argument_list|()
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL_NULL
argument_list|,
literal|"%s called with NULL_NULL tag\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|current_tag
operator|.
name|tag_type
operator|==
name|CVMX_POW_TAG_TYPE_NULL
argument_list|,
literal|"%s called with NULL tag. Deschedule not expected from NULL state\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Need to make sure any writes to the work queue entry are complete */
name|CVMX_SYNCWS
expr_stmt|;
name|tag_req
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_CN68XX_WQE
argument_list|)
condition|)
block|{
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_DESCH
expr_stmt|;
name|tag_req
operator|.
name|s_cn68xx_other
operator|.
name|no_sched
operator|=
name|no_sched
expr_stmt|;
block|}
else|else
block|{
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|op
operator|=
name|CVMX_POW_TAG_OP_DESCH
expr_stmt|;
name|tag_req
operator|.
name|s_cn38xx
operator|.
name|no_sched
operator|=
name|no_sched
expr_stmt|;
block|}
name|ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|mem_region
operator|=
name|CVMX_IO_SEG
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|is_io
operator|=
literal|1
expr_stmt|;
name|ptr
operator|.
name|sio
operator|.
name|did
operator|=
name|CVMX_OCT_DID_TAG_TAG3
expr_stmt|;
name|cvmx_write_io
argument_list|(
name|ptr
operator|.
name|u64
argument_list|,
name|tag_req
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* since TAG3 is used, this store will clear the local pending switch bit */
block|}
comment|/*********************************************************************************************** ** Define usage of bits within the 32 bit tag values. ***********************************************************************************************/
comment|/*  * Number of bits of the tag used by software.  The SW bits  * are always a contiguous block of the high starting at bit 31.  * The hardware bits are always the low bits.  By default, the top 8 bits  * of the tag are reserved for software, and the low 24 are set by the IPD unit.  */
define|#
directive|define
name|CVMX_TAG_SW_BITS
value|(8)
define|#
directive|define
name|CVMX_TAG_SW_SHIFT
value|(32 - CVMX_TAG_SW_BITS)
comment|/* Below is the list of values for the top 8 bits of the tag. */
define|#
directive|define
name|CVMX_TAG_SW_BITS_INTERNAL
value|0x1
comment|/* Tag values with top byte of this value are reserved for internal executive uses */
comment|/* The executive divides the remaining 24 bits as follows: **  * the upper 8 bits (bits 23 - 16 of the tag) define a subgroup **  * the lower 16 bits (bits 15 - 0 of the tag) define are the value with the subgroup ** Note that this section describes the format of tags generated by software - refer to the ** hardware documentation for a description of the tags values generated by the packet input ** hardware. ** Subgroups are defined here */
define|#
directive|define
name|CVMX_TAG_SUBGROUP_MASK
value|0xFFFF
comment|/* Mask for the value portion of the tag */
define|#
directive|define
name|CVMX_TAG_SUBGROUP_SHIFT
value|16
define|#
directive|define
name|CVMX_TAG_SUBGROUP_PKO
value|0x1
comment|/* End of executive tag subgroup definitions */
comment|/* The remaining values software bit values 0x2 - 0xff are available for application use */
comment|/**  * This function creates a 32 bit tag value from the two values provided.  *  * @param sw_bits The upper bits (number depends on configuration) are set to this value.  The remainder of  *                bits are set by the hw_bits parameter.  * @param hw_bits The lower bits (number depends on configuration) are set to this value.  The remainder of  *                bits are set by the sw_bits parameter.  *  * @return 32 bit value of the combined hw and sw bits.  */
specifier|static
specifier|inline
name|uint32_t
name|cvmx_pow_tag_compose
parameter_list|(
name|uint64_t
name|sw_bits
parameter_list|,
name|uint64_t
name|hw_bits
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|sw_bits
operator|&
name|cvmx_build_mask
argument_list|(
name|CVMX_TAG_SW_BITS
argument_list|)
operator|)
operator|<<
name|CVMX_TAG_SW_SHIFT
operator|)
operator||
operator|(
name|hw_bits
operator|&
name|cvmx_build_mask
argument_list|(
literal|32
operator|-
name|CVMX_TAG_SW_BITS
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
comment|/**  * Extracts the bits allocated for software use from the tag  *  * @param tag    32 bit tag value  *  * @return N bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define  */
specifier|static
specifier|inline
name|uint32_t
name|cvmx_pow_tag_get_sw_bits
parameter_list|(
name|uint64_t
name|tag
parameter_list|)
block|{
return|return
operator|(
operator|(
name|tag
operator|>>
operator|(
literal|32
operator|-
name|CVMX_TAG_SW_BITS
operator|)
operator|)
operator|&
name|cvmx_build_mask
argument_list|(
name|CVMX_TAG_SW_BITS
argument_list|)
operator|)
return|;
block|}
comment|/**  *  * Extracts the bits allocated for hardware use from the tag  *  * @param tag    32 bit tag value  *  * @return (32 - N) bit software tag value, where N is configurable with the CVMX_TAG_SW_BITS define  */
specifier|static
specifier|inline
name|uint32_t
name|cvmx_pow_tag_get_hw_bits
parameter_list|(
name|uint64_t
name|tag
parameter_list|)
block|{
return|return
operator|(
name|tag
operator|&
name|cvmx_build_mask
argument_list|(
literal|32
operator|-
name|CVMX_TAG_SW_BITS
argument_list|)
operator|)
return|;
block|}
comment|/**  * Store the current POW internal state into the supplied  * buffer. It is recommended that you pass a buffer of at least  * 128KB. The format of the capture may change based on SDK  * version and Octeon chip.  *  * @param buffer Buffer to store capture into  * @param buffer_size  *               The size of the supplied buffer  *  * @return Zero on sucess, negative on failure  */
specifier|extern
name|int
name|cvmx_pow_capture
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_size
parameter_list|)
function_decl|;
comment|/**  * Dump a POW capture to the console in a human readable format.  *  * @param buffer POW capture from cvmx_pow_capture()  * @param buffer_size  *               Size of the buffer  */
specifier|extern
name|void
name|cvmx_pow_display
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_size
parameter_list|)
function_decl|;
comment|/**  * Return the number of POW entries supported by this chip  *  * @return Number of POW entries  */
specifier|extern
name|int
name|cvmx_pow_get_num_entries
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_POW_H__ */
end_comment

end_unit

