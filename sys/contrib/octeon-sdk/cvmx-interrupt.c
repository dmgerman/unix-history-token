begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Mips interrupts.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
end_if

begin_comment
comment|/* Backtrace is only available with the new toolchain.  */
end_comment

begin_include
include|#
directive|include
file|<execinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __U_BOOT__ */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-uart.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pow.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ebt3000.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-atomic.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-init.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-hotplug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-profiler.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_include
include|#
directive|include
file|<octeon_mem_map.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<asm/arch/octeon_mem_map.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_stage1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_debug_handler_stage1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EXTERN_ASM
name|void
name|cvmx_interrupt_cache_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|cvmx_interrupt_in_isr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|__cvmx_interrupt_handler
block|{
name|cvmx_interrupt_func_t
name|handler
decl_stmt|;
comment|/**< One function to call per interrupt */
name|void
modifier|*
name|data
decl_stmt|;
comment|/**< User data per interrupt */
name|int
name|handler_data
decl_stmt|;
comment|/**< Used internally */
block|}
struct|;
end_struct

begin_comment
comment|/**  * Internal status the interrupt registration  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|__cvmx_interrupt_handler
name|handlers
index|[
name|CVMX_IRQ_MAX
index|]
decl_stmt|;
name|cvmx_interrupt_exception_t
name|exception_handler
decl_stmt|;
block|}
name|cvmx_interrupt_state_t
typedef|;
end_typedef

begin_comment
comment|/**  * Internal state the interrupt registration  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_interrupt_state_t
name|cvmx_interrupt_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_interrupt_default_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented once first core processing is finished. */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|int32_t
name|cvmx_interrupt_initialize_flag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __U_BOOT__ */
end_comment

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_define
define|#
directive|define
name|HI32
parameter_list|(
name|data64
parameter_list|)
value|((uint32_t)(data64>> 32))
end_define

begin_define
define|#
directive|define
name|LO32
parameter_list|(
name|data64
parameter_list|)
value|((uint32_t)(data64& 0xFFFFFFFF))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|reg_names
index|[]
index|[
literal|32
index|]
init|=
block|{
literal|"r0"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * version of printf that works better in exception context.  *  * @param format  */
end_comment

begin_function
name|void
name|cvmx_safe_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|count
operator|=
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|count
operator|=
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
comment|/* Spin until there is room */
do|do
block|{
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_SIM_SPEED
argument_list|)
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Just to reduce the load on the system */
endif|#
directive|endif
block|}
do|while
condition|(
name|lsrval
operator|.
name|s
operator|.
name|temt
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_UARTX_THR
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Textual descriptions of cause codes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|cause_names
index|[]
index|[
literal|128
index|]
init|=
block|{
comment|/*  0 */
literal|"Interrupt"
block|,
comment|/*  1 */
literal|"TLB modification"
block|,
comment|/*  2 */
literal|"tlb load/fetch"
block|,
comment|/*  3 */
literal|"tlb store"
block|,
comment|/*  4 */
literal|"address exc, load/fetch"
block|,
comment|/*  5 */
literal|"address exc, store"
block|,
comment|/*  6 */
literal|"bus error, instruction fetch"
block|,
comment|/*  7 */
literal|"bus error, load/store"
block|,
comment|/*  8 */
literal|"syscall"
block|,
comment|/*  9 */
literal|"breakpoint"
block|,
comment|/* 10 */
literal|"reserved instruction"
block|,
comment|/* 11 */
literal|"cop unusable"
block|,
comment|/* 12 */
literal|"arithmetic overflow"
block|,
comment|/* 13 */
literal|"trap"
block|,
comment|/* 14 */
literal|""
block|,
comment|/* 15 */
literal|"floating point exc"
block|,
comment|/* 16 */
literal|""
block|,
comment|/* 17 */
literal|""
block|,
comment|/* 18 */
literal|"cop2 exception"
block|,
comment|/* 19 */
literal|""
block|,
comment|/* 20 */
literal|""
block|,
comment|/* 21 */
literal|""
block|,
comment|/* 22 */
literal|"mdmx unusable"
block|,
comment|/* 23 */
literal|"watch"
block|,
comment|/* 24 */
literal|"machine check"
block|,
comment|/* 25 */
literal|""
block|,
comment|/* 26 */
literal|""
block|,
comment|/* 27 */
literal|""
block|,
comment|/* 28 */
literal|""
block|,
comment|/* 29 */
literal|""
block|,
comment|/* 30 */
literal|"cache error"
block|,
comment|/* 31 */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @INTERNAL  * print_reg64  * @param name   Name of the value to print  * @param reg    Value to print  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_reg64
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|reg
parameter_list|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"%16s: 0x%08x%08x\n"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Dump all useful registers to the console  *  * @param registers CPU register to dump  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_dump_registers
parameter_list|(
name|uint64_t
modifier|*
name|registers
parameter_list|)
block|{
name|uint64_t
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
block|{
name|r1
operator|=
name|registers
index|[
name|reg
index|]
expr_stmt|;
name|r2
operator|=
name|registers
index|[
name|reg
operator|+
literal|16
index|]
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%3s ($%02d): 0x%08x%08x \t %3s ($%02d): 0x%08x%08x\n"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|reg
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|r1
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|r1
argument_list|)
argument_list|,
name|reg_names
index|[
name|reg
operator|+
literal|16
index|]
argument_list|,
name|reg
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HI32
argument_list|(
name|r2
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|LO32
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CVMX_MF_COP0
argument_list|(
name|r1
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_CAUSE"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r2
argument_list|,
name|COP0_STATUS
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_STATUS"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r1
argument_list|,
name|COP0_BADVADDR
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_BADVADDR"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|r2
argument_list|,
name|COP0_EPC
argument_list|)
expr_stmt|;
name|print_reg64
argument_list|(
literal|"COP0_EPC"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Default exception handler. Prints out the exception  * cause decode and all relevant registers.  *  * @param registers Registers at time of the exception  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
comment|/* __U_BOOT__ */
name|void
name|__cvmx_interrupt_default_exception_handler
parameter_list|(
name|uint64_t
modifier|*
name|registers
parameter_list|)
block|{
name|uint64_t
name|trap_print_cause
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|int
name|modified_zero_pc
init|=
literal|0
decl_stmt|;
name|ebt3000_str_write
argument_list|(
literal|"Trap"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CVMX_MF_COP0
argument_list|(
name|trap_print_cause
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|str
operator|=
name|cause_names
index|[
operator|(
name|trap_print_cause
operator|>>
literal|2
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"Core %d: Unhandled Exception. Cause register decodes to:\n%s\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_get_core_num
argument_list|()
argument_list|,
name|str
operator|&&
operator|*
name|str
condition|?
name|str
else|:
literal|"Reserved exception cause"
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__U_BOOT__
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GNUC__
operator|>=
literal|4
operator|&&
operator|!
name|defined
argument_list|(
name|OCTEON_DISABLE_BACKTRACE
argument_list|)
name|cvmx_safe_printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|registers
index|[
literal|35
index|]
operator|==
literal|0
condition|)
block|{
name|modified_zero_pc
operator|=
literal|1
expr_stmt|;
comment|/* If PC is zero we probably did jalr $zero, in which case $31 - 8 is the call site. */
name|registers
index|[
literal|35
index|]
operator|=
name|registers
index|[
literal|31
index|]
operator|-
literal|8
expr_stmt|;
block|}
name|__octeon_print_backtrace_func
argument_list|(
operator|(
name|__octeon_backtrace_printf_t
operator|)
name|cvmx_safe_printf
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_zero_pc
condition|)
name|registers
index|[
literal|35
index|]
operator|=
literal|0
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"******************************************************************\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_interrupt_default_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
name|CVMX_BREAK
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Interrupts are suppressed when we are in the exception            handler (because of SR[EXL]).  Spin and poll the uart            status and see if the debugger is trying to stop us. */
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsrval
operator|.
name|s
operator|.
name|dr
condition|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
comment|/* Pulse the MCD0 signal. */
asm|asm
specifier|volatile
asm|(             ".set push\n"             ".set noreorder\n"             ".set mips64\n"             "dmfc0 %0, $22\n"             "ori   %0, %0, 0x10\n"             "dmtc0 %0, $22\n"             ".set pop\n"             : "=r" (tmp));
block|}
block|}
endif|#
directive|endif
comment|/* __U_BOOT__ */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__U_BOOT__
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Default interrupt handler if the user doesn't register one.  *  * @param irq_number IRQ that caused this interrupt  * @param registers  Register at the time of the interrupt  * @param user_arg   Unused optional user data  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_default
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"cvmx_interrupt_default: Received interrupt %d\n"
argument_list|,
name|irq_number
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_dump_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Map a ciu bit to an irq number.  0xff for invalid.  * 0-63 for en0.  * 64-127 for en1.  */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|uint8_t
name|cvmx_ciu_to_irq
index|[
literal|8
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cvmx_ciu_en0_to_irq
value|cvmx_ciu_to_irq[0]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu_en1_to_irq
value|cvmx_ciu_to_irq[1]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_wrkq_to_irq
value|cvmx_ciu_to_irq[0]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_wdog_to_irq
value|cvmx_ciu_to_irq[1]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_rml_to_irq
value|cvmx_ciu_to_irq[2]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_mio_to_irq
value|cvmx_ciu_to_irq[3]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_io_to_irq
value|cvmx_ciu_to_irq[4]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_mem_to_irq
value|cvmx_ciu_to_irq[5]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_eth_to_irq
value|cvmx_ciu_to_irq[6]
end_define

begin_define
define|#
directive|define
name|cvmx_ciu2_gpio_to_irq
value|cvmx_ciu_to_irq[7]
end_define

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|uint8_t
name|cvmx_ciu2_mbox_to_irq
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|uint8_t
name|cvmx_ciu_61xx_timer_to_irq
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|__cvmx_interrupt_set_mapping
parameter_list|(
name|int
name|irq
parameter_list|,
name|unsigned
name|int
name|en
parameter_list|,
name|unsigned
name|int
name|bit
parameter_list|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq
index|]
operator|.
name|handler_data
operator|=
operator|(
name|en
operator|<<
literal|6
operator|)
operator||
name|bit
expr_stmt|;
if|if
condition|(
name|en
operator|<=
literal|7
condition|)
name|cvmx_ciu_to_irq
index|[
name|en
index|]
index|[
name|bit
index|]
operator|=
name|irq
expr_stmt|;
elseif|else
if|if
condition|(
name|en
operator|==
literal|8
condition|)
name|cvmx_ciu_61xx_timer_to_irq
index|[
name|bit
index|]
operator|=
name|irq
expr_stmt|;
else|else
name|cvmx_ciu2_mbox_to_irq
index|[
name|bit
index|]
operator|=
name|irq
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint64_t
name|cvmx_interrupt_ciu_en0_mirror
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|cvmx_interrupt_ciu_en1_mirror
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|cvmx_interrupt_ciu_61xx_timer_mirror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @INTERNAL  * Called for all Performance Counter interrupts. Handler for   * interrupt line 6  *  * @param irq_number Interrupt number that we're being called for  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument*  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_perf
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|uint64_t
name|perf_counter
decl_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|perf_counter
argument_list|,
name|COP0_PERFVALUE0
argument_list|)
expr_stmt|;
if|if
condition|(
name|perf_counter
operator|&
operator|(
literal|1ull
operator|<<
literal|63
operator|)
condition|)
name|cvmx_collect_sample
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Handler for interrupt lines 2 and 3. These are directly tied  * to the CIU. The handler queries the status of the CIU and  * calls the secondary handler for the CIU interrupt that  * occurred.  *  * @param irq_number Interrupt number that fired (2 or 3)  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|int
name|ciu_offset
decl_stmt|;
name|uint64_t
name|irq_mask
decl_stmt|;
name|uint64_t
name|irq
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|irq_number
operator|==
name|CVMX_IRQ_MIPS2
condition|)
block|{
comment|/* Handle EN0 sources */
name|ciu_offset
operator|=
name|core
operator|*
literal|2
expr_stmt|;
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_SUM0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|)
operator|&
name|cvmx_interrupt_ciu_en0_mirror
expr_stmt|;
name|CVMX_DCLZ
argument_list|(
name|bit
argument_list|,
name|irq_mask
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|63
operator|-
name|bit
expr_stmt|;
comment|/* If ciu_int_sum1<sum2> is set, means its a timer interrupt */
if|if
condition|(
name|bit
operator|==
literal|51
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_2
argument_list|)
operator|)
condition|)
block|{
name|uint64_t
name|irq_mask
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SUM2_PPX_IP2
argument_list|(
name|core
argument_list|)
argument_list|)
operator|&
name|cvmx_interrupt_ciu_61xx_timer_mirror
expr_stmt|;
name|CVMX_DCLZ
argument_list|(
name|bit
argument_list|,
name|irq_mask
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|63
operator|-
name|bit
expr_stmt|;
comment|/* Handle TIMER(4..9) interrupts */
if|if
condition|(
name|bit
operator|<=
literal|9
operator|&&
name|bit
operator|>=
literal|4
condition|)
block|{
name|uint64_t
name|irq
init|=
name|cvmx_ciu_61xx_timer_to_irq
index|[
name|bit
index|]
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping */
name|cvmx_interrupt_ciu_61xx_timer_mirror
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|bit
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_EN2_PPX_IP2
argument_list|(
name|core
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_61xx_timer_mirror
argument_list|)
expr_stmt|;
return|return;
block|}
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
decl_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|bit
operator|>=
literal|0
condition|)
block|{
name|irq
operator|=
name|cvmx_ciu_en0_to_irq
index|[
name|bit
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping. */
name|cvmx_interrupt_ciu_en0_mirror
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|bit
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en0_mirror
argument_list|)
expr_stmt|;
return|return;
block|}
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
decl_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Handle EN1 sources */
name|ciu_offset
operator|=
name|cvmx_get_core_num
argument_list|()
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INT_SUM1
argument_list|)
operator|&
name|cvmx_interrupt_ciu_en1_mirror
expr_stmt|;
name|CVMX_DCLZ
argument_list|(
name|bit
argument_list|,
name|irq_mask
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|63
operator|-
name|bit
expr_stmt|;
if|if
condition|(
name|bit
operator|>=
literal|0
condition|)
block|{
name|irq
operator|=
name|cvmx_ciu_en1_to_irq
index|[
name|bit
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping. */
name|cvmx_interrupt_ciu_en1_mirror
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|bit
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|ciu_offset
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en1_mirror
argument_list|)
expr_stmt|;
return|return;
block|}
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
decl_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Handler for interrupt line 3, the DPI_DMA will have different value  * per core, all other fields values are identical for different cores.  *  These are directly tied to the CIU. The handler queries the status of  * the CIU and calls the secondary handler for the CIU interrupt that  * occurred.  *  * @param irq_number Interrupt number that fired (2 or 3)  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu_cn61xx
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
comment|/* Handle EN1 sources */
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|int
name|ciu_offset
decl_stmt|;
name|uint64_t
name|irq_mask
decl_stmt|;
name|uint64_t
name|irq
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|ciu_offset
operator|=
name|core
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|irq_mask
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SUM1_PPX_IP3
argument_list|(
name|core
argument_list|)
argument_list|)
operator|&
name|cvmx_interrupt_ciu_en1_mirror
expr_stmt|;
name|CVMX_DCLZ
argument_list|(
name|bit
argument_list|,
name|irq_mask
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|63
operator|-
name|bit
expr_stmt|;
if|if
condition|(
name|bit
operator|>=
literal|0
condition|)
block|{
name|irq
operator|=
name|cvmx_ciu_en1_to_irq
index|[
name|bit
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping. */
name|cvmx_interrupt_ciu_en1_mirror
operator|&=
operator|~
operator|(
literal|1ull
operator|<<
name|bit
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|ciu_offset
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en1_mirror
argument_list|)
expr_stmt|;
return|return;
block|}
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
decl_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Handler for interrupt line 2 on 68XX. These are directly tied  * to the CIU2. The handler queries the status of the CIU and  * calls the secondary handler for the CIU interrupt that  * occurred.  *  * @param irq_number Interrupt number that fired (2 or 3)  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu2
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|int
name|sum_bit
decl_stmt|,
name|src_bit
decl_stmt|;
name|uint64_t
name|irq
decl_stmt|;
name|uint64_t
name|src_reg
decl_stmt|,
name|src_val
decl_stmt|;
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
decl_stmt|;
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|uint64_t
name|sum
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU2_SUM_PPX_IP2
argument_list|(
name|core
argument_list|)
argument_list|)
decl_stmt|;
name|CVMX_DCLZ
argument_list|(
name|sum_bit
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|sum_bit
operator|=
literal|63
operator|-
name|sum_bit
expr_stmt|;
if|if
condition|(
name|sum_bit
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|sum_bit
condition|)
block|{
case|case
literal|63
case|:
case|case
literal|62
case|:
case|case
literal|61
case|:
case|case
literal|60
case|:
name|irq
operator|=
name|cvmx_ciu2_mbox_to_irq
index|[
name|sum_bit
operator|-
literal|60
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping. */
name|uint64_t
name|mask_reg
init|=
name|CVMX_CIU2_EN_PPX_IP2_MBOX_W1C
argument_list|(
name|core
argument_list|)
decl_stmt|;
name|cvmx_write_csr
argument_list|(
name|mask_reg
argument_list|,
literal|1ull
operator|<<
operator|(
name|sum_bit
operator|-
literal|60
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|h
operator|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
expr_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
case|case
literal|6
case|:
case|case
literal|5
case|:
case|case
literal|4
case|:
case|case
literal|3
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
name|src_reg
operator|=
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
name|core
argument_list|)
operator|+
operator|(
literal|0x1000
operator|*
name|sum_bit
operator|)
expr_stmt|;
name|src_val
operator|=
name|cvmx_read_csr
argument_list|(
name|src_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src_val
condition|)
break|break;
name|CVMX_DCLZ
argument_list|(
name|src_bit
argument_list|,
name|src_val
argument_list|)
expr_stmt|;
name|src_bit
operator|=
literal|63
operator|-
name|src_bit
expr_stmt|;
name|irq
operator|=
name|cvmx_ciu_to_irq
index|[
name|sum_bit
index|]
index|[
name|src_bit
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|irq
operator|==
literal|0xff
argument_list|)
condition|)
block|{
comment|/* No mapping. */
name|uint64_t
name|mask_reg
init|=
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
name|core
argument_list|)
operator|+
operator|(
literal|0x1000
operator|*
name|sum_bit
operator|)
decl_stmt|;
name|cvmx_write_csr
argument_list|(
name|mask_reg
argument_list|,
literal|1ull
operator|<<
name|src_bit
argument_list|)
expr_stmt|;
break|break;
block|}
name|h
operator|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|irq
expr_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|irq
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cvmx_safe_printf
argument_list|(
literal|"Unknown CIU2 bit: %d\n"
argument_list|,
name|sum_bit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Clear the source to reduce the chance for spurious interrupts.  */
comment|/* CN68XX has an CIU-15786 errata that accessing the ACK registers      * can stop interrupts from propagating      */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU2_INTR_CIU_READY
argument_list|)
expr_stmt|;
else|else
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU2_ACK_PPX_IP2
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Called for all RML interrupts. This is usually an ECC error  *  * @param irq_number Interrupt number that we're being called for  * @param registers  Registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ecc
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
modifier|*
name|registers
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_error_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Process an interrupt request  *  * @param registers Registers at time of interrupt / exception  * Registers 0-31 are standard MIPS, others specific to this routine  * @return  */
end_comment

begin_function_decl
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
modifier|*
name|registers
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|cvmx_interrupt_do_irq
parameter_list|(
name|uint64_t
modifier|*
name|registers
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
name|uint64_t
name|cause
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
name|uint64_t
name|cache_err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|exc_vec
decl_stmt|;
comment|/* Determine the cause of the interrupt */
asm|asm
specifier|volatile
asm|("dmfc0 %0,$13,0" : "=r" (cause));
asm|asm
specifier|volatile
asm|("dmfc0 %0,$12,0" : "=r" (status));
comment|/* In case of exception, clear all interrupts to avoid recursive interrupts.        Also clear EXL bit to display the correct PC value. */
if|if
condition|(
operator|(
name|cause
operator|&
literal|0x7c
operator|)
operator|==
literal|0
condition|)
block|{
asm|asm
specifier|volatile
asm|("dmtc0 %0, $12, 0" : : "r" (status& ~(0xff02)));
block|}
comment|/* The assembly stub at each exception vector saves its address in k1 when     ** it calls the stage 2 handler.  We use this to compute the exception vector     ** that brought us here */
name|exc_vec
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|registers
index|[
literal|27
index|]
operator|&
literal|0x780
argument_list|)
expr_stmt|;
comment|/* Mask off bits we need to ignore */
comment|/* Check for cache errors.  The cache errors go to a separate exception vector,     ** so we will only check these if we got here from a cache error exception, and     ** the ERL (error level) bit is set. */
name|i
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|exc_vec
operator|==
literal|0x100
operator|&&
operator|(
name|status
operator|&
literal|0x4
operator|)
condition|)
block|{
name|CVMX_MF_CACHE_ERR
argument_list|(
name|cache_err
argument_list|)
expr_stmt|;
comment|/* Use copy of DCACHE_ERR register that early exception stub read */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
block|{
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x1
condition|)
name|cvmx_safe_printf
argument_list|(
literal|"Dcache error detected: core: %d, way: %d, va 7:3: 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|registers
index|[
literal|34
index|]
operator|>>
literal|8
argument_list|)
operator|&
literal|0x3f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|registers
index|[
literal|34
index|]
operator|>>
literal|3
argument_list|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cache_err
operator|&
literal|0x1
condition|)
name|cvmx_safe_printf
argument_list|(
literal|"Icache error detected: core: %d, set: %d, way : %d, va 6:3 = 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|5
argument_list|)
operator|&
literal|0x3f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0x3
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|11
argument_list|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|cvmx_safe_printf
argument_list|(
literal|"Cache error exception: core %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x1
condition|)
name|cvmx_safe_printf
argument_list|(
literal|"Dcache error detected: core: %d, way: %d, va 9:7: 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|registers
index|[
literal|34
index|]
operator|>>
literal|10
argument_list|)
operator|&
literal|0x1f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|registers
index|[
literal|34
index|]
operator|>>
literal|7
argument_list|)
operator|&
literal|0x3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cache_err
operator|&
literal|0x1
condition|)
name|cvmx_safe_printf
argument_list|(
literal|"Icache error detected: core: %d, way : %d, va 9:3 = 0x%x\n"
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|10
argument_list|)
operator|&
literal|0x3f
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cache_err
operator|>>
literal|3
argument_list|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
else|else
name|cvmx_safe_printf
argument_list|(
literal|"Cache error exception: core %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|CVMX_MT_DCACHE_ERR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CVMX_MT_CACHE_ERR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The bus error exceptions can occur due to DID timeout or write buffer,        check by reading COP0_CACHEERRD */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|i
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x4
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Bus error detected due to DID timeout: core: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CVMX_MT_DCACHE_ERR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|registers
index|[
literal|34
index|]
operator|&
literal|0x2
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"Bus error detected due to write buffer parity: core: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CVMX_MT_DCACHE_ERR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cause
operator|&
literal|0x7c
operator|)
operator|!=
literal|0
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
goto|goto
name|return_from_interrupt
goto|;
block|}
comment|/* Convert the cause into an active mask */
name|mask
operator|=
operator|(
operator|(
name|cause
operator|&
name|status
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
goto|goto
name|return_from_interrupt
goto|;
comment|/* Spurious interrupt */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|struct
name|__cvmx_interrupt_handler
modifier|*
name|h
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
operator|+
name|i
decl_stmt|;
name|h
operator|->
name|handler
argument_list|(
name|i
argument_list|,
name|registers
argument_list|,
name|h
operator|->
name|data
argument_list|)
expr_stmt|;
goto|goto
name|return_from_interrupt
goto|;
block|}
block|}
comment|/* We should never get here */
name|__cvmx_interrupt_default_exception_handler
argument_list|(
name|registers
argument_list|)
expr_stmt|;
name|return_from_interrupt
label|:
comment|/* Restore Status register before returning from exception. */
asm|asm
specifier|volatile
asm|("dmtc0 %0, $12, 0" : : "r" (status));
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|cvmx_interrupt_mask_irq
function_decl|)
parameter_list|(
name|int
name|irq_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|cvmx_interrupt_unmask_irq
function_decl|)
parameter_list|(
name|int
name|irq_number
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CLEAR_OR_MASK
parameter_list|(
name|V
parameter_list|,
name|M
parameter_list|,
name|O
parameter_list|)
value|({\             if (O)             \                 (V)&= ~(M);   \             else               \                 (V) |= (M);    \         })
end_define

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu2_mask_unmask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|int
name|op
parameter_list|)
block|{
if|if
condition|(
name|irq_number
operator|<
literal|0
operator|||
name|irq_number
operator|>=
name|CVMX_IRQ_MAX
condition|)
return|return;
if|if
condition|(
name|irq_number
operator|<=
name|CVMX_IRQ_MIPS7
condition|)
block|{
name|uint32_t
name|flags
decl_stmt|,
name|mask
decl_stmt|;
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
asm|asm
specifier|volatile
asm|("mfc0 %0,$12,0" : "=r" (mask));
name|CLEAR_OR_MASK
argument_list|(
name|mask
argument_list|,
literal|1
operator|<<
operator|(
literal|8
operator|+
name|irq_number
operator|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("mtc0 %0,$12,0" : : "r" (mask));
name|cvmx_interrupt_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|idx
decl_stmt|;
name|uint64_t
name|reg
decl_stmt|;
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|int
name|bit
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|.
name|handler_data
decl_stmt|;
if|if
condition|(
name|bit
operator|<
literal|0
condition|)
return|return;
name|idx
operator|=
name|bit
operator|>>
literal|6
expr_stmt|;
name|bit
operator|&=
literal|0x3f
expr_stmt|;
if|if
condition|(
name|idx
operator|>
literal|7
condition|)
block|{
comment|/* MBOX */
if|if
condition|(
name|op
condition|)
name|reg
operator|=
name|CVMX_CIU2_EN_PPX_IP2_MBOX_W1C
argument_list|(
name|core
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|CVMX_CIU2_EN_PPX_IP2_MBOX_W1S
argument_list|(
name|core
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
condition|)
name|reg
operator|=
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
name|core
argument_list|)
operator|+
operator|(
literal|0x1000
operator|*
name|idx
operator|)
expr_stmt|;
else|else
name|reg
operator|=
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
name|core
argument_list|)
operator|+
operator|(
literal|0x1000
operator|*
name|idx
operator|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|reg
argument_list|,
literal|1ull
operator|<<
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu2_mask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|)
block|{
name|__cvmx_interrupt_ciu2_mask_unmask_irq
argument_list|(
name|irq_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu2_unmask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|)
block|{
name|__cvmx_interrupt_ciu2_mask_unmask_irq
argument_list|(
name|irq_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu_mask_unmask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|uint32_t
name|flags
decl_stmt|;
if|if
condition|(
name|irq_number
operator|<
literal|0
operator|||
name|irq_number
operator|>=
name|CVMX_IRQ_MAX
condition|)
return|return;
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
if|if
condition|(
name|irq_number
operator|<=
name|CVMX_IRQ_MIPS7
condition|)
block|{
name|uint32_t
name|mask
decl_stmt|;
asm|asm
specifier|volatile
asm|("mfc0 %0,$12,0" : "=r" (mask));
name|CLEAR_OR_MASK
argument_list|(
name|mask
argument_list|,
literal|1
operator|<<
operator|(
literal|8
operator|+
name|irq_number
operator|)
argument_list|,
name|op
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("mtc0 %0,$12,0" : : "r" (mask));
block|}
else|else
block|{
name|int
name|ciu_bit
decl_stmt|,
name|ciu_offset
decl_stmt|;
name|int
name|bit
init|=
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|.
name|handler_data
decl_stmt|;
name|int
name|is_timer_intr
init|=
name|bit
operator|>>
literal|6
decl_stmt|;
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|bit
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|ciu_bit
operator|=
name|bit
operator|&
literal|0x3f
expr_stmt|;
name|ciu_offset
operator|=
name|core
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|is_timer_intr
operator|==
literal|8
condition|)
block|{
name|CLEAR_OR_MASK
argument_list|(
name|cvmx_interrupt_ciu_61xx_timer_mirror
argument_list|,
literal|1ull
operator|<<
name|ciu_bit
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|CLEAR_OR_MASK
argument_list|(
name|cvmx_interrupt_ciu_en0_mirror
argument_list|,
literal|1ull
operator|<<
literal|51
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|// SUM2 bit
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_EN2_PPX_IP2
argument_list|(
name|core
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_61xx_timer_mirror
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
operator|&
literal|0x40
condition|)
block|{
comment|/* EN1 */
name|ciu_offset
operator|+=
literal|1
expr_stmt|;
name|CLEAR_OR_MASK
argument_list|(
name|cvmx_interrupt_ciu_en1_mirror
argument_list|,
literal|1ull
operator|<<
name|ciu_bit
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|ciu_offset
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en1_mirror
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* EN0 */
name|CLEAR_OR_MASK
argument_list|(
name|cvmx_interrupt_ciu_en0_mirror
argument_list|,
literal|1ull
operator|<<
name|ciu_bit
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|ciu_offset
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en0_mirror
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|cvmx_interrupt_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu_mask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|)
block|{
name|__cvmx_interrupt_ciu_mask_unmask_irq
argument_list|(
name|irq_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__cvmx_interrupt_ciu_unmask_irq
parameter_list|(
name|int
name|irq_number
parameter_list|)
block|{
name|__cvmx_interrupt_ciu_mask_unmask_irq
argument_list|(
name|irq_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Register an interrupt handler for the specified interrupt number.  *  * @param irq_number Interrupt number to register for See  *                   cvmx-interrupt.h for enumeration and description of sources.  * @param func       Function to call on interrupt.  * @param user_arg   User data to pass to the interrupt handler  */
end_comment

begin_function
name|void
name|cvmx_interrupt_register
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|cvmx_interrupt_func_t
name|func
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
if|if
condition|(
name|irq_number
operator|>=
name|CVMX_IRQ_MAX
operator|||
name|irq_number
operator|<
literal|0
condition|)
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx_interrupt_register: Illegal irq_number %d\n"
argument_list|,
name|irq_number
argument_list|)
expr_stmt|;
return|return;
block|}
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|.
name|handler
operator|=
name|func
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|irq_number
index|]
operator|.
name|data
operator|=
name|user_arg
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_interrupt_ciu_initialize
parameter_list|(
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
comment|/* Disable all CIU interrupts by default */
name|cvmx_interrupt_ciu_en0_mirror
operator|=
literal|0
expr_stmt|;
name|cvmx_interrupt_ciu_en1_mirror
operator|=
literal|0
expr_stmt|;
name|cvmx_interrupt_ciu_61xx_timer_mirror
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|core
operator|*
literal|2
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en0_mirror
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
operator|(
name|core
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en0_mirror
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
name|core
operator|*
literal|2
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en1_mirror
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN1
argument_list|(
operator|(
name|core
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_en1_mirror
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_2
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_EN2_PPX_IP2
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
name|cvmx_interrupt_ciu_61xx_timer_mirror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
operator|||
name|is_core_being_hot_plugged
argument_list|()
condition|)
return|return;
comment|/* On the first core, set up the maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_ciu_en0_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu_en1_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu_61xx_timer_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/* WORKQ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_WORKQ0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* GPIO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_GPIO0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* MBOX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MBOX0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* UART */
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_UART0
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|34
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_UART0
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|35
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_UART0
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* PCI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PCI_INT0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|36
argument_list|)
expr_stmt|;
comment|/* MSI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PCI_MSI0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|40
argument_list|)
expr_stmt|;
comment|/* TWSI */
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TWSI0
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TWSI0
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|)
expr_stmt|;
comment|/* other */
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_RML
argument_list|,
literal|0
argument_list|,
literal|46
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TRACE0
argument_list|,
literal|0
argument_list|,
literal|47
argument_list|)
expr_stmt|;
comment|/* GMX_DRP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_GMX_DRP0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|48
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPD_DRP
argument_list|,
literal|0
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_KEY_ZERO
argument_list|,
literal|0
argument_list|,
literal|51
argument_list|)
expr_stmt|;
comment|/* TIMER0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TIMER0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|52
argument_list|)
expr_stmt|;
comment|/* TIMER4..9 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TIMER4
operator|+
name|i
argument_list|,
literal|8
argument_list|,
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_USB0
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_USB0
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PCM
argument_list|,
literal|0
argument_list|,
literal|57
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MPI
argument_list|,
literal|0
argument_list|,
literal|58
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_POWIQ
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPDPPTHR
argument_list|,
literal|0
argument_list|,
literal|61
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MII0
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|62
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MII0
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_BOOTDMA
argument_list|,
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* WDOG */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_WDOG0
operator|+
name|i
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_NAND
argument_list|,
literal|1
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MIO
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IOB
argument_list|,
literal|1
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_FPA
argument_list|,
literal|1
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_POW
argument_list|,
literal|1
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_L2C
argument_list|,
literal|1
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPD
argument_list|,
literal|1
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PIP
argument_list|,
literal|1
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PKO
argument_list|,
literal|1
argument_list|,
literal|27
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_ZIP
argument_list|,
literal|1
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TIM
argument_list|,
literal|1
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_RAD
argument_list|,
literal|1
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_KEY
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DFA
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_USBCTL
argument_list|,
literal|1
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_SLI
argument_list|,
literal|1
argument_list|,
literal|34
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DPI
argument_list|,
literal|1
argument_list|,
literal|35
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_AGX0
argument_list|,
literal|1
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_AGX0
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DPI_DMA
argument_list|,
literal|1
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_AGL
argument_list|,
literal|1
argument_list|,
literal|46
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PTP
argument_list|,
literal|1
argument_list|,
literal|47
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PEM0
argument_list|,
literal|1
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PEM1
argument_list|,
literal|1
argument_list|,
literal|49
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_SRIO0
argument_list|,
literal|1
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_SRIO1
argument_list|,
literal|1
argument_list|,
literal|51
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_LMC0
argument_list|,
literal|1
argument_list|,
literal|52
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DFM
argument_list|,
literal|1
argument_list|,
literal|56
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_SRIO2
argument_list|,
literal|1
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_RST
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_interrupt_ciu2_initialize
parameter_list|(
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Disable all CIU2 interrupts by default */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_WRKQ
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_WRKQ
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WDOG
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_WDOG
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_WDOG
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_RML
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_RML
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_RML
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_MIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_MIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_MIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_IO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_IO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_IO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_MEM
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_MEM
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_MEM
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_PKT
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_PKT
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_PKT
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_GPIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_GPIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_GPIO
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_MBOX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP3_MBOX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU2_EN_PPX_IP4_MBOX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
operator|||
name|is_core_being_hot_plugged
argument_list|()
condition|)
return|return;
comment|/* On the first core, set up the maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_ciu2_wrkq_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_wdog_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_rml_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_mio_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_io_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_mem_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_eth_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_gpio_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|cvmx_ciu2_mbox_to_irq
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/* WORKQ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_WORKQ0
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* GPIO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_GPIO0
operator|+
name|i
argument_list|,
literal|7
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* MBOX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MBOX0
operator|+
name|i
argument_list|,
literal|60
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* UART */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_UART0
operator|+
name|i
argument_list|,
literal|3
argument_list|,
literal|36
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* PCI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PCI_INT0
operator|+
name|i
argument_list|,
literal|4
argument_list|,
literal|16
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* MSI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PCI_MSI0
operator|+
name|i
argument_list|,
literal|4
argument_list|,
literal|8
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* TWSI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TWSI0
operator|+
name|i
argument_list|,
literal|3
argument_list|,
literal|32
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* TRACE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TRACE0
operator|+
name|i
argument_list|,
literal|2
argument_list|,
literal|52
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* GMX_DRP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_GMX_DRP0
operator|+
name|i
argument_list|,
literal|6
argument_list|,
literal|8
operator|+
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPD_DRP
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* TIMER0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TIMER0
operator|+
name|i
argument_list|,
literal|3
argument_list|,
literal|8
operator|+
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_USB0
argument_list|,
literal|3
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPDPPTHR
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MII0
argument_list|,
literal|6
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_BOOTDMA
argument_list|,
literal|3
argument_list|,
literal|18
argument_list|)
expr_stmt|;
comment|/* WDOG */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_WDOG0
operator|+
name|i
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_NAND
argument_list|,
literal|3
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_MIO
argument_list|,
literal|3
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IOB
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_FPA
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_POW
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_L2C
argument_list|,
literal|2
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_IPD
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PIP
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PKO
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_ZIP
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_TIM
argument_list|,
literal|2
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_RAD
argument_list|,
literal|2
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_KEY
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DFA
argument_list|,
literal|2
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_USBCTL
argument_list|,
literal|3
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_SLI
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DPI
argument_list|,
literal|2
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_DPI_DMA
argument_list|,
literal|2
argument_list|,
literal|36
argument_list|)
expr_stmt|;
comment|/* AGX */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_AGX0
operator|+
name|i
argument_list|,
literal|6
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_AGL
argument_list|,
literal|6
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PTP
argument_list|,
literal|3
argument_list|,
literal|48
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PEM0
argument_list|,
literal|4
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_PEM1
argument_list|,
literal|4
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* LMC */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_LMC0
operator|+
name|i
argument_list|,
literal|5
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_RST
argument_list|,
literal|3
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|__cvmx_interrupt_set_mapping
argument_list|(
name|CVMX_IRQ_ILK
argument_list|,
literal|6
argument_list|,
literal|48
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize the interrupt routine and copy the low level  * stub into the correct interrupt vector. This is called  * automatically during application startup.  */
end_comment

begin_function
name|void
name|cvmx_interrupt_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|low_level_loc
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
operator|&&
operator|!
name|is_core_being_hot_plugged
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
comment|/* We assume this relationship between the registers. */
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x1000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_WDOG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x2000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_RML
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x3000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_MIO
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x4000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_IO
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x5000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_MEM
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x6000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_PKT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_SRC_PPX_IP2_WRKQ
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x7000
operator|==
name|CVMX_CIU2_SRC_PPX_IP2_GPIO
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x1000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_WDOG_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x2000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_RML_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x3000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_MIO_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x4000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_IO_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x5000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_MEM_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x6000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_PKT_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x7000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_GPIO_W1C
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x1000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_WDOG_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x2000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_RML_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x3000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_MIO_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x4000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_IO_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x5000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_MEM_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x6000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_PKT_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_BUILD_ASSERT
argument_list|(
name|CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S
argument_list|(
literal|0
argument_list|)
operator|+
literal|0x7000
operator|==
name|CVMX_CIU2_EN_PPX_IP2_GPIO_W1S
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !CVMX_ENABLE_CSR_ADDRESS_CHECKING */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_IRQ_MAX
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|.
name|handler
operator|=
name|__cvmx_interrupt_default
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|cvmx_interrupt_state
operator|.
name|handlers
index|[
name|i
index|]
operator|.
name|handler_data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_interrupt_mask_irq
operator|=
name|__cvmx_interrupt_ciu2_mask_irq
expr_stmt|;
name|cvmx_interrupt_unmask_irq
operator|=
name|__cvmx_interrupt_ciu2_unmask_irq
expr_stmt|;
name|cvmx_interrupt_ciu2_initialize
argument_list|(
name|sys_info_ptr
argument_list|)
expr_stmt|;
comment|/* Add an interrupt handlers for chained CIU interrupt */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS2
argument_list|,
name|__cvmx_interrupt_ciu2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_2
argument_list|)
condition|)
block|{
name|cvmx_interrupt_mask_irq
operator|=
name|__cvmx_interrupt_ciu_mask_irq
expr_stmt|;
name|cvmx_interrupt_unmask_irq
operator|=
name|__cvmx_interrupt_ciu_unmask_irq
expr_stmt|;
name|cvmx_interrupt_ciu_initialize
argument_list|(
name|sys_info_ptr
argument_list|)
expr_stmt|;
comment|/* Add an interrupt handlers for chained CIU interrupts */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS2
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS3
argument_list|,
name|__cvmx_interrupt_ciu_cn61xx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_interrupt_mask_irq
operator|=
name|__cvmx_interrupt_ciu_mask_irq
expr_stmt|;
name|cvmx_interrupt_unmask_irq
operator|=
name|__cvmx_interrupt_ciu_unmask_irq
expr_stmt|;
name|cvmx_interrupt_ciu_initialize
argument_list|(
name|sys_info_ptr
argument_list|)
expr_stmt|;
comment|/* Add an interrupt handlers for chained CIU interrupts */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS2
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS3
argument_list|,
name|__cvmx_interrupt_ciu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Move performance counter interrupts to IRQ 6*/
name|cvmx_update_perfcnt_irq
argument_list|()
expr_stmt|;
comment|/* Add an interrupt handler for Perf counter interrupts */
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIPS6
argument_list|,
name|__cvmx_interrupt_perf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
operator|&&
operator|!
name|is_core_being_hot_plugged
argument_list|()
condition|)
block|{
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|__cvmx_interrupt_default_exception_handler
expr_stmt|;
name|low_level_loc
operator|=
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|sys_info_ptr
operator|->
name|exception_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x80
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x100
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_cache_error
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x180
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|low_level_loc
operator|+
literal|0x200
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cvmx_interrupt_stage1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Make sure the locations used to count Icache and Dcache exceptions             starts out as zero */
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write64_uint64
argument_list|(
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
literal|24
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Add an interrupt handler for ECC failures */
if|if
condition|(
name|cvmx_error_initialize
argument_list|(
literal|0
comment|/* || CVMX_ERROR_FLAGS_ECC_SINGLE_BIT */
argument_list|)
condition|)
name|cvmx_warn
argument_list|(
literal|"cvmx_error_initialize() failed\n"
argument_list|)
expr_stmt|;
comment|/* Enable PIP/IPD, POW, PKO, FPA, NAND, KEY, RAD, L2C, LMC, GMX, AGL,            DFM, DFA, error handling interrupts. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_AGX0
operator|+
name|i
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_AGX0
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_NAND
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_NAND
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MIO
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MIO
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_FPA
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_FPA
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_IPD
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_IPD
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_PIP
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_PIP
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_POW
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_POW
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_L2C
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_L2C
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_PKO
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_PKO
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_ZIP
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_ZIP
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_RAD
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_RAD
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_KEY
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_KEY
argument_list|)
expr_stmt|;
comment|/* Before enabling SLI interrupt clear any RML_TO interrupt */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_INT_SUM
argument_list|)
operator|&
literal|0x1
condition|)
block|{
name|cvmx_safe_printf
argument_list|(
literal|"clearing pending SLI_INT_SUM[RML_TO] interrupt (ignore)\n"
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_INT_SUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_SLI
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_SLI
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_DPI
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_DPI
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_DFA
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_DFA
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_AGL
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_AGL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_LMC0
operator|+
name|i
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_LMC0
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_DFM
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_DFM
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_RST
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_RST
argument_list|)
expr_stmt|;
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_ILK
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_ILK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_RML
argument_list|,
name|__cvmx_interrupt_ecc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_RML
argument_list|)
expr_stmt|;
block|}
name|cvmx_atomic_set32
argument_list|(
operator|&
name|cvmx_interrupt_initialize_flag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|cvmx_atomic_get32
argument_list|(
operator|&
name|cvmx_interrupt_initialize_flag
argument_list|)
condition|)
empty_stmt|;
comment|/* Wait for first core to finish above. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MIPS2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MIPS2
argument_list|)
expr_stmt|;
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MIPS3
argument_list|)
expr_stmt|;
block|}
name|CVMX_ICACHE_INVALIDATE
expr_stmt|;
comment|/* Enable interrupts for each core (bit0 of COP0 Status) */
name|cvmx_interrupt_restore
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the exception handler for all non interrupt sources.  *  * @param handler New exception handler  * @return Old exception handler  */
end_comment

begin_function
name|cvmx_interrupt_exception_t
name|cvmx_interrupt_set_exception
parameter_list|(
name|cvmx_interrupt_exception_t
name|handler
parameter_list|)
block|{
name|cvmx_interrupt_exception_t
name|result
init|=
name|cvmx_interrupt_state
operator|.
name|exception_handler
decl_stmt|;
name|cvmx_interrupt_state
operator|.
name|exception_handler
operator|=
name|handler
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__U_BOOT__ */
end_comment

end_unit

