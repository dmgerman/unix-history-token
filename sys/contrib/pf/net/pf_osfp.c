begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pf_osfp.c,v 1.14 2008/06/12 18:17:01 henning Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003 Mike Frantzen<frantzen@w4g.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|<sys/pool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|format
parameter_list|,
name|x
modifier|...
parameter_list|)
define|\
value|if (V_pf_status.debug>= PF_DEBUG_NOISY)	\ 		printf(format , ##x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|format
parameter_list|,
name|x
modifier|...
parameter_list|)
define|\
value|if (pf_status.debug>= PF_DEBUG_NOISY)	\ 		printf(format , ##x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_typedef
typedef|typedef
name|uma_zone_t
name|pool_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|pool
name|pool_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Userland equivalents so we can lend code to tcpdump et al. */
end_comment

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_define
define|#
directive|define
name|pool_t
value|int
end_define

begin_define
define|#
directive|define
name|pool_get
parameter_list|(
name|pool
parameter_list|,
name|flags
parameter_list|)
value|malloc(*(pool))
end_define

begin_define
define|#
directive|define
name|pool_put
parameter_list|(
name|pool
parameter_list|,
name|item
parameter_list|)
value|free(item)
end_define

begin_define
define|#
directive|define
name|pool_init
parameter_list|(
name|pool
parameter_list|,
name|size
parameter_list|,
name|a
parameter_list|,
name|ao
parameter_list|,
name|f
parameter_list|,
name|m
parameter_list|,
name|p
parameter_list|)
value|(*(pool)) = (size)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|NTOHS
parameter_list|(
name|x
parameter_list|)
value|(x) = ntohs((u_int16_t)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PFDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/stdarg.h>
end_include

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|format
parameter_list|,
name|x
modifier|...
parameter_list|)
value|fprintf(stderr, format , ##x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|format
parameter_list|,
name|x
modifier|...
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PFDEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|pf_osfp_list
argument_list|,
name|pf_os_fingerprint
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pf_osfp_list
argument_list|,
name|pf_osfp_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pf_osfp_list
value|VNET(pf_osfp_list)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|pool_t
argument_list|,
name|pf_osfp_entry_pl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|pf_osfp_entry_pl
value|VNET(pf_osfp_entry_pl)
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|pool_t
argument_list|,
name|pf_osfp_pl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|pf_osfp_pl
value|VNET(pf_osfp_pl)
end_define

begin_else
else|#
directive|else
end_else

begin_macro
name|SLIST_HEAD
argument_list|(
argument|pf_osfp_list
argument_list|,
argument|pf_os_fingerprint
argument_list|)
end_macro

begin_expr_stmt
name|pf_osfp_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pool_t
name|pf_osfp_entry_pl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pool_t
name|pf_osfp_pl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|pf_os_fingerprint
modifier|*
name|pf_osfp_find
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|pf_os_fingerprint
modifier|*
name|pf_osfp_find_exact
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_osfp_insert
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * Passively fingerprint the OS of the host (IPv4 TCP SYN packets only)  * Returns the list of possible OSes.  */
end_comment

begin_function
name|struct
name|pf_osfp_enlist
modifier|*
name|pf_osfp_fingerprint
parameter_list|(
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
specifier|const
name|struct
name|tcphdr
modifier|*
name|tcp
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|char
name|hdr
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pd
operator|->
name|af
operator|!=
name|PF_INET
operator|&&
name|pd
operator|->
name|af
operator|!=
name|PF_INET6
operator|)
operator|||
name|pd
operator|->
name|proto
operator|!=
name|IPPROTO_TCP
operator|||
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|pd
operator|->
name|af
operator|==
name|PF_INET
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|NULL
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|tcp
operator|->
name|th_off
operator|<<
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pf_osfp_fingerprint_hdr
argument_list|(
name|ip
argument_list|,
name|ip6
argument_list|,
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
name|hdr
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_function
name|struct
name|pf_osfp_enlist
modifier|*
name|pf_osfp_fingerprint_hdr
parameter_list|(
specifier|const
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
parameter_list|,
specifier|const
name|struct
name|tcphdr
modifier|*
name|tcp
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
name|fp
decl_stmt|,
modifier|*
name|fpresult
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|optlen
init|=
literal|0
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|optp
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|char
name|srcname
index|[
literal|128
index|]
decl_stmt|;
else|#
directive|else
name|char
name|srcname
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_SYN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ip
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_OFFMASK
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
ifndef|#
directive|ifndef
name|_KERNEL
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
name|fp
operator|.
name|fp_psize
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|fp
operator|.
name|fp_ttl
operator|=
name|ip
operator|->
name|ip_ttl
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_DF
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|strlcpy
argument_list|(
name|srcname
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|srcname
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
operator|(
name|void
operator|)
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|,
name|srcname
argument_list|,
sizeof|sizeof
argument_list|(
name|srcname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|INET6
elseif|else
if|if
condition|(
name|ip6
condition|)
block|{
ifndef|#
directive|ifndef
name|_KERNEL
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
comment|/* jumbo payload? */
name|fp
operator|.
name|fp_psize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|fp
operator|.
name|fp_ttl
operator|=
name|ip6
operator|->
name|ip6_hlim
expr_stmt|;
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_DF
expr_stmt|;
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_INET6
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|strlcpy
argument_list|(
name|srcname
argument_list|,
name|ip6_sprintf
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|srcname
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
operator|(
name|void
operator|)
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|,
name|srcname
argument_list|,
sizeof|sizeof
argument_list|(
name|srcname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|fp
operator|.
name|fp_wsize
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
name|cnt
operator|=
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
expr_stmt|;
name|optp
operator|=
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|tcp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|optp
operator|+=
name|optlen
control|)
block|{
if|if
condition|(
operator|*
name|optp
operator|==
name|TCPOPT_EOL
condition|)
break|break;
name|fp
operator|.
name|fp_optcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|optp
operator|==
name|TCPOPT_NOP
condition|)
block|{
name|fp
operator|.
name|fp_tcpopts
operator|=
operator|(
name|fp
operator|.
name|fp_tcpopts
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_NOP
expr_stmt|;
name|optlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|optlen
operator|=
name|optp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|>
name|cnt
operator|||
name|optlen
operator|<
literal|2
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
operator|*
name|optp
condition|)
block|{
case|case
name|TCPOPT_MAXSEG
case|:
if|if
condition|(
name|optlen
operator|>=
name|TCPOLEN_MAXSEG
condition|)
name|memcpy
argument_list|(
operator|&
name|fp
operator|.
name|fp_mss
argument_list|,
operator|&
name|optp
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_mss
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|.
name|fp_tcpopts
operator|=
operator|(
name|fp
operator|.
name|fp_tcpopts
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_MSS
expr_stmt|;
name|NTOHS
argument_list|(
name|fp
operator|.
name|fp_mss
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPOPT_WINDOW
case|:
if|if
condition|(
name|optlen
operator|>=
name|TCPOLEN_WINDOW
condition|)
name|memcpy
argument_list|(
operator|&
name|fp
operator|.
name|fp_wscale
argument_list|,
operator|&
name|optp
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|.
name|fp_wscale
argument_list|)
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|fp
operator|.
name|fp_wscale
argument_list|)
expr_stmt|;
name|fp
operator|.
name|fp_tcpopts
operator|=
operator|(
name|fp
operator|.
name|fp_tcpopts
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_WSCALE
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK_PERMITTED
case|:
name|fp
operator|.
name|fp_tcpopts
operator|=
operator|(
name|fp
operator|.
name|fp_tcpopts
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_SACK
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
if|if
condition|(
name|optlen
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
name|u_int32_t
name|ts
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|optp
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
literal|0
condition|)
name|fp
operator|.
name|fp_flags
operator||=
name|PF_OSFP_TS0
expr_stmt|;
block|}
name|fp
operator|.
name|fp_tcpopts
operator|=
operator|(
name|fp
operator|.
name|fp_tcpopts
operator|<<
name|PF_OSFP_TCPOPT_BITS
operator|)
operator||
name|PF_OSFP_TCPOPT_TS
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|optlen
operator|=
name|MAX
argument_list|(
name|optlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* paranoia */
block|}
name|DPFPRINTF
argument_list|(
literal|"fingerprinted %s:%d  %d:%d:%d:%d:%llx (%d) "
literal|"(TS=%s,M=%s%d,W=%s%d)\n"
argument_list|,
name|srcname
argument_list|,
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
argument_list|,
name|fp
operator|.
name|fp_wsize
argument_list|,
name|fp
operator|.
name|fp_ttl
argument_list|,
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_DF
operator|)
operator|!=
literal|0
argument_list|,
name|fp
operator|.
name|fp_psize
argument_list|,
operator|(
name|long
name|long
name|int
operator|)
name|fp
operator|.
name|fp_tcpopts
argument_list|,
name|fp
operator|.
name|fp_optcnt
argument_list|,
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_TS0
operator|)
condition|?
literal|"0"
else|:
literal|""
argument_list|,
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_MSS_MOD
operator|)
condition|?
literal|"%"
else|:
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_MSS_DC
operator|)
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|fp
operator|.
name|fp_mss
argument_list|,
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_WSCALE_MOD
operator|)
condition|?
literal|"%"
else|:
operator|(
name|fp
operator|.
name|fp_flags
operator|&
name|PF_OSFP_WSCALE_DC
operator|)
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|fp
operator|.
name|fp_wscale
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
operator|(
name|fpresult
operator|=
name|pf_osfp_find
argument_list|(
argument|&V_pf_osfp_list
argument_list|,
argument|&fp
argument_list|,
else|#
directive|else
argument|if ((fpresult = pf_osfp_find(&pf_osfp_list,&fp,
endif|#
directive|endif
argument|PF_OSFP_MAXTTL_OFFSET))) 		return (&fpresult->fp_oses); 	return (NULL); }
comment|/* Match a fingerprint ID against a list of OSes */
argument|int pf_osfp_match(struct pf_osfp_enlist *list, pf_osfp_t os) { 	struct pf_osfp_entry *entry; 	int os_class
argument_list|,
argument|os_version
argument_list|,
argument|os_subtype; 	int en_class
argument_list|,
argument|en_version
argument_list|,
argument|en_subtype;  	if (os == PF_OSFP_ANY) 		return (
literal|1
argument|); 	if (list == NULL) { 		DPFPRINTF(
literal|"osfp no match against %x\n"
argument|, os); 		return (os == PF_OSFP_UNKNOWN); 	} 	PF_OSFP_UNPACK(os, os_class, os_version, os_subtype); 	SLIST_FOREACH(entry, list, fp_entry) { 		PF_OSFP_UNPACK(entry->fp_os, en_class, en_version, en_subtype); 		if ((os_class == PF_OSFP_ANY || en_class == os_class)&& 		    (os_version == PF_OSFP_ANY || en_version == os_version)&& 		    (os_subtype == PF_OSFP_ANY || en_subtype == os_subtype)) { 			DPFPRINTF(
literal|"osfp matched %s %s %s  %x==%x\n"
argument|, 			    entry->fp_class_nm, entry->fp_version_nm, 			    entry->fp_subtype_nm, os, entry->fp_os); 			return (
literal|1
argument|); 		} 	} 	DPFPRINTF(
literal|"fingerprint 0x%x didn't match\n"
argument|, os); 	return (
literal|0
argument|); }
comment|/* Initialize the OS fingerprint system */
ifdef|#
directive|ifdef
name|__FreeBSD__
argument|int
else|#
directive|else
argument|void
endif|#
directive|endif
argument|pf_osfp_initialize(void) {
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
argument|int error = ENOMEM;  	do { 		pf_osfp_entry_pl = pf_osfp_pl = NULL; 		UMA_CREATE(pf_osfp_entry_pl, struct pf_osfp_entry,
literal|"pfospfen"
argument|); 		UMA_CREATE(pf_osfp_pl, struct pf_os_fingerprint,
literal|"pfosfp"
argument|); 		error =
literal|0
argument|; 	} while(
literal|0
argument|);  	SLIST_INIT(&V_pf_osfp_list);
else|#
directive|else
argument|pool_init(&pf_osfp_entry_pl, sizeof(struct pf_osfp_entry),
literal|0
argument|,
literal|0
argument|,
literal|0
argument|,
literal|"pfosfpen"
argument|,&pool_allocator_nointr); 	pool_init(&pf_osfp_pl, sizeof(struct pf_os_fingerprint),
literal|0
argument|,
literal|0
argument|,
literal|0
argument|,
literal|"pfosfp"
argument|,&pool_allocator_nointr); 	SLIST_INIT(&pf_osfp_list);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
ifdef|#
directive|ifdef
name|_KERNEL
argument|return (error);
else|#
directive|else
argument|return (
literal|0
argument|);
endif|#
directive|endif
endif|#
directive|endif
argument|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|_KERNEL
operator|)
argument|void pf_osfp_cleanup(void) {  	UMA_DESTROY(pf_osfp_entry_pl); 	UMA_DESTROY(pf_osfp_pl); }
endif|#
directive|endif
comment|/* Flush the fingerprint list */
argument|void pf_osfp_flush(void) { 	struct pf_os_fingerprint *fp; 	struct pf_osfp_entry *entry;
ifdef|#
directive|ifdef
name|__FreeBSD__
argument|while ((fp = SLIST_FIRST(&V_pf_osfp_list))) { 		SLIST_REMOVE_HEAD(&V_pf_osfp_list, fp_next);
else|#
directive|else
argument|while ((fp = SLIST_FIRST(&pf_osfp_list))) { 		SLIST_REMOVE_HEAD(&pf_osfp_list, fp_next);
endif|#
directive|endif
argument|while ((entry = SLIST_FIRST(&fp->fp_oses))) { 			SLIST_REMOVE_HEAD(&fp->fp_oses, fp_entry); 			pool_put(&pf_osfp_entry_pl, entry); 		} 		pool_put(&pf_osfp_pl, fp); 	} }
comment|/* Add a fingerprint */
argument|int pf_osfp_add(struct pf_osfp_ioctl *fpioc) { 	struct pf_os_fingerprint *fp
argument_list|,
argument|fpadd; 	struct pf_osfp_entry *entry;  	memset(&fpadd,
literal|0
argument|, sizeof(fpadd)); 	fpadd.fp_tcpopts = fpioc->fp_tcpopts; 	fpadd.fp_wsize = fpioc->fp_wsize; 	fpadd.fp_psize = fpioc->fp_psize; 	fpadd.fp_mss = fpioc->fp_mss; 	fpadd.fp_flags = fpioc->fp_flags; 	fpadd.fp_optcnt = fpioc->fp_optcnt; 	fpadd.fp_wscale = fpioc->fp_wscale; 	fpadd.fp_ttl = fpioc->fp_ttl;
if|#
directive|if
literal|0
comment|/* XXX RYAN wants to fix logging */
argument|DPFPRINTF("adding osfp %s %s %s = %s%d:%d:%d:%s%d:0x%llx %d " 	    "(TS=%s,M=%s%d,W=%s%d) %x\n", 	    fpioc->fp_os.fp_class_nm, fpioc->fp_os.fp_version_nm, 	    fpioc->fp_os.fp_subtype_nm, 	    (fpadd.fp_flags& PF_OSFP_WSIZE_MOD) ? "%" : 	    (fpadd.fp_flags& PF_OSFP_WSIZE_MSS) ? "S" : 	    (fpadd.fp_flags& PF_OSFP_WSIZE_MTU) ? "T" : 	    (fpadd.fp_flags& PF_OSFP_WSIZE_DC) ? "*" : "", 	    fpadd.fp_wsize, 	    fpadd.fp_ttl, 	    (fpadd.fp_flags& PF_OSFP_DF) ? 1 : 0, 	    (fpadd.fp_flags& PF_OSFP_PSIZE_MOD) ? "%" : 	    (fpadd.fp_flags& PF_OSFP_PSIZE_DC) ? "*" : "", 	    fpadd.fp_psize, 	    (long long int)fpadd.fp_tcpopts, fpadd.fp_optcnt, 	    (fpadd.fp_flags& PF_OSFP_TS0) ? "0" : "", 	    (fpadd.fp_flags& PF_OSFP_MSS_MOD) ? "%" : 	    (fpadd.fp_flags& PF_OSFP_MSS_DC) ? "*" : "", 	    fpadd.fp_mss, 	    (fpadd.fp_flags& PF_OSFP_WSCALE_MOD) ? "%" : 	    (fpadd.fp_flags& PF_OSFP_WSCALE_DC) ? "*" : "", 	    fpadd.fp_wscale, 	    fpioc->fp_os.fp_os);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
argument|if ((fp = pf_osfp_find_exact(&V_pf_osfp_list,&fpadd))) {
else|#
directive|else
argument|if ((fp = pf_osfp_find_exact(&pf_osfp_list,&fpadd))) {
endif|#
directive|endif
argument|SLIST_FOREACH(entry,&fp->fp_oses, fp_entry) { 			if (PF_OSFP_ENTRY_EQ(entry,&fpioc->fp_os)) 				return (EEXIST); 		} 		if ((entry = pool_get(&pf_osfp_entry_pl,
ifdef|#
directive|ifdef
name|__FreeBSD__
argument|PR_NOWAIT)) == NULL)
else|#
directive|else
argument|PR_WAITOK|PR_LIMITFAIL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_else
else|else
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_osfp_pl
argument_list|,
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PR_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
name|PR_WAITOK
operator||
name|PR_LIMITFAIL
block|)
end_else

begin_expr_stmt
unit|)
operator|==
name|NULL
end_expr_stmt

begin_endif
unit|)
endif|#
directive|endif
end_endif

begin_return
return|return
operator|(
name|ENOMEM
operator|)
return|;
end_return

begin_expr_stmt
name|memset
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_tcpopts
operator|=
name|fpioc
operator|->
name|fp_tcpopts
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_wsize
operator|=
name|fpioc
operator|->
name|fp_wsize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_psize
operator|=
name|fpioc
operator|->
name|fp_psize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_mss
operator|=
name|fpioc
operator|->
name|fp_mss
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_flags
operator|=
name|fpioc
operator|->
name|fp_flags
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_optcnt
operator|=
name|fpioc
operator|->
name|fp_optcnt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_wscale
operator|=
name|fpioc
operator|->
name|fp_wscale
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|->
name|fp_ttl
operator|=
name|fpioc
operator|->
name|fp_ttl
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SLIST_INIT
argument_list|(
operator|&
name|fp
operator|->
name|fp_oses
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|entry
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_osfp_entry_pl
argument_list|,
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PR_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
name|PR_WAITOK
operator||
name|PR_LIMITFAIL
block|)
end_if

begin_expr_stmt
unit|)
operator|==
name|NULL
end_expr_stmt

begin_block
unit|)
block|{
endif|#
directive|endif
name|pool_put
argument_list|(
operator|&
name|pf_osfp_pl
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|pf_osfp_insert
argument_list|(
operator|&
name|V_pf_osfp_list
argument_list|,
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|pf_osfp_insert
argument_list|(
operator|&
name|pf_osfp_list
argument_list|,
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|} 	memcpy
operator|(
name|entry
operator|,
operator|&
name|fpioc
operator|->
name|fp_os
operator|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Make sure the strings are NUL terminated */
end_comment

begin_expr_stmt
name|entry
operator|->
name|fp_class_nm
index|[
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|fp_class_nm
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|entry
operator|->
name|fp_version_nm
index|[
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|fp_version_nm
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|entry
operator|->
name|fp_subtype_nm
index|[
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|fp_subtype_nm
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|fp
operator|->
name|fp_oses
argument_list|,
name|entry
argument_list|,
name|fp_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PFDEBUG
end_ifdef

begin_if
if|if
condition|(
operator|(
name|fp
operator|=
name|pf_osfp_validate
argument_list|()
operator|)
condition|)
name|printf
argument_list|(
literal|"Invalid fingerprint list\n"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PFDEBUG */
end_comment

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* Find a fingerprint in the list */
end_comment

begin_function
unit|struct
name|pf_os_fingerprint
modifier|*
name|pf_osfp_find
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
name|list
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
name|find
parameter_list|,
name|u_int8_t
name|ttldiff
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
modifier|*
name|f
decl_stmt|;
define|#
directive|define
name|MATCH_INT
parameter_list|(
name|_MOD
parameter_list|,
name|_DC
parameter_list|,
name|_field
parameter_list|)
define|\
value|if ((f->fp_flags& _DC) == 0) {					\ 		if ((f->fp_flags& _MOD) == 0) {			\ 			if (f->_field != find->_field)			\ 				continue;				\ 		} else {						\ 			if (f->_field == 0 || find->_field % f->_field)	\ 				continue;				\ 		}							\ 	}
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|list
argument_list|,
argument|fp_next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|fp_tcpopts
operator|!=
name|find
operator|->
name|fp_tcpopts
operator|||
name|f
operator|->
name|fp_optcnt
operator|!=
name|find
operator|->
name|fp_optcnt
operator|||
name|f
operator|->
name|fp_ttl
operator|<
name|find
operator|->
name|fp_ttl
operator|||
name|f
operator|->
name|fp_ttl
operator|-
name|find
operator|->
name|fp_ttl
operator|>
name|ttldiff
operator|||
operator|(
name|f
operator|->
name|fp_flags
operator|&
operator|(
name|PF_OSFP_DF
operator||
name|PF_OSFP_TS0
operator|)
operator|)
operator|!=
operator|(
name|find
operator|->
name|fp_flags
operator|&
operator|(
name|PF_OSFP_DF
operator||
name|PF_OSFP_TS0
operator|)
operator|)
condition|)
continue|continue;
name|MATCH_INT
argument_list|(
argument|PF_OSFP_PSIZE_MOD
argument_list|,
argument|PF_OSFP_PSIZE_DC
argument_list|,
argument|fp_psize
argument_list|)
name|MATCH_INT
argument_list|(
argument|PF_OSFP_MSS_MOD
argument_list|,
argument|PF_OSFP_MSS_DC
argument_list|,
argument|fp_mss
argument_list|)
name|MATCH_INT
argument_list|(
argument|PF_OSFP_WSCALE_MOD
argument_list|,
argument|PF_OSFP_WSCALE_DC
argument_list|,
argument|fp_wscale
argument_list|)
if|if
condition|(
operator|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_DC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MSS
condition|)
block|{
if|if
condition|(
name|find
operator|->
name|fp_mss
operator|==
literal|0
condition|)
continue|continue;
comment|/*  * Some "smart" NAT devices and DSL routers will tweak the MSS size and  * will set it to whatever is suitable for the link type.  */
define|#
directive|define
name|SMART_MSS
value|1460
if|if
condition|(
operator|(
name|find
operator|->
name|fp_wsize
operator|%
name|find
operator|->
name|fp_mss
operator|||
name|find
operator|->
name|fp_wsize
operator|/
name|find
operator|->
name|fp_mss
operator|!=
name|f
operator|->
name|fp_wsize
operator|)
operator|&&
operator|(
name|find
operator|->
name|fp_wsize
operator|%
name|SMART_MSS
operator|||
name|find
operator|->
name|fp_wsize
operator|/
name|SMART_MSS
operator|!=
name|f
operator|->
name|fp_wsize
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MTU
condition|)
block|{
if|if
condition|(
name|find
operator|->
name|fp_mss
operator|==
literal|0
condition|)
continue|continue;
define|#
directive|define
name|MTUOFF
value|(sizeof(struct ip) + sizeof(struct tcphdr))
define|#
directive|define
name|SMART_MTU
value|(SMART_MSS + MTUOFF)
if|if
condition|(
operator|(
name|find
operator|->
name|fp_wsize
operator|%
operator|(
name|find
operator|->
name|fp_mss
operator|+
name|MTUOFF
operator|)
operator|||
name|find
operator|->
name|fp_wsize
operator|/
operator|(
name|find
operator|->
name|fp_mss
operator|+
name|MTUOFF
operator|)
operator|!=
name|f
operator|->
name|fp_wsize
operator|)
operator|&&
operator|(
name|find
operator|->
name|fp_wsize
operator|%
name|SMART_MTU
operator|||
name|find
operator|->
name|fp_wsize
operator|/
name|SMART_MTU
operator|!=
name|f
operator|->
name|fp_wsize
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MOD
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fp_wsize
operator|==
literal|0
operator|||
name|find
operator|->
name|fp_wsize
operator|%
name|f
operator|->
name|fp_wsize
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|fp_wsize
operator|!=
name|find
operator|->
name|fp_wsize
condition|)
continue|continue;
block|}
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find an exact fingerprint in the list */
end_comment

begin_function
name|struct
name|pf_os_fingerprint
modifier|*
name|pf_osfp_find_exact
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
name|list
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
name|find
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
modifier|*
name|f
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|list
argument_list|,
argument|fp_next
argument_list|)
block|{
if|if
condition|(
name|f
operator|->
name|fp_tcpopts
operator|==
name|find
operator|->
name|fp_tcpopts
operator|&&
name|f
operator|->
name|fp_wsize
operator|==
name|find
operator|->
name|fp_wsize
operator|&&
name|f
operator|->
name|fp_psize
operator|==
name|find
operator|->
name|fp_psize
operator|&&
name|f
operator|->
name|fp_mss
operator|==
name|find
operator|->
name|fp_mss
operator|&&
name|f
operator|->
name|fp_flags
operator|==
name|find
operator|->
name|fp_flags
operator|&&
name|f
operator|->
name|fp_optcnt
operator|==
name|find
operator|->
name|fp_optcnt
operator|&&
name|f
operator|->
name|fp_wscale
operator|==
name|find
operator|->
name|fp_wscale
operator|&&
name|f
operator|->
name|fp_ttl
operator|==
name|find
operator|->
name|fp_ttl
condition|)
return|return
operator|(
name|f
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insert a fingerprint into the list */
end_comment

begin_function
name|void
name|pf_osfp_insert
parameter_list|(
name|struct
name|pf_osfp_list
modifier|*
name|list
parameter_list|,
name|struct
name|pf_os_fingerprint
modifier|*
name|ins
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
modifier|*
name|f
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* XXX need to go semi tree based.  can key on tcp options */
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|list
argument_list|,
argument|fp_next
argument_list|)
name|prev
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|SLIST_INSERT_AFTER
argument_list|(
name|prev
argument_list|,
name|ins
argument_list|,
name|fp_next
argument_list|)
expr_stmt|;
else|else
name|SLIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|ins
argument_list|,
name|fp_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill a fingerprint by its number (from an ioctl) */
end_comment

begin_function
name|int
name|pf_osfp_get
parameter_list|(
name|struct
name|pf_osfp_ioctl
modifier|*
name|fpioc
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
modifier|*
name|fp
decl_stmt|;
name|struct
name|pf_osfp_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|num
init|=
name|fpioc
operator|->
name|fp_getnum
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|fpioc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fpioc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|SLIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&V_pf_osfp_list
argument_list|,
argument|fp_next
argument_list|)
block|{
else|#
directive|else
name|SLIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&pf_osfp_list
argument_list|,
argument|fp_next
argument_list|)
block|{
endif|#
directive|endif
name|SLIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&fp->fp_oses
argument_list|,
argument|fp_entry
argument_list|)
block|{
if|if
condition|(
name|i
operator|++
operator|==
name|num
condition|)
block|{
name|fpioc
operator|->
name|fp_mss
operator|=
name|fp
operator|->
name|fp_mss
expr_stmt|;
name|fpioc
operator|->
name|fp_wsize
operator|=
name|fp
operator|->
name|fp_wsize
expr_stmt|;
name|fpioc
operator|->
name|fp_flags
operator|=
name|fp
operator|->
name|fp_flags
expr_stmt|;
name|fpioc
operator|->
name|fp_psize
operator|=
name|fp
operator|->
name|fp_psize
expr_stmt|;
name|fpioc
operator|->
name|fp_ttl
operator|=
name|fp
operator|->
name|fp_ttl
expr_stmt|;
name|fpioc
operator|->
name|fp_wscale
operator|=
name|fp
operator|->
name|fp_wscale
expr_stmt|;
name|fpioc
operator|->
name|fp_getnum
operator|=
name|num
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fpioc
operator|->
name|fp_os
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|fpioc
operator|->
name|fp_os
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Validate that each signature is reachable */
name|struct
name|pf_os_fingerprint
modifier|*
name|pf_osfp_validate
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_os_fingerprint
modifier|*
name|f
decl_stmt|,
modifier|*
name|f2
decl_stmt|,
name|find
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&V_pf_osfp_list
argument_list|,
argument|fp_next
argument_list|)
block|{
else|#
directive|else
name|SLIST_FOREACH
argument_list|(
argument|f
argument_list|,
argument|&pf_osfp_list
argument_list|,
argument|fp_next
argument_list|)
block|{
endif|#
directive|endif
name|memcpy
argument_list|(
operator|&
name|find
argument_list|,
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|find
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do a few MSS/th_win percolations to make things unique */
if|if
condition|(
name|find
operator|.
name|fp_mss
operator|==
literal|0
condition|)
name|find
operator|.
name|fp_mss
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MSS
condition|)
name|find
operator|.
name|fp_wsize
operator|*=
name|find
operator|.
name|fp_mss
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MTU
condition|)
name|find
operator|.
name|fp_wsize
operator|*=
operator|(
name|find
operator|.
name|fp_mss
operator|+
literal|40
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|->
name|fp_flags
operator|&
name|PF_OSFP_WSIZE_MOD
condition|)
name|find
operator|.
name|fp_wsize
operator|*=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|f
operator|!=
operator|(
name|f2
operator|=
name|pf_osfp_find
argument_list|(
operator|&
name|V_pf_osfp_list
argument_list|,
operator|&
name|find
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|f
operator|!=
operator|(
name|f2
operator|=
name|pf_osfp_find
argument_list|(
operator|&
name|pf_osfp_list
argument_list|,
operator|&
name|find
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|f2
condition|)
name|printf
argument_list|(
literal|"Found \"%s %s %s\" instead of "
literal|"\"%s %s %s\"\n"
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f2
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_class_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f2
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_version_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f2
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_subtype_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_class_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_version_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_subtype_nm
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Couldn't find \"%s %s %s\"\n"
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_class_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_version_nm
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|f
operator|->
name|fp_oses
argument_list|)
operator|->
name|fp_subtype_nm
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

