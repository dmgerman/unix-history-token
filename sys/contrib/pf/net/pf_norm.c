begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: pf_norm.c,v 1.80.2.1 2004/04/30 21:46:33 brad Exp $ */
end_comment

begin_comment
comment|/* add	$OpenBSD: pf_norm.c,v 1.87 2004/05/11 07:34:11 dhartmei Exp $ */
end_comment

begin_comment
comment|/*  * Copyright 2001 Niels Provos<provos@citi.umich.edu>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_pf.h"
end_include

begin_define
define|#
directive|define
name|NPFLOG
value|DEV_PFLOG
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"pflog.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|<sys/pool.h>
end_include

begin_include
include|#
directive|include
file|<dev/rndvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_struct
struct|struct
name|pf_frent
block|{
name|LIST_ENTRY
argument_list|(
argument|pf_frent
argument_list|)
name|fr_next
expr_stmt|;
name|struct
name|ip
modifier|*
name|fr_ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|fr_m
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pf_frcache
block|{
name|LIST_ENTRY
argument_list|(
argument|pf_frcache
argument_list|)
name|fr_next
expr_stmt|;
name|uint16_t
name|fr_off
decl_stmt|;
name|uint16_t
name|fr_end
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PFFRAG_SEENLAST
value|0x0001
end_define

begin_comment
comment|/* Seen the last fragment for this */
end_comment

begin_define
define|#
directive|define
name|PFFRAG_NOBUFFER
value|0x0002
end_define

begin_comment
comment|/* Non-buffering fragment cache */
end_comment

begin_define
define|#
directive|define
name|PFFRAG_DROP
value|0x0004
end_define

begin_comment
comment|/* Drop all fragments */
end_comment

begin_define
define|#
directive|define
name|BUFFER_FRAGMENTS
parameter_list|(
name|fr
parameter_list|)
value|(!((fr)->fr_flags& PFFRAG_NOBUFFER))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_struct
struct|struct
name|pf_fragment
block|{
name|RB_ENTRY
argument_list|(
argument|pf_fragment
argument_list|)
name|fr_entry
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|pf_fragment
argument_list|)
name|frag_next
expr_stmt|;
name|struct
name|in_addr
name|fr_src
decl_stmt|;
name|struct
name|in_addr
name|fr_dst
decl_stmt|;
name|u_int8_t
name|fr_p
decl_stmt|;
comment|/* protocol of this fragment */
name|u_int8_t
name|fr_flags
decl_stmt|;
comment|/* status flags */
name|u_int16_t
name|fr_id
decl_stmt|;
comment|/* fragment id for reassemble */
name|u_int16_t
name|fr_max
decl_stmt|;
comment|/* fragment data max */
name|u_int32_t
name|fr_timeout
decl_stmt|;
define|#
directive|define
name|fr_queue
value|fr_u.fru_queue
define|#
directive|define
name|fr_cache
value|fr_u.fru_cache
union|union
block|{
name|LIST_HEAD
argument_list|(
argument|pf_fragq
argument_list|,
argument|pf_frent
argument_list|)
name|fru_queue
expr_stmt|;
comment|/* buffering */
name|LIST_HEAD
argument_list|(
argument|pf_cacheq
argument_list|,
argument|pf_frcache
argument_list|)
name|fru_cache
expr_stmt|;
comment|/* non-buf */
block|}
name|fr_u
union|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|pf_fragqueue
argument_list|,
argument|pf_fragment
argument_list|)
end_macro

begin_expr_stmt
name|pf_fragqueue
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|pf_cachequeue
argument_list|,
argument|pf_fragment
argument_list|)
end_macro

begin_expr_stmt
name|pf_cachequeue
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_function_decl
specifier|static
name|__inline
name|int
name|pf_frag_compare
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|pf_frag_compare
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|RB_HEAD
argument_list|(
argument|pf_frag_tree
argument_list|,
argument|pf_fragment
argument_list|)
end_macro

begin_expr_stmt
name|pf_frag_tree
operator|,
name|pf_cache_tree
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_PROTOTYPE
argument_list|(
name|pf_frag_tree
argument_list|,
name|pf_fragment
argument_list|,
name|fr_entry
argument_list|,
name|pf_frag_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|pf_frag_tree
argument_list|,
name|pf_fragment
argument_list|,
name|fr_entry
argument_list|,
name|pf_frag_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Private prototypes */
end_comment

begin_function_decl
name|void
name|pf_ip2key
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_remove_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_flush_fragments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_free_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|pf_fragment
modifier|*
name|pf_find_fragment
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|pf_frag_tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|pf_reassemble
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
parameter_list|,
name|struct
name|pf_frent
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|pf_fragcache
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_normalize_tcpopt
parameter_list|(
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|tcphdr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|x
parameter_list|)
value|if (pf_status.debug>= PF_DEBUG_MISC) \ 			    { printf("%s: ", __func__); printf x ;}
end_define

begin_comment
comment|/* Globals */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
name|uma_zone_t
name|pf_frent_pl
decl_stmt|,
name|pf_frag_pl
decl_stmt|,
name|pf_cache_pl
decl_stmt|,
name|pf_cent_pl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|pf_state_scrub_pl
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|pool
name|pf_frent_pl
decl_stmt|,
name|pf_frag_pl
decl_stmt|,
name|pf_cache_pl
decl_stmt|,
name|pf_cent_pl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pool
name|pf_state_scrub_pl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|pf_nfrents
decl_stmt|,
name|pf_ncache
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pf_normalize_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * XXX 	 * No high water mark support(It's hint not hard limit). 	 * uma_zone_set_max(pf_frag_pl, PFFRAG_FRAG_HIWAT); 	 */
name|uma_zone_set_max
argument_list|(
name|pf_frent_pl
argument_list|,
name|PFFRAG_FRENT_HIWAT
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|pf_cache_pl
argument_list|,
name|PFFRAG_FRCACHE_HIWAT
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|pf_cent_pl
argument_list|,
name|PFFRAG_FRCENT_HIWAT
argument_list|)
expr_stmt|;
else|#
directive|else
name|pool_init
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_frent
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pffrent"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_frag_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_fragment
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pffrag"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_fragment
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pffrcache"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_frcache
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pffrcent"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_state_scrub_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state_scrub
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfstscr"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_sethiwat
argument_list|(
operator|&
name|pf_frag_pl
argument_list|,
name|PFFRAG_FRAG_HIWAT
argument_list|)
expr_stmt|;
name|pool_sethardlimit
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|PFFRAG_FRENT_HIWAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pool_sethardlimit
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
name|PFFRAG_FRCACHE_HIWAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pool_sethardlimit
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|PFFRAG_FRCENT_HIWAT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_fragqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_cachequeue
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|int
else|#
directive|else
specifier|static
name|__inline
name|int
endif|#
directive|endif
name|pf_frag_compare
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|a
parameter_list|,
name|struct
name|pf_fragment
modifier|*
name|b
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|diff
operator|=
name|a
operator|->
name|fr_id
operator|-
name|b
operator|->
name|fr_id
operator|)
condition|)
return|return
operator|(
name|diff
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|diff
operator|=
name|a
operator|->
name|fr_p
operator|-
name|b
operator|->
name|fr_p
operator|)
condition|)
return|return
operator|(
name|diff
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|fr_src
operator|.
name|s_addr
operator|<
name|b
operator|->
name|fr_src
operator|.
name|s_addr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|fr_src
operator|.
name|s_addr
operator|>
name|b
operator|->
name|fr_src
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|fr_dst
operator|.
name|s_addr
operator|<
name|b
operator|->
name|fr_dst
operator|.
name|s_addr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|fr_dst
operator|.
name|s_addr
operator|>
name|b
operator|->
name|fr_dst
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_purge_expired_fragments
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|u_int32_t
name|expire
init|=
name|time_second
operator|-
name|pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_FRAG
index|]
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|expire
init|=
name|time
operator|.
name|tv_sec
operator|-
name|pf_default_rule
operator|.
name|timeout
index|[
name|PFTM_FRAG
index|]
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
name|pf_fragqueue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"BUFFER_FRAGMENTS(frag) == 0: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frag
operator|->
name|fr_timeout
operator|>
name|expire
condition|)
break|break;
name|DPFPRINTF
argument_list|(
operator|(
literal|"expiring %d(%p)\n"
operator|,
name|frag
operator|->
name|fr_id
operator|,
name|frag
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"BUFFER_FRAGMENTS(frag) != 0: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frag
operator|->
name|fr_timeout
operator|>
name|expire
condition|)
break|break;
name|DPFPRINTF
argument_list|(
operator|(
literal|"expiring %d(%p)\n"
operator|,
name|frag
operator|->
name|fr_id
operator|,
name|frag
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pf_cachequeue
argument_list|)
operator|||
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
operator|!=
name|frag
operator|)
argument_list|,
operator|(
literal|"!(TAILQ_EMPTY() || TAILQ_LAST() == farg): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pf_cachequeue
argument_list|)
operator|||
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
operator|!=
name|frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Try to flush old fragments to make space for new ones  */
end_comment

begin_function
name|void
name|pf_flush_fragments
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|int
name|goal
decl_stmt|;
name|goal
operator|=
name|pf_nfrents
operator|*
literal|9
operator|/
literal|10
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"trying to free> %d frents\n"
operator|,
name|pf_nfrents
operator|-
name|goal
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|goal
operator|<
name|pf_nfrents
condition|)
block|{
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
name|pf_fragqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
break|break;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
name|goal
operator|=
name|pf_ncache
operator|*
literal|9
operator|/
literal|10
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"trying to free> %d cache entries\n"
operator|,
name|pf_ncache
operator|-
name|goal
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|goal
operator|<
name|pf_ncache
condition|)
block|{
name|frag
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|pf_cachequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
break|break;
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Frees the fragments and all associated entries */
end_comment

begin_function
name|void
name|pf_free_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|struct
name|pf_frcache
modifier|*
name|frcache
decl_stmt|;
comment|/* Free all fragments */
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
for|for
control|(
name|frent
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
init|;
name|frent
condition|;
name|frent
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_queue
argument_list|)
control|)
block|{
name|LIST_REMOVE
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|frent
operator|->
name|fr_m
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|frent
argument_list|)
expr_stmt|;
name|pf_nfrents
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|frcache
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
init|;
name|frcache
condition|;
name|frcache
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
control|)
block|{
name|LIST_REMOVE
argument_list|(
name|frcache
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|LIST_EMPTY
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
operator|->
name|fr_off
operator|>
name|frcache
operator|->
name|fr_end
operator|)
argument_list|,
operator|(
literal|"! (LIST_EMPTY() || LIST_FIRST()->fr_off>"
literal|" frcache->fr_end): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
operator|||
name|LIST_FIRST
argument_list|(
operator|&
name|frag
operator|->
name|fr_cache
argument_list|)
operator|->
name|fr_off
operator|>
name|frcache
operator|->
name|fr_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pool_put
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|frcache
argument_list|)
expr_stmt|;
name|pf_ncache
operator|--
expr_stmt|;
block|}
block|}
name|pf_remove_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_ip2key
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|key
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|)
block|{
name|key
operator|->
name|fr_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|key
operator|->
name|fr_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|key
operator|->
name|fr_src
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|key
operator|->
name|fr_dst
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pf_fragment
modifier|*
name|pf_find_fragment
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|pf_frag_tree
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|pf_fragment
name|key
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
decl_stmt|;
name|pf_ip2key
argument_list|(
operator|&
name|key
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|frag
operator|=
name|RB_FIND
argument_list|(
name|pf_frag_tree
argument_list|,
name|tree
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX Are we sure we want to update the timeout? */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|frag
operator|->
name|fr_timeout
operator|=
name|time_second
expr_stmt|;
else|#
directive|else
name|frag
operator|->
name|fr_timeout
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|frag
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Removes a fragment from the fragment queue and frees the fragment */
end_comment

begin_function
name|void
name|pf_remove_fragment
parameter_list|(
name|struct
name|pf_fragment
modifier|*
name|frag
parameter_list|)
block|{
if|if
condition|(
name|BUFFER_FRAGMENTS
argument_list|(
name|frag
argument_list|)
condition|)
block|{
name|RB_REMOVE
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|pf_frag_tree
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_frag_pl
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RB_REMOVE
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|pf_cache_tree
argument_list|,
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
name|frag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FR_IP_OFF
parameter_list|(
name|fr
parameter_list|)
value|((ntohs((fr)->fr_ip->ip_off)& IP_OFFMASK)<< 3)
end_define

begin_function
name|struct
name|mbuf
modifier|*
name|pf_reassemble
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
name|frag
parameter_list|,
name|struct
name|pf_frent
modifier|*
name|frent
parameter_list|,
name|int
name|mff
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frea
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frep
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|frent
operator|->
name|fr_ip
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|u_int16_t
name|off
init|=
operator|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
decl_stmt|;
name|u_int16_t
name|ip_len
init|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|ip
operator|->
name|ip_hl
operator|*
literal|4
decl_stmt|;
name|u_int16_t
name|max
init|=
name|ip_len
operator|+
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|*
name|frag
operator|==
name|NULL
operator|||
name|BUFFER_FRAGMENTS
argument_list|(
operator|*
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"! (*frag == NULL || BUFFER_FRAGMENTS(*frag)): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|*
name|frag
operator|==
name|NULL
operator|||
name|BUFFER_FRAGMENTS
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Strip off ip header */
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/* Create a new reassembly queue for this packet */
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
operator|*
name|frag
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_frag_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
name|pf_flush_fragments
argument_list|()
expr_stmt|;
operator|*
name|frag
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_frag_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|drop_fragment
goto|;
block|}
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_src
operator|=
name|frent
operator|->
name|fr_ip
operator|->
name|ip_src
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_dst
operator|=
name|frent
operator|->
name|fr_ip
operator|->
name|ip_dst
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_p
operator|=
name|frent
operator|->
name|fr_ip
operator|->
name|ip_p
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_id
operator|=
name|frent
operator|->
name|fr_ip
operator|->
name|ip_id
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_timeout
operator|=
name|time_second
expr_stmt|;
else|#
directive|else
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_timeout
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
name|LIST_INIT
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|pf_frag_tree
argument_list|,
operator|*
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pf_fragqueue
argument_list|,
operator|*
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
comment|/* We do not have a previous fragment */
name|frep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|insert
goto|;
block|}
comment|/* 	 * Find a fragment after the current one: 	 *  - off contains the real shifted offset. 	 */
name|LIST_FOREACH
argument_list|(
argument|frea
argument_list|,
argument|&(*frag)->fr_queue
argument_list|,
argument|fr_next
argument_list|)
block|{
if|if
condition|(
name|FR_IP_OFF
argument_list|(
name|frea
argument_list|)
operator|>
name|off
condition|)
break|break;
name|frep
operator|=
name|frea
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|frep
operator|!=
name|NULL
operator|||
name|frea
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"!(frep != NULL || frea != NULL): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
empty_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|frep
operator|!=
name|NULL
operator|||
name|frea
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frep
operator|!=
name|NULL
operator|&&
name|FR_IP_OFF
argument_list|(
name|frep
argument_list|)
operator|+
name|ntohs
argument_list|(
name|frep
operator|->
name|fr_ip
operator|->
name|ip_len
argument_list|)
operator|-
name|frep
operator|->
name|fr_ip
operator|->
name|ip_hl
operator|*
literal|4
operator|>
name|off
condition|)
block|{
name|u_int16_t
name|precut
decl_stmt|;
name|precut
operator|=
name|FR_IP_OFF
argument_list|(
name|frep
argument_list|)
operator|+
name|ntohs
argument_list|(
name|frep
operator|->
name|fr_ip
operator|->
name|ip_len
argument_list|)
operator|-
name|frep
operator|->
name|fr_ip
operator|->
name|ip_hl
operator|*
literal|4
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|precut
operator|>=
name|ip_len
condition|)
goto|goto
name|drop_fragment
goto|;
name|m_adj
argument_list|(
name|frent
operator|->
name|fr_m
argument_list|,
name|precut
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"overlap -%d\n"
operator|,
name|precut
operator|)
argument_list|)
expr_stmt|;
comment|/* Enforce 8 byte boundaries */
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|+
operator|(
name|precut
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
expr_stmt|;
name|ip_len
operator|-=
name|precut
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip_len
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|frea
operator|!=
name|NULL
operator|&&
name|ip_len
operator|+
name|off
operator|>
name|FR_IP_OFF
argument_list|(
name|frea
argument_list|)
condition|;
name|frea
operator|=
name|next
control|)
block|{
name|u_int16_t
name|aftercut
decl_stmt|;
name|aftercut
operator|=
name|ip_len
operator|+
name|off
operator|-
name|FR_IP_OFF
argument_list|(
name|frea
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"adjust overlap %d\n"
operator|,
name|aftercut
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aftercut
operator|<
name|ntohs
argument_list|(
name|frea
operator|->
name|fr_ip
operator|->
name|ip_len
argument_list|)
operator|-
name|frea
operator|->
name|fr_ip
operator|->
name|ip_hl
operator|*
literal|4
condition|)
block|{
name|frea
operator|->
name|fr_ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|frea
operator|->
name|fr_ip
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
argument_list|)
expr_stmt|;
name|frea
operator|->
name|fr_ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|frea
operator|->
name|fr_ip
operator|->
name|ip_off
argument_list|)
operator|+
operator|(
name|aftercut
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|frea
operator|->
name|fr_m
argument_list|,
name|aftercut
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This fragment is completely overlapped, loose it */
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|frea
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|frea
operator|->
name|fr_m
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|frea
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|frea
argument_list|)
expr_stmt|;
name|pf_nfrents
operator|--
expr_stmt|;
block|}
name|insert
label|:
comment|/* Update maximum data size */
if|if
condition|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|<
name|max
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
name|max
expr_stmt|;
comment|/* This is the last segment */
if|if
condition|(
operator|!
name|mff
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
if|if
condition|(
name|frep
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|frep
argument_list|,
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
comment|/* Check if we are completely reassembled */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Check if we have all the data */
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|frep
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
init|;
name|frep
condition|;
name|frep
operator|=
name|next
control|)
block|{
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|frep
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|off
operator|+=
name|ntohs
argument_list|(
name|frep
operator|->
name|fr_ip
operator|->
name|ip_len
argument_list|)
operator|-
name|frep
operator|->
name|fr_ip
operator|->
name|ip_hl
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|off
operator|<
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|&&
operator|(
name|next
operator|==
name|NULL
operator|||
name|FR_IP_OFF
argument_list|(
name|next
argument_list|)
operator|!=
name|off
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"missing fragment at %d, next %d, max %d\n"
operator|,
name|off
operator|,
name|next
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|FR_IP_OFF
argument_list|(
name|next
argument_list|)
operator|,
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DPFPRINTF
argument_list|(
operator|(
literal|"%d< %d?\n"
operator|,
name|off
operator|,
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* We have all the data */
name|frent
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_queue
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|frent
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"frent == NULL: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|frent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|frent
operator|->
name|fr_ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|off
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"drop: too big: %d\n"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
comment|/* Magic from ip_input */
name|ip
operator|=
name|frent
operator|->
name|fr_ip
expr_stmt|;
name|m
operator|=
name|frent
operator|->
name|fr_m
expr_stmt|;
name|m2
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|frent
argument_list|)
expr_stmt|;
name|pf_nfrents
operator|--
expr_stmt|;
for|for
control|(
name|frent
operator|=
name|next
init|;
name|frent
operator|!=
name|NULL
condition|;
name|frent
operator|=
name|next
control|)
block|{
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|frent
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|m2
operator|=
name|frent
operator|->
name|fr_m
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|frent
argument_list|)
expr_stmt|;
name|pf_nfrents
operator|--
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
block|}
name|ip
operator|->
name|ip_src
operator|=
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_dst
expr_stmt|;
comment|/* Remove from fragment queue */
name|pf_remove_fragment
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|off
operator|+
name|hlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|hlen
expr_stmt|;
comment|/* some debugging cruft by sklower, below, will go away soon */
comment|/* XXX this should be done elsewhere */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|m2
operator|=
name|m
init|;
name|m2
condition|;
name|m2
operator|=
name|m2
operator|->
name|m_next
control|)
name|plen
operator|+=
name|m2
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|DPFPRINTF
argument_list|(
operator|(
literal|"complete: %p(%d)\n"
operator|,
name|m
operator|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
name|drop_fragment
label|:
comment|/* Oops - fail safe - drop packet */
name|pool_put
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|frent
argument_list|)
expr_stmt|;
name|pf_nfrents
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|pf_fragcache
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|struct
name|ip
modifier|*
name|h
parameter_list|,
name|struct
name|pf_fragment
modifier|*
modifier|*
name|frag
parameter_list|,
name|int
name|mff
parameter_list|,
name|int
name|drop
parameter_list|,
name|int
modifier|*
name|nomem
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_frcache
modifier|*
name|frp
decl_stmt|,
modifier|*
name|fra
decl_stmt|,
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|int
name|ip_len
init|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
decl_stmt|;
name|u_int16_t
name|off
init|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|<<
literal|3
decl_stmt|;
name|u_int16_t
name|max
init|=
name|ip_len
operator|+
name|off
decl_stmt|;
name|int
name|hosed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|*
name|frag
operator|==
name|NULL
operator|||
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
operator|*
name|frag
argument_list|)
operator|)
argument_list|,
operator|(
literal|"!(*frag == NULL || !BUFFER_FRAGMENTS(*frag)): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|*
name|frag
operator|==
name|NULL
operator|||
operator|!
name|BUFFER_FRAGMENTS
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create a new range queue for this packet */
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
operator|*
name|frag
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
block|{
name|pf_flush_fragments
argument_list|()
expr_stmt|;
operator|*
name|frag
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|frag
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
comment|/* Get an entry for the queue */
name|cur
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_cache_pl
argument_list|,
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
name|pf_ncache
operator|++
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|=
name|PFFRAG_NOBUFFER
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_src
operator|=
name|h
operator|->
name|ip_src
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_dst
operator|=
name|h
operator|->
name|ip_dst
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_p
operator|=
name|h
operator|->
name|ip_p
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_id
operator|=
name|h
operator|->
name|ip_id
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_timeout
operator|=
name|time_second
expr_stmt|;
else|#
directive|else
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_timeout
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
name|cur
operator|->
name|fr_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fr_end
operator|=
name|max
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_cache
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_cache
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|pf_frag_tree
argument_list|,
operator|&
name|pf_cache_tree
argument_list|,
operator|*
name|frag
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pf_cachequeue
argument_list|,
operator|*
name|frag
argument_list|,
name|frag_next
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: new %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|pass
goto|;
block|}
comment|/* 	 * Find a fragment after the current one: 	 *  - off contains the real shifted offset. 	 */
name|frp
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fra
argument_list|,
argument|&(*frag)->fr_cache
argument_list|,
argument|fr_next
argument_list|)
block|{
if|if
condition|(
name|fra
operator|->
name|fr_off
operator|>
name|off
condition|)
break|break;
name|frp
operator|=
name|fra
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|frp
operator|!=
name|NULL
operator|||
name|fra
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"!(frp != NULL || fra != NULL): %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|frp
operator|!=
name|NULL
operator|||
name|fra
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frp
operator|!=
name|NULL
condition|)
block|{
name|int
name|precut
decl_stmt|;
name|precut
operator|=
name|frp
operator|->
name|fr_end
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|precut
operator|>=
name|ip_len
condition|)
block|{
comment|/* Fragment is entirely a duplicate */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: dead (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fr_off
operator|,
name|frp
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|drop_fragment
goto|;
block|}
if|if
condition|(
name|precut
operator|==
literal|0
condition|)
block|{
comment|/* They are adjacent.  Fixup cache entry */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fr_off
operator|,
name|frp
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|frp
operator|->
name|fr_end
operator|=
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|precut
operator|>
literal|0
condition|)
block|{
comment|/* The first part of this payload overlaps with a 			 * fragment that has already been passed. 			 * Need to trim off the first part of the payload. 			 * But to do so easily, we need to create another 			 * mbuf to throw the original header into. 			 */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: chop %d (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|precut
operator|,
name|frp
operator|->
name|fr_off
operator|,
name|frp
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|precut
expr_stmt|;
name|max
operator|-=
name|precut
expr_stmt|;
comment|/* Update the previous frag to encompass this one */
name|frp
operator|->
name|fr_end
operator|=
name|max
expr_stmt|;
if|if
condition|(
operator|!
name|drop
condition|)
block|{
comment|/* XXX Optimization opportunity 				 * This is a very heavy way to trim the payload. 				 * we could do it much faster by diddling mbuf 				 * internals but that would be even less legible 				 * than this mbuf magic.  For my next trick, 				 * I'll pull a rabbit out of my laptop. 				 */
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|*
name|m0
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* From KAME Project : We have missed this! */
name|m_adj
argument_list|(
operator|*
name|m0
argument_list|,
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|-
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|m0
operator|=
name|m_copym2
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|h
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|m0
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_next
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"(*m0)->m_next != NULL: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_adj
argument_list|(
name|m
argument_list|,
name|precut
operator|+
operator|(
name|h
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|m_cat
argument_list|(
operator|*
name|m0
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|m_next
control|)
name|plen
operator|+=
name|t
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|precut
operator|)
argument_list|,
operator|(
literal|"m->m_len != ntohs(h->ip_len) - precut: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|precut
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|+
operator|(
name|precut
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|precut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hosed
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is a gap between fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: gap %d (%d-%d) %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|-
name|precut
operator|,
name|frp
operator|->
name|fr_off
operator|,
name|frp
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|pf_ncache
operator|++
expr_stmt|;
name|cur
operator|->
name|fr_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fr_end
operator|=
name|max
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|frp
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fra
operator|!=
name|NULL
condition|)
block|{
name|int
name|aftercut
decl_stmt|;
name|int
name|merge
init|=
literal|0
decl_stmt|;
name|aftercut
operator|=
name|max
operator|-
name|fra
operator|->
name|fr_off
expr_stmt|;
if|if
condition|(
name|aftercut
operator|==
literal|0
condition|)
block|{
comment|/* Adjacent fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fr_off
operator|,
name|fra
operator|->
name|fr_end
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fr_off
operator|=
name|off
expr_stmt|;
name|merge
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aftercut
operator|>
literal|0
condition|)
block|{
comment|/* Need to chop off the tail of this fragment */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: chop %d %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|aftercut
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fr_off
operator|,
name|fra
operator|->
name|fr_end
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fr_off
operator|=
name|off
expr_stmt|;
name|max
operator|-=
name|aftercut
expr_stmt|;
name|merge
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|drop
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|aftercut
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|int
name|plen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|m_next
control|)
name|plen
operator|+=
name|t
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
operator|)
argument_list|,
operator|(
literal|"m->m_len != ntohs(h->ip_len) - aftercut: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_len
operator|==
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|aftercut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hosed
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
block|{
comment|/* There is a gap between fragments */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: gap %d %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|-
name|aftercut
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fr_off
operator|,
name|fra
operator|->
name|fr_end
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|pf_ncache
operator|++
expr_stmt|;
name|cur
operator|->
name|fr_off
operator|=
name|off
expr_stmt|;
name|cur
operator|->
name|fr_end
operator|=
name|max
expr_stmt|;
name|LIST_INSERT_BEFORE
argument_list|(
name|fra
argument_list|,
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
block|}
comment|/* Need to glue together two separate fragment descriptors */
if|if
condition|(
name|merge
condition|)
block|{
if|if
condition|(
name|cur
operator|&&
name|fra
operator|->
name|fr_off
operator|<=
name|cur
operator|->
name|fr_end
condition|)
block|{
comment|/* Need to merge in a previous 'cur' */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent(merge "
literal|"%d-%d) %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|cur
operator|->
name|fr_off
operator|,
name|cur
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fr_off
operator|,
name|fra
operator|->
name|fr_end
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fr_off
operator|=
name|cur
operator|->
name|fr_off
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|cur
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|pf_ncache
operator|--
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frp
operator|&&
name|fra
operator|->
name|fr_off
operator|<=
name|frp
operator|->
name|fr_end
condition|)
block|{
comment|/* Need to merge in a modified 'frp' */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|cur
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"cur != NULL: %s"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: adjacent(merge "
literal|"%d-%d) %d-%d (%d-%d)\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|frp
operator|->
name|fr_off
operator|,
name|frp
operator|->
name|fr_end
operator|,
name|off
operator|,
name|max
operator|,
name|fra
operator|->
name|fr_off
operator|,
name|fra
operator|->
name|fr_end
operator|)
argument_list|)
expr_stmt|;
name|fra
operator|->
name|fr_off
operator|=
name|frp
operator|->
name|fr_off
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|frp
argument_list|,
name|fr_next
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_cent_pl
argument_list|,
name|frp
argument_list|)
expr_stmt|;
name|pf_ncache
operator|--
expr_stmt|;
name|frp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hosed
condition|)
block|{
comment|/* 		 * We must keep tracking the overall fragment even when 		 * we're going to drop it anyway so that we know when to 		 * free the overall descriptor.  Thus we drop the frag late. 		 */
goto|goto
name|drop_fragment
goto|;
block|}
name|pass
label|:
comment|/* Update maximum data size */
if|if
condition|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|<
name|max
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|=
name|max
expr_stmt|;
comment|/* This is the last segment */
if|if
condition|(
operator|!
name|mff
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
comment|/* Check if we are completely reassembled */
if|if
condition|(
operator|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|LIST_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_cache
argument_list|)
operator|->
name|fr_off
operator|==
literal|0
operator|&&
name|LIST_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_cache
argument_list|)
operator|->
name|fr_end
operator|==
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
condition|)
block|{
comment|/* Remove from fragment queue */
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: done 0-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_max
operator|)
argument_list|)
expr_stmt|;
name|pf_free_fragment
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
operator|*
name|frag
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|no_mem
label|:
operator|*
name|nomem
operator|=
literal|1
expr_stmt|;
comment|/* Still need to pay attention to !IP_MF */
if|if
condition|(
operator|!
name|mff
operator|&&
operator|*
name|frag
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|drop_fragment
label|:
comment|/* Still need to pay attention to !IP_MF */
if|if
condition|(
operator|!
name|mff
operator|&&
operator|*
name|frag
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_SEENLAST
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
comment|/* This fragment has been deemed bad.  Don't reass */
if|if
condition|(
operator|(
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator|&
name|PFFRAG_DROP
operator|)
operator|==
literal|0
condition|)
name|DPFPRINTF
argument_list|(
operator|(
literal|"fragcache[%d]: dropping overall fragment\n"
operator|,
name|h
operator|->
name|ip_id
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|frag
operator|)
operator|->
name|fr_flags
operator||=
name|PFFRAG_DROP
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_normalize_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
name|struct
name|pf_frent
modifier|*
name|frent
decl_stmt|;
name|struct
name|pf_fragment
modifier|*
name|frag
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|int
name|mff
init|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_MF
operator|)
decl_stmt|;
name|int
name|hlen
init|=
name|h
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|u_int16_t
name|fragoff
init|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
decl_stmt|;
name|u_int16_t
name|max
decl_stmt|;
name|int
name|ip_len
decl_stmt|;
name|int
name|ip_off
decl_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|kif
operator|!=
name|NULL
operator|&&
operator|(
name|r
operator|->
name|kif
operator|!=
name|kif
operator|&&
name|r
operator|->
name|kif
operator|!=
name|kif
operator|->
name|pfik_parent
operator|)
operator|==
operator|!
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|AF_INET
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|h
operator|->
name|ip_p
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|AF_INET
argument_list|,
name|r
operator|->
name|src
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|AF_INET
argument_list|,
name|r
operator|->
name|dst
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
name|r
operator|->
name|packets
operator|++
expr_stmt|;
comment|/* Check for illegal packets */
if|if
condition|(
name|hlen
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|hlen
operator|>
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
condition|)
goto|goto
name|drop
goto|;
comment|/* Clear IP_DF if the rule uses the no-df option */
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_NODF
condition|)
name|h
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
operator|~
name|IP_DF
argument_list|)
expr_stmt|;
comment|/* We will need other tests here */
if|if
condition|(
operator|!
name|fragoff
operator|&&
operator|!
name|mff
condition|)
goto|goto
name|no_fragment
goto|;
comment|/* We're dealing with a fragment now. Don't allow fragments 	 * with IP_DF to enter the cache. If the flag was cleared by 	 * no-df above, fine. Otherwise drop it. 	 */
if|if
condition|(
name|h
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_DF
argument_list|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"IP_DF\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip_len
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
expr_stmt|;
name|ip_off
operator|=
operator|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|<<
literal|3
expr_stmt|;
comment|/* All fragments are 8 byte aligned */
if|if
condition|(
name|mff
operator|&&
operator|(
name|ip_len
operator|&
literal|0x7
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"mff and %d\n"
operator|,
name|ip_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Respect maximum length */
if|if
condition|(
name|fragoff
operator|+
name|ip_len
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|DPFPRINTF
argument_list|(
operator|(
literal|"max packet %d\n"
operator|,
name|fragoff
operator|+
name|ip_len
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|max
operator|=
name|fragoff
operator|+
name|ip_len
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|rule_flag
operator|&
operator|(
name|PFRULE_FRAGCROP
operator||
name|PFRULE_FRAGDROP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Fully buffer all of the fragments */
name|frag
operator|=
name|pf_find_fragment
argument_list|(
name|h
argument_list|,
operator|&
name|pf_frag_tree
argument_list|)
expr_stmt|;
comment|/* Check if we saw the last fragment already */
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|max
operator|>
name|frag
operator|->
name|fr_max
condition|)
goto|goto
name|bad
goto|;
comment|/* Get an entry for the fragment queue */
name|frent
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_frent_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frent
operator|==
name|NULL
condition|)
block|{
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
name|pf_nfrents
operator|++
expr_stmt|;
name|frent
operator|->
name|fr_ip
operator|=
name|h
expr_stmt|;
name|frent
operator|->
name|fr_m
operator|=
name|m
expr_stmt|;
comment|/* Might return a completely reassembled mbuf, or NULL */
name|DPFPRINTF
argument_list|(
operator|(
literal|"reass frag %d @ %d-%d\n"
operator|,
name|h
operator|->
name|ip_id
operator|,
name|fragoff
operator|,
name|max
operator|)
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|m
operator|=
name|pf_reassemble
argument_list|(
name|m0
argument_list|,
operator|&
name|frag
argument_list|,
name|frent
argument_list|,
name|mff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_DROP
operator|)
return|;
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_DROP
operator|)
condition|)
goto|goto
name|drop
goto|;
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* non-buffering fragment cache (drops or masks overlaps) */
name|int
name|nomem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|PF_OUT
condition|)
block|{
if|if
condition|(
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_PF_FRAGCACHE
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Already passed the fragment cache in the 				 * input direction.  If we continued, it would 				 * appear to be a dup and would be dropped. 				 */
goto|goto
name|fragment_pass
goto|;
block|}
block|}
name|frag
operator|=
name|pf_find_fragment
argument_list|(
name|h
argument_list|,
operator|&
name|pf_cache_tree
argument_list|)
expr_stmt|;
comment|/* Check if we saw the last fragment already */
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_SEENLAST
operator|)
operator|&&
name|max
operator|>
name|frag
operator|->
name|fr_max
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_FRAGDROP
condition|)
name|frag
operator|->
name|fr_flags
operator||=
name|PFFRAG_DROP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|m0
operator|=
name|m
operator|=
name|pf_fragcache
argument_list|(
name|m0
argument_list|,
name|h
argument_list|,
operator|&
name|frag
argument_list|,
name|mff
argument_list|,
operator|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_FRAGDROP
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|&
name|nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nomem
condition|)
goto|goto
name|no_mem
goto|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|dir
operator|==
name|PF_IN
condition|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_PF_FRAGCACHE
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frag
operator|!=
name|NULL
operator|&&
operator|(
name|frag
operator|->
name|fr_flags
operator|&
name|PFFRAG_DROP
operator|)
condition|)
goto|goto
name|drop
goto|;
goto|goto
name|fragment_pass
goto|;
block|}
name|no_fragment
label|:
comment|/* At this point, only IP_DF is allowed in ip_off */
name|h
operator|->
name|ip_off
operator|&=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
comment|/* Enforce a minimum ttl, may cause endless packet loops */
if|if
condition|(
name|r
operator|->
name|min_ttl
operator|&&
name|h
operator|->
name|ip_ttl
operator|<
name|r
operator|->
name|min_ttl
condition|)
name|h
operator|->
name|ip_ttl
operator|=
name|r
operator|->
name|min_ttl
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|rule_flag
operator|&
name|PFRULE_RANDOMID
condition|)
block|{
name|u_int16_t
name|ip_id
init|=
name|h
operator|->
name|ip_id
decl_stmt|;
name|h
operator|->
name|ip_id
operator|=
name|ip_randomid
argument_list|()
expr_stmt|;
name|h
operator|->
name|ip_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|h
operator|->
name|ip_sum
argument_list|,
name|ip_id
argument_list|,
name|h
operator|->
name|ip_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|fragment_pass
label|:
comment|/* Enforce a minimum ttl, may cause endless packet loops */
if|if
condition|(
name|r
operator|->
name|min_ttl
operator|&&
name|h
operator|->
name|ip_ttl
operator|<
name|r
operator|->
name|min_ttl
condition|)
name|h
operator|->
name|ip_ttl
operator|=
name|r
operator|->
name|min_ttl
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|no_mem
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|drop
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|bad
label|:
name|DPFPRINTF
argument_list|(
operator|(
literal|"dropping bad fragment\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free associated fragments */
if|if
condition|(
name|frag
operator|!=
name|NULL
condition|)
name|pf_free_fragment
argument_list|(
name|frag
argument_list|)
expr_stmt|;
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|pf_normalize_ip6
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|m0
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|ip6_ext
name|ext
decl_stmt|;
name|struct
name|ip6_opt
name|opt
decl_stmt|;
name|struct
name|ip6_opt_jumbo
name|jumbo
decl_stmt|;
name|struct
name|ip6_frag
name|frag
decl_stmt|;
name|u_int32_t
name|jumbolen
init|=
literal|0
decl_stmt|,
name|plen
decl_stmt|;
name|u_int16_t
name|fragoff
init|=
literal|0
decl_stmt|;
name|int
name|optend
decl_stmt|;
name|int
name|ooff
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|;
name|int
name|terminal
decl_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|kif
operator|!=
name|NULL
operator|&&
operator|(
name|r
operator|->
name|kif
operator|!=
name|kif
operator|&&
name|r
operator|->
name|kif
operator|!=
name|kif
operator|->
name|pfik_parent
operator|)
operator|==
operator|!
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|AF_INET6
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
if|#
directive|if
literal|0
comment|/* header chain! */
if|else if (r->proto&& r->proto != h->ip6_nxt) 			r = r->skip[PF_SKIP_PROTO].ptr;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_src
argument_list|,
name|AF_INET6
argument_list|,
name|r
operator|->
name|src
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
operator|(
expr|struct
name|pf_addr
operator|*
operator|)
operator|&
name|h
operator|->
name|ip6_dst
argument_list|,
name|AF_INET6
argument_list|,
name|r
operator|->
name|dst
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
name|r
operator|->
name|packets
operator|++
expr_stmt|;
comment|/* Check for illegal packets */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|IPV6_MAXPACKET
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|drop
goto|;
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|proto
operator|=
name|h
operator|->
name|ip6_nxt
expr_stmt|;
name|terminal
operator|=
literal|0
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_FRAGMENT
case|:
goto|goto
name|fragment
goto|;
break|break;
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_ROUTING
case|:
case|case
name|IPPROTO_DSTOPTS
case|:
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_AH
condition|)
name|off
operator|+=
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
else|else
name|off
operator|+=
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|proto
operator|=
name|ext
operator|.
name|ip6e_nxt
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|optend
operator|=
name|off
operator|+
operator|(
name|ext
operator|.
name|ip6e_len
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|ooff
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|opt
operator|.
name|ip6o_type
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
operator|.
name|ip6o_type
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
name|opt
operator|.
name|ip6o_type
operator|==
name|IP6OPT_PAD1
condition|)
block|{
name|ooff
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
if|if
condition|(
name|ooff
operator|+
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
operator|+
name|opt
operator|.
name|ip6o_len
operator|>
name|optend
condition|)
goto|goto
name|drop
goto|;
switch|switch
condition|(
name|opt
operator|.
name|ip6o_type
condition|)
block|{
case|case
name|IP6OPT_JUMBO
case|:
if|if
condition|(
name|h
operator|->
name|ip6_plen
operator|!=
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|ooff
argument_list|,
operator|&
name|jumbo
argument_list|,
sizeof|sizeof
argument_list|(
name|jumbo
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|memcpy
argument_list|(
operator|&
name|jumbolen
argument_list|,
name|jumbo
operator|.
name|ip6oj_jumbo_len
argument_list|,
sizeof|sizeof
argument_list|(
name|jumbolen
argument_list|)
argument_list|)
expr_stmt|;
name|jumbolen
operator|=
name|ntohl
argument_list|(
name|jumbolen
argument_list|)
expr_stmt|;
if|if
condition|(
name|jumbolen
operator|<=
name|IPV6_MAXPACKET
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|jumbolen
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|drop
goto|;
break|break;
default|default:
break|break;
block|}
name|ooff
operator|+=
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
operator|+
name|opt
operator|.
name|ip6o_len
expr_stmt|;
block|}
do|while
condition|(
name|ooff
operator|<
name|optend
condition|)
do|;
name|off
operator|=
name|optend
expr_stmt|;
name|proto
operator|=
name|ext
operator|.
name|ip6e_nxt
expr_stmt|;
break|break;
default|default:
name|terminal
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|terminal
condition|)
do|;
comment|/* jumbo payload option must be present, or plen> 0 */
if|if
condition|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|==
literal|0
condition|)
name|plen
operator|=
name|jumbolen
expr_stmt|;
else|else
name|plen
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
name|plen
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
goto|goto
name|shortpkt
goto|;
comment|/* Enforce a minimum ttl, may cause endless packet loops */
if|if
condition|(
name|r
operator|->
name|min_ttl
operator|&&
name|h
operator|->
name|ip6_hlim
operator|<
name|r
operator|->
name|min_ttl
condition|)
name|h
operator|->
name|ip6_hlim
operator|=
name|r
operator|->
name|min_ttl
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|fragment
label|:
if|if
condition|(
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
operator|==
literal|0
operator|||
name|jumbolen
condition|)
goto|goto
name|drop
goto|;
name|plen
operator|=
name|ntohs
argument_list|(
name|h
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
operator|&
name|frag
argument_list|,
sizeof|sizeof
argument_list|(
name|frag
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AF_INET6
argument_list|)
condition|)
goto|goto
name|shortpkt
goto|;
name|fragoff
operator|=
name|ntohs
argument_list|(
name|frag
operator|.
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragoff
operator|+
operator|(
name|plen
operator|-
name|off
operator|-
sizeof|sizeof
argument_list|(
name|frag
argument_list|)
operator|)
operator|>
name|IPV6_MAXPACKET
condition|)
goto|goto
name|badfrag
goto|;
comment|/* do something about it */
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|shortpkt
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_SHORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|drop
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
name|badfrag
label|:
name|REASON_SET
argument_list|(
name|reason
argument_list|,
name|PFRES_FRAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET6
argument_list|,
name|dir
argument_list|,
operator|*
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pf_normalize_tcp
parameter_list|(
name|int
name|dir
parameter_list|,
name|struct
name|pfi_kif
modifier|*
name|kif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|ipoff
parameter_list|,
name|int
name|off
parameter_list|,
name|void
modifier|*
name|h
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|pf_rule
modifier|*
name|r
decl_stmt|,
modifier|*
name|rm
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|pd
operator|->
name|hdr
operator|.
name|tcp
decl_stmt|;
name|int
name|rewrite
init|=
literal|0
decl_stmt|;
name|u_short
name|reason
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|sa_family_t
name|af
init|=
name|pd
operator|->
name|af
decl_stmt|;
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|r
operator|->
name|evaluations
operator|++
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|kif
operator|!=
name|NULL
operator|&&
operator|(
name|r
operator|->
name|kif
operator|!=
name|kif
operator|&&
name|r
operator|->
name|kif
operator|!=
name|kif
operator|->
name|pfik_parent
operator|)
operator|==
operator|!
name|r
operator|->
name|ifnot
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_IFP
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|direction
operator|&&
name|r
operator|->
name|direction
operator|!=
name|dir
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DIR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|af
operator|&&
name|r
operator|->
name|af
operator|!=
name|af
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_AF
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|proto
operator|&&
name|r
operator|->
name|proto
operator|!=
name|pd
operator|->
name|proto
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_PROTO
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|src
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|src
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|src
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|src
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|src
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|th
operator|->
name|th_sport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_SRC_PORT
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|PF_MISMATCHAW
argument_list|(
operator|&
name|r
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|pd
operator|->
name|dst
argument_list|,
name|af
argument_list|,
name|r
operator|->
name|dst
operator|.
name|not
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_ADDR
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|dst
operator|.
name|port_op
operator|&&
operator|!
name|pf_match_port
argument_list|(
name|r
operator|->
name|dst
operator|.
name|port_op
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|th
operator|->
name|th_dport
argument_list|)
condition|)
name|r
operator|=
name|r
operator|->
name|skip
index|[
name|PF_SKIP_DST_PORT
index|]
operator|.
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|os_fingerprint
operator|!=
name|PF_OSFP_ANY
operator|&&
operator|!
name|pf_osfp_match
argument_list|(
name|pf_osfp_fingerprint
argument_list|(
name|pd
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
name|th
argument_list|)
argument_list|,
name|r
operator|->
name|os_fingerprint
argument_list|)
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
block|{
name|rm
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rm
operator|==
name|NULL
condition|)
return|return
operator|(
name|PF_PASS
operator|)
return|;
else|else
name|r
operator|->
name|packets
operator|++
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rule_flag
operator|&
name|PFRULE_REASSEMBLE_TCP
condition|)
name|pd
operator|->
name|flags
operator||=
name|PFDESC_TCP_NORM
expr_stmt|;
name|flags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TH_SYN
condition|)
block|{
comment|/* Illegal packet */
if|if
condition|(
name|flags
operator|&
name|TH_RST
condition|)
goto|goto
name|tcp_drop
goto|;
if|if
condition|(
name|flags
operator|&
name|TH_FIN
condition|)
name|flags
operator|&=
operator|~
name|TH_FIN
expr_stmt|;
block|}
else|else
block|{
comment|/* Illegal packet */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* These flags are only valid if ACK is set */
if|if
condition|(
operator|(
name|flags
operator|&
name|TH_FIN
operator|)
operator|||
operator|(
name|flags
operator|&
name|TH_PUSH
operator|)
operator|||
operator|(
name|flags
operator|&
name|TH_URG
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
block|}
comment|/* Check for illegal header length */
if|if
condition|(
name|th
operator|->
name|th_off
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
condition|)
goto|goto
name|tcp_drop
goto|;
comment|/* If flags changed, or reserved data set, then adjust */
if|if
condition|(
name|flags
operator|!=
name|th
operator|->
name|th_flags
operator|||
name|th
operator|->
name|th_x2
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|ov
decl_stmt|,
name|nv
decl_stmt|;
name|ov
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
operator|&
name|th
operator|->
name|th_ack
operator|+
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|th_flags
operator|=
name|flags
expr_stmt|;
name|th
operator|->
name|th_x2
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
operator|&
name|th
operator|->
name|th_ack
operator|+
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|th
operator|->
name|th_sum
argument_list|,
name|ov
argument_list|,
name|nv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Remove urgent pointer, if TH_URG is not set */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_URG
operator|)
operator|&&
name|th
operator|->
name|th_urp
condition|)
block|{
name|th
operator|->
name|th_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|th
operator|->
name|th_sum
argument_list|,
name|th
operator|->
name|th_urp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_urp
operator|=
literal|0
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Process options */
if|if
condition|(
name|r
operator|->
name|max_mss
operator|&&
name|pf_normalize_tcpopt
argument_list|(
name|r
argument_list|,
name|m
argument_list|,
name|th
argument_list|,
name|off
argument_list|)
condition|)
name|rewrite
operator|=
literal|1
expr_stmt|;
comment|/* copy back packet headers if we sanitized */
if|if
condition|(
name|rewrite
condition|)
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|th
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_PASS
operator|)
return|;
name|tcp_drop
label|:
name|REASON_SET
argument_list|(
operator|&
name|reason
argument_list|,
name|PFRES_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|log
condition|)
name|PFLOG_PACKET
argument_list|(
name|kif
argument_list|,
name|h
argument_list|,
name|m
argument_list|,
name|AF_INET
argument_list|,
name|dir
argument_list|,
name|reason
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PF_DROP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_normalize_tcp_init
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|)
block|{
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|src
operator|->
name|scrub
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"pf_normalize_tcp_init: src->scrub != NULL"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|src
operator|->
name|scrub
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|src
operator|->
name|scrub
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_state_scrub_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|scrub
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bzero
argument_list|(
name|src
operator|->
name|scrub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
operator|->
name|scrub
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip_ttl
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip6_hlim
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* 	 * All normalizations below are only begun if we see the start of 	 * the connections.  They must all set an enabled bit in pfss_flags 	 */
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|th
operator|->
name|th_off
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|&&
name|src
operator|->
name|scrub
operator|&&
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|th
operator|->
name|th_off
operator|<<
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Diddle with TCP options */
name|int
name|hlen
decl_stmt|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPOPT_NOP
case|:
name|opt
operator|++
expr_stmt|;
name|hlen
operator|--
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
if|if
condition|(
name|opt
index|[
literal|1
index|]
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator||=
name|PFSS_TIMESTAMP
expr_stmt|;
name|src
operator|->
name|scrub
operator|->
name|pfss_ts_mod
operator|=
name|arc4random
argument_list|()
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|hlen
operator|-=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opt
operator|+=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_normalize_tcp_cleanup
parameter_list|(
name|struct
name|pf_state
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|src
operator|.
name|scrub
condition|)
name|pool_put
argument_list|(
operator|&
name|pf_state_scrub_pl
argument_list|,
name|state
operator|->
name|src
operator|.
name|scrub
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dst
operator|.
name|scrub
condition|)
name|pool_put
argument_list|(
operator|&
name|pf_state_scrub_pl
argument_list|,
name|state
operator|->
name|dst
operator|.
name|scrub
argument_list|)
expr_stmt|;
comment|/* Someday... flush the TCP segment reassembly descriptors. */
block|}
end_function

begin_function
name|int
name|pf_normalize_tcp_stateful
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|pf_pdesc
modifier|*
name|pd
parameter_list|,
name|u_short
modifier|*
name|reason
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|src
parameter_list|,
name|struct
name|pf_state_peer
modifier|*
name|dst
parameter_list|,
name|int
modifier|*
name|writeback
parameter_list|)
block|{
name|u_int8_t
name|hdr
index|[
literal|60
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|opt
decl_stmt|;
name|int
name|copyback
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|KASSERT
argument_list|(
operator|(
name|src
operator|->
name|scrub
operator|||
name|dst
operator|->
name|scrub
operator|)
argument_list|,
operator|(
literal|"pf_normalize_tcp_statefull: src->scrub&& dst->scrub!"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|KASSERT
argument_list|(
name|src
operator|->
name|scrub
operator|||
name|dst
operator|->
name|scrub
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Enforce the minimum TTL seen for this connection.  Negate a common 	 * technique to evade an intrusion detection system and confuse 	 * firewall state code. 	 */
switch|switch
condition|(
name|pd
operator|->
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
if|if
condition|(
name|src
operator|->
name|scrub
condition|)
block|{
name|struct
name|ip
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ip_ttl
operator|>
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip_ttl
expr_stmt|;
name|h
operator|->
name|ip_ttl
operator|=
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
if|if
condition|(
name|src
operator|->
name|scrub
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|h
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ip6_hlim
operator|>
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
condition|)
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
operator|=
name|h
operator|->
name|ip6_hlim
expr_stmt|;
name|h
operator|->
name|ip6_hlim
operator|=
name|src
operator|->
name|scrub
operator|->
name|pfss_ttl
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
name|th
operator|->
name|th_off
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>>
literal|2
operator|)
operator|&&
operator|(
operator|(
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
operator|)
operator|||
operator|(
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
operator|)
operator|)
operator|&&
name|pf_pull_hdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|hdr
argument_list|,
name|th
operator|->
name|th_off
operator|<<
literal|2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pd
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Diddle with TCP options */
name|int
name|hlen
decl_stmt|;
name|opt
operator|=
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|hlen
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
switch|switch
condition|(
operator|*
name|opt
condition|)
block|{
case|case
name|TCPOPT_EOL
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPOPT_NOP
case|:
name|opt
operator|++
expr_stmt|;
name|hlen
operator|--
expr_stmt|;
break|break;
case|case
name|TCPOPT_TIMESTAMP
case|:
comment|/* Modulate the timestamps.  Can be used for 				 * NAT detection, OS uptime determination or 				 * reboot detection. 				 */
if|if
condition|(
name|opt
index|[
literal|1
index|]
operator|>=
name|TCPOLEN_TIMESTAMP
condition|)
block|{
name|u_int32_t
name|ts_value
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|scrub
operator|&&
operator|(
name|src
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|ts_value
argument_list|,
operator|&
name|opt
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|ts_value
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|ts_value
argument_list|)
operator|+
name|src
operator|->
name|scrub
operator|->
name|pfss_ts_mod
argument_list|)
expr_stmt|;
name|pf_change_a
argument_list|(
operator|&
name|opt
index|[
literal|2
index|]
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|ts_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Modulate TS reply iff valid (!0) */
name|memcpy
argument_list|(
operator|&
name|ts_value
argument_list|,
operator|&
name|opt
index|[
literal|6
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts_value
operator|&&
name|dst
operator|->
name|scrub
operator|&&
operator|(
name|dst
operator|->
name|scrub
operator|->
name|pfss_flags
operator|&
name|PFSS_TIMESTAMP
operator|)
condition|)
block|{
name|ts_value
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|ts_value
argument_list|)
operator|-
name|dst
operator|->
name|scrub
operator|->
name|pfss_ts_mod
argument_list|)
expr_stmt|;
name|pf_change_a
argument_list|(
operator|&
name|opt
index|[
literal|6
index|]
argument_list|,
operator|&
name|th
operator|->
name|th_sum
argument_list|,
name|ts_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copyback
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* FALLTHROUGH */
default|default:
name|hlen
operator|-=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opt
operator|+=
name|MAX
argument_list|(
name|opt
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|copyback
condition|)
block|{
comment|/* Copyback the options, caller copys back header */
operator|*
name|writeback
operator|=
literal|1
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
name|hdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* I have a dream....  TCP segment reassembly.... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_normalize_tcpopt
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|mss
decl_stmt|;
name|int
name|thoff
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|cnt
decl_stmt|,
name|optlen
init|=
literal|0
decl_stmt|;
name|int
name|rewrite
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|optp
decl_stmt|;
name|thoff
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
name|cnt
operator|=
name|thoff
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|optp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|optp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|optp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
break|break;
name|optlen
operator|=
name|optp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
literal|2
operator|||
name|optlen
operator|>
name|cnt
condition|)
break|break;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_MAXSEG
case|:
name|mss
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|optp
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
operator|*
name|mss
argument_list|)
operator|)
operator|>
name|r
operator|->
name|max_mss
condition|)
block|{
name|th
operator|->
name|th_sum
operator|=
name|pf_cksum_fixup
argument_list|(
name|th
operator|->
name|th_sum
argument_list|,
operator|*
name|mss
argument_list|,
name|htons
argument_list|(
name|r
operator|->
name|max_mss
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mss
operator|=
name|htons
argument_list|(
name|r
operator|->
name|max_mss
argument_list|)
expr_stmt|;
name|rewrite
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|rewrite
operator|)
return|;
block|}
end_function

end_unit

