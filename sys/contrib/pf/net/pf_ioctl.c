begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pf_ioctl.c,v 1.175 2007/02/26 22:47:43 deraadt Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Daniel Hartmeier  * Copyright (c) 2002,2003 Henning Brauer  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  *  */
end_comment

begin_include
include|#
directive|include
file|"pfsync.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeout.h>
end_include

begin_include
include|#
directive|include
file|<sys/pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<uvm/uvm_extern.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<dev/rndvar.h>
end_include

begin_include
include|#
directive|include
file|<crypto/md5.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_if
if|#
directive|if
name|NPFSYNC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/if_pfsync.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPFSYNC> 0 */
end_comment

begin_if
if|#
directive|if
name|NPFLOG
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/if_pflog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPFLOG> 0 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|pfattach
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_thread_create
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfopen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|,
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfioctl
parameter_list|(
name|dev_t
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function_decl
name|int
name|pf_begin_altq
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_rollback_altq
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_commit_altq
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_enable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_disable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ */
end_comment

begin_function_decl
name|int
name|pf_begin_rules
parameter_list|(
name|u_int32_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_rollback_rules
parameter_list|(
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_setup_pfsync_matching
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_hash_rule
parameter_list|(
name|MD5_CTX
modifier|*
parameter_list|,
name|struct
name|pf_rule
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_hash_rule_addr
parameter_list|(
name|MD5_CTX
modifier|*
parameter_list|,
name|struct
name|pf_rule_addr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_commit_rules
parameter_list|(
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pf_rule
name|pf_default_rule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rwlock
name|pf_consistency_lock
init|=
name|RWLOCK_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pf_altq_running
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TAGID_MAX
value|50000
end_define

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|pf_tags
argument_list|,
argument|pf_tagname
argument_list|)
end_macro

begin_expr_stmt
name|pf_tags
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pf_tags
argument_list|)
operator|,
name|pf_qids
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pf_qids
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
operator|(
name|PF_QNAME_SIZE
operator|!=
name|PF_TAG_NAME_SIZE
operator|)
end_if

begin_error
error|#
directive|error
error|PF_QNAME_SIZE must be equal to PF_TAG_NAME_SIZE
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|u_int16_t
name|tagname2tag
parameter_list|(
name|struct
name|pf_tags
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tag2tagname
parameter_list|(
name|struct
name|pf_tags
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tag_unref
parameter_list|(
name|struct
name|pf_tags
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_rtlabel_add
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_rtlabel_remove
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_rtlabel_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (pf_status.debug>= (n)) printf x
end_define

begin_function
name|void
name|pfattach
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|timeout
init|=
name|pf_default_rule
operator|.
name|timeout
decl_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfrulepl"
argument_list|,
operator|&
name|pool_allocator_nointr
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_src_tree_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfsrctrpl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfstatepl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfaltqpl"
argument_list|,
operator|&
name|pool_allocator_nointr
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfpooladdrpl"
argument_list|,
operator|&
name|pool_allocator_nointr
argument_list|)
expr_stmt|;
name|pfr_initialize
argument_list|()
expr_stmt|;
name|pfi_initialize
argument_list|()
expr_stmt|;
name|pf_osfp_initialize
argument_list|()
expr_stmt|;
name|pool_sethardlimit
argument_list|(
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|pp
argument_list|,
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|limit
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctob
argument_list|(
name|physmem
argument_list|)
operator|<=
literal|100
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|pf_pool_limits
index|[
name|PF_LIMIT_TABLE_ENTRIES
index|]
operator|.
name|limit
operator|=
name|PFR_KENTRY_HIWAT_SMALL
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|tree_src_tracking
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|pf_main_ruleset
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|pf_altqs_active
operator|=
operator|&
name|pf_altqs
index|[
literal|0
index|]
expr_stmt|;
name|pf_altqs_inactive
operator|=
operator|&
name|pf_altqs
index|[
literal|1
index|]
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|state_list
argument_list|)
expr_stmt|;
comment|/* default rule should never be garbage collected */
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_prev
operator|=
operator|&
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_next
expr_stmt|;
name|pf_default_rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
name|pf_default_rule
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
name|pf_default_rule
operator|.
name|rtableid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* initialize default timeouts */
name|timeout
index|[
name|PFTM_TCP_FIRST_PACKET
index|]
operator|=
name|PFTM_TCP_FIRST_PACKET_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TCP_OPENING
index|]
operator|=
name|PFTM_TCP_OPENING_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TCP_ESTABLISHED
index|]
operator|=
name|PFTM_TCP_ESTABLISHED_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TCP_CLOSING
index|]
operator|=
name|PFTM_TCP_CLOSING_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TCP_FIN_WAIT
index|]
operator|=
name|PFTM_TCP_FIN_WAIT_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TCP_CLOSED
index|]
operator|=
name|PFTM_TCP_CLOSED_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_UDP_FIRST_PACKET
index|]
operator|=
name|PFTM_UDP_FIRST_PACKET_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_UDP_SINGLE
index|]
operator|=
name|PFTM_UDP_SINGLE_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_UDP_MULTIPLE
index|]
operator|=
name|PFTM_UDP_MULTIPLE_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_ICMP_FIRST_PACKET
index|]
operator|=
name|PFTM_ICMP_FIRST_PACKET_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_ICMP_ERROR_REPLY
index|]
operator|=
name|PFTM_ICMP_ERROR_REPLY_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_OTHER_FIRST_PACKET
index|]
operator|=
name|PFTM_OTHER_FIRST_PACKET_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_OTHER_SINGLE
index|]
operator|=
name|PFTM_OTHER_SINGLE_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_OTHER_MULTIPLE
index|]
operator|=
name|PFTM_OTHER_MULTIPLE_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_FRAG
index|]
operator|=
name|PFTM_FRAG_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_INTERVAL
index|]
operator|=
name|PFTM_INTERVAL_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_SRC_NODE
index|]
operator|=
name|PFTM_SRC_NODE_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_TS_DIFF
index|]
operator|=
name|PFTM_TS_DIFF_VAL
expr_stmt|;
name|timeout
index|[
name|PFTM_ADAPTIVE_START
index|]
operator|=
name|PFSTATE_ADAPT_START
expr_stmt|;
name|timeout
index|[
name|PFTM_ADAPTIVE_END
index|]
operator|=
name|PFSTATE_ADAPT_END
expr_stmt|;
name|pf_normalize_init
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pf_status
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|pf_status
operator|.
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
comment|/* XXX do our best to avoid a conflict */
name|pf_status
operator|.
name|hostid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
comment|/* require process context to purge states, so perform in a thread */
name|kthread_create_deferred
argument_list|(
name|pf_thread_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_thread_create
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|kthread_create
argument_list|(
name|pf_purge_thread
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"pfpurge"
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pfpurge thread"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
name|anchor
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|u_int8_t
name|rule_action
parameter_list|,
name|u_int32_t
name|rule_number
parameter_list|,
name|u_int8_t
name|r_last
parameter_list|,
name|u_int8_t
name|active
parameter_list|,
name|u_int8_t
name|check_ticket
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|rule_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|active
condition|)
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r_last
condition|)
block|{
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|rule_number
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|rule
operator|->
name|rpool
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|,
name|struct
name|pf_palist
modifier|*
name|poolb
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|mv_pool_pa
decl_stmt|;
while|while
condition|(
operator|(
name|mv_pool_pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|poolb
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|empty_pool_pa
decl_stmt|;
while|while
condition|(
operator|(
name|empty_pool_pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|empty_pool_pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|empty_pool_pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pfi_kif_unref
argument_list|(
name|empty_pool_pa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|empty_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|empty_pool_pa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_rm_rule
parameter_list|(
name|struct
name|pf_rulequeue
modifier|*
name|rulequeue
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
if|if
condition|(
name|rulequeue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|states
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * XXX - we need to remove the table *before* detaching 			 * the rule to make sure the table code does not delete 			 * the anchor under our feet. 			 */
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|overload_tbl
condition|)
name|pfr_detach_table
argument_list|(
name|rule
operator|->
name|overload_tbl
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|rulequeue
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|states
operator|>
literal|0
operator|||
name|rule
operator|->
name|src_nodes
operator|>
literal|0
operator|||
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|!=
name|NULL
condition|)
return|return;
name|pf_tag_unref
argument_list|(
name|rule
operator|->
name|tag
argument_list|)
expr_stmt|;
name|pf_tag_unref
argument_list|(
name|rule
operator|->
name|match_tag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|rule
operator|->
name|pqid
operator|!=
name|rule
operator|->
name|qid
condition|)
name|pf_qid_unref
argument_list|(
name|rule
operator|->
name|pqid
argument_list|)
expr_stmt|;
name|pf_qid_unref
argument_list|(
name|rule
operator|->
name|qid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pf_rtlabel_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_rtlabel_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rulequeue
operator|==
name|NULL
condition|)
block|{
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|overload_tbl
condition|)
name|pfr_detach_table
argument_list|(
name|rule
operator|->
name|overload_tbl
argument_list|)
expr_stmt|;
block|}
name|pfi_kif_unref
argument_list|(
name|rule
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
name|pf_anchor_remove
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|pf_empty_pool
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|tagname2tag
parameter_list|(
name|struct
name|pf_tags
modifier|*
name|head
parameter_list|,
name|char
modifier|*
name|tagname
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|tag
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|new_tagid
init|=
literal|1
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tag
argument_list|,
argument|head
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|tagname
argument_list|,
name|tag
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
comment|/* 	 * to avoid fragmentation, we do a linear search from the beginning 	 * and take the first free slot we find. if there is none or the list 	 * is empty, append a new entry at the end. 	 */
comment|/* new entry */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
name|head
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|tag
operator|==
name|new_tagid
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
control|)
name|new_tagid
operator|=
name|p
operator|->
name|tag
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|new_tagid
operator|>
name|TAGID_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* allocate and fill new struct pf_tagname */
name|tag
operator|=
operator|(
expr|struct
name|pf_tagname
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pf_tagname
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_tagname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tag
operator|->
name|name
argument_list|,
name|tagname
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|->
name|tag
operator|=
name|new_tagid
expr_stmt|;
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* insert new entry before p */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
comment|/* either list empty or no free slot in between */
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tag2tagname
parameter_list|(
name|struct
name|pf_tags
modifier|*
name|head
parameter_list|,
name|u_int16_t
name|tagid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|tag
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tag
argument_list|,
argument|head
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|tag
operator|->
name|tag
operator|==
name|tagid
condition|)
block|{
name|strlcpy
argument_list|(
name|p
argument_list|,
name|tag
operator|->
name|name
argument_list|,
name|PF_TAG_NAME_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|tag_unref
parameter_list|(
name|struct
name|pf_tags
modifier|*
name|head
parameter_list|,
name|u_int16_t
name|tag
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
operator|--
name|p
operator|->
name|ref
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
name|u_int16_t
name|pf_tagname2tag
parameter_list|(
name|char
modifier|*
name|tagname
parameter_list|)
block|{
return|return
operator|(
name|tagname2tag
argument_list|(
operator|&
name|pf_tags
argument_list|,
name|tagname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_tag2tagname
parameter_list|(
name|u_int16_t
name|tagid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|tag2tagname
argument_list|(
operator|&
name|pf_tags
argument_list|,
name|tagid
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_tag_ref
parameter_list|(
name|u_int16_t
name|tag
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|t
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&pf_tags
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|t
operator|->
name|tag
operator|==
name|tag
condition|)
break|break;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
name|t
operator|->
name|ref
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_tag_unref
parameter_list|(
name|u_int16_t
name|tag
parameter_list|)
block|{
name|tag_unref
argument_list|(
operator|&
name|pf_tags
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pf_rtlabel_add
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|PF_ADDR_RTLABEL
operator|&&
operator|(
name|a
operator|->
name|v
operator|.
name|rtlabel
operator|=
name|rtlabel_name2id
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabelname
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_rtlabel_remove
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|PF_ADDR_RTLABEL
condition|)
name|rtlabel_unref
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_rtlabel_copyout
parameter_list|(
name|struct
name|pf_addr_wrap
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
name|PF_ADDR_RTLABEL
operator|&&
name|a
operator|->
name|v
operator|.
name|rtlabel
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|rtlabel_id2name
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabel
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabelname
argument_list|,
literal|"?"
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabelname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabelname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|v
operator|.
name|rtlabelname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function
name|u_int32_t
name|pf_qname2qid
parameter_list|(
name|char
modifier|*
name|qname
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|tagname2tag
argument_list|(
operator|&
name|pf_qids
argument_list|,
name|qname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_qid2qname
parameter_list|(
name|u_int32_t
name|qid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|tag2tagname
argument_list|(
operator|&
name|pf_qids
argument_list|,
operator|(
name|u_int16_t
operator|)
name|qid
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_qid_unref
parameter_list|(
name|u_int32_t
name|qid
parameter_list|)
block|{
name|tag_unref
argument_list|(
operator|&
name|pf_qids
argument_list|,
operator|(
name|u_int16_t
operator|)
name|qid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pf_begin_altq
parameter_list|(
name|u_int32_t
modifier|*
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ticket
operator|=
operator|++
name|ticket_altqs_inactive
expr_stmt|;
name|altqs_inactive_open
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_rollback_altq
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|altqs_inactive_open
operator|||
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
name|altqs_inactive_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_commit_altq
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|)
block|{
name|struct
name|pf_altqqueue
modifier|*
name|old_altqs
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|s
decl_stmt|,
name|err
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|altqs_inactive_open
operator|||
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* swap altqs, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_altqs
operator|=
name|pf_altqs_active
expr_stmt|;
name|pf_altqs_active
operator|=
name|pf_altqs_inactive
expr_stmt|;
name|pf_altqs_inactive
operator|=
name|old_altqs
expr_stmt|;
name|ticket_altqs_active
operator|=
name|ticket_altqs_inactive
expr_stmt|;
comment|/* Attach new disciplines */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* attach the discipline */
name|error
operator|=
name|altq_pfattach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pf_altq_running
condition|)
name|error
operator|=
name|pf_enable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
if|if
condition|(
name|pf_altq_running
condition|)
name|error
operator|=
name|pf_disable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
name|err
operator|=
name|altq_pfdetach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
name|err
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
else|else
name|pf_qid_unref
argument_list|(
name|altq
operator|->
name|qid
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|altqs_inactive_open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_enable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|altq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|altq_type
operator|!=
name|ALTQT_NONE
condition|)
name|error
operator|=
name|altq_enable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* set tokenbucket regulator */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ifp
operator|!=
name|NULL
operator|&&
name|ALTQ_IS_ENABLED
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|tb
operator|.
name|rate
operator|=
name|altq
operator|->
name|ifbandwidth
expr_stmt|;
name|tb
operator|.
name|depth
operator|=
name|altq
operator|->
name|tbrsize
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_disable_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|altq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * when the discipline is no longer referenced, it was overridden 	 * by a new one.  if so, just return. 	 */
if|if
condition|(
name|altq
operator|->
name|altq_disc
operator|!=
name|ifp
operator|->
name|if_snd
operator|.
name|altq_disc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|altq_disable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* clear tokenbucket regulator */
name|tb
operator|.
name|rate
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ */
end_comment

begin_function
name|int
name|pf_begin_rules
parameter_list|(
name|u_int32_t
modifier|*
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
operator|*
name|ticket
operator|=
operator|++
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_rollback_rules
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
operator|!=
name|ticket
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PF_MD5_UPD
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|)
define|\
value|MD5Update(ctx, (u_int8_t *)&(st)->elm, sizeof((st)->elm))
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_STR
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|)
define|\
value|MD5Update(ctx, (u_int8_t *) (st)->elm, strlen((st)->elm))
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_HTONL
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|,
name|stor
parameter_list|)
value|do {				\ 		(stor) = htonl((st)->elm);				\ 		MD5Update(ctx, (u_int8_t *)&(stor), sizeof(u_int32_t));\ } while (0)
end_define

begin_define
define|#
directive|define
name|PF_MD5_UPD_HTONS
parameter_list|(
name|st
parameter_list|,
name|elm
parameter_list|,
name|stor
parameter_list|)
value|do {				\ 		(stor) = htons((st)->elm);				\ 		MD5Update(ctx, (u_int8_t *)&(stor), sizeof(u_int16_t));\ } while (0)
end_define

begin_function
name|void
name|pf_hash_rule_addr
parameter_list|(
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|struct
name|pf_rule_addr
modifier|*
name|pfr
parameter_list|)
block|{
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pfr
operator|->
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|PF_ADDR_DYNIFTL
case|:
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|ifname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|iflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_TABLE
case|:
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|tblname
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_ADDRMASK
case|:
comment|/* XXX ignore af? */
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|addr32
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
operator|.
name|addr32
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_ADDR_RTLABEL
case|:
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|addr
operator|.
name|v
operator|.
name|rtlabelname
argument_list|)
expr_stmt|;
break|break;
block|}
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|neg
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|pfr
argument_list|,
name|port_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pf_hash_rule
parameter_list|(
name|MD5_CTX
modifier|*
name|ctx
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
name|u_int16_t
name|x
decl_stmt|;
name|u_int32_t
name|y
decl_stmt|;
name|pf_hash_rule_addr
argument_list|(
name|ctx
argument_list|,
operator|&
name|rule
operator|->
name|src
argument_list|)
expr_stmt|;
name|pf_hash_rule_addr
argument_list|(
name|ctx
argument_list|,
operator|&
name|rule
operator|->
name|dst
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_STR
argument_list|(
name|rule
argument_list|,
name|match_tagname
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONS
argument_list|(
name|rule
argument_list|,
name|match_tag
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* dup? */
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|os_fingerprint
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|prob
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|uid
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|uid
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|uid
operator|.
name|op
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|gid
index|[
literal|0
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|gid
index|[
literal|1
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|gid
operator|.
name|op
argument_list|)
expr_stmt|;
name|PF_MD5_UPD_HTONL
argument_list|(
name|rule
argument_list|,
name|rule_flag
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|quick
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|ifnot
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|match_tag_not
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|natpass
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|keep_state
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|flagset
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|allow_opts
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|PF_MD5_UPD
argument_list|(
name|rule
argument_list|,
name|tos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pf_commit_rules
parameter_list|(
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|rs_num
parameter_list|,
name|char
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|,
modifier|*
modifier|*
name|old_array
decl_stmt|;
name|struct
name|pf_rulequeue
modifier|*
name|old_rules
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|old_rcount
decl_stmt|;
if|if
condition|(
name|rs_num
operator|<
literal|0
operator|||
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|ticket
operator|!=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Calculate checksum for the main ruleset */
if|if
condition|(
name|rs
operator|==
operator|&
name|pf_main_ruleset
condition|)
block|{
name|error
operator|=
name|pf_setup_pfsync_matching
argument_list|(
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Swap rules, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_rules
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
expr_stmt|;
name|old_rcount
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
expr_stmt|;
name|old_array
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr_array
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
operator|=
name|old_rules
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|old_array
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|=
name|old_rcount
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|=
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Purge the old rule list. */
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|old_rules
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|old_rules
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
name|free
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|NULL
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|=
literal|0
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|rs
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_setup_pfsync_matching
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|rs
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_cnt
decl_stmt|;
name|u_int8_t
name|digest
index|[
name|PF_MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|rs_cnt
operator|=
literal|0
init|;
name|rs_cnt
operator|<
name|PF_RULESET_MAX
condition|;
name|rs_cnt
operator|++
control|)
block|{
comment|/* XXX PF_RULESET_SCRUB as well? */
if|if
condition|(
name|rs_cnt
operator|==
name|PF_RULESET_SCRUB
condition|)
continue|continue;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
name|free
argument_list|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|rcount
condition|)
block|{
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|*
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|rcount
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|rule
argument_list|,
argument|rs->rules[rs_cnt].inactive.ptr
argument_list|,
argument|entries
argument_list|)
block|{
name|pf_hash_rule
argument_list|(
operator|&
name|ctx
argument_list|,
name|rule
argument_list|)
expr_stmt|;
operator|(
name|rs
operator|->
name|rules
index|[
name|rs_cnt
index|]
operator|.
name|inactive
operator|.
name|ptr_array
operator|)
index|[
name|rule
operator|->
name|nr
index|]
operator|=
name|rule
expr_stmt|;
block|}
block|}
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pf_status
operator|.
name|pf_chksum
argument_list|,
name|digest
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_status
operator|.
name|pf_chksum
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_pool
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* XXX keep in sync with switch() below */
if|if
condition|(
name|securelevel
operator|>
literal|1
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETRULE
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCSETSTATUSIF
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCCLRSTATUS
case|:
case|case
name|DIOCNATLOOK
case|:
case|case
name|DIOCSETDEBUG
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCCLRRULECTRS
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRCLRTSTATS
case|:
case|case
name|DIOCRCLRADDRS
case|:
case|case
name|DIOCRADDADDRS
case|:
case|case
name|DIOCRDELADDRS
case|:
case|case
name|DIOCRSETADDRS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRCLRASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
case|case
name|DIOCGETSRCNODES
case|:
case|case
name|DIOCCLRSRCNODES
case|:
case|case
name|DIOCIGETIFACES
case|:
case|case
name|DIOCSETIFFLAG
case|:
case|case
name|DIOCCLRIFFLAG
case|:
break|break;
case|case
name|DIOCRCLRTABLES
case|:
case|case
name|DIOCRADDTABLES
case|:
case|case
name|DIOCRDELTABLES
case|:
case|case
name|DIOCRSETTFLAGS
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
operator|)
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_DUMMY
condition|)
break|break;
comment|/* dummy operation ok */
return|return
operator|(
name|EPERM
operator|)
return|;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCNATLOOK
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
case|case
name|DIOCGETSRCNODES
case|:
case|case
name|DIOCIGETIFACES
case|:
break|break;
case|case
name|DIOCRCLRTABLES
case|:
case|case
name|DIOCRADDTABLES
case|:
case|case
name|DIOCRDELTABLES
case|:
case|case
name|DIOCRCLRTSTATS
case|:
case|case
name|DIOCRCLRADDRS
case|:
case|case
name|DIOCRADDADDRS
case|:
case|case
name|DIOCRDELADDRS
case|:
case|case
name|DIOCRSETADDRS
case|:
case|case
name|DIOCRSETTFLAGS
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
operator|)
operator|->
name|pfrio_flags
operator|&
name|PFR_FLAG_DUMMY
condition|)
block|{
name|flags
operator||=
name|FWRITE
expr_stmt|;
comment|/* need write lock for dummy */
break|break;
comment|/* dummy operation ok */
block|}
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|DIOCGETRULE
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
operator|)
operator|->
name|action
operator|==
name|PF_GET_CLR_CNTR
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|rw_enter_write
argument_list|(
operator|&
name|pf_consistency_lock
argument_list|)
expr_stmt|;
else|else
name|rw_enter_read
argument_list|(
operator|&
name|pf_consistency_lock
argument_list|)
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSTART
case|:
if|if
condition|(
name|pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
name|pf_status
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
name|pf_status
operator|.
name|stateid
operator|==
literal|0
condition|)
block|{
name|pf_status
operator|.
name|stateid
operator|=
name|time_second
expr_stmt|;
name|pf_status
operator|.
name|stateid
operator|=
name|pf_status
operator|.
name|stateid
operator|<<
literal|32
expr_stmt|;
block|}
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: started\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCSTOP
case|:
if|if
condition|(
operator|!
name|pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
block|{
name|pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: stopped\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCADDRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|pool_ticket
operator|!=
name|ticket_pabuf
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|rule
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pr
operator|->
name|rule
argument_list|,
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|rule
operator|->
name|cuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|rule
operator|->
name|cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|rule
operator|->
name|anchor
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* initialize refcounting */
name|rule
operator|->
name|states
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|src_nodes
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|rule
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|rule
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|rule
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|rule
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|rule
operator|->
name|kif
operator|=
name|pfi_kif_get
argument_list|(
name|rule
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|kif
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pfi_kif_ref
argument_list|(
name|rule
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|rtableid
operator|>
literal|0
operator|&&
operator|!
name|rtable_exists
argument_list|(
name|rule
operator|->
name|rtableid
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|rule
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|rule
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|pqname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|pqid
operator|=
name|pf_qname2qid
argument_list|(
name|rule
operator|->
name|pqname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|rule
operator|->
name|pqid
operator|=
name|rule
operator|->
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rt
operator|&&
operator|!
name|rule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|#
directive|if
name|NPFLOG
operator|>
literal|0
if|if
condition|(
name|rule
operator|->
name|logif
operator|>=
name|PFLOGIFS_MAX
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pf_rtlabel_add
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
operator|||
name|pf_rtlabel_add
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_anchor_setup
argument_list|(
name|rule
argument_list|,
name|ruleset
argument_list|,
name|pr
operator|->
name|anchor_call
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pf_pabuf
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|pa
operator|->
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|overload_tblname
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|rule
operator|->
name|overload_tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|rule
operator|->
name|overload_tblname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|rule
operator|->
name|overload_tbl
operator|->
name|pfrkt_flags
operator||=
name|PFR_TFLAG_ACTIVE
expr_stmt|;
block|}
name|pf_mv_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|)
operator|&&
name|rule
operator|->
name|anchor
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|rule
argument_list|)
expr_stmt|;
break|break;
block|}
name|rule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|rule
operator|->
name|evaluations
operator|=
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|rcount
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULES
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|tail
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|pr
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|ticket
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|,
name|i
decl_stmt|;
name|pr
operator|->
name|anchor
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|pr
operator|->
name|nr
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|rule
argument_list|,
operator|&
name|pr
operator|->
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_anchor_copyout
argument_list|(
name|ruleset
argument_list|,
name|rule
argument_list|,
name|pr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pfi_dynaddr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pfi_dynaddr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_rtlabel_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_rtlabel_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|action
operator|==
name|PF_GET_CLR_CNTR
condition|)
block|{
name|rule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCCHANGERULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pcr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|oldrule
init|=
name|NULL
decl_stmt|,
modifier|*
name|newrule
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
operator|)
operator|&&
name|pcr
operator|->
name|pool_ticket
operator|!=
name|ticket_pabuf
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|>
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pcr
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pcr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|pcr
operator|->
name|ticket
operator|=
operator|++
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|pcr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
name|newrule
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pcr
operator|->
name|rule
argument_list|,
name|newrule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|newrule
operator|->
name|cuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|newrule
operator|->
name|cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* initialize refcounting */
name|newrule
operator|->
name|states
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|newrule
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|newrule
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|newrule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newrule
operator|->
name|kif
operator|=
name|pfi_kif_get
argument_list|(
name|newrule
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|kif
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pfi_kif_ref
argument_list|(
name|newrule
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
block|}
else|else
name|newrule
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|rtableid
operator|>
literal|0
operator|&&
operator|!
name|rtable_exists
argument_list|(
name|newrule
operator|->
name|rtableid
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|newrule
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|newrule
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|newrule
operator|->
name|pqname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|pqid
operator|=
name|pf_qname2qid
argument_list|(
name|newrule
operator|->
name|pqname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
name|newrule
operator|->
name|pqid
operator|=
name|newrule
operator|->
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALTQ */
if|if
condition|(
name|newrule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|rt
operator|&&
operator|!
name|newrule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_rtlabel_add
argument_list|(
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|)
operator|||
name|pf_rtlabel_add
argument_list|(
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_anchor_setup
argument_list|(
name|newrule
argument_list|,
name|ruleset
argument_list|,
name|pcr
operator|->
name|anchor_call
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pf_pabuf
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|pa
operator|->
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|overload_tblname
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|newrule
operator|->
name|overload_tbl
operator|=
name|pfr_attach_table
argument_list|(
name|ruleset
argument_list|,
name|newrule
operator|->
name|overload_tblname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|newrule
operator|->
name|overload_tbl
operator|->
name|pfrkt_flags
operator||=
name|PFR_TFLAG_ACTIVE
expr_stmt|;
block|}
name|pf_mv_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|!
name|newrule
operator|->
name|anchor
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
break|break;
block|}
name|newrule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|newrule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|newrule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|newrule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|pf_empty_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldrule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
block|{
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldrule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldrule
operator|->
name|nr
operator|!=
name|pcr
operator|->
name|nr
operator|)
condition|)
name|oldrule
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newrule
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|rcount
operator|++
expr_stmt|;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|oldrule
argument_list|,
argument|ruleset->rules[rs_num].active.ptr
argument_list|,
argument|entries
argument_list|)
name|oldrule
operator|->
name|nr
operator|=
name|nr
operator|++
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|++
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSTATES
case|:
block|{
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|,
modifier|*
name|nexts
decl_stmt|;
name|struct
name|pfioc_state_kill
modifier|*
name|psk
init|=
operator|(
expr|struct
name|pfioc_state_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|killed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|state
operator|=
name|RB_MIN
argument_list|(
name|pf_state_tree_id
argument_list|,
operator|&
name|tree_id
argument_list|)
init|;
name|state
condition|;
name|state
operator|=
name|nexts
control|)
block|{
name|nexts
operator|=
name|RB_NEXT
argument_list|(
name|pf_state_tree_id
argument_list|,
operator|&
name|tree_id
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psk
operator|->
name|psk_ifname
index|[
literal|0
index|]
operator|||
operator|!
name|strcmp
argument_list|(
name|psk
operator|->
name|psk_ifname
argument_list|,
name|state
operator|->
name|u
operator|.
name|s
operator|.
name|kif
operator|->
name|pfik_name
argument_list|)
condition|)
block|{
if|#
directive|if
name|NPFSYNC
comment|/* don't send out individual delete messages */
name|state
operator|->
name|sync_flags
operator|=
name|PFSTATE_NOSYNC
expr_stmt|;
endif|#
directive|endif
name|pf_unlink_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
block|}
name|psk
operator|->
name|psk_af
operator|=
name|killed
expr_stmt|;
if|#
directive|if
name|NPFSYNC
name|pfsync_clear_states
argument_list|(
name|pf_status
operator|.
name|hostid
argument_list|,
name|psk
operator|->
name|psk_ifname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|DIOCKILLSTATES
case|:
block|{
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|,
modifier|*
name|nexts
decl_stmt|;
name|struct
name|pf_state_host
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|struct
name|pfioc_state_kill
modifier|*
name|psk
init|=
operator|(
expr|struct
name|pfioc_state_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|killed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|state
operator|=
name|RB_MIN
argument_list|(
name|pf_state_tree_id
argument_list|,
operator|&
name|tree_id
argument_list|)
init|;
name|state
condition|;
name|state
operator|=
name|nexts
control|)
block|{
name|nexts
operator|=
name|RB_NEXT
argument_list|(
name|pf_state_tree_id
argument_list|,
operator|&
name|tree_id
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|direction
operator|==
name|PF_OUT
condition|)
block|{
name|src
operator|=
operator|&
name|state
operator|->
name|lan
expr_stmt|;
name|dst
operator|=
operator|&
name|state
operator|->
name|ext
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|&
name|state
operator|->
name|ext
expr_stmt|;
name|dst
operator|=
operator|&
name|state
operator|->
name|lan
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|psk
operator|->
name|psk_af
operator|||
name|state
operator|->
name|af
operator|==
name|psk
operator|->
name|psk_af
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_proto
operator|||
name|psk
operator|->
name|psk_proto
operator|==
name|state
operator|->
name|proto
operator|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|neg
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|src
operator|->
name|addr
argument_list|,
name|state
operator|->
name|af
argument_list|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|neg
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|dst
operator|->
name|addr
argument_list|,
name|state
operator|->
name|af
argument_list|)
operator|&&
operator|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|src
operator|->
name|port
argument_list|)
operator|)
operator|&&
operator|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|dst
operator|->
name|port
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_ifname
index|[
literal|0
index|]
operator|||
operator|!
name|strcmp
argument_list|(
name|psk
operator|->
name|psk_ifname
argument_list|,
name|state
operator|->
name|u
operator|.
name|s
operator|.
name|kif
operator|->
name|pfik_name
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|NPFSYNC
operator|>
literal|0
comment|/* send immediate delete of state */
name|pfsync_delete_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|->
name|sync_flags
operator||=
name|PFSTATE_NOSYNC
expr_stmt|;
endif|#
directive|endif
name|pf_unlink_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
block|}
name|psk
operator|->
name|psk_af
operator|=
name|killed
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|struct
name|pfi_kif
modifier|*
name|kif
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|state
operator|.
name|timeout
operator|>=
name|PFTM_MAX
operator|&&
name|ps
operator|->
name|state
operator|.
name|timeout
operator|!=
name|PFTM_UNTIL_PACKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|kif
operator|=
name|pfi_kif_get
argument_list|(
name|ps
operator|->
name|state
operator|.
name|u
operator|.
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|kif
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|ps
operator|->
name|state
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|state
operator|->
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|rule
operator|.
name|ptr
operator|=
operator|&
name|pf_default_rule
expr_stmt|;
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|rt_kif
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|creation
operator|=
name|time_second
expr_stmt|;
name|state
operator|->
name|pfsync_time
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|state
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|state
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pf_insert_state
argument_list|(
name|kif
argument_list|,
name|state
argument_list|)
condition|)
block|{
name|pfi_kif_unref
argument_list|(
name|kif
argument_list|,
name|PFI_KIF_REF_NONE
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCGETSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|state
argument_list|,
argument|pf_state_tree_id
argument_list|,
argument|&tree_id
argument_list|)
block|{
if|if
condition|(
name|nr
operator|>=
name|ps
operator|->
name|nr
condition|)
break|break;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|secs
operator|=
name|time_second
expr_stmt|;
name|bcopy
argument_list|(
name|state
argument_list|,
operator|&
name|ps
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ps
operator|->
name|state
operator|.
name|u
operator|.
name|ifname
argument_list|,
name|state
operator|->
name|u
operator|.
name|s
operator|.
name|kif
operator|->
name|pfik_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|state
operator|.
name|u
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|rule
operator|.
name|nr
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|nat_rule
operator|.
name|nr
operator|=
operator|(
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|anchor
operator|.
name|nr
operator|=
operator|(
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|creation
operator|=
name|secs
operator|-
name|ps
operator|->
name|state
operator|.
name|creation
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|expire
operator|=
name|pf_state_expires
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|state
operator|.
name|expire
operator|>
name|secs
condition|)
name|ps
operator|->
name|state
operator|.
name|expire
operator|-=
name|secs
expr_stmt|;
else|else
name|ps
operator|->
name|state
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATES
case|:
block|{
name|struct
name|pfioc_states
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_states
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|p
decl_stmt|,
modifier|*
name|pstore
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|space
init|=
name|ps
operator|->
name|ps_len
decl_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
name|pf_status
operator|.
name|states
expr_stmt|;
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
operator|*
name|nr
expr_stmt|;
break|break;
block|}
name|pstore
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pstore
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|ps
operator|->
name|ps_states
expr_stmt|;
name|state
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|state_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|timeout
operator|!=
name|PFTM_UNLINKED
condition|)
block|{
name|int
name|secs
init|=
name|time_second
decl_stmt|;
if|if
condition|(
operator|(
name|nr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|ps
operator|->
name|ps_len
condition|)
break|break;
name|bcopy
argument_list|(
name|state
argument_list|,
name|pstore
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pstore
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|pstore
operator|->
name|u
operator|.
name|ifname
argument_list|,
name|state
operator|->
name|u
operator|.
name|s
operator|.
name|kif
operator|->
name|pfik_name
argument_list|,
sizeof|sizeof
argument_list|(
name|pstore
operator|->
name|u
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
name|pstore
operator|->
name|rule
operator|.
name|nr
operator|=
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|->
name|nat_rule
operator|.
name|nr
operator|=
operator|(
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|->
name|anchor
operator|.
name|nr
operator|=
operator|(
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|->
name|creation
operator|=
name|secs
operator|-
name|pstore
operator|->
name|creation
expr_stmt|;
name|pstore
operator|->
name|expire
operator|=
name|pf_state_expires
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstore
operator|->
name|expire
operator|>
name|secs
condition|)
name|pstore
operator|->
name|expire
operator|-=
name|secs
expr_stmt|;
else|else
name|pstore
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|pstore
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
name|state
operator|=
name|TAILQ_NEXT
argument_list|(
name|state
argument_list|,
name|u
operator|.
name|s
operator|.
name|entry_list
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
operator|*
name|nr
expr_stmt|;
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATUS
case|:
block|{
name|struct
name|pf_status
modifier|*
name|s
init|=
operator|(
expr|struct
name|pf_status
operator|*
operator|)
name|addr
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|pf_status
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|pfi_fill_oldstatus
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETSTATUSIF
case|:
block|{
name|struct
name|pfioc_if
modifier|*
name|pi
init|=
operator|(
expr|struct
name|pfioc_if
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|ifname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifunit
argument_list|(
name|pi
operator|->
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|pi
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSTATUS
case|:
block|{
name|bzero
argument_list|(
name|pf_status
operator|.
name|counters
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_status
operator|.
name|counters
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pf_status
operator|.
name|fcounters
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_status
operator|.
name|fcounters
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pf_status
operator|.
name|scounters
argument_list|,
sizeof|sizeof
argument_list|(
name|pf_status
operator|.
name|scounters
argument_list|)
argument_list|)
expr_stmt|;
name|pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
operator|*
name|pf_status
operator|.
name|ifname
condition|)
name|pfi_clr_istats
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCNATLOOK
case|:
block|{
name|struct
name|pfioc_natlook
modifier|*
name|pnl
init|=
operator|(
expr|struct
name|pfioc_natlook
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|struct
name|pf_state_cmp
name|key
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|,
name|direction
init|=
name|pnl
operator|->
name|direction
decl_stmt|;
name|key
operator|.
name|af
operator|=
name|pnl
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pnl
operator|->
name|proto
expr_stmt|;
if|if
condition|(
operator|!
name|pnl
operator|->
name|proto
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
operator|(
operator|(
name|pnl
operator|->
name|proto
operator|==
name|IPPROTO_TCP
operator|||
name|pnl
operator|->
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
operator|(
operator|!
name|pnl
operator|->
name|dport
operator|||
operator|!
name|pnl
operator|->
name|sport
operator|)
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* 			 * userland gives us source and dest of connection, 			 * reverse the lookup so we ask for what happens with 			 * the return traffic, enabling us to find it in the 			 * state tree. 			 */
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|ext
operator|.
name|addr
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|ext
operator|.
name|port
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|gwy
operator|.
name|addr
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|gwy
operator|.
name|port
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
name|state
operator|=
name|pf_find_state_all
argument_list|(
operator|&
name|key
argument_list|,
name|PF_EXT_GWY
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|lan
operator|.
name|addr
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|lan
operator|.
name|port
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|ext
operator|.
name|addr
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|ext
operator|.
name|port
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
name|state
operator|=
name|pf_find_state_all
argument_list|(
operator|&
name|key
argument_list|,
name|PF_LAN_EXT
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|error
operator|=
name|E2BIG
expr_stmt|;
comment|/* more than one state */
elseif|else
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rsaddr
argument_list|,
operator|&
name|state
operator|->
name|lan
operator|.
name|addr
argument_list|,
name|state
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rsport
operator|=
name|state
operator|->
name|lan
operator|.
name|port
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rdaddr
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rdport
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
block|}
else|else
block|{
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rdaddr
argument_list|,
operator|&
name|state
operator|->
name|gwy
operator|.
name|addr
argument_list|,
name|state
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rdport
operator|=
name|state
operator|->
name|gwy
operator|.
name|port
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rsaddr
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rsport
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCSETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
operator|||
name|pt
operator|->
name|seconds
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|old
operator|=
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|==
name|PFTM_INTERVAL
operator|&&
name|pt
operator|->
name|seconds
operator|==
literal|0
condition|)
name|pt
operator|->
name|seconds
operator|=
literal|1
expr_stmt|;
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
operator|=
name|pt
operator|->
name|seconds
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|==
name|PFTM_INTERVAL
operator|&&
name|pt
operator|->
name|seconds
operator|<
name|old
condition|)
name|wakeup
argument_list|(
name|pf_purge_thread
argument_list|)
expr_stmt|;
name|pt
operator|->
name|seconds
operator|=
name|old
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pt
operator|->
name|seconds
operator|=
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pl
operator|->
name|limit
operator|=
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old_limit
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
operator|||
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|pp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|pool_sethardlimit
argument_list|(
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|pp
argument_list|,
name|pl
operator|->
name|limit
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|old_limit
operator|=
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
operator|=
name|pl
operator|->
name|limit
expr_stmt|;
name|pl
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETDEBUG
case|:
block|{
name|u_int32_t
modifier|*
name|level
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|pf_status
operator|.
name|debug
operator|=
operator|*
name|level
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRRULECTRS
case|:
block|{
comment|/* obsoleted by DIOCGETRULE with action=PF_GET_CLR_CNTR */
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
operator|&
name|pf_main_ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rule
argument_list|,
argument|ruleset->rules[PF_RULESET_FILTER].active.ptr
argument_list|,
argument|entries
argument_list|)
block|{
name|rule
operator|->
name|evaluations
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|rule
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|DIOCSTARTALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
comment|/* enable all altq interfaces on active list */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pf_enable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pf_altq_running
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: started\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSTOPALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
comment|/* disable all altq interfaces on active list */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pf_disable_altq
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pf_altq_running
operator|=
literal|0
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: stopped\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|,
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|altq
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pa
operator|->
name|altq
argument_list|,
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if this is for a queue, find the discipline and 		 * copy the necessary fields 		 */
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|altq
operator|->
name|qid
operator|=
name|pf_qname2qid
argument_list|(
name|altq
operator|->
name|qname
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|a
argument_list|,
argument|pf_altqs_inactive
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a
operator|->
name|ifname
argument_list|,
name|altq
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|==
literal|0
operator|&&
name|a
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|altq
operator|->
name|altq_disc
operator|=
name|a
operator|->
name|altq_disc
expr_stmt|;
break|break;
block|}
block|}
block|}
name|error
operator|=
name|altq_add
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETALTQS
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|pa
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
name|pa
operator|->
name|nr
operator|++
expr_stmt|;
name|pa
operator|->
name|ticket
operator|=
name|ticket_altqs_active
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|ticket_altqs_active
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pa
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEALTQ
case|:
comment|/* CHANGEALTQ not supported yet! */
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|DIOCGETQSTATS
case|:
block|{
name|struct
name|pfioc_qstats
modifier|*
name|pq
init|=
operator|(
expr|struct
name|pfioc_qstats
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|ticket
operator|!=
name|ticket_altqs_active
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nbytes
operator|=
name|pq
operator|->
name|nbytes
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pq
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_getqstats
argument_list|(
name|altq
argument_list|,
name|pq
operator|->
name|buf
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pq
operator|->
name|scheduler
operator|=
name|altq
operator|->
name|scheduler
expr_stmt|;
name|pq
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|DIOCBEGINADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|pf_empty_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ticket
operator|=
operator|++
name|ticket_pabuf
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|ticket
operator|!=
name|ticket_pabuf
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|pa
operator|->
name|kif
operator|=
name|pfi_kif_get
argument_list|(
name|pa
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|kif
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pfi_kif_ref
argument_list|(
name|pa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|pa
operator|->
name|addr
argument_list|,
name|pp
operator|->
name|af
argument_list|)
condition|)
block|{
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pfi_kif_unref
argument_list|(
name|pa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|pp
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pool->list
argument_list|,
argument|entries
argument_list|)
name|pp
operator|->
name|nr
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pp
operator|->
name|nr
operator|)
condition|)
block|{
name|pa
operator|=
name|TAILQ_NEXT
argument_list|(
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|pa
argument_list|,
operator|&
name|pp
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
name|pfi_dynaddr_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_rtlabel_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pca
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|oldpa
init|=
name|NULL
decl_stmt|,
modifier|*
name|newpa
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
if|if
condition|(
name|pca
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|>
name|PF_CHANGE_REMOVE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pca
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pca
operator|->
name|anchor
argument_list|,
name|pca
operator|->
name|ticket
argument_list|,
name|pca
operator|->
name|r_action
argument_list|,
name|pca
operator|->
name|r_num
argument_list|,
name|pca
operator|->
name|r_last
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
name|newpa
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pca
operator|->
name|addr
argument_list|,
name|newpa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|newpa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newpa
operator|->
name|kif
operator|=
name|pfi_kif_get
argument_list|(
name|newpa
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|->
name|kif
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pfi_kif_ref
argument_list|(
name|newpa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
block|}
else|else
name|newpa
operator|->
name|kif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pfi_dynaddr_setup
argument_list|(
operator|&
name|newpa
operator|->
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
operator|||
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newpa
operator|->
name|addr
argument_list|)
condition|)
block|{
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|newpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pfi_kif_unref
argument_list|(
name|newpa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldpa
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pf_palist
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldpa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
name|pca
operator|->
name|nr
operator|)
condition|)
block|{
name|oldpa
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|pfi_dynaddr_remove
argument_list|(
operator|&
name|oldpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|oldpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pfi_kif_unref
argument_list|(
name|oldpa
operator|->
name|kif
argument_list|,
name|PFI_KIF_REF_RULE
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|oldpa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pool
operator|->
name|counter
argument_list|,
operator|&
name|pool
operator|->
name|cur
operator|->
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULESETS
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|pr
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ruleset
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/* XXX kludge for pf_main_ruleset */
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_global
argument_list|,
argument|&pf_anchors
argument_list|)
if|if
condition|(
name|anchor
operator|->
name|parent
operator|==
name|NULL
condition|)
name|pr
operator|->
name|nr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_node
argument_list|,
argument|&ruleset->anchor->children
argument_list|)
name|pr
operator|->
name|nr
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCGETRULESET
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|pr
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pr
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ruleset
operator|->
name|anchor
operator|==
name|NULL
condition|)
block|{
comment|/* XXX kludge for pf_main_ruleset */
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_global
argument_list|,
argument|&pf_anchors
argument_list|)
if|if
condition|(
name|anchor
operator|->
name|parent
operator|==
name|NULL
operator|&&
name|nr
operator|++
operator|==
name|pr
operator|->
name|nr
condition|)
block|{
name|strlcpy
argument_list|(
name|pr
operator|->
name|name
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|RB_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|pf_anchor_node
argument_list|,
argument|&ruleset->anchor->children
argument_list|)
if|if
condition|(
name|nr
operator|++
operator|==
name|pr
operator|->
name|nr
condition|)
block|{
name|strlcpy
argument_list|(
name|pr
operator|->
name|name
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pr
operator|->
name|name
index|[
literal|0
index|]
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_add_tables
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_del_tables
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_tstats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_tstats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_tstats
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETTFLAGS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_set_tflags
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_setflag
argument_list|,
name|io
operator|->
name|pfrio_clrflag
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_add_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_del_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_set_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size2
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_astats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRTSTADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_tst_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nmatch
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRINADEFINE
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_ina_define
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_naddr
argument_list|,
name|io
operator|->
name|pfrio_ticket
argument_list|,
name|io
operator|->
name|pfrio_flags
operator||
name|PFR_FLAG_USERIOCTL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPADD
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|pf_osfp_add
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPGET
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|pf_osfp_get
argument_list|(
name|io
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXBEGIN
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioe
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|table
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ioe
operator|=
operator|(
expr|struct
name|pfioc_trans_e
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|pfr_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|io
operator|->
name|array
operator|+
name|i
argument_list|,
name|ioe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_altq
argument_list|(
operator|&
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
name|bzero
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_begin
argument_list|(
name|table
argument_list|,
operator|&
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_begin_rules
argument_list|(
operator|&
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|ioe
argument_list|,
name|io
operator|->
name|array
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|->
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXROLLBACK
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioe
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|table
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ioe
operator|=
operator|(
expr|struct
name|pfioc_trans_e
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|pfr_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|io
operator|->
name|array
operator|+
name|i
argument_list|,
name|ioe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_rollback_altq
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
name|bzero
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_rollback
argument_list|(
name|table
argument_list|,
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_rollback_rules
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
block|}
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCXCOMMIT
case|:
block|{
name|struct
name|pfioc_trans
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_trans
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pfioc_trans_e
modifier|*
name|ioe
decl_stmt|;
name|struct
name|pfr_table
modifier|*
name|table
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|esize
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ioe
operator|=
operator|(
expr|struct
name|pfioc_trans_e
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|pfr_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* first makes sure everything will succeed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|io
operator|->
name|array
operator|+
name|i
argument_list|,
name|ioe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
name|ioe
operator|->
name|anchor
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
name|altqs_inactive_open
operator|||
name|ioe
operator|->
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|ioe
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|topen
operator|||
name|ioe
operator|->
name|ticket
operator|!=
name|rs
operator|->
name|tticket
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
default|default:
if|if
condition|(
name|ioe
operator|->
name|rs_num
operator|<
literal|0
operator|||
name|ioe
operator|->
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rs
operator|=
name|pf_find_ruleset
argument_list|(
name|ioe
operator|->
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
operator|||
operator|!
name|rs
operator|->
name|rules
index|[
name|ioe
operator|->
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|open
operator|||
name|rs
operator|->
name|rules
index|[
name|ioe
operator|->
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
operator|!=
name|ioe
operator|->
name|ticket
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
block|}
block|}
comment|/* now do the commit - no errors should happen here */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|io
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|io
operator|->
name|array
operator|+
name|i
argument_list|,
name|ioe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ioe
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|ioe
operator|->
name|rs_num
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|PF_RULESET_ALTQ
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commit_altq
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|PF_RULESET_TABLE
case|:
name|bzero
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|pfrt_anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pfr_ina_commit
argument_list|(
name|table
argument_list|,
name|ioe
operator|->
name|ticket
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commit_rules
argument_list|(
name|ioe
operator|->
name|ticket
argument_list|,
name|ioe
operator|->
name|rs_num
argument_list|,
name|ioe
operator|->
name|anchor
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* really bad */
block|}
break|break;
block|}
block|}
name|free
argument_list|(
name|table
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSRCNODES
case|:
block|{
name|struct
name|pfioc_src_nodes
modifier|*
name|psn
init|=
operator|(
expr|struct
name|pfioc_src_nodes
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_src_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|pstore
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|space
init|=
name|psn
operator|->
name|psn_len
decl_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_src_tree
argument_list|,
argument|&tree_src_tracking
argument_list|)
name|nr
operator|++
expr_stmt|;
name|psn
operator|->
name|psn_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
operator|*
name|nr
expr_stmt|;
break|break;
block|}
name|pstore
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pstore
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|psn
operator|->
name|psn_src_nodes
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_src_tree
argument_list|,
argument|&tree_src_tracking
argument_list|)
block|{
name|int
name|secs
init|=
name|time_second
decl_stmt|,
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|nr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|psn
operator|->
name|psn_len
condition|)
break|break;
name|bcopy
argument_list|(
name|n
argument_list|,
name|pstore
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pstore
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|rule
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|pstore
operator|->
name|rule
operator|.
name|nr
operator|=
name|n
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|->
name|creation
operator|=
name|secs
operator|-
name|pstore
operator|->
name|creation
expr_stmt|;
if|if
condition|(
name|pstore
operator|->
name|expire
operator|>
name|secs
condition|)
name|pstore
operator|->
name|expire
operator|-=
name|secs
expr_stmt|;
else|else
name|pstore
operator|->
name|expire
operator|=
literal|0
expr_stmt|;
comment|/* adjust the connection rate estimate */
name|diff
operator|=
name|secs
operator|-
name|n
operator|->
name|conn_rate
operator|.
name|last
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
name|n
operator|->
name|conn_rate
operator|.
name|seconds
condition|)
name|pstore
operator|->
name|conn_rate
operator|.
name|count
operator|=
literal|0
expr_stmt|;
else|else
name|pstore
operator|->
name|conn_rate
operator|.
name|count
operator|-=
name|n
operator|->
name|conn_rate
operator|.
name|count
operator|*
name|diff
operator|/
name|n
operator|->
name|conn_rate
operator|.
name|seconds
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|pstore
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
name|psn
operator|->
name|psn_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_src_node
argument_list|)
operator|*
name|nr
expr_stmt|;
name|free
argument_list|(
name|pstore
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSRCNODES
case|:
block|{
name|struct
name|pf_src_node
modifier|*
name|n
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|state
argument_list|,
argument|pf_state_tree_id
argument_list|,
argument|&tree_id
argument_list|)
block|{
name|state
operator|->
name|src_node
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|nat_src_node
operator|=
name|NULL
expr_stmt|;
block|}
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_src_tree
argument_list|,
argument|&tree_src_tracking
argument_list|)
block|{
name|n
operator|->
name|expire
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|states
operator|=
literal|0
expr_stmt|;
block|}
name|pf_purge_expired_src_nodes
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pf_status
operator|.
name|src_nodes
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DIOCKILLSRCNODES
case|:
block|{
name|struct
name|pf_src_node
modifier|*
name|sn
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|s
decl_stmt|;
name|struct
name|pfioc_src_node_kill
modifier|*
name|psnk
init|= \
operator|(
expr|struct
name|pfioc_src_node_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|killed
init|=
literal|0
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|sn
argument_list|,
argument|pf_src_tree
argument_list|,
argument|&tree_src_tracking
argument_list|)
block|{
if|if
condition|(
name|PF_MATCHA
argument_list|(
name|psnk
operator|->
name|psnk_src
operator|.
name|neg
argument_list|, \
operator|&
name|psnk
operator|->
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|, \
operator|&
name|psnk
operator|->
name|psnk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|, \
operator|&
name|sn
operator|->
name|addr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psnk
operator|->
name|psnk_dst
operator|.
name|neg
argument_list|, \
operator|&
name|psnk
operator|->
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|, \
operator|&
name|psnk
operator|->
name|psnk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|, \
operator|&
name|sn
operator|->
name|raddr
argument_list|,
name|sn
operator|->
name|af
argument_list|)
condition|)
block|{
comment|/* Handle state to src_node linkage */
if|if
condition|(
name|sn
operator|->
name|states
operator|!=
literal|0
condition|)
block|{
name|RB_FOREACH
argument_list|(
argument|s
argument_list|,
argument|pf_state_tree_id
argument_list|,
argument|&tree_id
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|src_node
operator|==
name|sn
condition|)
name|s
operator|->
name|src_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nat_src_node
operator|==
name|sn
condition|)
name|s
operator|->
name|nat_src_node
operator|=
name|NULL
expr_stmt|;
block|}
name|sn
operator|->
name|states
operator|=
literal|0
expr_stmt|;
block|}
name|sn
operator|->
name|expire
operator|=
literal|1
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|killed
operator|>
literal|0
condition|)
name|pf_purge_expired_src_nodes
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|psnk
operator|->
name|psnk_af
operator|=
name|killed
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETHOSTID
case|:
block|{
name|u_int32_t
modifier|*
name|hostid
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
operator|*
name|hostid
operator|==
literal|0
condition|)
name|pf_status
operator|.
name|hostid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
else|else
name|pf_status
operator|.
name|hostid
operator|=
operator|*
name|hostid
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPFLUSH
case|:
name|pf_osfp_flush
argument_list|()
expr_stmt|;
break|break;
case|case
name|DIOCIGETIFACES
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfiio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfi_kif
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfi_get_ifaces
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|io
operator|->
name|pfiio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfiio_size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETIFFLAG
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|pfi_set_flags
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|io
operator|->
name|pfiio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRIFFLAG
case|:
block|{
name|struct
name|pfioc_iface
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_iface
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|pfi_clear_flags
argument_list|(
name|io
operator|->
name|pfiio_name
argument_list|,
name|io
operator|->
name|pfiio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|rw_exit_write
argument_list|(
operator|&
name|pf_consistency_lock
argument_list|)
expr_stmt|;
else|else
name|rw_exit_read
argument_list|(
operator|&
name|pf_consistency_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

