begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: pf_ioctl.c,v 1.81.2.2 2004/04/30 23:28:58 brad Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Daniel Hartmeier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/timeout.h>
end_include

begin_include
include|#
directive|include
file|<sys/pool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
end_if

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|500112
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|501108
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function_decl
name|void
name|init_zone_var
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cleanup_pf_zone
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfattach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|pfattach
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfopen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pf_get_ruleset_number
parameter_list|(
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_init_ruleset
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|,
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function_decl
name|int
name|pfioctl
parameter_list|(
name|dev_t
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|pfioctl
parameter_list|(
name|dev_t
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|callout
name|pf_expire_to
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|501108
end_if

begin_decl_stmt
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|timeout
name|pf_expire_to
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|pf_rule
name|pf_default_rule
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TAGID_MAX
value|50000
end_define

begin_macro
name|TAILQ_HEAD
argument_list|(
argument|pf_tags
argument_list|,
argument|pf_tagname
argument_list|)
end_macro

begin_expr_stmt
name|pf_tags
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pf_tags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPFPRINTF
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|if (pf_status.debug>= (n)) printf x
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|dev_t
name|pf_dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX - These are new and need to be checked when moveing to a new version  */
end_comment

begin_function_decl
specifier|static
name|int
name|pf_beginrules
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_commitrules
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_beginaltqs
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_commitaltqs
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_stopaltq
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|pf_clearstates
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_clear_tables
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * XXX - These are new and need to be checked when moveing to a new version  */
end_comment

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
end_if

begin_function_decl
specifier|static
name|int
name|pf_check_in
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check_out
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_check6_in
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check6_out
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* (__FreeBSD_version>= 501108) */
end_comment

begin_function_decl
specifier|static
name|int
name|pf_check_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|pf_check6_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_check6_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (__FreeBSD_version>= 501108) */
end_comment

begin_function_decl
specifier|static
name|int
name|hook_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dehook_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shutdown_pf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pf_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pf_cdevsw
init|=
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|500105
operator|)
comment|/* open */
name|noopen
block|,
comment|/* close */
name|noclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|pfioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
name|PF_NAME
block|,
comment|/* maj */
name|PF_CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* kqfilter */
name|nokqfilter
block|,
elif|#
directive|elif
operator|(
name|__FreeBSD_version
operator|<
literal|501110
operator|)
operator|.
name|d_open
operator|=
name|noopen
block|,
operator|.
name|d_close
operator|=
name|noclose
block|,
operator|.
name|d_read
operator|=
name|noread
block|,
operator|.
name|d_write
operator|=
name|nowrite
block|,
operator|.
name|d_ioctl
operator|=
name|pfioctl
block|,
operator|.
name|d_poll
operator|=
name|nopoll
block|,
operator|.
name|d_mmap
operator|=
name|nommap
block|,
operator|.
name|d_strategy
operator|=
name|nostrategy
block|,
operator|.
name|d_name
operator|=
name|PF_NAME
block|,
operator|.
name|d_maj
operator|=
name|MAJOR_AUTO
block|,
comment|/* PF_CDEV_MAJOR */
operator|.
name|d_dump
operator|=
name|nodump
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_kqfilter
operator|=
name|nokqfilter
block|,
else|#
directive|else
operator|.
name|d_ioctl
operator|=
name|pfioctl
block|,
operator|.
name|d_name
operator|=
name|PF_NAME
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pf_pfil_hooked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|pf_task_mtx
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_pf_mutex
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|pf_task_mtx
argument_list|,
literal|"pf task mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/*  * pf_altq_mtx is initialized at altq_subr.c.  *  * #if defined(ALTQ)&& !defined(ALTQ3_COMPAT)  *	mtx_init(&pf_altq_mtx, "pf altq mtx", NULL, MTX_DEF);  * #endif  */
block|}
end_function

begin_function
name|void
name|destroy_pf_mutex
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|pf_task_mtx
argument_list|)
expr_stmt|;
comment|/*  * pf_altq_mtx is initialized at altq_subr.c.  *  * #if defined(ALTQ)&& !defined(ALTQ3_COMPAT)  * 	mtx_destroy(&pf_altq_mtx);  * #endif  */
block|}
end_function

begin_function
name|void
name|init_zone_var
parameter_list|(
name|void
parameter_list|)
block|{
name|pf_tree_pl
operator|=
name|pf_rule_pl
operator|=
name|pf_addr_pl
operator|=
name|NULL
expr_stmt|;
name|pf_state_pl
operator|=
name|pf_altq_pl
operator|=
name|pf_pooladdr_pl
operator|=
name|NULL
expr_stmt|;
name|pf_frent_pl
operator|=
name|pf_frag_pl
operator|=
name|pf_cache_pl
operator|=
name|pf_cent_pl
operator|=
name|NULL
expr_stmt|;
name|pf_state_scrub_pl
operator|=
name|NULL
expr_stmt|;
name|pfr_ktable_pl
operator|=
name|pfr_kentry_pl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cleanup_pf_zone
parameter_list|(
name|void
parameter_list|)
block|{
name|UMA_DESTROY
argument_list|(
name|pf_tree_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_rule_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_addr_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_state_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_altq_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_pooladdr_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_frent_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_frag_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_cache_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_cent_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pfr_ktable_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pfr_kentry_pl
argument_list|)
expr_stmt|;
name|UMA_DESTROY
argument_list|(
name|pf_state_scrub_pl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfattach
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|my_timeout
init|=
name|pf_default_rule
operator|.
name|timeout
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
do|do
block|{
name|UMA_CREATE
argument_list|(
name|pf_tree_pl
argument_list|,
expr|struct
name|pf_tree_node
argument_list|,
literal|"pftrpl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_rule_pl
argument_list|,
expr|struct
name|pf_rule
argument_list|,
literal|"pfrulepl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_addr_pl
argument_list|,
expr|struct
name|pf_addr_dyn
argument_list|,
literal|"pfaddrpl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_state_pl
argument_list|,
expr|struct
name|pf_state
argument_list|,
literal|"pfstatepl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_altq_pl
argument_list|,
expr|struct
name|pf_altq
argument_list|,
literal|"pfaltqpl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_pooladdr_pl
argument_list|,
expr|struct
name|pf_pooladdr
argument_list|,
literal|"pfpooladdrpl"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pfr_ktable_pl
argument_list|,
expr|struct
name|pfr_ktable
argument_list|,
literal|"pfrktable"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pfr_kentry_pl
argument_list|,
expr|struct
name|pfr_kentry
argument_list|,
literal|"pfrkentry"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_frent_pl
argument_list|,
expr|struct
name|pf_frent
argument_list|,
literal|"pffrent"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_frag_pl
argument_list|,
expr|struct
name|pf_fragment
argument_list|,
literal|"pffrag"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_cache_pl
argument_list|,
expr|struct
name|pf_fragment
argument_list|,
literal|"pffrcache"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_cent_pl
argument_list|,
expr|struct
name|pf_frcache
argument_list|,
literal|"pffrcent"
argument_list|)
expr_stmt|;
name|UMA_CREATE
argument_list|(
name|pf_state_scrub_pl
argument_list|,
expr|struct
name|pf_state_scrub
argument_list|,
literal|"pfstatescrub"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
name|cleanup_pf_zone
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pfr_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_osfp_initialize
argument_list|()
operator|)
condition|)
block|{
name|cleanup_pf_zone
argument_list|()
expr_stmt|;
name|pf_osfp_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|pp
operator|=
name|pf_state_pl
expr_stmt|;
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|limit
operator|=
name|PFSTATE_HIWAT
expr_stmt|;
name|pf_pool_limits
index|[
name|PF_LIMIT_FRAGS
index|]
operator|.
name|pp
operator|=
name|pf_frent_pl
expr_stmt|;
name|pf_pool_limits
index|[
name|PF_LIMIT_FRAGS
index|]
operator|.
name|limit
operator|=
name|PFFRAG_FRENT_HIWAT
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|pp
argument_list|,
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|limit
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|tree_lan_ext
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|tree_ext_gwy
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|pf_main_ruleset
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|pf_altqs_active
operator|=
operator|&
name|pf_altqs
index|[
literal|0
index|]
expr_stmt|;
name|pf_altqs_inactive
operator|=
operator|&
name|pf_altqs
index|[
literal|1
index|]
expr_stmt|;
comment|/* default rule should never be garbage collected */
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_prev
operator|=
operator|&
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_next
expr_stmt|;
name|pf_default_rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
name|pf_default_rule
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* initialize default timeouts */
name|my_timeout
index|[
name|PFTM_TCP_FIRST_PACKET
index|]
operator|=
literal|120
expr_stmt|;
comment|/* First TCP packet */
name|my_timeout
index|[
name|PFTM_TCP_OPENING
index|]
operator|=
literal|30
expr_stmt|;
comment|/* No response yet */
name|my_timeout
index|[
name|PFTM_TCP_ESTABLISHED
index|]
operator|=
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* Established */
name|my_timeout
index|[
name|PFTM_TCP_CLOSING
index|]
operator|=
literal|15
operator|*
literal|60
expr_stmt|;
comment|/* Half closed */
name|my_timeout
index|[
name|PFTM_TCP_FIN_WAIT
index|]
operator|=
literal|45
expr_stmt|;
comment|/* Got both FINs */
name|my_timeout
index|[
name|PFTM_TCP_CLOSED
index|]
operator|=
literal|90
expr_stmt|;
comment|/* Got a RST */
name|my_timeout
index|[
name|PFTM_UDP_FIRST_PACKET
index|]
operator|=
literal|60
expr_stmt|;
comment|/* First UDP packet */
name|my_timeout
index|[
name|PFTM_UDP_SINGLE
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Unidirectional */
name|my_timeout
index|[
name|PFTM_UDP_MULTIPLE
index|]
operator|=
literal|60
expr_stmt|;
comment|/* Bidirectional */
name|my_timeout
index|[
name|PFTM_ICMP_FIRST_PACKET
index|]
operator|=
literal|20
expr_stmt|;
comment|/* First ICMP packet */
name|my_timeout
index|[
name|PFTM_ICMP_ERROR_REPLY
index|]
operator|=
literal|10
expr_stmt|;
comment|/* Got error response */
name|my_timeout
index|[
name|PFTM_OTHER_FIRST_PACKET
index|]
operator|=
literal|60
expr_stmt|;
comment|/* First packet */
name|my_timeout
index|[
name|PFTM_OTHER_SINGLE
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Unidirectional */
name|my_timeout
index|[
name|PFTM_OTHER_MULTIPLE
index|]
operator|=
literal|60
expr_stmt|;
comment|/* Bidirectional */
name|my_timeout
index|[
name|PFTM_FRAG
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Fragment expire */
name|my_timeout
index|[
name|PFTM_INTERVAL
index|]
operator|=
literal|10
expr_stmt|;
comment|/* Expire interval */
comment|/* 	 * XXX 	 *  The 2nd arg. 0 to callout_init(9) shoule be set to CALLOUT_MPSAFE 	 * if Gaint lock is removed from the network stack. 	 */
name|callout_init
argument_list|(
operator|&
name|pf_expire_to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pf_expire_to
argument_list|,
name|my_timeout
index|[
name|PFTM_INTERVAL
index|]
operator|*
name|hz
argument_list|,
name|pf_purge_timeout
argument_list|,
operator|&
name|pf_expire_to
argument_list|)
expr_stmt|;
name|pf_normalize_init
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
name|pf_pfil_hooked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__FreeBSD__ */
end_comment

begin_function
name|void
name|pfattach
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|timeout
init|=
name|pf_default_rule
operator|.
name|timeout
decl_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_tree_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_tree_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pftrpl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfrulepl"
argument_list|,
operator|&
name|pool_allocator_nointr
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_addr_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_addr_dyn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfaddrpl"
argument_list|,
operator|&
name|pool_allocator_nointr
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfstatepl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfaltqpl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pfpooladdrpl"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pfr_initialize
argument_list|()
expr_stmt|;
name|pf_osfp_initialize
argument_list|()
expr_stmt|;
name|pool_sethardlimit
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|pf_pool_limits
index|[
name|PF_LIMIT_STATES
index|]
operator|.
name|limit
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|tree_lan_ext
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|tree_ext_gwy
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
name|pf_init_ruleset
argument_list|(
operator|&
name|pf_main_ruleset
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_altqs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|pf_altqs_active
operator|=
operator|&
name|pf_altqs
index|[
literal|0
index|]
expr_stmt|;
name|pf_altqs_inactive
operator|=
operator|&
name|pf_altqs
index|[
literal|1
index|]
expr_stmt|;
comment|/* default rule should never be garbage collected */
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_prev
operator|=
operator|&
name|pf_default_rule
operator|.
name|entries
operator|.
name|tqe_next
expr_stmt|;
name|pf_default_rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
name|pf_default_rule
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* initialize default timeouts */
name|timeout
index|[
name|PFTM_TCP_FIRST_PACKET
index|]
operator|=
literal|120
expr_stmt|;
comment|/* First TCP packet */
name|timeout
index|[
name|PFTM_TCP_OPENING
index|]
operator|=
literal|30
expr_stmt|;
comment|/* No response yet */
name|timeout
index|[
name|PFTM_TCP_ESTABLISHED
index|]
operator|=
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* Established */
name|timeout
index|[
name|PFTM_TCP_CLOSING
index|]
operator|=
literal|15
operator|*
literal|60
expr_stmt|;
comment|/* Half closed */
name|timeout
index|[
name|PFTM_TCP_FIN_WAIT
index|]
operator|=
literal|45
expr_stmt|;
comment|/* Got both FINs */
name|timeout
index|[
name|PFTM_TCP_CLOSED
index|]
operator|=
literal|90
expr_stmt|;
comment|/* Got a RST */
name|timeout
index|[
name|PFTM_UDP_FIRST_PACKET
index|]
operator|=
literal|60
expr_stmt|;
comment|/* First UDP packet */
name|timeout
index|[
name|PFTM_UDP_SINGLE
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Unidirectional */
name|timeout
index|[
name|PFTM_UDP_MULTIPLE
index|]
operator|=
literal|60
expr_stmt|;
comment|/* Bidirectional */
name|timeout
index|[
name|PFTM_ICMP_FIRST_PACKET
index|]
operator|=
literal|20
expr_stmt|;
comment|/* First ICMP packet */
name|timeout
index|[
name|PFTM_ICMP_ERROR_REPLY
index|]
operator|=
literal|10
expr_stmt|;
comment|/* Got error response */
name|timeout
index|[
name|PFTM_OTHER_FIRST_PACKET
index|]
operator|=
literal|60
expr_stmt|;
comment|/* First packet */
name|timeout
index|[
name|PFTM_OTHER_SINGLE
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Unidirectional */
name|timeout
index|[
name|PFTM_OTHER_MULTIPLE
index|]
operator|=
literal|60
expr_stmt|;
comment|/* Bidirectional */
name|timeout
index|[
name|PFTM_FRAG
index|]
operator|=
literal|30
expr_stmt|;
comment|/* Fragment expire */
name|timeout
index|[
name|PFTM_INTERVAL
index|]
operator|=
literal|10
expr_stmt|;
comment|/* Expire interval */
name|timeout_set
argument_list|(
operator|&
name|pf_expire_to
argument_list|,
name|pf_purge_timeout
argument_list|,
operator|&
name|pf_expire_to
argument_list|)
expr_stmt|;
name|timeout_add
argument_list|(
operator|&
name|pf_expire_to
argument_list|,
name|timeout
index|[
name|PFTM_INTERVAL
index|]
operator|*
name|hz
argument_list|)
expr_stmt|;
name|pf_normalize_init
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|debug
operator|=
name|PF_DEBUG_URGENT
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_function
name|struct
name|pf_pool
modifier|*
name|pf_get_pool
parameter_list|(
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|u_int8_t
name|rule_action
parameter_list|,
name|u_int32_t
name|rule_number
parameter_list|,
name|u_int8_t
name|r_last
parameter_list|,
name|u_int8_t
name|active
parameter_list|,
name|u_int8_t
name|check_ticket
parameter_list|)
block|{
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|rule_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|active
condition|)
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_ticket
operator|&&
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r_last
condition|)
name|rule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r_last
condition|)
block|{
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|rule_number
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|rule
operator|->
name|rpool
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pf_get_ruleset_number
parameter_list|(
name|u_int8_t
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|PF_SCRUB
case|:
return|return
operator|(
name|PF_RULESET_SCRUB
operator|)
return|;
break|break;
case|case
name|PF_PASS
case|:
case|case
name|PF_DROP
case|:
return|return
operator|(
name|PF_RULESET_FILTER
operator|)
return|;
break|break;
case|case
name|PF_NAT
case|:
case|case
name|PF_NONAT
case|:
return|return
operator|(
name|PF_RULESET_NAT
operator|)
return|;
break|break;
case|case
name|PF_BINAT
case|:
case|case
name|PF_NOBINAT
case|:
return|return
operator|(
name|PF_RULESET_BINAT
operator|)
return|;
break|break;
case|case
name|PF_RDR
case|:
case|case
name|PF_NORDR
case|:
return|return
operator|(
name|PF_RULESET_RDR
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|PF_RULESET_MAX
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|pf_init_ruleset
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|ruleset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|ruleset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_ruleset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_RULESET_MAX
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|queues
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|queues
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|active
operator|.
name|ptr
operator|=
operator|&
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|queues
index|[
literal|0
index|]
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|inactive
operator|.
name|ptr
operator|=
operator|&
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|queues
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|pf_anchor
modifier|*
name|pf_find_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|anchor
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
while|while
condition|(
name|anchor
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|=
name|strcmp
argument_list|(
name|anchor
operator|->
name|name
argument_list|,
name|anchorname
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|anchor
operator|=
name|TAILQ_NEXT
argument_list|(
name|anchor
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|anchor
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_ruleset
modifier|*
name|pf_find_ruleset
parameter_list|(
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
operator|&&
operator|!
name|rulesetname
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|&
name|pf_main_ruleset
operator|)
return|;
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
operator|||
operator|!
name|rulesetname
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|anchorname
index|[
name|PF_ANCHOR_NAME_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rulesetname
index|[
name|PF_RULESET_NAME_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|anchor
operator|=
name|pf_find_anchor
argument_list|(
name|anchorname
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ruleset
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|)
expr_stmt|;
while|while
condition|(
name|ruleset
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ruleset
operator|->
name|name
argument_list|,
name|rulesetname
argument_list|)
operator|<
literal|0
condition|)
name|ruleset
operator|=
name|TAILQ_NEXT
argument_list|(
name|ruleset
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|ruleset
operator|->
name|name
argument_list|,
name|rulesetname
argument_list|)
condition|)
return|return
operator|(
name|ruleset
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|pf_ruleset
modifier|*
name|pf_find_or_create_ruleset
parameter_list|(
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
operator|&&
operator|!
name|rulesetname
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|&
name|pf_main_ruleset
operator|)
return|;
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
operator|||
operator|!
name|rulesetname
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|anchorname
index|[
name|PF_ANCHOR_NAME_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rulesetname
index|[
name|PF_RULESET_NAME_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|anchorname
argument_list|)
operator|<
literal|0
condition|)
name|a
operator|=
name|TAILQ_NEXT
argument_list|(
name|a
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|anchorname
argument_list|)
condition|)
name|anchor
operator|=
name|a
expr_stmt|;
else|else
block|{
name|anchor
operator|=
operator|(
expr|struct
name|pf_anchor
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pf_anchor
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|anchor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_anchor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|anchorname
argument_list|,
name|anchor
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|anchor
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|a
argument_list|,
name|anchor
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pf_anchors
argument_list|,
name|anchor
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|r
operator|->
name|name
argument_list|,
name|rulesetname
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
name|TAILQ_NEXT
argument_list|(
name|r
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|r
operator|->
name|name
argument_list|,
name|rulesetname
argument_list|)
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|ruleset
operator|=
operator|(
expr|struct
name|pf_ruleset
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pf_ruleset
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|!=
name|NULL
condition|)
block|{
name|pf_init_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rulesetname
argument_list|,
name|ruleset
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ruleset
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ruleset
operator|->
name|anchor
operator|=
name|anchor
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|r
argument_list|,
name|ruleset
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|,
name|ruleset
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ruleset
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_remove_if_empty_ruleset
parameter_list|(
name|struct
name|pf_ruleset
modifier|*
name|ruleset
parameter_list|)
block|{
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
operator|||
name|ruleset
operator|->
name|anchor
operator|==
name|NULL
operator|||
name|ruleset
operator|->
name|tables
operator|>
literal|0
operator|||
name|ruleset
operator|->
name|topen
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_RULESET_MAX
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|i
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
condition|)
return|return;
name|anchor
operator|=
name|ruleset
operator|->
name|anchor
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|,
name|ruleset
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ruleset
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_anchors
argument_list|,
name|anchor
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|anchor
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|pf_update_anchor_rules
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_mv_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|,
name|struct
name|pf_palist
modifier|*
name|poolb
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|mv_pool_pa
decl_stmt|;
while|while
condition|(
operator|(
name|mv_pool_pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|poolb
argument_list|,
name|mv_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_empty_pool
parameter_list|(
name|struct
name|pf_palist
modifier|*
name|poola
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|empty_pool_pa
decl_stmt|;
while|while
condition|(
operator|(
name|empty_pool_pa
operator|=
name|TAILQ_FIRST
argument_list|(
name|poola
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pf_dynaddr_remove
argument_list|(
operator|&
name|empty_pool_pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|empty_pool_pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|poola
argument_list|,
name|empty_pool_pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|empty_pool_pa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pf_rm_rule
parameter_list|(
name|struct
name|pf_rulequeue
modifier|*
name|rulequeue
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|)
block|{
if|if
condition|(
name|rulequeue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|states
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * XXX - we need to remove the table *before* detaching 			 * the rule to make sure the table code does not delete 			 * the anchor under our feet. 			 */
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|rulequeue
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|states
operator|>
literal|0
operator|||
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|!=
name|NULL
condition|)
return|return;
name|pf_tag_unref
argument_list|(
name|rule
operator|->
name|tag
argument_list|)
expr_stmt|;
name|pf_tag_unref
argument_list|(
name|rule
operator|->
name|match_tag
argument_list|)
expr_stmt|;
name|pf_dynaddr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_dynaddr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rulequeue
operator|==
name|NULL
condition|)
block|{
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
name|pf_empty_pool
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|pf_tagname2tag
parameter_list|(
name|char
modifier|*
name|tagname
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|tag
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|new_tagid
init|=
literal|1
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tag
argument_list|,
argument|&pf_tags
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|tagname
argument_list|,
name|tag
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
comment|/* 	 * to avoid fragmentation, we do a linear search from the beginning 	 * and take the first free slot we find. if there is none or the list 	 * is empty, append a new entry at the end. 	 */
comment|/* new entry */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pf_tags
argument_list|)
condition|)
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pf_tags
argument_list|)
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|tag
operator|==
name|new_tagid
condition|;
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
control|)
name|new_tagid
operator|=
name|p
operator|->
name|tag
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|new_tagid
operator|>
name|TAGID_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* allocate and fill new struct pf_tagname */
name|tag
operator|=
operator|(
expr|struct
name|pf_tagname
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pf_tagname
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_tagname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tag
operator|->
name|name
argument_list|,
name|tagname
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|->
name|tag
operator|=
name|new_tagid
expr_stmt|;
name|tag
operator|->
name|ref
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* insert new entry before p */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
comment|/* either list empty or no free slot in between */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pf_tags
argument_list|,
name|tag
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pf_tag2tagname
parameter_list|(
name|u_int16_t
name|tagid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|tag
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tag
argument_list|,
argument|&pf_tags
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|tag
operator|->
name|tag
operator|==
name|tagid
condition|)
block|{
name|strlcpy
argument_list|(
name|p
argument_list|,
name|tag
operator|->
name|name
argument_list|,
name|PF_TAG_NAME_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|pf_tag_unref
parameter_list|(
name|u_int16_t
name|tag
parameter_list|)
block|{
name|struct
name|pf_tagname
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pf_tags
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
operator|--
name|p
operator|->
name|ref
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pf_tags
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
name|int
name|pfioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|addr
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|thread
operator|*
name|td
argument_list|)
else|#
directive|else
name|int
name|pfioctl
argument_list|(
name|dev_t
name|dev
argument_list|,
name|u_long
name|cmd
argument_list|,
name|caddr_t
name|addr
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|proc
operator|*
name|p
argument_list|)
endif|#
directive|endif
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_pool
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* XXX keep in sync with switch() below */
if|if
condition|(
name|securelevel
operator|>
literal|1
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETRULE
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCSETSTATUSIF
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCCLRSTATUS
case|:
case|case
name|DIOCNATLOOK
case|:
case|case
name|DIOCSETDEBUG
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCCLRRULECTRS
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETANCHORS
case|:
case|case
name|DIOCGETANCHOR
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRCLRTSTATS
case|:
case|case
name|DIOCRCLRADDRS
case|:
case|case
name|DIOCRADDADDRS
case|:
case|case
name|DIOCRDELADDRS
case|:
case|case
name|DIOCRSETADDRS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRCLRASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|DIOCGIFSPEED
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FWRITE
operator|)
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGETRULES
case|:
case|case
name|DIOCGETRULE
case|:
case|case
name|DIOCGETADDRS
case|:
case|case
name|DIOCGETADDR
case|:
case|case
name|DIOCGETSTATE
case|:
case|case
name|DIOCGETSTATUS
case|:
case|case
name|DIOCGETSTATES
case|:
case|case
name|DIOCGETTIMEOUT
case|:
case|case
name|DIOCGETLIMIT
case|:
case|case
name|DIOCGETALTQS
case|:
case|case
name|DIOCGETALTQ
case|:
case|case
name|DIOCGETQSTATS
case|:
case|case
name|DIOCGETANCHORS
case|:
case|case
name|DIOCGETANCHOR
case|:
case|case
name|DIOCGETRULESETS
case|:
case|case
name|DIOCGETRULESET
case|:
case|case
name|DIOCRGETTABLES
case|:
case|case
name|DIOCRGETTSTATS
case|:
case|case
name|DIOCRGETADDRS
case|:
case|case
name|DIOCRGETASTATS
case|:
case|case
name|DIOCRTSTADDRS
case|:
case|case
name|DIOCOSFPGET
case|:
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|DIOCGIFSPEED
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSTART
case|:
if|if
condition|(
name|pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
name|u_int32_t
name|states
init|=
name|pf_status
operator|.
name|states
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|hook_pf
argument_list|()
expr_stmt|;
name|PF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: pfil registeration fail\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|pf_status
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|pf_status
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|pf_status
operator|.
name|states
operator|=
name|states
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|pf_status
operator|.
name|since
operator|=
name|time_second
expr_stmt|;
else|#
directive|else
name|pf_status
operator|.
name|since
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status_ifp
operator|!=
name|NULL
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|501113
operator|)
name|snprintf
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|,
literal|"%s%d"
argument_list|,
name|status_ifp
operator|->
name|if_name
argument_list|,
name|status_ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|strlcpy
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|status_ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: started\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCSTOP
case|:
if|if
condition|(
operator|!
name|pf_status
operator|.
name|running
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
block|{
name|pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|dehook_pf
argument_list|()
expr_stmt|;
name|PF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_status
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: pfil unregisteration failed\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"pf: stopped\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCBEGINRULES
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|pr
operator|->
name|ticket
operator|=
operator|++
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|anchorname
index|[
literal|0
index|]
operator|&&
name|ruleset
operator|!=
operator|&
name|pf_main_ruleset
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|pool_ticket
operator|!=
name|ticket_pabuf
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|rule
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pr
operator|->
name|rule
argument_list|,
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|rule
operator|->
name|anchor
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* initialize refcounting */
name|rule
operator|->
name|states
operator|=
literal|0
expr_stmt|;
name|rule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|rule
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|rule
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|rule
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|rule
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|rule
operator|->
name|ifp
operator|=
name|ifunit
argument_list|(
name|rule
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|rule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|rule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rt
operator|&&
operator|!
name|rule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|rule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|src
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|rule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pf_pabuf
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|pa
operator|->
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|pf_mv_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|rule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|)
operator|&&
operator|!
name|rule
operator|->
name|anchorname
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|rule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|rule
argument_list|)
expr_stmt|;
break|break;
block|}
name|rule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|rule
operator|->
name|evaluations
operator|=
name|rule
operator|->
name|packets
operator|=
name|rule
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCOMMITRULES
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rulequeue
modifier|*
name|old_rules
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|rs_num
operator|==
name|PF_RULESET_FILTER
condition|)
name|pf_rule_set_qid
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap rules, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_rules
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
operator|=
name|old_rules
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Purge the old rule list. */
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|old_rules
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|old_rules
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|pf_update_anchor_rules
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULES
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|tail
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|tail
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
name|pr
operator|->
name|nr
operator|=
name|tail
operator|->
name|nr
operator|+
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|pr
operator|->
name|ticket
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|,
name|i
decl_stmt|;
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|rule
operator|->
name|nr
operator|!=
name|pr
operator|->
name|nr
operator|)
condition|)
name|rule
operator|=
name|TAILQ_NEXT
argument_list|(
name|rule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|rule
argument_list|,
operator|&
name|pr
operator|->
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|pf_dynaddr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_dynaddr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|src
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pr
operator|->
name|rule
operator|.
name|dst
operator|.
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|pr
operator|->
name|rule
operator|.
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|=
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGERULE
case|:
block|{
name|struct
name|pfioc_rule
modifier|*
name|pcr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|oldrule
init|=
name|NULL
decl_stmt|,
modifier|*
name|newrule
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
operator|)
operator|&&
name|pcr
operator|->
name|pool_ticket
operator|!=
name|ticket_pabuf
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|>
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pcr
operator|->
name|anchor
argument_list|,
name|pcr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pcr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_GET_TICKET
condition|)
block|{
name|pcr
operator|->
name|ticket
operator|=
operator|++
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|pcr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pcr
operator|->
name|rule
operator|.
name|return_icmp
operator|>>
literal|8
operator|>
name|ICMP_MAXTYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
name|newrule
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrule
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pcr
operator|->
name|rule
argument_list|,
name|newrule
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_rule
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* initialize refcounting */
name|newrule
operator|->
name|states
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|entries
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|newrule
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|newrule
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|newrule
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newrule
operator|->
name|ifp
operator|=
name|ifunit
argument_list|(
name|newrule
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_rule_pl
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|newrule
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|newrule
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|newrule
operator|->
name|qid
operator|=
name|pf_qname_to_qid
argument_list|(
name|newrule
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|pqname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|newrule
operator|->
name|pqid
operator|=
name|pf_qname_to_qid
argument_list|(
name|newrule
operator|->
name|pqname
argument_list|)
expr_stmt|;
else|else
name|newrule
operator|->
name|pqid
operator|=
name|newrule
operator|->
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|newrule
operator|->
name|tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|match_tagname
index|[
literal|0
index|]
condition|)
if|if
condition|(
operator|(
name|newrule
operator|->
name|match_tag
operator|=
name|pf_tagname2tag
argument_list|(
name|newrule
operator|->
name|match_tagname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
if|if
condition|(
name|newrule
operator|->
name|rt
operator|&&
operator|!
name|newrule
operator|->
name|direction
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|,
name|newrule
operator|->
name|af
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|src
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newrule
operator|->
name|dst
operator|.
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|pf_mv_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_NAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_RDR
operator|)
operator|||
operator|(
name|newrule
operator|->
name|action
operator|==
name|PF_BINAT
operator|)
operator|||
operator|(
name|newrule
operator|->
name|rt
operator|>
name|PF_FASTROUTE
operator|)
operator|)
operator|&&
operator|!
name|newrule
operator|->
name|anchorname
index|[
literal|0
index|]
operator|)
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
break|break;
block|}
name|newrule
operator|->
name|rpool
operator|.
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|newrule
operator|->
name|rpool
operator|.
name|list
argument_list|)
expr_stmt|;
name|newrule
operator|->
name|evaluations
operator|=
name|newrule
operator|->
name|packets
operator|=
literal|0
expr_stmt|;
name|newrule
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
block|}
name|pf_empty_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldrule
operator|=
name|TAILQ_LAST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|pf_rulequeue
argument_list|)
expr_stmt|;
else|else
block|{
name|oldrule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldrule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|oldrule
operator|->
name|nr
operator|!=
name|pcr
operator|->
name|nr
operator|)
condition|)
name|oldrule
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
block|{
name|pf_rm_rule
argument_list|(
name|NULL
argument_list|,
name|newrule
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
name|pf_rm_rule
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|oldrule
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pcr
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|,
name|oldrule
argument_list|,
name|newrule
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|oldrule
argument_list|,
argument|ruleset->rules[rs_num].active.ptr
argument_list|,
argument|entries
argument_list|)
name|oldrule
operator|->
name|nr
operator|=
name|nr
operator|++
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|pf_update_anchor_rules
argument_list|()
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRSTATES
case|:
block|{
name|struct
name|pf_tree_node
modifier|*
name|n
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
name|n
operator|->
name|state
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
name|pf_purge_expired_states
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|states
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCKILLSTATES
case|:
block|{
name|struct
name|pf_tree_node
modifier|*
name|n
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|st
decl_stmt|;
name|struct
name|pfioc_state_kill
modifier|*
name|psk
init|=
operator|(
expr|struct
name|pfioc_state_kill
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|killed
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
block|{
name|st
operator|=
name|n
operator|->
name|state
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|psk
operator|->
name|psk_af
operator|||
name|st
operator|->
name|af
operator|==
name|psk
operator|->
name|psk_af
operator|)
operator|&&
operator|(
operator|!
name|psk
operator|->
name|psk_proto
operator|||
name|psk
operator|->
name|psk_proto
operator|==
name|st
operator|->
name|proto
operator|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|not
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|st
operator|->
name|lan
operator|.
name|addr
argument_list|,
name|st
operator|->
name|af
argument_list|)
operator|&&
name|PF_MATCHA
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|not
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|psk
operator|->
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
operator|&
name|st
operator|->
name|ext
operator|.
name|addr
argument_list|,
name|st
operator|->
name|af
argument_list|)
operator|&&
operator|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_src
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_src
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|st
operator|->
name|lan
operator|.
name|port
argument_list|)
operator|)
operator|&&
operator|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
operator|==
literal|0
operator|||
name|pf_match_port
argument_list|(
name|psk
operator|->
name|psk_dst
operator|.
name|port_op
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|0
index|]
argument_list|,
name|psk
operator|->
name|psk_dst
operator|.
name|port
index|[
literal|1
index|]
argument_list|,
name|st
operator|->
name|ext
operator|.
name|port
argument_list|)
operator|)
condition|)
block|{
name|st
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
name|killed
operator|++
expr_stmt|;
block|}
block|}
name|pf_purge_expired_states
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|psk
operator|->
name|psk_af
operator|=
name|killed
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|state
operator|.
name|timeout
operator|>=
name|PFTM_MAX
operator|&&
name|ps
operator|->
name|state
operator|.
name|timeout
operator|!=
name|PFTM_UNTIL_PACKET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ps
operator|->
name|state
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|rule
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|rt_ifp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|state
operator|->
name|creation
operator|=
name|time_second
expr_stmt|;
else|#
directive|else
name|state
operator|->
name|creation
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|packets
index|[
literal|0
index|]
operator|=
name|state
operator|->
name|packets
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|bytes
index|[
literal|0
index|]
operator|=
name|state
operator|->
name|bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pf_insert_state
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_state_pl
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATE
case|:
block|{
name|struct
name|pfioc_state
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_state
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_tree_node
modifier|*
name|n
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
block|{
if|if
condition|(
name|nr
operator|>=
name|ps
operator|->
name|nr
condition|)
break|break;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|n
operator|->
name|state
argument_list|,
operator|&
name|ps
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|rule
operator|.
name|nr
operator|=
name|n
operator|->
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|nat_rule
operator|.
name|nr
operator|=
operator|(
name|n
operator|->
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|->
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|anchor
operator|.
name|nr
operator|=
operator|(
name|n
operator|->
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|->
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ps
operator|->
name|state
operator|.
name|expire
operator|=
name|pf_state_expires
argument_list|(
name|n
operator|->
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|ps
operator|->
name|state
operator|.
name|expire
operator|>
name|time_second
condition|)
name|ps
operator|->
name|state
operator|.
name|expire
operator|-=
name|time_second
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ps
operator|->
name|state
operator|.
name|expire
operator|>
name|time
operator|.
name|tv_sec
condition|)
name|ps
operator|->
name|state
operator|.
name|expire
operator|-=
name|time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
else|else
name|ps
operator|->
name|state
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATES
case|:
block|{
name|struct
name|pfioc_states
modifier|*
name|ps
init|=
operator|(
expr|struct
name|pfioc_states
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_tree_node
modifier|*
name|n
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|p
decl_stmt|,
name|pstore
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|int
name|space
init|=
name|ps
operator|->
name|ps_len
decl_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
name|nr
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
operator|*
name|nr
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|p
operator|=
name|ps
operator|->
name|ps_states
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|secs
init|=
name|time_second
decl_stmt|;
else|#
directive|else
name|int
name|secs
init|=
name|time
operator|.
name|tv_sec
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|nr
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|ps
operator|->
name|ps_len
condition|)
break|break;
name|bcopy
argument_list|(
name|n
operator|->
name|state
argument_list|,
operator|&
name|pstore
argument_list|,
sizeof|sizeof
argument_list|(
name|pstore
argument_list|)
argument_list|)
expr_stmt|;
name|pstore
operator|.
name|rule
operator|.
name|nr
operator|=
name|n
operator|->
name|state
operator|->
name|rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|.
name|nat_rule
operator|.
name|nr
operator|=
operator|(
name|n
operator|->
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|->
name|state
operator|->
name|nat_rule
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|.
name|anchor
operator|.
name|nr
operator|=
operator|(
name|n
operator|->
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|->
name|state
operator|->
name|anchor
operator|.
name|ptr
operator|->
name|nr
expr_stmt|;
name|pstore
operator|.
name|creation
operator|=
name|secs
operator|-
name|pstore
operator|.
name|creation
expr_stmt|;
name|pstore
operator|.
name|expire
operator|=
name|pf_state_expires
argument_list|(
name|n
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstore
operator|.
name|expire
operator|>
name|secs
condition|)
name|pstore
operator|.
name|expire
operator|-=
name|secs
expr_stmt|;
else|else
name|pstore
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_COPYOUT
argument_list|(
operator|&
name|pstore
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|pstore
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|p
operator|++
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
name|ps
operator|->
name|ps_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pf_state
argument_list|)
operator|*
name|nr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETSTATUS
case|:
block|{
name|struct
name|pf_status
modifier|*
name|s
init|=
operator|(
expr|struct
name|pf_status
operator|*
operator|)
name|addr
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|pf_status
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETSTATUSIF
case|:
block|{
name|struct
name|pfioc_if
modifier|*
name|pi
init|=
operator|(
expr|struct
name|pfioc_if
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|ifname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|status_ifp
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|pi
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|==
name|status_ifp
condition|)
break|break;
name|status_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* fallthrough into DIOCCLRSTATUS */
block|}
case|case
name|DIOCCLRSTATUS
case|:
block|{
name|u_int32_t
name|running
init|=
name|pf_status
operator|.
name|running
decl_stmt|;
name|u_int32_t
name|states
init|=
name|pf_status
operator|.
name|states
decl_stmt|;
name|u_int32_t
name|since
init|=
name|pf_status
operator|.
name|since
decl_stmt|;
name|u_int32_t
name|debug
init|=
name|pf_status
operator|.
name|debug
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|pf_status
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_status
argument_list|)
argument_list|)
expr_stmt|;
name|pf_status
operator|.
name|running
operator|=
name|running
expr_stmt|;
name|pf_status
operator|.
name|states
operator|=
name|states
expr_stmt|;
name|pf_status
operator|.
name|since
operator|=
name|since
expr_stmt|;
name|pf_status
operator|.
name|debug
operator|=
name|debug
expr_stmt|;
if|if
condition|(
name|status_ifp
operator|!=
name|NULL
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|501113
operator|)
name|snprintf
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|,
literal|"%s%d"
argument_list|,
name|status_ifp
operator|->
name|if_name
argument_list|,
name|status_ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|strlcpy
argument_list|(
name|pf_status
operator|.
name|ifname
argument_list|,
name|status_ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|DIOCNATLOOK
case|:
block|{
name|struct
name|pfioc_natlook
modifier|*
name|pnl
init|=
operator|(
expr|struct
name|pfioc_natlook
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|st
decl_stmt|;
name|struct
name|pf_tree_node
name|key
decl_stmt|;
name|int
name|direction
init|=
name|pnl
operator|->
name|direction
decl_stmt|;
name|key
operator|.
name|af
operator|=
name|pnl
operator|->
name|af
expr_stmt|;
name|key
operator|.
name|proto
operator|=
name|pnl
operator|->
name|proto
expr_stmt|;
comment|/* 		 * userland gives us source and dest of connection, reverse 		 * the lookup so we ask for what happens with the return 		 * traffic, enabling us to find it in the state tree. 		 */
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|1
index|]
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|key
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|key
operator|.
name|port
index|[
literal|0
index|]
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
if|if
condition|(
operator|!
name|pnl
operator|->
name|proto
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
name|PF_AZERO
argument_list|(
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
operator|||
operator|!
name|pnl
operator|->
name|dport
operator|||
operator|!
name|pnl
operator|->
name|sport
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
name|st
operator|=
name|pf_find_state
argument_list|(
operator|&
name|tree_ext_gwy
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
else|else
name|st
operator|=
name|pf_find_state
argument_list|(
operator|&
name|tree_lan_ext
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|PF_IN
condition|)
block|{
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rsaddr
argument_list|,
operator|&
name|st
operator|->
name|lan
operator|.
name|addr
argument_list|,
name|st
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rsport
operator|=
name|st
operator|->
name|lan
operator|.
name|port
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rdaddr
argument_list|,
operator|&
name|pnl
operator|->
name|daddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rdport
operator|=
name|pnl
operator|->
name|dport
expr_stmt|;
block|}
else|else
block|{
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rdaddr
argument_list|,
operator|&
name|st
operator|->
name|gwy
operator|.
name|addr
argument_list|,
name|st
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rdport
operator|=
name|st
operator|->
name|gwy
operator|.
name|port
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pnl
operator|->
name|rsaddr
argument_list|,
operator|&
name|pnl
operator|->
name|saddr
argument_list|,
name|pnl
operator|->
name|af
argument_list|)
expr_stmt|;
name|pnl
operator|->
name|rsport
operator|=
name|pnl
operator|->
name|sport
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIOCSETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
operator|||
name|pt
operator|->
name|seconds
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|old
operator|=
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
operator|=
name|pt
operator|->
name|seconds
expr_stmt|;
name|pt
operator|->
name|seconds
operator|=
name|old
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETTIMEOUT
case|:
block|{
name|struct
name|pfioc_tm
modifier|*
name|pt
init|=
operator|(
expr|struct
name|pfioc_tm
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pt
operator|->
name|timeout
operator|<
literal|0
operator|||
name|pt
operator|->
name|timeout
operator|>=
name|PFTM_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pt
operator|->
name|seconds
operator|=
name|pf_default_rule
operator|.
name|timeout
index|[
name|pt
operator|->
name|timeout
index|]
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pl
operator|->
name|limit
operator|=
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETLIMIT
case|:
block|{
name|struct
name|pfioc_limit
modifier|*
name|pl
init|=
operator|(
expr|struct
name|pfioc_limit
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|old_limit
decl_stmt|;
if|if
condition|(
name|pl
operator|->
name|index
operator|<
literal|0
operator|||
name|pl
operator|->
name|index
operator|>=
name|PF_LIMIT_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|uma_zone_set_max
argument_list|(
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|pp
argument_list|,
name|pl
operator|->
name|limit
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pool_sethardlimit
argument_list|(
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|pp
argument_list|,
name|pl
operator|->
name|limit
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
endif|#
directive|endif
name|old_limit
operator|=
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
expr_stmt|;
name|pf_pool_limits
index|[
name|pl
operator|->
name|index
index|]
operator|.
name|limit
operator|=
name|pl
operator|->
name|limit
expr_stmt|;
name|pl
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSETDEBUG
case|:
block|{
name|u_int32_t
modifier|*
name|level
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|pf_status
operator|.
name|debug
operator|=
operator|*
name|level
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCLRRULECTRS
case|:
block|{
name|struct
name|pf_ruleset
modifier|*
name|ruleset
init|=
operator|&
name|pf_main_ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rule
argument_list|,
argument|ruleset->rules[PF_RULESET_FILTER].active.ptr
argument_list|,
argument|entries
argument_list|)
name|rule
operator|->
name|evaluations
operator|=
name|rule
operator|->
name|packets
operator|=
name|rule
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|DIOCGIFSPEED
case|:
block|{
name|struct
name|pf_ifspeed
modifier|*
name|psp
init|=
operator|(
expr|struct
name|pf_ifspeed
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ifspeed
name|ps
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|psp
operator|->
name|ifname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Can we completely trust user-land? */
name|strlcpy
argument_list|(
name|ps
operator|.
name|ifname
argument_list|,
name|psp
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ifunit
argument_list|(
name|ps
operator|.
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|psp
operator|->
name|baudrate
operator|=
name|ifp
operator|->
name|if_baudrate
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
ifdef|#
directive|ifdef
name|ALTQ
case|case
name|DIOCSTARTALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
comment|/* enable all altq interfaces on active list */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|altq_type
operator|!=
name|ALTQT_NONE
condition|)
name|error
operator|=
name|altq_enable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* set tokenbucket regulator */
name|tb
operator|.
name|rate
operator|=
name|altq
operator|->
name|ifbandwidth
expr_stmt|;
name|tb
operator|.
name|depth
operator|=
name|altq
operator|->
name|tbrsize
expr_stmt|;
name|error
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
name|pfaltq_running
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pfaltq_running
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: started\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCSTOPALTQ
case|:
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* disable all altq interfaces on active list */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|altq_type
operator|!=
name|ALTQT_NONE
condition|)
block|{
name|err
operator|=
name|altq_disable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
comment|/* clear tokenbucket regulator */
name|tb
operator|.
name|rate
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
name|pfaltq_running
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pfaltq_running
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"altq: stopped\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCBEGINALTQS
case|:
block|{
name|u_int32_t
modifier|*
name|ticket
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
operator|*
name|ticket
operator|=
operator|++
name|ticket_altqs_inactive
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|,
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|altq
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pa
operator|->
name|altq
argument_list|,
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if this is for a queue, find the discipline and 		 * copy the necessary fields 		 */
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|a
argument_list|,
argument|pf_altqs_inactive
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a
operator|->
name|ifname
argument_list|,
name|altq
operator|->
name|ifname
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|==
literal|0
operator|&&
name|a
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|altq
operator|->
name|altq_disc
operator|=
name|a
operator|->
name|altq_disc
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_add
argument_list|(
name|altq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCOMMITALTQS
case|:
block|{
name|u_int32_t
modifier|*
name|ticket
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altqqueue
modifier|*
name|old_altqs
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* Swap altqs, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_altqs
operator|=
name|pf_altqs_active
expr_stmt|;
name|pf_altqs_active
operator|=
name|pf_altqs_inactive
expr_stmt|;
name|pf_altqs_inactive
operator|=
name|old_altqs
expr_stmt|;
name|ticket_altqs_active
operator|=
name|ticket_altqs_inactive
expr_stmt|;
comment|/* Attach new disciplines */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* attach the discipline */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_pfattach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
block|}
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|altq_pfdetach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
name|err
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|pool_put
argument_list|(
operator|&
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* update queue IDs */
name|pf_rule_set_qid
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|&pf_anchors
argument_list|,
argument|entries
argument_list|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ruleset
argument_list|,
argument|&anchor->rulesets
argument_list|,
argument|entries
argument_list|)
block|{
name|pf_rule_set_qid
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DIOCGETALTQS
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|pa
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
name|pa
operator|->
name|nr
operator|++
expr_stmt|;
name|pa
operator|->
name|ticket
operator|=
name|ticket_altqs_active
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETALTQ
case|:
block|{
name|struct
name|pfioc_altq
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_altq
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
if|if
condition|(
name|pa
operator|->
name|ticket
operator|!=
name|ticket_altqs_active
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pa
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|altq
argument_list|,
operator|&
name|pa
operator|->
name|altq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEALTQ
case|:
comment|/* CHANGEALTQ not supported yet! */
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|DIOCGETQSTATS
case|:
block|{
name|struct
name|pfioc_qstats
modifier|*
name|pq
init|=
operator|(
expr|struct
name|pfioc_qstats
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|ticket
operator|!=
name|ticket_altqs_active
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nbytes
operator|=
name|pq
operator|->
name|nbytes
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_active
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altq
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pq
operator|->
name|nr
operator|)
condition|)
block|{
name|altq
operator|=
name|TAILQ_NEXT
argument_list|(
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|altq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_getqstats
argument_list|(
name|altq
argument_list|,
name|pq
operator|->
name|buf
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pq
operator|->
name|scheduler
operator|=
name|altq
operator|->
name|scheduler
expr_stmt|;
name|pq
operator|->
name|nbytes
operator|=
name|nbytes
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* ALTQ */
case|case
name|DIOCBEGINADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|pf_empty_pool
argument_list|(
operator|&
name|pf_pabuf
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ticket
operator|=
operator|++
name|ticket_pabuf
expr_stmt|;
break|break;
block|}
case|case
name|DIOCADDADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pp
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pp
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pp
operator|->
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|pa
operator|->
name|ifp
operator|=
name|ifunit
argument_list|(
name|pa
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|pa
operator|->
name|addr
argument_list|,
name|pp
operator|->
name|af
argument_list|)
condition|)
block|{
name|pf_dynaddr_remove
argument_list|(
operator|&
name|pa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pf_pabuf
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDRS
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|pp
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ruleset
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&pool->list
argument_list|,
argument|entries
argument_list|)
name|pp
operator|->
name|nr
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pp
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pp
operator|->
name|anchor
argument_list|,
name|pp
operator|->
name|ruleset
argument_list|,
name|pp
operator|->
name|ticket
argument_list|,
name|pp
operator|->
name|r_action
argument_list|,
name|pp
operator|->
name|r_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|nr
operator|<
name|pp
operator|->
name|nr
operator|)
condition|)
block|{
name|pa
operator|=
name|TAILQ_NEXT
argument_list|(
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|pa
argument_list|,
operator|&
name|pp
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
name|pf_dynaddr_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_copyout
argument_list|(
operator|&
name|pp
operator|->
name|addr
operator|.
name|addr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCCHANGEADDR
case|:
block|{
name|struct
name|pfioc_pooladdr
modifier|*
name|pca
init|=
operator|(
expr|struct
name|pfioc_pooladdr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|oldpa
init|=
name|NULL
decl_stmt|,
modifier|*
name|newpa
init|=
name|NULL
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
if|if
condition|(
name|pca
operator|->
name|action
operator|<
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|>
name|PF_CHANGE_REMOVE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_ADDRMASK
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_DYNIFTL
operator|&&
name|pca
operator|->
name|addr
operator|.
name|addr
operator|.
name|type
operator|!=
name|PF_ADDR_TABLE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pca
operator|->
name|anchor
argument_list|,
name|pca
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|pool
operator|=
name|pf_get_pool
argument_list|(
name|pca
operator|->
name|anchor
argument_list|,
name|pca
operator|->
name|ruleset
argument_list|,
name|pca
operator|->
name|ticket
argument_list|,
name|pca
operator|->
name|r_action
argument_list|,
name|pca
operator|->
name|r_num
argument_list|,
name|pca
operator|->
name|r_last
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|!=
name|PF_CHANGE_REMOVE
condition|)
block|{
name|newpa
operator|=
name|pool_get
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|PR_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|pca
operator|->
name|addr
argument_list|,
name|newpa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INET
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifndef|#
directive|ifndef
name|INET6
if|if
condition|(
name|pca
operator|->
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|newpa
operator|->
name|ifname
index|[
literal|0
index|]
condition|)
block|{
name|newpa
operator|->
name|ifp
operator|=
name|ifunit
argument_list|(
name|newpa
operator|->
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpa
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|newpa
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pf_dynaddr_setup
argument_list|(
operator|&
name|newpa
operator|->
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
operator|||
name|pf_tbladdr_setup
argument_list|(
name|ruleset
argument_list|,
operator|&
name|newpa
operator|->
name|addr
argument_list|)
condition|)
block|{
name|pf_dynaddr_remove
argument_list|(
operator|&
name|newpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|newpa
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
condition|)
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_TAIL
condition|)
name|oldpa
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pf_palist
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|oldpa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oldpa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
name|pca
operator|->
name|nr
operator|)
condition|)
block|{
name|oldpa
operator|=
name|TAILQ_NEXT
argument_list|(
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_REMOVE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|pf_dynaddr_remove
argument_list|(
operator|&
name|oldpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pf_tbladdr_remove
argument_list|(
operator|&
name|oldpa
operator|->
name|addr
argument_list|)
expr_stmt|;
name|pool_put
argument_list|(
operator|&
name|pf_pooladdr_pl
argument_list|,
name|oldpa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldpa
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_HEAD
operator|||
name|pca
operator|->
name|action
operator|==
name|PF_CHANGE_ADD_BEFORE
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|oldpa
argument_list|,
name|newpa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
name|PF_ACPY
argument_list|(
operator|&
name|pool
operator|->
name|counter
argument_list|,
operator|&
name|pool
operator|->
name|cur
operator|->
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
name|pca
operator|->
name|af
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETANCHORS
case|:
block|{
name|struct
name|pfioc_anchor
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_anchor
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|pa
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|&pf_anchors
argument_list|,
argument|entries
argument_list|)
name|pa
operator|->
name|nr
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETANCHOR
case|:
block|{
name|struct
name|pfioc_anchor
modifier|*
name|pa
init|=
operator|(
expr|struct
name|pfioc_anchor
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
name|anchor
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pf_anchors
argument_list|)
expr_stmt|;
while|while
condition|(
name|anchor
operator|!=
name|NULL
operator|&&
name|nr
operator|<
name|pa
operator|->
name|nr
condition|)
block|{
name|anchor
operator|=
name|TAILQ_NEXT
argument_list|(
name|anchor
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|anchor
operator|==
name|NULL
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|anchor
operator|->
name|name
argument_list|,
name|pa
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULESETS
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|pr
operator|->
name|anchor
index|[
name|PF_ANCHOR_NAME_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|anchor
operator|=
name|pf_find_anchor
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|pr
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ruleset
argument_list|,
argument|&anchor->rulesets
argument_list|,
argument|entries
argument_list|)
name|pr
operator|->
name|nr
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|DIOCGETRULESET
case|:
block|{
name|struct
name|pfioc_ruleset
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_ruleset
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|u_int32_t
name|nr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|anchor
operator|=
name|pf_find_anchor
argument_list|(
name|pr
operator|->
name|anchor
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ruleset
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|anchor
operator|->
name|rulesets
argument_list|)
expr_stmt|;
while|while
condition|(
name|ruleset
operator|!=
name|NULL
operator|&&
name|nr
operator|<
name|pr
operator|->
name|nr
condition|)
block|{
name|ruleset
operator|=
name|TAILQ_NEXT
argument_list|(
name|ruleset
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ruleset
operator|->
name|name
argument_list|,
name|pr
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_add_tables
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_del_tables
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTABLES
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_tstats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_tstats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRTSTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_tstats
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETTFLAGS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_table
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_set_tflags
argument_list|(
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_setflag
argument_list|,
name|io
operator|->
name|pfrio_clrflag
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRADDADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_add_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRDELADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_del_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRSETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_set_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size2
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRGETASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_astats
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_get_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
operator|&
name|io
operator|->
name|pfrio_size
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRCLRASTATS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_clr_astats
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nzero
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRTSTADDRS
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_tst_addrs
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nmatch
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRINABEGIN
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_ina_begin
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ticket
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRINACOMMIT
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_ina_commit
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_ticket
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nchange
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCRINADEFINE
case|:
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|io
operator|->
name|pfrio_esize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pfr_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pfr_ina_define
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
name|io
operator|->
name|pfrio_buffer
argument_list|,
name|io
operator|->
name|pfrio_size
argument_list|,
operator|&
name|io
operator|->
name|pfrio_nadd
argument_list|,
operator|&
name|io
operator|->
name|pfrio_naddr
argument_list|,
name|io
operator|->
name|pfrio_ticket
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPFLUSH
case|:
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|pf_osfp_flush
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCOSFPADD
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|pf_osfp_add
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIOCOSFPGET
case|:
block|{
name|struct
name|pf_osfp_ioctl
modifier|*
name|io
init|=
operator|(
expr|struct
name|pf_osfp_ioctl
operator|*
operator|)
name|addr
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|pf_osfp_get
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
name|fail
label|:
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/*  * XXX - Check for version missmatch!!!  */
end_comment

begin_function
specifier|static
name|int
name|pf_beginrules
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
do|do
block|{
name|ruleset
operator|=
name|pf_find_or_create_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|pr
operator|->
name|ticket
operator|=
operator|++
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_commitrules
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|pfioc_rule
modifier|*
name|pr
init|=
operator|(
expr|struct
name|pfioc_rule
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|struct
name|pf_rulequeue
modifier|*
name|old_rules
decl_stmt|;
name|struct
name|pf_rule
modifier|*
name|rule
decl_stmt|;
name|int
name|rs_num
decl_stmt|,
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
do|do
block|{
name|ruleset
operator|=
name|pf_find_ruleset
argument_list|(
name|pr
operator|->
name|anchor
argument_list|,
name|pr
operator|->
name|ruleset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ruleset
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rs_num
operator|=
name|pf_get_ruleset_number
argument_list|(
name|pr
operator|->
name|rule
operator|.
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs_num
operator|>=
name|PF_RULESET_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pr
operator|->
name|ticket
operator|!=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ALTQ
comment|/* set queue IDs */
if|if
condition|(
name|rs_num
operator|==
name|PF_RULESET_FILTER
condition|)
name|pf_rule_set_qid
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Swap rules, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_rules
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ptr
operator|=
name|old_rules
expr_stmt|;
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ticket
operator|=
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|inactive
operator|.
name|ticket
expr_stmt|;
name|pf_calc_skip_steps
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|rs_num
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Purge the old rule list. */
while|while
condition|(
operator|(
name|rule
operator|=
name|TAILQ_FIRST
argument_list|(
name|old_rules
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pf_rm_rule
argument_list|(
name|old_rules
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|pf_remove_if_empty_ruleset
argument_list|(
name|ruleset
argument_list|)
expr_stmt|;
name|pf_update_anchor_rules
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_function
specifier|static
name|int
name|pf_beginaltqs
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ticket
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* detach and destroy the discipline */
name|error
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|uma_zfree
argument_list|(
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
operator|*
name|ticket
operator|=
operator|++
name|ticket_altqs_inactive
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_commitaltqs
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|ticket
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|pf_altqqueue
modifier|*
name|old_altqs
decl_stmt|;
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|struct
name|pf_anchor
modifier|*
name|anchor
decl_stmt|;
name|struct
name|pf_ruleset
modifier|*
name|ruleset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|ticket
operator|!=
name|ticket_altqs_inactive
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* Swap altqs, keep the old. */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|old_altqs
operator|=
name|pf_altqs_active
expr_stmt|;
name|pf_altqs_active
operator|=
name|pf_altqs_inactive
expr_stmt|;
name|pf_altqs_inactive
operator|=
name|old_altqs
expr_stmt|;
name|ticket_altqs_active
operator|=
name|ticket_altqs_inactive
expr_stmt|;
comment|/* Attach new disciplines */
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* attach the discipline */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_pfattach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|altq_fail
goto|;
block|}
block|}
block|}
comment|/* Purge the old altq list */
while|while
condition|(
operator|(
name|altq
operator|=
name|TAILQ_FIRST
argument_list|(
name|pf_altqs_inactive
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|pf_altqs_inactive
argument_list|,
name|altq
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* detach and destroy the discipline */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|altq_pfdetach
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
name|err
operator|=
name|altq_remove
argument_list|(
name|altq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|PF_LOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|uma_zfree
argument_list|(
name|pf_altq_pl
argument_list|,
name|altq
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* update queue IDs */
name|pf_rule_set_qid
argument_list|(
name|pf_main_ruleset
operator|.
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|anchor
argument_list|,
argument|&pf_anchors
argument_list|,
argument|entries
argument_list|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ruleset
argument_list|,
argument|&anchor->rulesets
argument_list|,
argument|entries
argument_list|)
block|{
name|pf_rule_set_qid
argument_list|(
name|ruleset
operator|->
name|rules
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|active
operator|.
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|altq_fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_stopaltq
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_altq
modifier|*
name|altq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|tb_profile
name|tb
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|/* disable all altq interfaces on active list */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|altq
argument_list|,
argument|pf_altqs_active
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|altq
operator|->
name|qname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|altq
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|altq_type
operator|!=
name|ALTQT_NONE
condition|)
block|{
name|err
operator|=
name|altq_disable
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
comment|/* clear tokenbucket regulator */
name|tb
operator|.
name|rate
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|tbr_set
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
name|pfaltq_running
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pfaltq_running
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|pf_clearstates
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pf_tree_node
modifier|*
name|n
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|n
argument_list|,
argument|pf_state_tree
argument_list|,
argument|&tree_ext_gwy
argument_list|)
name|n
operator|->
name|state
operator|->
name|timeout
operator|=
name|PFTM_PURGE
expr_stmt|;
name|pf_purge_expired_states
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|states
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_clear_tables
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|pfioc_table
modifier|*
name|io
init|=
operator|(
expr|struct
name|pfioc_table
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pfr_clr_tables
argument_list|(
operator|&
name|io
operator|->
name|pfrio_table
argument_list|,
operator|&
name|io
operator|->
name|pfrio_ndel
argument_list|,
name|io
operator|->
name|pfrio_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|shutdown_pf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
endif|#
directive|endif
name|struct
name|pfioc_table
name|io
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pf_expire_to
argument_list|)
expr_stmt|;
name|PF_LOCK
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
operator|(
name|error
operator|=
name|pf_stopaltq
argument_list|()
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"ALTQ: stop(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_SCRUB: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_SCRUB: commit(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_PASS: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_PASS: commit(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * XXX not sure, but can't hurt:  */
name|bzero
argument_list|(
operator|&
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_NAT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_NAT: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_NAT: commit(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_BINAT
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_BINAT: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_BINAT: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_RDR
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_RDR: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitrules
argument_list|(
operator|&
name|pr
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"PF_RDR: commit(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|ALTQ
name|bzero
argument_list|(
operator|&
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_beginaltqs
argument_list|(
operator|&
name|pa
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"ALTQ: begin(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|pf_commitaltqs
argument_list|(
operator|&
name|pa
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"ALTQ: commit(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|pf_clearstates
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|io
argument_list|,
sizeof|sizeof
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pf_clear_tables
argument_list|(
operator|&
name|io
argument_list|)
operator|)
condition|)
block|{
name|DPFPRINTF
argument_list|(
name|PF_DEBUG_MISC
argument_list|,
operator|(
literal|"TABLES: clear(%i)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pf_osfp_flush
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|PF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
name|pf_check_in
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
else|#
directive|else
function|pf_check_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
endif|#
directive|endif
block|{
comment|/* 	 * XXX Wed Jul 9 22:03:16 2003 UTC 	 * OpenBSD has changed its byte ordering convention on ip_len/ip_off 	 * in network stack. OpenBSD's network stack have converted 	 * ip_len/ip_off to host byte order frist as FreeBSD. 	 * Now this is not true anymore , so we should convert back to network 	 * byte order.  	 */
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|chk
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* if m_pkthdr.len is less than ip header, pf will handle. */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
name|chk
operator|=
name|pf_test
argument_list|(
name|PF_IN
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* pf_test can change ip header location */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_function
specifier|static
name|int
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
name|pf_check_out
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
else|#
directive|else
function|pf_check_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
endif|#
directive|endif
block|{
comment|/* 	 * XXX Wed Jul 9 22:03:16 2003 UTC 	 * OpenBSD has changed its byte ordering convention on ip_len/ip_off 	 * in network stack. OpenBSD's network stack have converted 	 * ip_len/ip_off to host byte order frist as FreeBSD. 	 * Now this is not true anymore , so we should convert back to network 	 * byte order.  	 */
name|struct
name|ip
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|chk
decl_stmt|;
comment|/* We need a proper CSUM befor we start (s. OpenBSD ip_output) */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
condition|)
block|{
comment|/* if m_pkthdr.len is less than ip header, pf will handle. */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
name|chk
operator|=
name|pf_test
argument_list|(
name|PF_OUT
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* pf_test can change ip header location */
name|h
operator|=
name|mtod
argument_list|(
operator|*
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|h
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|int
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
name|pf_check6_in
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
else|#
directive|else
function|pf_check6_in
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
endif|#
directive|endif
block|{
comment|/* 	 * IPv6 does not affected ip_len/ip_off byte order changes. 	 */
name|int
name|chk
decl_stmt|;
name|chk
operator|=
name|pf_test6
argument_list|(
name|PF_IN
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_function
specifier|static
name|int
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
name|pf_check6_out
parameter_list|(
name|void
modifier|*
name|ip
parameter_list|,
name|int
name|hlen
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
else|#
directive|else
function|pf_check6_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
endif|#
directive|endif
block|{
comment|/* 	 * IPv6 does not affected ip_len/ip_off byte order changes. 	 */
name|int
name|chk
decl_stmt|;
comment|/* We need a proper CSUM befor we start (s. OpenBSD ip_output) */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
name|chk
operator|=
name|pf_test6
argument_list|(
name|PF_OUT
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|&&
operator|*
name|m
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|chk
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
specifier|static
name|int
name|hook_pf
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|501108
operator|)
name|struct
name|pfil_head
modifier|*
name|pfh_inet
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|pfil_head
modifier|*
name|pfh_inet6
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|PF_ASSERT
argument_list|(
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_pfil_hooked
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
comment|/* 	 * XXX 	 * There is no easy way to get pfil header pointer with address 	 * family such as AF_INET, AF_INET6. 	 * Needs direct variable reference. 	 */
name|pfil_add_hook
argument_list|(
name|pf_check_in
argument_list|,
name|PFIL_IN
argument_list|,
operator|&
name|inetsw
index|[
name|ip_protox
index|[
name|IPPROTO_IP
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check_out
argument_list|,
name|PFIL_OUT
argument_list|,
operator|&
name|inetsw
index|[
name|ip_protox
index|[
name|IPPROTO_IP
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|pfil_add_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|PFIL_IN
argument_list|,
operator|&
name|inet6sw
index|[
name|ip6_protox
index|[
name|IPPROTO_IPV6
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|PFIL_OUT
argument_list|,
operator|&
name|inet6sw
index|[
name|ip6_protox
index|[
name|IPPROTO_IPV6
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version>= 501108 */
name|pfh_inet
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_add_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|pfh_inet6
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet6
operator|==
name|NULL
condition|)
block|{
name|pfil_remove_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
block|}
name|pfil_add_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
name|pfil_add_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __FreeBSD_version>= 501108 */
name|pf_pfil_hooked
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dehook_pf
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|501108
operator|)
name|struct
name|pfil_head
modifier|*
name|pfh_inet
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|pfil_head
modifier|*
name|pfh_inet6
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|PF_ASSERT
argument_list|(
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_pfil_hooked
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|501108
operator|)
name|pfil_remove_hook
argument_list|(
name|pf_check_in
argument_list|,
name|PFIL_IN
argument_list|,
operator|&
name|inetsw
index|[
name|ip_protox
index|[
name|IPPROTO_IP
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check_out
argument_list|,
name|PFIL_OUT
argument_list|,
operator|&
name|inetsw
index|[
name|ip_protox
index|[
name|IPPROTO_IP
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|pfil_remove_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|PFIL_IN
argument_list|,
operator|&
name|inet6sw
index|[
name|ip6_protox
index|[
name|IPPROTO_IPV6
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|PFIL_OUT
argument_list|,
operator|&
name|inet6sw
index|[
name|ip6_protox
index|[
name|IPPROTO_IPV6
index|]
index|]
operator|.
name|pr_pfh
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* __FreeBSD_version>= 501108 */
name|pfh_inet
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_remove_hook
argument_list|(
name|pf_check_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|pfh_inet6
operator|=
name|pfil_head_get
argument_list|(
name|PFIL_TYPE_AF
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfh_inet6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* XXX */
name|pfil_remove_hook
argument_list|(
name|pf_check6_in
argument_list|,
name|NULL
argument_list|,
name|PFIL_IN
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
name|pfil_remove_hook
argument_list|(
name|pf_check6_out
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
operator||
name|PFIL_WAITOK
argument_list|,
name|pfh_inet6
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __FreeBSD_version>= 501108 */
name|pf_pfil_hooked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_load
parameter_list|(
name|void
parameter_list|)
block|{
name|init_zone_var
argument_list|()
expr_stmt|;
name|init_pf_mutex
argument_list|()
expr_stmt|;
name|pf_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|pf_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
name|PF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfattach
argument_list|()
operator|<
literal|0
condition|)
block|{
name|destroy_dev
argument_list|(
name|pf_dev
argument_list|)
expr_stmt|;
name|destroy_pf_mutex
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ALTQ
name|mtx_lock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
operator|++
name|pfaltq_ref
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PF_LOCK
argument_list|()
expr_stmt|;
name|pf_status
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|PF_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|dehook_pf
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Should not happen! 		 * XXX Due to error code ESRCH, kldunload will show 		 * a message like 'No such process'. 		 */
name|printf
argument_list|(
literal|"%s : pfil unregisteration fail\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|shutdown_pf
argument_list|()
expr_stmt|;
name|cleanup_pf_zone
argument_list|()
expr_stmt|;
name|pf_osfp_cleanup
argument_list|()
expr_stmt|;
name|destroy_dev
argument_list|(
name|pf_dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
name|mtx_lock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
operator|--
name|pfaltq_ref
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pf_altq_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|destroy_pf_mutex
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|pf_load
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|pf_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|pf_mod
init|=
block|{
literal|"pf"
block|,
name|pf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|pf
argument_list|,
name|pf_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pf
argument_list|,
name|pflog
argument_list|,
name|PFLOG_MINVER
argument_list|,
name|PFLOG_PREFVER
argument_list|,
name|PFLOG_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pf
argument_list|,
name|pfsync
argument_list|,
name|PFSYNC_MINVER
argument_list|,
name|PFSYNC_PREFVER
argument_list|,
name|PFSYNC_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|pf
argument_list|,
name|pfaltq
argument_list|,
name|PFALTQ_MINVER
argument_list|,
name|PFALTQ_PREFVER
argument_list|,
name|PFALTQ_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pf
argument_list|,
name|PF_MODVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

end_unit

