begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*- ******************************************************************************* Copyright (C) 2015 Annapurna Labs Ltd.  This file may be licensed under the terms of the Annapurna Labs Commercial License Agreement.  Alternatively, this file can be distributed under the terms of the GNU General Public License V2 as published by the Free Software Foundation and can be found at http://www.gnu.org/licenses/gpl-2.0.html  Alternatively, redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      *     Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.      *     Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *******************************************************************************/
end_comment

begin_comment
comment|/**  *  @{  * @file   al_hal_udma_main.c  *  * @brief  Universal DMA HAL driver for main functions (initialization, data path)  *  */
end_comment

begin_include
include|#
directive|include
file|<al_hal_udma.h>
end_include

begin_include
include|#
directive|include
file|<al_hal_udma_config.h>
end_include

begin_define
define|#
directive|define
name|AL_UDMA_Q_RST_TOUT
value|10000
end_define

begin_comment
comment|/* Queue reset timeout [uSecs] */
end_comment

begin_define
define|#
directive|define
name|UDMA_STATE_IDLE
value|0x0
end_define

begin_define
define|#
directive|define
name|UDMA_STATE_NORMAL
value|0x1
end_define

begin_define
define|#
directive|define
name|UDMA_STATE_ABORT
value|0x2
end_define

begin_define
define|#
directive|define
name|UDMA_STATE_RESERVED
value|0x3
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|al_udma_states_name
index|[]
init|=
block|{
literal|"Disable"
block|,
literal|"Idle"
block|,
literal|"Normal"
block|,
literal|"Abort"
block|,
literal|"Reset"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AL_UDMA_INITIAL_RING_ID
value|1
end_define

begin_comment
comment|/*  dma_q flags */
end_comment

begin_define
define|#
directive|define
name|AL_UDMA_Q_FLAGS_IGNORE_RING_ID
value|AL_BIT(0)
end_define

begin_define
define|#
directive|define
name|AL_UDMA_Q_FLAGS_NO_COMP_UPDATE
value|AL_BIT(1)
end_define

begin_define
define|#
directive|define
name|AL_UDMA_Q_FLAGS_EN_COMP_COAL
value|AL_BIT(2)
end_define

begin_function
specifier|static
name|void
name|al_udma_set_defaults
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|uint8_t
name|rev_id
init|=
name|udma
operator|->
name|rev_id
decl_stmt|;
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
block|{
name|struct
name|unit_regs
modifier|*
name|tmp_unit_regs
init|=
operator|(
expr|struct
name|unit_regs
operator|*
operator|)
name|udma
operator|->
name|udma_regs
decl_stmt|;
comment|/* Setting the data fifo depth to 4K (256 strips of 16B) 		 * This allows the UDMA to have 16 outstanding writes */
if|if
condition|(
name|rev_id
operator|>=
name|AL_UDMA_REV_ID_2
condition|)
block|{
name|al_reg_write32_masked
argument_list|(
operator|&
name|tmp_unit_regs
operator|->
name|m2s
operator|.
name|m2s_rd
operator|.
name|data_cfg
argument_list|,
name|UDMA_M2S_RD_DATA_CFG_DATA_FIFO_DEPTH_MASK
argument_list|,
literal|256
operator|<<
name|UDMA_M2S_RD_DATA_CFG_DATA_FIFO_DEPTH_SHIFT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rev_id
operator|==
name|AL_UDMA_REV_ID_0
condition|)
comment|/* disable AXI timeout for M0*/
name|al_reg_write32
argument_list|(
operator|&
name|tmp_unit_regs
operator|->
name|gen
operator|.
name|axi
operator|.
name|cfg_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* set AXI timeout to 1M (~2.6 ms) */
name|al_reg_write32
argument_list|(
operator|&
name|tmp_unit_regs
operator|->
name|gen
operator|.
name|axi
operator|.
name|cfg_1
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|tmp_unit_regs
operator|->
name|m2s
operator|.
name|m2s_comp
operator|.
name|cfg_application_ack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ack time out */
if|if
condition|(
name|rev_id
operator|==
name|AL_UDMA_REV_ID_0
condition|)
block|{
name|tmp
operator|=
name|al_reg_read32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|m2s
operator|.
name|axi_m2s
operator|.
name|desc_wr_cfg_1
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|UDMA_AXI_M2S_DESC_WR_CFG_1_MAX_AXI_BEATS_MASK
expr_stmt|;
name|tmp
operator||=
literal|4
operator|<<
name|UDMA_AXI_M2S_DESC_WR_CFG_1_MAX_AXI_BEATS_SHIFT
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|m2s
operator|.
name|axi_m2s
operator|.
name|desc_wr_cfg_1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_RX
condition|)
block|{
name|al_reg_write32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m_comp
operator|.
name|cfg_application_ack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ack time out */
block|}
block|}
end_function

begin_comment
comment|/**  * misc queue configurations  *  * @param udma_q udma queue data structure  *  * @return 0  */
end_comment

begin_function
specifier|static
name|int
name|al_udma_q_config
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|)
block|{
name|uint32_t
modifier|*
name|reg_addr
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|udma_q
operator|->
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
block|{
name|reg_addr
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|m2s_q
operator|.
name|rlimit
operator|.
name|mask
expr_stmt|;
name|val
operator|=
name|al_reg_read32
argument_list|(
name|reg_addr
argument_list|)
expr_stmt|;
comment|// enable DMB
name|val
operator|&=
operator|~
name|UDMA_M2S_Q_RATE_LIMIT_MASK_INTERNAL_PAUSE_DMB
expr_stmt|;
name|al_reg_write32
argument_list|(
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * set the queue's completion configuration register  *  * @param udma_q udma queue data structure  *  * @return 0  */
end_comment

begin_function
specifier|static
name|int
name|al_udma_q_config_compl
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|)
block|{
name|uint32_t
modifier|*
name|reg_addr
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|udma_q
operator|->
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|reg_addr
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|m2s_q
operator|.
name|comp_cfg
expr_stmt|;
else|else
name|reg_addr
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|s2m_q
operator|.
name|comp_cfg
expr_stmt|;
name|val
operator|=
name|al_reg_read32
argument_list|(
name|reg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|udma_q
operator|->
name|flags
operator|&
name|AL_UDMA_Q_FLAGS_NO_COMP_UPDATE
condition|)
name|val
operator|&=
operator|~
name|UDMA_M2S_Q_COMP_CFG_EN_COMP_RING_UPDATE
expr_stmt|;
else|else
name|val
operator||=
name|UDMA_M2S_Q_COMP_CFG_EN_COMP_RING_UPDATE
expr_stmt|;
if|if
condition|(
name|udma_q
operator|->
name|flags
operator|&
name|AL_UDMA_Q_FLAGS_EN_COMP_COAL
condition|)
name|val
operator|&=
operator|~
name|UDMA_M2S_Q_COMP_CFG_DIS_COMP_COAL
expr_stmt|;
else|else
name|val
operator||=
name|UDMA_M2S_Q_COMP_CFG_DIS_COMP_COAL
expr_stmt|;
name|al_reg_write32
argument_list|(
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* set the completion queue size */
if|if
condition|(
name|udma_q
operator|->
name|udma
operator|->
name|type
operator|==
name|UDMA_RX
condition|)
block|{
name|val
operator|=
name|al_reg_read32
argument_list|(
operator|&
name|udma_q
operator|->
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m_comp
operator|.
name|cfg_1c
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|UDMA_S2M_COMP_CFG_1C_DESC_SIZE_MASK
expr_stmt|;
comment|/* the register expects it to be in words */
name|val
operator||=
operator|(
name|udma_q
operator|->
name|cdesc_size
operator|>>
literal|2
operator|)
operator|&
name|UDMA_S2M_COMP_CFG_1C_DESC_SIZE_MASK
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m_comp
operator|.
name|cfg_1c
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * reset the queues pointers (Head, Tail, etc) and set the base addresses  *  * @param udma_q udma queue data structure  */
end_comment

begin_function
specifier|static
name|int
name|al_udma_q_set_pointers
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|)
block|{
comment|/* reset the descriptors ring pointers */
comment|/* assert descriptor base address aligned. */
name|al_assert
argument_list|(
operator|(
name|AL_ADDR_LOW
argument_list|(
name|udma_q
operator|->
name|desc_phy_base
argument_list|)
operator|&
operator|~
name|UDMA_M2S_Q_TDRBP_LOW_ADDR_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|drbp_low
argument_list|,
name|AL_ADDR_LOW
argument_list|(
name|udma_q
operator|->
name|desc_phy_base
argument_list|)
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|drbp_high
argument_list|,
name|AL_ADDR_HIGH
argument_list|(
name|udma_q
operator|->
name|desc_phy_base
argument_list|)
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|drl
argument_list|,
name|udma_q
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* if completion ring update disabled */
if|if
condition|(
name|udma_q
operator|->
name|cdesc_base_ptr
operator|==
name|NULL
condition|)
block|{
name|udma_q
operator|->
name|flags
operator||=
name|AL_UDMA_Q_FLAGS_NO_COMP_UPDATE
expr_stmt|;
block|}
else|else
block|{
comment|/* reset the completion descriptors ring pointers */
comment|/* assert completion base address aligned. */
name|al_assert
argument_list|(
operator|(
name|AL_ADDR_LOW
argument_list|(
name|udma_q
operator|->
name|cdesc_phy_base
argument_list|)
operator|&
operator|~
name|UDMA_M2S_Q_TCRBP_LOW_ADDR_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|crbp_low
argument_list|,
name|AL_ADDR_LOW
argument_list|(
name|udma_q
operator|->
name|cdesc_phy_base
argument_list|)
argument_list|)
expr_stmt|;
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|crbp_high
argument_list|,
name|AL_ADDR_HIGH
argument_list|(
name|udma_q
operator|->
name|cdesc_phy_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|al_udma_q_config_compl
argument_list|(
name|udma_q
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * enable/disable udma queue  *  * @param udma_q udma queue data structure  * @param enable none zero value enables the queue, zero means disable  *  * @return 0  */
end_comment

begin_function
specifier|static
name|int
name|al_udma_q_enable
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|uint32_t
name|reg
init|=
name|al_reg_read32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|cfg
argument_list|)
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|reg
operator||=
operator|(
name|UDMA_M2S_Q_CFG_EN_PREF
operator||
name|UDMA_M2S_Q_CFG_EN_SCHEDULING
operator|)
expr_stmt|;
name|udma_q
operator|->
name|status
operator|=
name|AL_QUEUE_ENABLED
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|&=
operator|~
operator|(
name|UDMA_M2S_Q_CFG_EN_PREF
operator||
name|UDMA_M2S_Q_CFG_EN_SCHEDULING
operator|)
expr_stmt|;
name|udma_q
operator|->
name|status
operator|=
name|AL_QUEUE_DISABLED
expr_stmt|;
block|}
name|al_reg_write32
argument_list|(
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|cfg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/************************ API functions ***************************************/
end_comment

begin_comment
comment|/* Initializations functions */
end_comment

begin_comment
comment|/*  * Initialize the udma engine  */
end_comment

begin_function
name|int
name|al_udma_init
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|,
name|struct
name|al_udma_params
modifier|*
name|udma_params
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|al_assert
argument_list|(
name|udma
argument_list|)
expr_stmt|;
if|if
condition|(
name|udma_params
operator|->
name|num_of_queues
operator|>
name|DMA_MAX_Q
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: invalid num_of_queues parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|udma
operator|->
name|type
operator|=
name|udma_params
operator|->
name|type
expr_stmt|;
name|udma
operator|->
name|num_of_queues
operator|=
name|udma_params
operator|->
name|num_of_queues
expr_stmt|;
name|udma
operator|->
name|gen_regs
operator|=
operator|&
name|udma_params
operator|->
name|udma_regs_base
operator|->
name|gen
expr_stmt|;
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|udma
operator|->
name|udma_regs
operator|=
operator|(
expr|union
name|udma_regs
operator|*
operator|)
operator|&
name|udma_params
operator|->
name|udma_regs_base
operator|->
name|m2s
expr_stmt|;
else|else
name|udma
operator|->
name|udma_regs
operator|=
operator|(
expr|union
name|udma_regs
operator|*
operator|)
operator|&
name|udma_params
operator|->
name|udma_regs_base
operator|->
name|s2m
expr_stmt|;
name|udma
operator|->
name|rev_id
operator|=
name|al_udma_get_revision
argument_list|(
name|udma_params
operator|->
name|udma_regs_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|udma_params
operator|->
name|name
operator|==
name|NULL
condition|)
name|udma
operator|->
name|name
operator|=
literal|""
expr_stmt|;
else|else
name|udma
operator|->
name|name
operator|=
name|udma_params
operator|->
name|name
expr_stmt|;
name|udma
operator|->
name|state
operator|=
name|UDMA_DISABLE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMA_MAX_Q
condition|;
name|i
operator|++
control|)
block|{
name|udma
operator|->
name|udma_q
index|[
name|i
index|]
operator|.
name|status
operator|=
name|AL_QUEUE_NOT_INITIALIZED
expr_stmt|;
block|}
comment|/* initialize configuration registers to correct values */
name|al_udma_set_defaults
argument_list|(
name|udma
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"udma [%s] initialized. base %p\n"
argument_list|,
name|udma
operator|->
name|name
argument_list|,
name|udma
operator|->
name|udma_regs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the udma queue data structure  */
end_comment

begin_function
name|int
name|al_udma_q_init
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|,
name|uint32_t
name|qid
parameter_list|,
name|struct
name|al_udma_q_params
modifier|*
name|q_params
parameter_list|)
block|{
name|struct
name|al_udma_q
modifier|*
name|udma_q
decl_stmt|;
name|al_assert
argument_list|(
name|udma
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
name|udma
operator|->
name|num_of_queues
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: invalid queue id (%d)\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|udma
operator|->
name|udma_q
index|[
name|qid
index|]
operator|.
name|status
operator|==
name|AL_QUEUE_ENABLED
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: queue (%d) already enabled!\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
if|if
condition|(
name|q_params
operator|->
name|size
operator|<
name|AL_UDMA_MIN_Q_SIZE
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: queue (%d) size too small\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|q_params
operator|->
name|size
operator|>
name|AL_UDMA_MAX_Q_SIZE
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: queue (%d) size too large\n"
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|q_params
operator|->
name|size
operator|&
operator|(
name|q_params
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|al_err
argument_list|(
literal|"udma: queue (%d) size (%d) must be power of 2\n"
argument_list|,
name|q_params
operator|->
name|size
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|udma_q
operator|=
operator|&
name|udma
operator|->
name|udma_q
index|[
name|qid
index|]
expr_stmt|;
comment|/* set the queue's regs base address */
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|udma_q
operator|->
name|q_regs
operator|=
operator|(
expr|union
name|udma_q_regs
name|__iomem
operator|*
operator|)
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|m2s
operator|.
name|m2s_q
index|[
name|qid
index|]
expr_stmt|;
else|else
name|udma_q
operator|->
name|q_regs
operator|=
operator|(
expr|union
name|udma_q_regs
name|__iomem
operator|*
operator|)
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m_q
index|[
name|qid
index|]
expr_stmt|;
name|udma_q
operator|->
name|adapter_rev_id
operator|=
name|q_params
operator|->
name|adapter_rev_id
expr_stmt|;
name|udma_q
operator|->
name|size
operator|=
name|q_params
operator|->
name|size
expr_stmt|;
name|udma_q
operator|->
name|size_mask
operator|=
name|q_params
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|udma_q
operator|->
name|desc_base_ptr
operator|=
name|q_params
operator|->
name|desc_base
expr_stmt|;
name|udma_q
operator|->
name|desc_phy_base
operator|=
name|q_params
operator|->
name|desc_phy_base
expr_stmt|;
name|udma_q
operator|->
name|cdesc_base_ptr
operator|=
name|q_params
operator|->
name|cdesc_base
expr_stmt|;
name|udma_q
operator|->
name|cdesc_phy_base
operator|=
name|q_params
operator|->
name|cdesc_phy_base
expr_stmt|;
name|udma_q
operator|->
name|cdesc_size
operator|=
name|q_params
operator|->
name|cdesc_size
expr_stmt|;
name|udma_q
operator|->
name|next_desc_idx
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|next_cdesc_idx
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|end_cdesc_ptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|udma_q
operator|->
name|cdesc_base_ptr
operator|+
operator|(
name|udma_q
operator|->
name|size
operator|-
literal|1
operator|)
operator|*
name|udma_q
operator|->
name|cdesc_size
expr_stmt|;
name|udma_q
operator|->
name|comp_head_idx
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|comp_head_ptr
operator|=
operator|(
expr|union
name|al_udma_cdesc
operator|*
operator|)
name|udma_q
operator|->
name|cdesc_base_ptr
expr_stmt|;
name|udma_q
operator|->
name|desc_ring_id
operator|=
name|AL_UDMA_INITIAL_RING_ID
expr_stmt|;
name|udma_q
operator|->
name|comp_ring_id
operator|=
name|AL_UDMA_INITIAL_RING_ID
expr_stmt|;
if|#
directive|if
literal|0
block|udma_q->desc_ctrl_bits = AL_UDMA_INITIAL_RING_ID<< 						AL_M2S_DESC_RING_ID_SHIFT;
endif|#
directive|endif
name|udma_q
operator|->
name|pkt_crnt_descs
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|status
operator|=
name|AL_QUEUE_DISABLED
expr_stmt|;
name|udma_q
operator|->
name|udma
operator|=
name|udma
expr_stmt|;
name|udma_q
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
comment|/* start hardware configuration: */
name|al_udma_q_config
argument_list|(
name|udma_q
argument_list|)
expr_stmt|;
comment|/* reset the queue pointers */
name|al_udma_q_set_pointers
argument_list|(
name|udma_q
argument_list|)
expr_stmt|;
comment|/* enable the q */
name|al_udma_q_enable
argument_list|(
name|udma_q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"udma [%s %d]: %s q init. size 0x%x\n"
literal|"  desc ring info: phys base 0x%llx virt base %p\n"
literal|"  cdesc ring info: phys base 0x%llx virt base %p "
literal|"entry size 0x%x"
argument_list|,
name|udma_q
operator|->
name|udma
operator|->
name|name
argument_list|,
name|udma_q
operator|->
name|qid
argument_list|,
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|?
literal|"Tx"
else|:
literal|"Rx"
argument_list|,
name|q_params
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|q_params
operator|->
name|desc_phy_base
argument_list|,
name|q_params
operator|->
name|desc_base
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|q_params
operator|->
name|cdesc_phy_base
argument_list|,
name|q_params
operator|->
name|cdesc_base
argument_list|,
name|q_params
operator|->
name|cdesc_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a udma queue  */
end_comment

begin_function
name|int
name|al_udma_q_reset
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|)
block|{
name|unsigned
name|int
name|remaining_time
init|=
name|AL_UDMA_Q_RST_TOUT
decl_stmt|;
name|uint32_t
modifier|*
name|status_reg
decl_stmt|;
name|uint32_t
modifier|*
name|dcp_reg
decl_stmt|;
name|uint32_t
modifier|*
name|crhp_reg
decl_stmt|;
name|uint32_t
modifier|*
name|q_sw_ctrl_reg
decl_stmt|;
name|al_assert
argument_list|(
name|udma_q
argument_list|)
expr_stmt|;
comment|/* De-assert scheduling and prefetch */
name|al_udma_q_enable
argument_list|(
name|udma_q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for scheduling and prefetch to stop */
name|status_reg
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|status
expr_stmt|;
while|while
condition|(
name|remaining_time
condition|)
block|{
name|uint32_t
name|status
init|=
name|al_reg_read32
argument_list|(
name|status_reg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
operator|(
name|UDMA_M2S_Q_STATUS_PREFETCH
operator||
name|UDMA_M2S_Q_STATUS_SCHEDULER
operator|)
operator|)
condition|)
break|break;
name|remaining_time
operator|--
expr_stmt|;
name|al_udelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|remaining_time
condition|)
block|{
name|al_err
argument_list|(
literal|"udma [%s %d]: %s timeout waiting for prefetch and "
literal|"scheduler disable\n"
argument_list|,
name|udma_q
operator|->
name|udma
operator|->
name|name
argument_list|,
name|udma_q
operator|->
name|qid
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
comment|/* Wait for the completion queue to reach to the same pointer as the 	 * prefetch stopped at ([TR]DCP == [TR]CRHP) */
name|dcp_reg
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|dcp
expr_stmt|;
name|crhp_reg
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|rings
operator|.
name|crhp
expr_stmt|;
while|while
condition|(
name|remaining_time
condition|)
block|{
name|uint32_t
name|dcp
init|=
name|al_reg_read32
argument_list|(
name|dcp_reg
argument_list|)
decl_stmt|;
name|uint32_t
name|crhp
init|=
name|al_reg_read32
argument_list|(
name|crhp_reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcp
operator|==
name|crhp
condition|)
break|break;
name|remaining_time
operator|--
expr_stmt|;
name|al_udelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|remaining_time
condition|)
block|{
name|al_err
argument_list|(
literal|"udma [%s %d]: %s timeout waiting for dcp==crhp\n"
argument_list|,
name|udma_q
operator|->
name|udma
operator|->
name|name
argument_list|,
name|udma_q
operator|->
name|qid
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
name|ETIMEDOUT
return|;
block|}
comment|/* Assert the queue reset */
if|if
condition|(
name|udma_q
operator|->
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|q_sw_ctrl_reg
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|m2s_q
operator|.
name|q_sw_ctrl
expr_stmt|;
else|else
name|q_sw_ctrl_reg
operator|=
operator|&
name|udma_q
operator|->
name|q_regs
operator|->
name|s2m_q
operator|.
name|q_sw_ctrl
expr_stmt|;
name|al_reg_write32
argument_list|(
name|q_sw_ctrl_reg
argument_list|,
name|UDMA_M2S_Q_SW_CTRL_RST_Q
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * return (by reference) a pointer to a specific queue date structure.  */
end_comment

begin_function
name|int
name|al_udma_q_handle_get
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|,
name|uint32_t
name|qid
parameter_list|,
name|struct
name|al_udma_q
modifier|*
modifier|*
name|q_handle
parameter_list|)
block|{
name|al_assert
argument_list|(
name|udma
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|q_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|qid
operator|>=
name|udma
operator|->
name|num_of_queues
argument_list|)
condition|)
block|{
name|al_err
argument_list|(
literal|"udma [%s]: invalid queue id (%d)\n"
argument_list|,
name|udma
operator|->
name|name
argument_list|,
name|qid
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
operator|*
name|q_handle
operator|=
operator|&
name|udma
operator|->
name|udma_q
index|[
name|qid
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Change the UDMA's state  */
end_comment

begin_function
name|int
name|al_udma_state_set
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|,
name|enum
name|al_udma_state
name|state
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|al_assert
argument_list|(
name|udma
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|udma
operator|->
name|state
condition|)
name|al_dbg
argument_list|(
literal|"udma [%s]: requested state identical to "
literal|"current state (%d)\n"
argument_list|,
name|udma
operator|->
name|name
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"udma [%s]: change state from (%s) to (%s)\n"
argument_list|,
name|udma
operator|->
name|name
argument_list|,
name|al_udma_states_name
index|[
name|udma
operator|->
name|state
index|]
argument_list|,
name|al_udma_states_name
index|[
name|state
index|]
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|UDMA_DISABLE
case|:
name|reg
operator||=
name|UDMA_M2S_CHANGE_STATE_DIS
expr_stmt|;
break|break;
case|case
name|UDMA_NORMAL
case|:
name|reg
operator||=
name|UDMA_M2S_CHANGE_STATE_NORMAL
expr_stmt|;
break|break;
case|case
name|UDMA_ABORT
case|:
name|reg
operator||=
name|UDMA_M2S_CHANGE_STATE_ABORT
expr_stmt|;
break|break;
default|default:
name|al_err
argument_list|(
literal|"udma: invalid state (%d)\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|al_reg_write32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|m2s
operator|.
name|m2s
operator|.
name|change_state
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|al_reg_write32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m
operator|.
name|change_state
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|udma
operator|->
name|state
operator|=
name|state
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * return the current UDMA hardware state  */
end_comment

begin_function
name|enum
name|al_udma_state
name|al_udma_state_get
parameter_list|(
name|struct
name|al_udma
modifier|*
name|udma
parameter_list|)
block|{
name|uint32_t
name|state_reg
decl_stmt|;
name|uint32_t
name|comp_ctrl
decl_stmt|;
name|uint32_t
name|stream_if
decl_stmt|;
name|uint32_t
name|data_rd
decl_stmt|;
name|uint32_t
name|desc_pref
decl_stmt|;
if|if
condition|(
name|udma
operator|->
name|type
operator|==
name|UDMA_TX
condition|)
name|state_reg
operator|=
name|al_reg_read32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|m2s
operator|.
name|m2s
operator|.
name|state
argument_list|)
expr_stmt|;
else|else
name|state_reg
operator|=
name|al_reg_read32
argument_list|(
operator|&
name|udma
operator|->
name|udma_regs
operator|->
name|s2m
operator|.
name|s2m
operator|.
name|state
argument_list|)
expr_stmt|;
name|comp_ctrl
operator|=
name|AL_REG_FIELD_GET
argument_list|(
name|state_reg
argument_list|,
name|UDMA_M2S_STATE_COMP_CTRL_MASK
argument_list|,
name|UDMA_M2S_STATE_COMP_CTRL_SHIFT
argument_list|)
expr_stmt|;
name|stream_if
operator|=
name|AL_REG_FIELD_GET
argument_list|(
name|state_reg
argument_list|,
name|UDMA_M2S_STATE_STREAM_IF_MASK
argument_list|,
name|UDMA_M2S_STATE_STREAM_IF_SHIFT
argument_list|)
expr_stmt|;
name|data_rd
operator|=
name|AL_REG_FIELD_GET
argument_list|(
name|state_reg
argument_list|,
name|UDMA_M2S_STATE_DATA_RD_CTRL_MASK
argument_list|,
name|UDMA_M2S_STATE_DATA_RD_CTRL_SHIFT
argument_list|)
expr_stmt|;
name|desc_pref
operator|=
name|AL_REG_FIELD_GET
argument_list|(
name|state_reg
argument_list|,
name|UDMA_M2S_STATE_DESC_PREF_MASK
argument_list|,
name|UDMA_M2S_STATE_DESC_PREF_SHIFT
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|comp_ctrl
operator|!=
name|UDMA_STATE_RESERVED
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|stream_if
operator|!=
name|UDMA_STATE_RESERVED
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|data_rd
operator|!=
name|UDMA_STATE_RESERVED
argument_list|)
expr_stmt|;
name|al_assert
argument_list|(
name|desc_pref
operator|!=
name|UDMA_STATE_RESERVED
argument_list|)
expr_stmt|;
comment|/* if any of the states is abort then return abort */
if|if
condition|(
operator|(
name|comp_ctrl
operator|==
name|UDMA_STATE_ABORT
operator|)
operator|||
operator|(
name|stream_if
operator|==
name|UDMA_STATE_ABORT
operator|)
operator|||
operator|(
name|data_rd
operator|==
name|UDMA_STATE_ABORT
operator|)
operator|||
operator|(
name|desc_pref
operator|==
name|UDMA_STATE_ABORT
operator|)
condition|)
return|return
name|UDMA_ABORT
return|;
comment|/* if any of the states is normal then return normal */
if|if
condition|(
operator|(
name|comp_ctrl
operator|==
name|UDMA_STATE_NORMAL
operator|)
operator|||
operator|(
name|stream_if
operator|==
name|UDMA_STATE_NORMAL
operator|)
operator|||
operator|(
name|data_rd
operator|==
name|UDMA_STATE_NORMAL
operator|)
operator|||
operator|(
name|desc_pref
operator|==
name|UDMA_STATE_NORMAL
operator|)
condition|)
return|return
name|UDMA_NORMAL
return|;
return|return
name|UDMA_IDLE
return|;
block|}
end_function

begin_comment
comment|/*  * Action handling  */
end_comment

begin_comment
comment|/*  * get next completed packet from completion ring of the queue  */
end_comment

begin_function
name|uint32_t
name|al_udma_cdesc_packet_get
parameter_list|(
name|struct
name|al_udma_q
modifier|*
name|udma_q
parameter_list|,
specifier|volatile
name|union
name|al_udma_cdesc
modifier|*
modifier|*
name|cdesc
parameter_list|)
block|{
name|uint32_t
name|count
decl_stmt|;
specifier|volatile
name|union
name|al_udma_cdesc
modifier|*
name|curr
decl_stmt|;
name|uint32_t
name|comp_flags
decl_stmt|;
comment|/* this function requires the completion ring update */
name|al_assert
argument_list|(
operator|!
operator|(
name|udma_q
operator|->
name|flags
operator|&
name|AL_UDMA_Q_FLAGS_NO_COMP_UPDATE
operator|)
argument_list|)
expr_stmt|;
comment|/* comp_head points to the last comp desc that was processed */
name|curr
operator|=
name|udma_q
operator|->
name|comp_head_ptr
expr_stmt|;
name|comp_flags
operator|=
name|swap32_from_le
argument_list|(
name|curr
operator|->
name|al_desc_comp_tx
operator|.
name|ctrl_meta
argument_list|)
expr_stmt|;
comment|/* check if the completion descriptor is new */
if|if
condition|(
name|unlikely
argument_list|(
name|al_udma_new_cdesc
argument_list|(
name|udma_q
argument_list|,
name|comp_flags
argument_list|)
operator|==
name|AL_FALSE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* if new desc found, increment the current packets descriptors */
name|count
operator|=
name|udma_q
operator|->
name|pkt_crnt_descs
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|cdesc_is_last
argument_list|(
name|comp_flags
argument_list|)
condition|)
block|{
name|curr
operator|=
name|al_cdesc_next_update
argument_list|(
name|udma_q
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|comp_flags
operator|=
name|swap32_from_le
argument_list|(
name|curr
operator|->
name|al_desc_comp_tx
operator|.
name|ctrl_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|al_udma_new_cdesc
argument_list|(
name|udma_q
argument_list|,
name|comp_flags
argument_list|)
operator|==
name|AL_FALSE
argument_list|)
condition|)
block|{
comment|/* the current packet here doesn't have all  */
comment|/* descriptors completed. log the current desc */
comment|/* location and number of completed descriptors so */
comment|/*  far. then return */
name|udma_q
operator|->
name|pkt_crnt_descs
operator|=
name|count
expr_stmt|;
name|udma_q
operator|->
name|comp_head_ptr
operator|=
name|curr
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|++
expr_stmt|;
comment|/* check against max descs per packet. */
name|al_assert
argument_list|(
name|count
operator|<=
name|udma_q
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* return back the first descriptor of the packet */
operator|*
name|cdesc
operator|=
name|al_udma_cdesc_idx_to_ptr
argument_list|(
name|udma_q
argument_list|,
name|udma_q
operator|->
name|next_cdesc_idx
argument_list|)
expr_stmt|;
name|udma_q
operator|->
name|pkt_crnt_descs
operator|=
literal|0
expr_stmt|;
name|udma_q
operator|->
name|comp_head_ptr
operator|=
name|al_cdesc_next_update
argument_list|(
name|udma_q
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|al_dbg
argument_list|(
literal|"udma [%s %d]: packet completed. first desc %p (ixd 0x%x)"
literal|" descs %d\n"
argument_list|,
name|udma_q
operator|->
name|udma
operator|->
name|name
argument_list|,
name|udma_q
operator|->
name|qid
argument_list|,
operator|*
name|cdesc
argument_list|,
name|udma_q
operator|->
name|next_cdesc_idx
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/** @} end of UDMA group */
end_comment

end_unit

