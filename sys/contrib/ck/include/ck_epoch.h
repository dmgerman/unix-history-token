begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CK_EPOCH_H
end_ifndef

begin_define
define|#
directive|define
name|CK_EPOCH_H
end_define

begin_comment
comment|/*  * The implementation here is inspired from the work described in:  *   Fraser, K. 2004. Practical Lock-Freedom. PhD Thesis, University  *   of Cambridge Computing Laboratory.  */
end_comment

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_md.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<ck_stack.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdbool.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CK_EPOCH_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|CK_EPOCH_LENGTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is used for sense detection with-respect to concurrent  * epoch sections.  */
end_comment

begin_define
define|#
directive|define
name|CK_EPOCH_SENSE
value|(2)
end_define

begin_struct_decl
struct_decl|struct
name|ck_epoch_entry
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|ck_epoch_entry
name|ck_epoch_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|ck_epoch_cb_t
parameter_list|(
name|ck_epoch_entry_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * This should be embedded into objects you wish to be the target of  * ck_epoch_cb_t functions (with ck_epoch_call).  */
end_comment

begin_struct
struct|struct
name|ck_epoch_entry
block|{
name|ck_epoch_cb_t
modifier|*
name|function
decl_stmt|;
name|ck_stack_entry_t
name|stack_entry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A section object may be passed to every begin-end pair to allow for  * forward progress guarantees with-in prolonged active sections.  */
end_comment

begin_struct
struct|struct
name|ck_epoch_section
block|{
name|unsigned
name|int
name|bucket
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ck_epoch_section
name|ck_epoch_section_t
typedef|;
end_typedef

begin_comment
comment|/*  * Return pointer to ck_epoch_entry container object.  */
end_comment

begin_define
define|#
directive|define
name|CK_EPOCH_CONTAINER
parameter_list|(
name|T
parameter_list|,
name|M
parameter_list|,
name|N
parameter_list|)
define|\
value|CK_CC_CONTAINER(struct ck_epoch_entry, T, M, N)
end_define

begin_struct
struct|struct
name|ck_epoch_ref
block|{
name|unsigned
name|int
name|epoch
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ck_epoch_record
block|{
name|ck_stack_entry_t
name|record_next
decl_stmt|;
name|struct
name|ck_epoch
modifier|*
name|global
decl_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|unsigned
name|int
name|epoch
decl_stmt|;
name|unsigned
name|int
name|active
decl_stmt|;
struct|struct
block|{
name|struct
name|ck_epoch_ref
name|bucket
index|[
name|CK_EPOCH_SENSE
index|]
decl_stmt|;
block|}
name|local
name|CK_CC_CACHELINE
struct|;
name|unsigned
name|int
name|n_pending
decl_stmt|;
name|unsigned
name|int
name|n_peak
decl_stmt|;
name|unsigned
name|int
name|n_dispatch
decl_stmt|;
name|void
modifier|*
name|ct
decl_stmt|;
name|ck_stack_t
name|pending
index|[
name|CK_EPOCH_LENGTH
index|]
decl_stmt|;
block|}
name|CK_CC_CACHELINE
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ck_epoch_record
name|ck_epoch_record_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ck_epoch
block|{
name|unsigned
name|int
name|epoch
decl_stmt|;
name|unsigned
name|int
name|n_free
decl_stmt|;
name|ck_stack_t
name|records
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ck_epoch
name|ck_epoch_t
typedef|;
end_typedef

begin_comment
comment|/*  * Internal functions.  */
end_comment

begin_function_decl
name|void
name|_ck_epoch_addref
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|,
name|ck_epoch_section_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|_ck_epoch_delref
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|,
name|ck_epoch_section_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|void
modifier|*
name|ck_epoch_record_ct
parameter_list|(
specifier|const
name|ck_epoch_record_t
modifier|*
name|record
parameter_list|)
block|{
return|return
name|ck_pr_load_ptr
argument_list|(
operator|&
name|record
operator|->
name|ct
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Marks the beginning of an epoch-protected section.  */
end_comment

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|void
name|ck_epoch_begin
parameter_list|(
name|ck_epoch_record_t
modifier|*
name|record
parameter_list|,
name|ck_epoch_section_t
modifier|*
name|section
parameter_list|)
block|{
name|struct
name|ck_epoch
modifier|*
name|epoch
init|=
name|record
operator|->
name|global
decl_stmt|;
comment|/* 	 * Only observe new epoch if thread is not recursing into a read 	 * section. 	 */
if|if
condition|(
name|record
operator|->
name|active
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|g_epoch
decl_stmt|;
comment|/* 		 * It is possible for loads to be re-ordered before the store 		 * is committed into the caller's epoch and active fields. 		 * For this reason, store to load serialization is necessary. 		 */
if|#
directive|if
name|defined
argument_list|(
name|CK_MD_TSO
argument_list|)
name|ck_pr_fas_uint
argument_list|(
operator|&
name|record
operator|->
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_load
argument_list|()
expr_stmt|;
else|#
directive|else
name|ck_pr_store_uint
argument_list|(
operator|&
name|record
operator|->
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_memory
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * This load is allowed to be re-ordered prior to setting 		 * active flag due to monotonic nature of the global epoch. 		 * However, stale values lead to measurable performance 		 * degradation in some torture tests so we disallow early load 		 * of global epoch. 		 */
name|g_epoch
operator|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|epoch
operator|->
name|epoch
argument_list|)
expr_stmt|;
name|ck_pr_store_uint
argument_list|(
operator|&
name|record
operator|->
name|epoch
argument_list|,
name|g_epoch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ck_pr_store_uint
argument_list|(
operator|&
name|record
operator|->
name|active
argument_list|,
name|record
operator|->
name|active
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
name|_ck_epoch_addref
argument_list|(
name|record
argument_list|,
name|section
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Marks the end of an epoch-protected section. Returns true if no more  * sections exist for the caller.  */
end_comment

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|bool
name|ck_epoch_end
parameter_list|(
name|ck_epoch_record_t
modifier|*
name|record
parameter_list|,
name|ck_epoch_section_t
modifier|*
name|section
parameter_list|)
block|{
name|ck_pr_fence_release
argument_list|()
expr_stmt|;
name|ck_pr_store_uint
argument_list|(
operator|&
name|record
operator|->
name|active
argument_list|,
name|record
operator|->
name|active
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
return|return
name|_ck_epoch_delref
argument_list|(
name|record
argument_list|,
name|section
argument_list|)
return|;
return|return
name|record
operator|->
name|active
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Defers the execution of the function pointed to by the "cb"  * argument until an epoch counter loop. This allows for a  * non-blocking deferral.  *  * We can get away without a fence here due to the monotonic nature  * of the epoch counter. Worst case, this will result in some delays  * before object destruction.  */
end_comment

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|void
name|ck_epoch_call
parameter_list|(
name|ck_epoch_record_t
modifier|*
name|record
parameter_list|,
name|ck_epoch_entry_t
modifier|*
name|entry
parameter_list|,
name|ck_epoch_cb_t
modifier|*
name|function
parameter_list|)
block|{
name|struct
name|ck_epoch
modifier|*
name|epoch
init|=
name|record
operator|->
name|global
decl_stmt|;
name|unsigned
name|int
name|e
init|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|epoch
operator|->
name|epoch
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
name|e
operator|&
operator|(
name|CK_EPOCH_LENGTH
operator|-
literal|1
operator|)
decl_stmt|;
name|record
operator|->
name|n_pending
operator|++
expr_stmt|;
name|entry
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|ck_stack_push_spnc
argument_list|(
operator|&
name|record
operator|->
name|pending
index|[
name|offset
index|]
argument_list|,
operator|&
name|entry
operator|->
name|stack_entry
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Same as ck_epoch_call, but allows for records to be shared and is reentrant.  */
end_comment

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|void
name|ck_epoch_call_strict
parameter_list|(
name|ck_epoch_record_t
modifier|*
name|record
parameter_list|,
name|ck_epoch_entry_t
modifier|*
name|entry
parameter_list|,
name|ck_epoch_cb_t
modifier|*
name|function
parameter_list|)
block|{
name|struct
name|ck_epoch
modifier|*
name|epoch
init|=
name|record
operator|->
name|global
decl_stmt|;
name|unsigned
name|int
name|e
init|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|epoch
operator|->
name|epoch
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
name|e
operator|&
operator|(
name|CK_EPOCH_LENGTH
operator|-
literal|1
operator|)
decl_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|record
operator|->
name|n_pending
argument_list|)
expr_stmt|;
name|entry
operator|->
name|function
operator|=
name|function
expr_stmt|;
comment|/* Store fence is implied by push operation. */
name|ck_stack_push_upmc
argument_list|(
operator|&
name|record
operator|->
name|pending
index|[
name|offset
index|]
argument_list|,
operator|&
name|entry
operator|->
name|stack_entry
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This callback is used for synchronize_wait to allow for custom blocking  * behavior.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|ck_epoch_wait_cb_t
parameter_list|(
name|ck_epoch_t
modifier|*
parameter_list|,
name|ck_epoch_record_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Return latest epoch value. This operation provides load ordering.  */
end_comment

begin_function
name|CK_CC_FORCE_INLINE
specifier|static
name|unsigned
name|int
name|ck_epoch_value
parameter_list|(
specifier|const
name|ck_epoch_t
modifier|*
name|ep
parameter_list|)
block|{
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
return|return
name|ck_pr_load_uint
argument_list|(
operator|&
name|ep
operator|->
name|epoch
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|void
name|ck_epoch_init
parameter_list|(
name|ck_epoch_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Attempts to recycle an unused epoch record. If one is successfully  * allocated, the record context pointer is also updated.  */
end_comment

begin_function_decl
name|ck_epoch_record_t
modifier|*
name|ck_epoch_recycle
parameter_list|(
name|ck_epoch_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Registers an epoch record. An optional context pointer may be passed that  * is retrievable with ck_epoch_record_ct.  */
end_comment

begin_function_decl
name|void
name|ck_epoch_register
parameter_list|(
name|ck_epoch_t
modifier|*
parameter_list|,
name|ck_epoch_record_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Marks a record as available for re-use by a subsequent recycle operation.  * Note that the record cannot be physically destroyed.  */
end_comment

begin_function_decl
name|void
name|ck_epoch_unregister
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|ck_epoch_poll
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_epoch_synchronize
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_epoch_synchronize_wait
parameter_list|(
name|ck_epoch_t
modifier|*
parameter_list|,
name|ck_epoch_wait_cb_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_epoch_barrier
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_epoch_barrier_wait
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|,
name|ck_epoch_wait_cb_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Reclaim entries associated with a record. This is safe to call only on  * the caller's record or records that are using call_strict.  */
end_comment

begin_function_decl
name|void
name|ck_epoch_reclaim
parameter_list|(
name|ck_epoch_record_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_EPOCH_H */
end_comment

end_unit

