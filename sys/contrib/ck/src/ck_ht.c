begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2012-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|CK_HT_IM
end_define

begin_include
include|#
directive|include
file|<ck_ht.h>
end_include

begin_comment
comment|/*  * This implementation borrows several techniques from Josh Dybnis's  * nbds library which can be found at http://code.google.com/p/nbds  *  * This release currently only includes support for 64-bit platforms.  * We can address 32-bit platforms in a future release.  */
end_comment

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_md.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdint.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdbool.h>
end_include

begin_include
include|#
directive|include
file|<ck_string.h>
end_include

begin_include
include|#
directive|include
file|"ck_ht_hash.h"
end_include

begin_include
include|#
directive|include
file|"ck_internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CK_HT_BUCKET_LENGTH
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CK_HT_PP
end_ifdef

begin_define
define|#
directive|define
name|CK_HT_BUCKET_SHIFT
value|2ULL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CK_HT_BUCKET_SHIFT
value|1ULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CK_HT_BUCKET_LENGTH
value|(1U<< CK_HT_BUCKET_SHIFT)
end_define

begin_define
define|#
directive|define
name|CK_HT_BUCKET_MASK
value|(CK_HT_BUCKET_LENGTH - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CK_HT_PROBE_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|CK_HT_PROBE_DEFAULT
value|64ULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CK_F_PR_LOAD_8
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_8
argument_list|)
end_if

begin_define
define|#
directive|define
name|CK_HT_WORD
value|uint8_t
end_define

begin_define
define|#
directive|define
name|CK_HT_WORD_MAX
value|UINT8_MAX
end_define

begin_define
define|#
directive|define
name|CK_HT_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_8(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HT_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_8(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_16
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_16
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_HT_WORD
value|uint16_t
end_define

begin_define
define|#
directive|define
name|CK_HT_WORD_MAX
value|UINT16_MAX
end_define

begin_define
define|#
directive|define
name|CK_HT_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_16(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HT_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_16(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_32
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_32
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_HT_WORD
value|uint32_t
end_define

begin_define
define|#
directive|define
name|CK_HT_WORD_MAX
value|UINT32_MAX
end_define

begin_define
define|#
directive|define
name|CK_HT_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_32(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HT_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_32(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"ck_ht is not supported on your platform."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ck_ht_map
block|{
name|unsigned
name|int
name|mode
decl_stmt|;
name|CK_HT_TYPE
name|deletions
decl_stmt|;
name|CK_HT_TYPE
name|probe_maximum
decl_stmt|;
name|CK_HT_TYPE
name|probe_length
decl_stmt|;
name|CK_HT_TYPE
name|probe_limit
decl_stmt|;
name|CK_HT_TYPE
name|size
decl_stmt|;
name|CK_HT_TYPE
name|n_entries
decl_stmt|;
name|CK_HT_TYPE
name|mask
decl_stmt|;
name|CK_HT_TYPE
name|capacity
decl_stmt|;
name|CK_HT_TYPE
name|step
decl_stmt|;
name|CK_HT_WORD
modifier|*
name|probe_bound
decl_stmt|;
name|struct
name|ck_ht_entry
modifier|*
name|entries
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|ck_ht_stat
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|struct
name|ck_ht_stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
init|=
name|table
operator|->
name|map
decl_stmt|;
name|st
operator|->
name|n_entries
operator|=
name|map
operator|->
name|n_entries
expr_stmt|;
name|st
operator|->
name|probe_maximum
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_ht_hash
parameter_list|(
name|struct
name|ck_ht_hash
modifier|*
name|h
parameter_list|,
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|uint16_t
name|key_length
parameter_list|)
block|{
name|table
operator|->
name|h
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|,
name|table
operator|->
name|seed
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_ht_hash_direct
parameter_list|(
name|struct
name|ck_ht_hash
modifier|*
name|h
parameter_list|,
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|uintptr_t
name|key
parameter_list|)
block|{
name|ck_ht_hash
argument_list|(
name|h
argument_list|,
name|table
argument_list|,
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_ht_hash_wrapper
parameter_list|(
name|struct
name|ck_ht_hash
modifier|*
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|length
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
name|h
operator|->
name|value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|MurmurHash64A
argument_list|(
name|key
argument_list|,
name|length
argument_list|,
name|seed
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ck_ht_map
modifier|*
name|ck_ht_map_create
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|CK_HT_TYPE
name|entries
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|;
name|CK_HT_TYPE
name|size
decl_stmt|;
name|uintptr_t
name|prefix
decl_stmt|;
name|uint32_t
name|n_entries
decl_stmt|;
name|n_entries
operator|=
name|ck_internal_power_2
argument_list|(
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_entries
operator|<
name|CK_HT_BUCKET_LENGTH
condition|)
name|n_entries
operator|=
name|CK_HT_BUCKET_LENGTH
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ck_ht_map
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ck_ht_entry
argument_list|)
operator|*
name|n_entries
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_WORKLOAD_DELETE
condition|)
block|{
name|prefix
operator|=
sizeof|sizeof
argument_list|(
name|CK_HT_WORD
argument_list|)
operator|*
name|n_entries
expr_stmt|;
name|size
operator|+=
name|prefix
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
name|map
operator|=
name|table
operator|->
name|m
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|map
operator|->
name|mode
operator|=
name|table
operator|->
name|mode
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|map
operator|->
name|probe_limit
operator|=
name|ck_internal_max_64
argument_list|(
name|n_entries
operator|>>
operator|(
name|CK_HT_BUCKET_SHIFT
operator|+
literal|2
operator|)
argument_list|,
name|CK_HT_PROBE_DEFAULT
argument_list|)
expr_stmt|;
name|map
operator|->
name|deletions
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|probe_maximum
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|capacity
operator|=
name|n_entries
expr_stmt|;
name|map
operator|->
name|step
operator|=
name|ck_internal_bsf_64
argument_list|(
name|map
operator|->
name|capacity
argument_list|)
expr_stmt|;
name|map
operator|->
name|mask
operator|=
name|map
operator|->
name|capacity
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|n_entries
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|entries
operator|=
operator|(
expr|struct
name|ck_ht_entry
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|map
index|[
literal|1
index|]
operator|+
name|prefix
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_WORKLOAD_DELETE
condition|)
block|{
name|map
operator|->
name|probe_bound
operator|=
operator|(
name|CK_HT_WORD
operator|*
operator|)
operator|&
name|map
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|probe_bound
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|->
name|probe_bound
operator|=
name|NULL
expr_stmt|;
block|}
name|memset
argument_list|(
name|map
operator|->
name|entries
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ck_ht_entry
argument_list|)
operator|*
name|n_entries
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ck_ht_map_bound_set
parameter_list|(
name|struct
name|ck_ht_map
modifier|*
name|m
parameter_list|,
name|struct
name|ck_ht_hash
name|h
parameter_list|,
name|CK_HT_TYPE
name|n_probes
parameter_list|)
block|{
name|CK_HT_TYPE
name|offset
init|=
name|h
operator|.
name|value
operator|&
name|m
operator|->
name|mask
decl_stmt|;
if|if
condition|(
name|n_probes
operator|>
name|m
operator|->
name|probe_maximum
condition|)
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|probe_bound
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
operator|<
name|n_probes
condition|)
block|{
if|if
condition|(
name|n_probes
operator|>=
name|CK_HT_WORD_MAX
condition|)
name|n_probes
operator|=
name|CK_HT_WORD_MAX
expr_stmt|;
name|CK_HT_STORE
argument_list|(
operator|&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|CK_HT_TYPE
name|ck_ht_map_bound_get
parameter_list|(
name|struct
name|ck_ht_map
modifier|*
name|m
parameter_list|,
name|struct
name|ck_ht_hash
name|h
parameter_list|)
block|{
name|CK_HT_TYPE
name|offset
init|=
name|h
operator|.
name|value
operator|&
name|m
operator|->
name|mask
decl_stmt|;
name|CK_HT_TYPE
name|r
init|=
name|CK_HT_WORD_MAX
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|CK_HT_LOAD
argument_list|(
operator|&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|CK_HT_WORD_MAX
condition|)
name|r
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_ht_map_destroy
parameter_list|(
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|struct
name|ck_ht_map
modifier|*
name|map
parameter_list|,
name|bool
name|defer
parameter_list|)
block|{
name|m
operator|->
name|free
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|defer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|ck_ht_map_probe_next
parameter_list|(
name|struct
name|ck_ht_map
modifier|*
name|map
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|size_t
name|probes
parameter_list|)
block|{
name|ck_ht_hash_t
name|r
decl_stmt|;
name|size_t
name|stride
decl_stmt|;
name|unsigned
name|long
name|level
init|=
operator|(
name|unsigned
name|long
operator|)
name|probes
operator|>>
name|CK_HT_BUCKET_SHIFT
decl_stmt|;
name|r
operator|.
name|value
operator|=
operator|(
name|h
operator|.
name|value
operator|>>
name|map
operator|->
name|step
operator|)
operator|>>
name|level
expr_stmt|;
name|stride
operator|=
operator|(
name|r
operator|.
name|value
operator|&
operator|~
name|CK_HT_BUCKET_MASK
operator|)
operator|<<
literal|1
operator||
operator|(
name|r
operator|.
name|value
operator|&
name|CK_HT_BUCKET_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|offset
operator|+
name|level
operator|+
operator|(
name|stride
operator||
name|CK_HT_BUCKET_LENGTH
operator|)
operator|)
operator|&
name|map
operator|->
name|mask
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_init
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|ck_ht_hash_cb_t
modifier|*
name|h
parameter_list|,
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|CK_HT_TYPE
name|entries
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|malloc
operator|==
name|NULL
operator|||
name|m
operator|->
name|free
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|table
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|table
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|table
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|table
operator|->
name|h
operator|=
name|ck_ht_hash_wrapper
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|h
operator|=
name|h
expr_stmt|;
block|}
name|table
operator|->
name|map
operator|=
name|ck_ht_map_create
argument_list|(
name|table
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
name|table
operator|->
name|map
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ck_ht_entry
modifier|*
name|ck_ht_map_probe_wr
parameter_list|(
name|struct
name|ck_ht_map
modifier|*
name|map
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|snapshot
parameter_list|,
name|ck_ht_entry_t
modifier|*
modifier|*
name|available
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|uint16_t
name|key_length
parameter_list|,
name|CK_HT_TYPE
modifier|*
name|probe_limit
parameter_list|,
name|CK_HT_TYPE
modifier|*
name|probe_wr
parameter_list|)
block|{
name|struct
name|ck_ht_entry
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|cursor
decl_stmt|;
name|struct
name|ck_ht_entry
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|CK_HT_TYPE
name|probes
init|=
literal|0
decl_stmt|;
name|CK_HT_TYPE
name|limit
decl_stmt|;
if|if
condition|(
name|probe_limit
operator|==
name|NULL
condition|)
block|{
name|limit
operator|=
name|ck_ht_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|limit
operator|=
name|CK_HT_TYPE_MAX
expr_stmt|;
block|}
name|offset
operator|=
name|h
operator|.
name|value
operator|&
name|map
operator|->
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|probe_limit
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Probe on a complete cache line first. Scan forward and wrap around to 		 * the beginning of the cache line. Only when the complete cache line has 		 * been scanned do we move on to the next row. 		 */
name|bucket
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|map
operator|->
name|entries
operator|+
name|offset
argument_list|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CK_HT_BUCKET_LENGTH
condition|;
name|j
operator|++
control|)
block|{
name|uint16_t
name|k
decl_stmt|;
if|if
condition|(
name|probes
operator|++
operator|>
name|limit
condition|)
break|break;
name|cursor
operator|=
name|bucket
operator|+
operator|(
operator|(
name|j
operator|+
name|offset
operator|)
operator|&
operator|(
name|CK_HT_BUCKET_LENGTH
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* 			 * It is probably worth it to encapsulate probe state 			 * in order to prevent a complete reprobe sequence in 			 * the case of intermittent writers. 			 */
if|if
condition|(
name|cursor
operator|->
name|key
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
block|{
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|first
operator|=
name|cursor
expr_stmt|;
operator|*
name|probe_wr
operator|=
name|probes
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cursor
operator|->
name|key
operator|==
name|CK_HT_KEY_EMPTY
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|cursor
operator|->
name|key
operator|==
operator|(
name|uintptr_t
operator|)
name|key
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|map
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|void
modifier|*
name|pointer
decl_stmt|;
comment|/* 				 * Check memoized portion of hash value before 				 * expensive full-length comparison. 				 */
name|k
operator|=
name|ck_ht_entry_key_length
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|key_length
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CK_HT_PP
if|if
condition|(
operator|(
name|cursor
operator|->
name|value
operator|>>
name|CK_MD_VMA_BITS
operator|)
operator|!=
operator|(
operator|(
name|h
operator|.
name|value
operator|>>
literal|32
operator|)
operator|&
name|CK_HT_KEY_MASK
operator|)
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
name|cursor
operator|->
name|hash
operator|!=
name|h
operator|.
name|value
condition|)
continue|continue;
endif|#
directive|endif
name|pointer
operator|=
name|ck_ht_entry_key
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pointer
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|leave
goto|;
block|}
block|}
name|offset
operator|=
name|ck_ht_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|=
name|NULL
expr_stmt|;
name|leave
label|:
if|if
condition|(
name|probe_limit
operator|!=
name|NULL
condition|)
block|{
operator|*
name|probe_limit
operator|=
name|probes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
operator|*
name|probe_wr
operator|=
name|probes
expr_stmt|;
block|}
operator|*
name|available
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|cursor
operator|!=
name|NULL
condition|)
block|{
operator|*
name|snapshot
operator|=
operator|*
name|cursor
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_gc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|ht
parameter_list|,
name|unsigned
name|long
name|cycles
parameter_list|,
name|unsigned
name|long
name|seed
parameter_list|)
block|{
name|CK_HT_WORD
modifier|*
name|bounds
init|=
name|NULL
decl_stmt|;
name|struct
name|ck_ht_map
modifier|*
name|map
init|=
name|ht
operator|->
name|map
decl_stmt|;
name|CK_HT_TYPE
name|maximum
decl_stmt|,
name|i
decl_stmt|;
name|CK_HT_TYPE
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|n_entries
operator|==
literal|0
condition|)
block|{
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|probe_maximum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|map
operator|->
name|probe_bound
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CK_HT_WORD
argument_list|)
operator|*
name|map
operator|->
name|capacity
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|cycles
operator|==
literal|0
condition|)
block|{
name|maximum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|CK_HT_WORD
argument_list|)
operator|*
name|map
operator|->
name|capacity
expr_stmt|;
name|bounds
operator|=
name|ht
operator|->
name|m
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bounds
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|bounds
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|maximum
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ck_ht_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|priority
decl_stmt|,
name|snapshot
decl_stmt|;
name|struct
name|ck_ht_hash
name|h
decl_stmt|;
name|CK_HT_TYPE
name|probes_wr
decl_stmt|;
name|CK_HT_TYPE
name|offset
decl_stmt|;
name|entry
operator|=
operator|&
name|map
operator|->
name|entries
index|[
operator|(
name|i
operator|+
name|seed
operator|)
operator|&
name|map
operator|->
name|mask
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|key
operator|==
name|CK_HT_KEY_EMPTY
operator|||
name|entry
operator|->
name|key
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ht
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
ifndef|#
directive|ifndef
name|CK_HT_PP
name|h
operator|.
name|value
operator|=
name|entry
operator|->
name|hash
expr_stmt|;
else|#
directive|else
name|ht
operator|->
name|h
argument_list|(
operator|&
name|h
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ht
operator|->
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|CK_HT_PP
name|h
operator|.
name|value
operator|=
name|entry
operator|->
name|hash
expr_stmt|;
else|#
directive|else
name|ht
operator|->
name|h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|,
name|ht
operator|->
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|h
operator|.
name|value
operator|&
name|map
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|priority
operator|!=
name|NULL
condition|)
block|{
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CK_HT_PP
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|priority
operator|->
name|key_length
argument_list|,
name|entry
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|priority
operator|->
name|hash
argument_list|,
name|entry
operator|->
name|hash
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|priority
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|priority
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|entry
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|CK_HT_KEY_TOMBSTONE
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cycles
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|probes_wr
operator|>
name|maximum
condition|)
name|maximum
operator|=
name|probes_wr
expr_stmt|;
if|if
condition|(
name|probes_wr
operator|>=
name|CK_HT_WORD_MAX
condition|)
name|probes_wr
operator|=
name|CK_HT_WORD_MAX
expr_stmt|;
if|if
condition|(
name|bounds
operator|!=
name|NULL
operator|&&
name|probes_wr
operator|>
name|bounds
index|[
name|offset
index|]
condition|)
name|bounds
index|[
name|offset
index|]
operator|=
name|probes_wr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|cycles
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|maximum
operator|!=
name|map
operator|->
name|probe_maximum
condition|)
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|probe_maximum
argument_list|,
name|maximum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bounds
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
name|CK_HT_STORE
argument_list|(
operator|&
name|map
operator|->
name|probe_bound
index|[
name|i
index|]
argument_list|,
name|bounds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ht
operator|->
name|m
operator|->
name|free
argument_list|(
name|bounds
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ck_ht_entry
modifier|*
name|ck_ht_map_probe_rd
parameter_list|(
name|struct
name|ck_ht_map
modifier|*
name|map
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|snapshot
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|uint16_t
name|key_length
parameter_list|)
block|{
name|struct
name|ck_ht_entry
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|cursor
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|CK_HT_TYPE
name|probes
init|=
literal|0
decl_stmt|;
name|CK_HT_TYPE
name|probe_maximum
decl_stmt|;
ifndef|#
directive|ifndef
name|CK_HT_PP
name|CK_HT_TYPE
name|d
init|=
literal|0
decl_stmt|;
name|CK_HT_TYPE
name|d_prime
init|=
literal|0
decl_stmt|;
name|retry
label|:
endif|#
directive|endif
name|probe_maximum
operator|=
name|ck_ht_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|offset
operator|=
name|h
operator|.
name|value
operator|&
name|map
operator|->
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|probe_limit
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Probe on a complete cache line first. Scan forward and wrap around to 		 * the beginning of the cache line. Only when the complete cache line has 		 * been scanned do we move on to the next row. 		 */
name|bucket
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|map
operator|->
name|entries
operator|+
name|offset
argument_list|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CK_HT_BUCKET_LENGTH
condition|;
name|j
operator|++
control|)
block|{
name|uint16_t
name|k
decl_stmt|;
if|if
condition|(
name|probes
operator|++
operator|>
name|probe_maximum
condition|)
return|return
name|NULL
return|;
name|cursor
operator|=
name|bucket
operator|+
operator|(
operator|(
name|j
operator|+
name|offset
operator|)
operator|&
operator|(
name|CK_HT_BUCKET_LENGTH
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CK_HT_PP
name|snapshot
operator|->
name|key
operator|=
operator|(
name|uintptr_t
operator|)
name|ck_pr_load_ptr
argument_list|(
operator|&
name|cursor
operator|->
name|key
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|snapshot
operator|->
name|value
operator|=
operator|(
name|uintptr_t
operator|)
name|ck_pr_load_ptr
argument_list|(
operator|&
name|cursor
operator|->
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|)
expr_stmt|;
name|snapshot
operator|->
name|key
operator|=
operator|(
name|uintptr_t
operator|)
name|ck_pr_load_ptr
argument_list|(
operator|&
name|cursor
operator|->
name|key
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|snapshot
operator|->
name|key_length
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|cursor
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|snapshot
operator|->
name|hash
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|cursor
operator|->
name|hash
argument_list|)
expr_stmt|;
name|snapshot
operator|->
name|value
operator|=
operator|(
name|uintptr_t
operator|)
name|ck_pr_load_ptr
argument_list|(
operator|&
name|cursor
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * It is probably worth it to encapsulate probe state 			 * in order to prevent a complete reprobe sequence in 			 * the case of intermittent writers. 			 */
if|if
condition|(
name|snapshot
operator|->
name|key
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
continue|continue;
if|if
condition|(
name|snapshot
operator|->
name|key
operator|==
name|CK_HT_KEY_EMPTY
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|snapshot
operator|->
name|key
operator|==
operator|(
name|uintptr_t
operator|)
name|key
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|map
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|void
modifier|*
name|pointer
decl_stmt|;
comment|/* 				 * Check memoized portion of hash value before 				 * expensive full-length comparison. 				 */
name|k
operator|=
name|ck_ht_entry_key_length
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|key_length
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CK_HT_PP
if|if
condition|(
operator|(
name|snapshot
operator|->
name|value
operator|>>
name|CK_MD_VMA_BITS
operator|)
operator|!=
operator|(
operator|(
name|h
operator|.
name|value
operator|>>
literal|32
operator|)
operator|&
name|CK_HT_KEY_MASK
operator|)
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
name|snapshot
operator|->
name|hash
operator|!=
name|h
operator|.
name|value
condition|)
continue|continue;
name|d_prime
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|)
expr_stmt|;
comment|/* 				 * It is possible that the slot was 				 * replaced, initiate a re-probe. 				 */
if|if
condition|(
name|d
operator|!=
name|d_prime
condition|)
goto|goto
name|retry
goto|;
endif|#
directive|endif
name|pointer
operator|=
name|ck_ht_entry_key
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|pointer
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|leave
goto|;
block|}
block|}
name|offset
operator|=
name|ck_ht_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
name|leave
label|:
return|return
name|cursor
return|;
block|}
end_function

begin_function
name|CK_HT_TYPE
name|ck_ht_count
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
init|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|table
operator|->
name|map
argument_list|)
decl_stmt|;
return|return
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|map
operator|->
name|n_entries
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_next
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|struct
name|ck_ht_iterator
modifier|*
name|i
parameter_list|,
name|struct
name|ck_ht_entry
modifier|*
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
init|=
name|table
operator|->
name|map
decl_stmt|;
name|uintptr_t
name|key
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|offset
operator|>=
name|map
operator|->
name|capacity
condition|)
return|return
name|false
return|;
do|do
block|{
name|key
operator|=
name|map
operator|->
name|entries
index|[
name|i
operator|->
name|offset
index|]
operator|.
name|key
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|CK_HT_KEY_EMPTY
operator|&&
name|key
operator|!=
name|CK_HT_KEY_TOMBSTONE
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|i
operator|->
name|offset
operator|<
name|map
operator|->
name|capacity
condition|)
do|;
if|if
condition|(
name|i
operator|->
name|offset
operator|>=
name|map
operator|->
name|capacity
condition|)
return|return
name|false
return|;
operator|*
name|entry
operator|=
name|map
operator|->
name|entries
operator|+
name|i
operator|->
name|offset
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_reset_size_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|CK_HT_TYPE
name|size
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|update
decl_stmt|;
name|map
operator|=
name|table
operator|->
name|map
expr_stmt|;
name|update
operator|=
name|ck_ht_map_create
argument_list|(
name|table
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|table
operator|->
name|map
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|ck_ht_map_destroy
argument_list|(
name|table
operator|->
name|m
argument_list|,
name|map
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_reset_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
init|=
name|table
operator|->
name|map
decl_stmt|;
return|return
name|ck_ht_reset_size_spmc
argument_list|(
name|table
argument_list|,
name|map
operator|->
name|capacity
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_grow_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|CK_HT_TYPE
name|capacity
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|update
decl_stmt|;
name|struct
name|ck_ht_entry
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|struct
name|ck_ht_hash
name|h
decl_stmt|;
name|size_t
name|k
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|offset
decl_stmt|;
name|CK_HT_TYPE
name|probes
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|table
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|capacity
operator|>=
name|capacity
condition|)
return|return
name|false
return|;
name|update
operator|=
name|ck_ht_map_create
argument_list|(
name|table
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|map
operator|->
name|capacity
condition|;
name|k
operator|++
control|)
block|{
name|previous
operator|=
operator|&
name|map
operator|->
name|entries
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|previous
operator|->
name|key
operator|==
name|CK_HT_KEY_EMPTY
operator|||
name|previous
operator|->
name|key
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
continue|continue;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
ifdef|#
directive|ifdef
name|CK_HT_PP
name|void
modifier|*
name|key
decl_stmt|;
name|uint16_t
name|key_length
decl_stmt|;
name|key
operator|=
name|ck_ht_entry_key
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|key_length
operator|=
name|ck_ht_entry_key_length
argument_list|(
name|previous
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CK_HT_PP
name|h
operator|.
name|value
operator|=
name|previous
operator|->
name|hash
expr_stmt|;
else|#
directive|else
name|table
operator|->
name|h
argument_list|(
operator|&
name|h
argument_list|,
name|key
argument_list|,
name|key_length
argument_list|,
name|table
operator|->
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|CK_HT_PP
name|h
operator|.
name|value
operator|=
name|previous
operator|->
name|hash
expr_stmt|;
else|#
directive|else
name|table
operator|->
name|h
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|previous
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|previous
operator|->
name|key
argument_list|)
argument_list|,
name|table
operator|->
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|offset
operator|=
name|h
operator|.
name|value
operator|&
name|update
operator|->
name|mask
expr_stmt|;
name|probes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|update
operator|->
name|probe_limit
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
name|update
operator|->
name|entries
operator|+
name|offset
argument_list|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CK_HT_BUCKET_LENGTH
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|ck_ht_entry
modifier|*
name|cursor
init|=
name|bucket
operator|+
operator|(
operator|(
name|j
operator|+
name|offset
operator|)
operator|&
operator|(
name|CK_HT_BUCKET_LENGTH
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|probes
operator|++
expr_stmt|;
if|if
condition|(
name|CK_CC_LIKELY
argument_list|(
name|cursor
operator|->
name|key
operator|==
name|CK_HT_KEY_EMPTY
argument_list|)
condition|)
block|{
operator|*
name|cursor
operator|=
operator|*
name|previous
expr_stmt|;
name|update
operator|->
name|n_entries
operator|++
expr_stmt|;
name|ck_ht_map_bound_set
argument_list|(
name|update
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|CK_HT_BUCKET_LENGTH
condition|)
break|break;
name|offset
operator|=
name|ck_ht_map_probe_next
argument_list|(
name|update
argument_list|,
name|offset
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|update
operator|->
name|probe_limit
condition|)
block|{
comment|/* 			 * We have hit the probe limit, the map needs to be even 			 * larger. 			 */
name|ck_ht_map_destroy
argument_list|(
name|table
operator|->
name|m
argument_list|,
name|update
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|capacity
operator|<<=
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|table
operator|->
name|map
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|ck_ht_map_destroy
argument_list|(
name|table
operator|->
name|m
argument_list|,
name|map
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_remove_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|;
name|struct
name|ck_ht_entry
modifier|*
name|candidate
decl_stmt|,
name|snapshot
decl_stmt|;
name|map
operator|=
name|table
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|candidate
operator|=
name|ck_ht_map_probe_rd
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|candidate
operator|=
name|ck_ht_map_probe_rd
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* No matching entry was found. */
if|if
condition|(
name|candidate
operator|==
name|NULL
operator|||
name|snapshot
operator|.
name|key
operator|==
name|CK_HT_KEY_EMPTY
condition|)
return|return
name|false
return|;
operator|*
name|entry
operator|=
name|snapshot
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|CK_HT_KEY_TOMBSTONE
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|n_entries
argument_list|,
name|map
operator|->
name|n_entries
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_get_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ck_ht_entry
modifier|*
name|candidate
decl_stmt|,
name|snapshot
decl_stmt|;
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|;
name|CK_HT_TYPE
name|d
decl_stmt|,
name|d_prime
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|table
operator|->
name|map
argument_list|)
expr_stmt|;
comment|/* 	 * Platforms that cannot read key and key_length atomically must reprobe 	 * on the scan of any single entry. 	 */
name|d
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|candidate
operator|=
name|ck_ht_map_probe_rd
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|candidate
operator|=
name|ck_ht_map_probe_rd
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d_prime
operator|=
name|CK_HT_TYPE_LOAD
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|d_prime
condition|)
block|{
comment|/* 		 * It is possible we have read (K, V'). Only valid states are 		 * (K, V), (K', V') and (T, V). Restart load operation in face 		 * of concurrent deletions or replacements. 		 */
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|candidate
operator|==
name|NULL
operator|||
name|snapshot
operator|.
name|key
operator|==
name|CK_HT_KEY_EMPTY
condition|)
return|return
name|false
return|;
operator|*
name|entry
operator|=
name|snapshot
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_set_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ck_ht_entry
name|snapshot
decl_stmt|,
modifier|*
name|candidate
decl_stmt|,
modifier|*
name|priority
decl_stmt|;
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|;
name|CK_HT_TYPE
name|probes
decl_stmt|,
name|probes_wr
decl_stmt|;
name|bool
name|empty
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|map
operator|=
name|table
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|candidate
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|&
name|probes
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|candidate
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|,
operator|&
name|probes
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|priority
operator|!=
name|NULL
condition|)
block|{
name|probes
operator|=
name|probes_wr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|candidate
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|ck_ht_grow_spmc
argument_list|(
name|table
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|candidate
operator|==
name|NULL
condition|)
block|{
name|candidate
operator|=
name|priority
expr_stmt|;
name|empty
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|candidate
operator|->
name|key
operator|!=
name|CK_HT_KEY_EMPTY
operator|&&
name|priority
operator|!=
name|NULL
operator|&&
name|candidate
operator|!=
name|priority
condition|)
block|{
comment|/* 		 * Entry is moved into another position in probe sequence. 		 * We avoid a state of (K, B) (where [K, B] -> [K', B]) by 		 * guaranteeing a forced reprobe before transitioning from K to 		 * T. (K, B) implies (K, B, D') so we will reprobe successfully 		 * from this transient state. 		 */
name|probes
operator|=
name|probes_wr
expr_stmt|;
ifndef|#
directive|ifndef
name|CK_HT_PP
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|priority
operator|->
name|key_length
argument_list|,
name|entry
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|priority
operator|->
name|hash
argument_list|,
name|entry
operator|->
name|hash
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Readers must observe version counter change before they 		 * observe re-use. If they observe re-use, it is at most 		 * a tombstone. 		 */
if|if
condition|(
name|priority
operator|->
name|value
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
block|{
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|priority
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|priority
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
comment|/* 		 * Make sure that readers who observe the tombstone would 		 * also observe counter change. 		 */
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|CK_HT_KEY_TOMBSTONE
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * In this case we are inserting a new entry or replacing 		 * an existing entry. Yes, this can be combined into above branch, 		 * but isn't because you are actually looking at dying code 		 * (ck_ht is effectively deprecated and is being replaced soon). 		 */
name|bool
name|replace
init|=
name|candidate
operator|->
name|key
operator|!=
name|CK_HT_KEY_EMPTY
operator|&&
name|candidate
operator|->
name|key
operator|!=
name|CK_HT_KEY_TOMBSTONE
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|priority
operator|->
name|key
operator|==
name|CK_HT_KEY_TOMBSTONE
condition|)
block|{
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
name|candidate
operator|=
name|priority
expr_stmt|;
name|probes
operator|=
name|probes_wr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CK_HT_PP
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
else|#
directive|else
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|candidate
operator|->
name|key_length
argument_list|,
name|entry
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|candidate
operator|->
name|hash
argument_list|,
name|entry
operator|->
name|hash
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we are insert a new entry then increment number 		 * of entries associated with map. 		 */
if|if
condition|(
name|replace
operator|==
name|false
condition|)
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|n_entries
argument_list|,
name|map
operator|->
name|n_entries
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ck_ht_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
comment|/* Enforce a load factor of 0.5. */
if|if
condition|(
name|map
operator|->
name|n_entries
operator|*
literal|2
operator|>
name|map
operator|->
name|capacity
condition|)
name|ck_ht_grow_spmc
argument_list|(
name|table
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
operator|==
name|true
condition|)
block|{
name|entry
operator|->
name|key
operator|=
name|CK_HT_KEY_EMPTY
expr_stmt|;
block|}
else|else
block|{
operator|*
name|entry
operator|=
name|snapshot
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_ht_put_spmc
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|,
name|ck_ht_hash_t
name|h
parameter_list|,
name|ck_ht_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ck_ht_entry
name|snapshot
decl_stmt|,
modifier|*
name|candidate
decl_stmt|,
modifier|*
name|priority
decl_stmt|;
name|struct
name|ck_ht_map
modifier|*
name|map
decl_stmt|;
name|CK_HT_TYPE
name|probes
decl_stmt|,
name|probes_wr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|map
operator|=
name|table
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|mode
operator|&
name|CK_HT_MODE_BYTESTRING
condition|)
block|{
name|candidate
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
name|ck_ht_entry_key
argument_list|(
name|entry
argument_list|)
argument_list|,
name|ck_ht_entry_key_length
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|&
name|probes
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|candidate
operator|=
name|ck_ht_map_probe_wr
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
operator|&
name|snapshot
argument_list|,
operator|&
name|priority
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|key
argument_list|)
argument_list|,
operator|&
name|probes
argument_list|,
operator|&
name|probes_wr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|candidate
operator|!=
name|NULL
operator|||
name|priority
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|ck_ht_grow_spmc
argument_list|(
name|table
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|priority
operator|!=
name|NULL
condition|)
block|{
comment|/* Version counter is updated before re-use. */
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|deletions
argument_list|,
name|map
operator|->
name|deletions
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
comment|/* Re-use tombstone if one was found. */
name|candidate
operator|=
name|priority
expr_stmt|;
name|probes
operator|=
name|probes_wr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|candidate
operator|->
name|key
operator|!=
name|CK_HT_KEY_EMPTY
operator|&&
name|candidate
operator|->
name|key
operator|!=
name|CK_HT_KEY_TOMBSTONE
condition|)
block|{
comment|/* 		 * If the snapshot key is non-empty and the value field is not 		 * a tombstone then an identical key was found. As store does 		 * not implement replacement, we will fail. 		 */
return|return
name|false
return|;
block|}
name|ck_ht_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CK_HT_PP
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
else|#
directive|else
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|candidate
operator|->
name|key_length
argument_list|,
name|entry
operator|->
name|key_length
argument_list|)
expr_stmt|;
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|candidate
operator|->
name|hash
argument_list|,
name|entry
operator|->
name|hash
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr_unsafe
argument_list|(
operator|&
name|candidate
operator|->
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CK_HT_TYPE_STORE
argument_list|(
operator|&
name|map
operator|->
name|n_entries
argument_list|,
name|map
operator|->
name|n_entries
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Enforce a load factor of 0.5. */
if|if
condition|(
name|map
operator|->
name|n_entries
operator|*
literal|2
operator|>
name|map
operator|->
name|capacity
condition|)
name|ck_ht_grow_spmc
argument_list|(
name|table
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ck_ht_destroy
parameter_list|(
name|struct
name|ck_ht
modifier|*
name|table
parameter_list|)
block|{
name|ck_ht_map_destroy
argument_list|(
name|table
operator|->
name|m
argument_list|,
name|table
operator|->
name|map
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

