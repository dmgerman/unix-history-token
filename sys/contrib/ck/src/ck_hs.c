begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2012-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_hs.h>
end_include

begin_include
include|#
directive|include
file|<ck_limits.h>
end_include

begin_include
include|#
directive|include
file|<ck_md.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdint.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdbool.h>
end_include

begin_include
include|#
directive|include
file|<ck_string.h>
end_include

begin_include
include|#
directive|include
file|"ck_internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CK_HS_PROBE_L1_SHIFT
end_ifndef

begin_define
define|#
directive|define
name|CK_HS_PROBE_L1_SHIFT
value|3ULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_HS_PROBE_L1_SHIFT */
end_comment

begin_define
define|#
directive|define
name|CK_HS_PROBE_L1
value|(1<< CK_HS_PROBE_L1_SHIFT)
end_define

begin_define
define|#
directive|define
name|CK_HS_PROBE_L1_MASK
value|(CK_HS_PROBE_L1 - 1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CK_HS_PROBE_L1_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|CK_HS_PROBE_L1_DEFAULT
value|CK_MD_CACHELINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CK_HS_VMA_MASK
value|((uintptr_t)((1ULL<< CK_MD_VMA_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|CK_HS_VMA
parameter_list|(
name|x
parameter_list|)
define|\
value|((void *)((uintptr_t)(x)& CK_HS_VMA_MASK))
end_define

begin_define
define|#
directive|define
name|CK_HS_EMPTY
value|NULL
end_define

begin_define
define|#
directive|define
name|CK_HS_TOMBSTONE
value|((void *)~(uintptr_t)0)
end_define

begin_define
define|#
directive|define
name|CK_HS_G
value|(2)
end_define

begin_define
define|#
directive|define
name|CK_HS_G_MASK
value|(CK_HS_G - 1)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CK_F_PR_LOAD_8
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_8
argument_list|)
end_if

begin_define
define|#
directive|define
name|CK_HS_WORD
value|uint8_t
end_define

begin_define
define|#
directive|define
name|CK_HS_WORD_MAX
value|UINT8_MAX
end_define

begin_define
define|#
directive|define
name|CK_HS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_8(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_8(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_16
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_16
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_HS_WORD
value|uint16_t
end_define

begin_define
define|#
directive|define
name|CK_HS_WORD_MAX
value|UINT16_MAX
end_define

begin_define
define|#
directive|define
name|CK_HS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_16(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_16(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_32
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_32
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_HS_WORD
value|uint32_t
end_define

begin_define
define|#
directive|define
name|CK_HS_WORD_MAX
value|UINT32_MAX
end_define

begin_define
define|#
directive|define
name|CK_HS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_32(x, y)
end_define

begin_define
define|#
directive|define
name|CK_HS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_32(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"ck_hs is not supported on your platform."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|ck_hs_probe_behavior
block|{
name|CK_HS_PROBE
init|=
literal|0
block|,
comment|/* Default behavior. */
name|CK_HS_PROBE_TOMBSTONE
block|,
comment|/* Short-circuit on tombstone. */
name|CK_HS_PROBE_INSERT
comment|/* Short-circuit on probe bound if tombstone found. */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ck_hs_map
block|{
name|unsigned
name|int
name|generation
index|[
name|CK_HS_G
index|]
decl_stmt|;
name|unsigned
name|int
name|probe_maximum
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|step
decl_stmt|;
name|unsigned
name|int
name|probe_limit
decl_stmt|;
name|unsigned
name|int
name|tombstones
decl_stmt|;
name|unsigned
name|long
name|n_entries
decl_stmt|;
name|unsigned
name|long
name|capacity
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|CK_HS_WORD
modifier|*
name|probe_bound
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|entries
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|void
name|ck_hs_map_signal
parameter_list|(
name|struct
name|ck_hs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
name|h
operator|&=
name|CK_HS_G_MASK
expr_stmt|;
name|ck_pr_store_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
index|]
argument_list|,
name|map
operator|->
name|generation
index|[
name|h
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hs_iterator_init
parameter_list|(
name|struct
name|ck_hs_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|iterator
operator|->
name|cursor
operator|=
name|NULL
expr_stmt|;
name|iterator
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|bool
name|ck_hs_next
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_hs_iterator
modifier|*
name|i
parameter_list|,
name|void
modifier|*
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|void
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|offset
operator|>=
name|map
operator|->
name|capacity
condition|)
return|return
name|false
return|;
do|do
block|{
name|value
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|map
operator|->
name|entries
index|[
name|i
operator|->
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|CK_HS_EMPTY
operator|&&
name|value
operator|!=
name|CK_HS_TOMBSTONE
condition|)
block|{
ifdef|#
directive|ifdef
name|CK_HS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
name|value
operator|=
name|CK_HS_VMA
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|->
name|offset
operator|++
expr_stmt|;
operator|*
name|key
operator|=
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|->
name|offset
operator|<
name|map
operator|->
name|capacity
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|ck_hs_stat
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_hs_stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|st
operator|->
name|n_entries
operator|=
name|map
operator|->
name|n_entries
expr_stmt|;
name|st
operator|->
name|tombstones
operator|=
name|map
operator|->
name|tombstones
expr_stmt|;
name|st
operator|->
name|probe_maximum
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|unsigned
name|long
name|ck_hs_count
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|)
block|{
return|return
name|hs
operator|->
name|map
operator|->
name|n_entries
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_hs_map_destroy
parameter_list|(
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|struct
name|ck_hs_map
modifier|*
name|map
parameter_list|,
name|bool
name|defer
parameter_list|)
block|{
name|m
operator|->
name|free
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|defer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hs_destroy
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|)
block|{
name|ck_hs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|hs
operator|->
name|map
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ck_hs_map
modifier|*
name|ck_hs_map_create
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|entries
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|n_entries
decl_stmt|,
name|prefix
decl_stmt|,
name|limit
decl_stmt|;
name|n_entries
operator|=
name|ck_internal_power_2
argument_list|(
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_entries
operator|<
name|CK_HS_PROBE_L1
condition|)
name|n_entries
operator|=
name|CK_HS_PROBE_L1
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ck_hs_map
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|n_entries
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_DELETE
condition|)
block|{
name|prefix
operator|=
sizeof|sizeof
argument_list|(
name|CK_HS_WORD
argument_list|)
operator|*
name|n_entries
expr_stmt|;
name|size
operator|+=
name|prefix
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
name|map
operator|=
name|hs
operator|->
name|m
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* We should probably use a more intelligent heuristic for default probe length. */
name|limit
operator|=
name|ck_internal_max
argument_list|(
name|n_entries
operator|>>
operator|(
name|CK_HS_PROBE_L1_SHIFT
operator|+
literal|2
operator|)
argument_list|,
name|CK_HS_PROBE_L1_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|UINT_MAX
condition|)
name|limit
operator|=
name|UINT_MAX
expr_stmt|;
name|map
operator|->
name|probe_limit
operator|=
operator|(
name|unsigned
name|int
operator|)
name|limit
expr_stmt|;
name|map
operator|->
name|probe_maximum
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|capacity
operator|=
name|n_entries
expr_stmt|;
name|map
operator|->
name|step
operator|=
name|ck_internal_bsf
argument_list|(
name|n_entries
argument_list|)
expr_stmt|;
name|map
operator|->
name|mask
operator|=
name|n_entries
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|n_entries
operator|=
literal|0
expr_stmt|;
comment|/* Align map allocation to cache line. */
name|map
operator|->
name|entries
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|map
index|[
literal|1
index|]
operator|+
name|prefix
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|entries
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|n_entries
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|generation
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|map
operator|->
name|generation
argument_list|)
expr_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_DELETE
condition|)
block|{
name|map
operator|->
name|probe_bound
operator|=
operator|(
name|CK_HS_WORD
operator|*
operator|)
operator|&
name|map
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|probe_bound
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|->
name|probe_bound
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Commit entries purge with respect to map publication. */
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_reset_size
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|capacity
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|previous
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|map
operator|=
name|ck_hs_map_create
argument_list|(
name|hs
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ck_hs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|previous
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_reset
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|previous
decl_stmt|;
name|previous
operator|=
name|hs
operator|->
name|map
expr_stmt|;
return|return
name|ck_hs_reset_size
argument_list|(
name|hs
argument_list|,
name|previous
operator|->
name|capacity
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ck_hs_map_probe_next
parameter_list|(
name|struct
name|ck_hs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
name|unsigned
name|long
name|level
parameter_list|,
name|unsigned
name|long
name|probes
parameter_list|)
block|{
name|unsigned
name|long
name|r
decl_stmt|,
name|stride
decl_stmt|;
name|r
operator|=
operator|(
name|h
operator|>>
name|map
operator|->
name|step
operator|)
operator|>>
name|level
expr_stmt|;
name|stride
operator|=
operator|(
name|r
operator|&
operator|~
name|CK_HS_PROBE_L1_MASK
operator|)
operator|<<
literal|1
operator||
operator|(
name|r
operator|&
name|CK_HS_PROBE_L1_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|offset
operator|+
operator|(
name|probes
operator|>>
name|CK_HS_PROBE_L1_SHIFT
operator|)
operator|+
operator|(
name|stride
operator||
name|CK_HS_PROBE_L1
operator|)
operator|)
operator|&
name|map
operator|->
name|mask
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ck_hs_map_bound_set
parameter_list|(
name|struct
name|ck_hs_map
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
name|unsigned
name|long
name|n_probes
parameter_list|)
block|{
name|unsigned
name|long
name|offset
init|=
name|h
operator|&
name|m
operator|->
name|mask
decl_stmt|;
if|if
condition|(
name|n_probes
operator|>
name|m
operator|->
name|probe_maximum
condition|)
name|ck_pr_store_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|probe_bound
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
operator|<
name|n_probes
condition|)
block|{
if|if
condition|(
name|n_probes
operator|>
name|CK_HS_WORD_MAX
condition|)
name|n_probes
operator|=
name|CK_HS_WORD_MAX
expr_stmt|;
name|CK_HS_STORE
argument_list|(
operator|&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|ck_hs_map_bound_get
parameter_list|(
name|struct
name|ck_hs_map
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
name|unsigned
name|long
name|offset
init|=
name|h
operator|&
name|m
operator|->
name|mask
decl_stmt|;
name|unsigned
name|int
name|r
init|=
name|CK_HS_WORD_MAX
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|CK_HS_LOAD
argument_list|(
operator|&
name|m
operator|->
name|probe_bound
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|CK_HS_WORD_MAX
condition|)
name|r
operator|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_grow
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|capacity
parameter_list|)
block|{
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|update
decl_stmt|;
name|unsigned
name|long
name|k
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|offset
decl_stmt|,
name|probes
decl_stmt|;
specifier|const
name|void
modifier|*
name|previous
decl_stmt|,
modifier|*
modifier|*
name|bucket
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|capacity
operator|>
name|capacity
condition|)
return|return
name|false
return|;
name|update
operator|=
name|ck_hs_map_create
argument_list|(
name|hs
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|map
operator|->
name|capacity
condition|;
name|k
operator|++
control|)
block|{
name|unsigned
name|long
name|h
decl_stmt|;
name|previous
operator|=
name|map
operator|->
name|entries
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|previous
operator|==
name|CK_HS_EMPTY
operator|||
name|previous
operator|==
name|CK_HS_TOMBSTONE
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CK_HS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
name|previous
operator|=
name|CK_HS_VMA
argument_list|(
name|previous
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
name|hs
operator|->
name|hf
argument_list|(
name|previous
argument_list|,
name|hs
operator|->
name|seed
argument_list|)
expr_stmt|;
name|offset
operator|=
name|h
operator|&
name|update
operator|->
name|mask
expr_stmt|;
name|i
operator|=
name|probes
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bucket
operator|=
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|update
operator|->
name|entries
index|[
name|offset
index|]
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CK_HS_PROBE_L1
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|cursor
init|=
name|bucket
operator|+
operator|(
operator|(
name|j
operator|+
name|offset
operator|)
operator|&
operator|(
name|CK_HS_PROBE_L1
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|probes
operator|++
operator|==
name|update
operator|->
name|probe_limit
condition|)
break|break;
if|if
condition|(
name|CK_CC_LIKELY
argument_list|(
operator|*
name|cursor
operator|==
name|CK_HS_EMPTY
argument_list|)
condition|)
block|{
operator|*
name|cursor
operator|=
name|map
operator|->
name|entries
index|[
name|k
index|]
expr_stmt|;
name|update
operator|->
name|n_entries
operator|++
expr_stmt|;
name|ck_hs_map_bound_set
argument_list|(
name|update
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|CK_HS_PROBE_L1
condition|)
break|break;
name|offset
operator|=
name|ck_hs_map_probe_next
argument_list|(
name|update
argument_list|,
name|offset
argument_list|,
name|h
argument_list|,
name|i
operator|++
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|probes
operator|>
name|update
operator|->
name|probe_limit
condition|)
block|{
comment|/* 			 * We have hit the probe limit, map needs to be even larger. 			 */
name|ck_hs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|update
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|capacity
operator|<<=
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|ck_hs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|map
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_hs_map_postinsert
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_hs_map
modifier|*
name|map
parameter_list|)
block|{
name|map
operator|->
name|n_entries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|n_entries
operator|<<
literal|1
operator|)
operator|>
name|map
operator|->
name|capacity
condition|)
name|ck_hs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|bool
name|ck_hs_rebuild
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|)
block|{
return|return
name|ck_hs_grow
argument_list|(
name|hs
argument_list|,
name|hs
operator|->
name|map
operator|->
name|capacity
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
modifier|*
name|ck_hs_map_probe
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_hs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
modifier|*
name|n_probes
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
modifier|*
name|priority
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|object
parameter_list|,
name|unsigned
name|long
name|probe_limit
parameter_list|,
name|enum
name|ck_hs_probe_behavior
name|behavior
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|bucket
decl_stmt|,
modifier|*
modifier|*
name|cursor
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|compare
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|pr
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|,
name|j
decl_stmt|,
name|i
decl_stmt|,
name|probes
decl_stmt|,
name|opl
decl_stmt|;
ifdef|#
directive|ifdef
name|CK_HS_PP
comment|/* If we are storing object pointers, then we may leverage pointer packing. */
name|unsigned
name|long
name|hv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
block|{
name|hv
operator|=
operator|(
name|h
operator|>>
literal|25
operator|)
operator|&
name|CK_HS_KEY_MASK
expr_stmt|;
name|compare
operator|=
name|CK_HS_VMA
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|key
expr_stmt|;
block|}
else|#
directive|else
name|compare
operator|=
name|key
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|h
operator|&
name|map
operator|->
name|mask
expr_stmt|;
operator|*
name|object
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|probes
operator|=
literal|0
expr_stmt|;
name|opl
operator|=
name|probe_limit
expr_stmt|;
if|if
condition|(
name|behavior
operator|==
name|CK_HS_PROBE_INSERT
condition|)
name|probe_limit
operator|=
name|ck_hs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bucket
operator|=
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|map
operator|->
name|entries
index|[
name|offset
index|]
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CK_HS_PROBE_L1
condition|;
name|j
operator|++
control|)
block|{
name|cursor
operator|=
name|bucket
operator|+
operator|(
operator|(
name|j
operator|+
name|offset
operator|)
operator|&
operator|(
name|CK_HS_PROBE_L1
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|probes
operator|++
operator|==
name|probe_limit
condition|)
block|{
if|if
condition|(
name|probe_limit
operator|==
name|opl
operator|||
name|pr
operator|!=
name|NULL
condition|)
block|{
name|k
operator|=
name|CK_HS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
comment|/* 				 * If no eligible slot has been found yet, continue probe 				 * sequence with original probe limit. 				 */
name|probe_limit
operator|=
name|opl
expr_stmt|;
block|}
name|k
operator|=
name|ck_pr_load_ptr
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|CK_HS_EMPTY
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|k
operator|==
name|CK_HS_TOMBSTONE
condition|)
block|{
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
block|{
name|pr
operator|=
name|cursor
expr_stmt|;
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
if|if
condition|(
name|behavior
operator|==
name|CK_HS_PROBE_TOMBSTONE
condition|)
block|{
name|k
operator|=
name|CK_HS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|CK_HS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|k
operator|>>
name|CK_MD_VMA_BITS
operator|)
operator|!=
name|hv
condition|)
continue|continue;
name|k
operator|=
name|CK_HS_VMA
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|k
operator|==
name|compare
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|hs
operator|->
name|compare
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|hs
operator|->
name|compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|)
operator|==
name|true
condition|)
goto|goto
name|leave
goto|;
block|}
name|offset
operator|=
name|ck_hs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|h
argument_list|,
name|i
operator|++
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|leave
label|:
if|if
condition|(
name|probes
operator|>
name|probe_limit
condition|)
block|{
name|cursor
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|object
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
operator|*
name|priority
operator|=
name|pr
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|void
modifier|*
name|ck_hs_marshal
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CK_HS_PP
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
block|{
name|insert
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|CK_HS_VMA
argument_list|(
name|key
argument_list|)
operator||
operator|(
operator|(
name|h
operator|>>
literal|25
operator|)
operator|<<
name|CK_MD_VMA_BITS
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insert
operator|=
name|key
expr_stmt|;
block|}
return|return
name|insert
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|mode
expr_stmt|;
operator|(
name|void
operator|)
name|h
expr_stmt|;
return|return
name|key
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|ck_hs_gc
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|cycles
parameter_list|,
name|unsigned
name|long
name|seed
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|unsigned
name|int
name|maximum
decl_stmt|;
name|CK_HS_WORD
modifier|*
name|bounds
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|n_entries
operator|==
literal|0
condition|)
block|{
name|ck_pr_store_uint
argument_list|(
operator|&
name|map
operator|->
name|probe_maximum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|map
operator|->
name|probe_bound
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CK_HS_WORD
argument_list|)
operator|*
name|map
operator|->
name|capacity
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|cycles
operator|==
literal|0
condition|)
block|{
name|maximum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|probe_bound
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|CK_HS_WORD
argument_list|)
operator|*
name|map
operator|->
name|capacity
expr_stmt|;
name|bounds
operator|=
name|hs
operator|->
name|m
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bounds
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|bounds
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|maximum
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|,
name|offset
decl_stmt|,
name|h
decl_stmt|;
name|entry
operator|=
name|map
operator|->
name|entries
index|[
operator|(
name|i
operator|+
name|seed
operator|)
operator|&
name|map
operator|->
name|mask
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|CK_HS_EMPTY
operator|||
name|entry
operator|==
name|CK_HS_TOMBSTONE
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CK_HS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_HS_MODE_OBJECT
condition|)
name|entry
operator|=
name|CK_HS_VMA
argument_list|(
name|entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
name|hs
operator|->
name|hf
argument_list|(
name|entry
argument_list|,
name|hs
operator|->
name|seed
argument_list|)
expr_stmt|;
name|offset
operator|=
name|h
operator|&
name|map
operator|->
name|mask
expr_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|entry
argument_list|,
operator|&
name|object
argument_list|,
name|ck_hs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|CK_HS_PROBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|void
modifier|*
name|insert
init|=
name|ck_hs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
decl_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|first
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_hs_map_signal
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cycles
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n_probes
operator|>
name|maximum
condition|)
name|maximum
operator|=
name|n_probes
expr_stmt|;
if|if
condition|(
name|n_probes
operator|>
name|CK_HS_WORD_MAX
condition|)
name|n_probes
operator|=
name|CK_HS_WORD_MAX
expr_stmt|;
if|if
condition|(
name|bounds
operator|!=
name|NULL
operator|&&
name|n_probes
operator|>
name|bounds
index|[
name|offset
index|]
condition|)
name|bounds
index|[
name|offset
index|]
operator|=
name|n_probes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|cycles
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * The following only apply to garbage collection involving 	 * a full scan of all entries. 	 */
if|if
condition|(
name|maximum
operator|!=
name|map
operator|->
name|probe_maximum
condition|)
name|ck_pr_store_uint
argument_list|(
operator|&
name|map
operator|->
name|probe_maximum
argument_list|,
name|maximum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bounds
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
name|CK_HS_STORE
argument_list|(
operator|&
name|map
operator|->
name|probe_bound
index|[
name|i
index|]
argument_list|,
name|bounds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|hs
operator|->
name|m
operator|->
name|free
argument_list|(
name|bounds
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_fas
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|previous
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|,
modifier|*
name|insert
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
operator|*
name|previous
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|ck_hs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|CK_HS_PROBE
argument_list|)
expr_stmt|;
comment|/* Replacement semantics presume existence. */
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|insert
operator|=
name|ck_hs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|ck_pr_store_ptr
argument_list|(
name|first
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_hs_map_signal
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
operator|*
name|previous
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * An apply function takes two arguments. The first argument is a pointer to a  * pre-existing object. The second argument is a pointer to the fifth argument  * passed to ck_hs_apply. If a non-NULL pointer is passed to the first argument  * and the return value of the apply function is NULL, then the pre-existing  * value is deleted. If the return pointer is the same as the one passed to the  * apply function then no changes are made to the hash table.  If the first  * argument is non-NULL and the return pointer is different than that passed to  * the apply function, then the pre-existing value is replaced. For  * replacement, it is required that the value itself is identical to the  * previous value.  */
end_comment

begin_function
name|bool
name|ck_hs_apply
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|ck_hs_apply_fn_t
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|cl
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|,
modifier|*
name|delta
decl_stmt|,
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|CK_HS_PROBE_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
operator|&&
name|first
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ck_hs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
name|delta
operator|=
name|fn
argument_list|(
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The apply function has requested deletion. If the object doesn't exist, 		 * then exit early. 		 */
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|object
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Otherwise, mark slot as deleted. */
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
name|map
operator|->
name|n_entries
operator|--
expr_stmt|;
name|map
operator|->
name|tombstones
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* The apply function has not requested hash set modification so exit early. */
if|if
condition|(
name|delta
operator|==
name|object
condition|)
return|return
name|true
return|;
comment|/* A modification or insertion has been requested. */
name|ck_hs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_hs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|delta
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This follows the same semantics as ck_hs_set, please refer to that 		 * function for documentation. 		 */
name|ck_pr_store_ptr
argument_list|(
name|first
argument_list|,
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|ck_hs_map_signal
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If we are storing into same slot, then atomic store is sufficient 		 * for replacement. 		 */
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
name|ck_hs_map_postinsert
argument_list|(
name|hs
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_set
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|previous
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|,
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|;
operator|*
name|previous
operator|=
name|NULL
expr_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|CK_HS_PROBE_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
operator|&&
name|first
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ck_hs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
name|ck_hs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_hs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* If an earlier bucket was found, then store entry there. */
name|ck_pr_store_ptr
argument_list|(
name|first
argument_list|,
name|insert
argument_list|)
expr_stmt|;
comment|/* 		 * If a duplicate key was found, then delete it after 		 * signaling concurrent probes to restart. Optionally, 		 * it is possible to install tombstone after grace 		 * period if we can guarantee earlier position of 		 * duplicate key. 		 */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|ck_hs_map_signal
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If we are storing into same slot, then atomic store is sufficient 		 * for replacement. 		 */
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
name|ck_hs_map_postinsert
argument_list|(
name|hs
argument_list|,
name|map
argument_list|)
expr_stmt|;
operator|*
name|previous
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|bool
name|ck_hs_put_internal
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|enum
name|ck_hs_probe_behavior
name|behavior
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|,
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
operator|&&
name|first
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ck_hs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
comment|/* Fail operation if a match was found. */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
name|ck_hs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_hs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* Insert key into first bucket in probe sequence. */
name|ck_pr_store_ptr
argument_list|(
name|first
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An empty slot was found. */
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|insert
argument_list|)
expr_stmt|;
block|}
name|ck_hs_map_postinsert
argument_list|(
name|hs
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_put
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
return|return
name|ck_hs_put_internal
argument_list|(
name|hs
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
name|CK_HS_PROBE_INSERT
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_put_unique
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
return|return
name|ck_hs_put_internal
argument_list|(
name|hs
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
name|CK_HS_PROBE_TOMBSTONE
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ck_hs_get
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|unsigned
name|int
name|g
decl_stmt|,
name|g_p
decl_stmt|,
name|probe
decl_stmt|;
name|unsigned
name|int
modifier|*
name|generation
decl_stmt|;
do|do
block|{
name|map
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|)
expr_stmt|;
name|generation
operator|=
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_HS_G_MASK
index|]
expr_stmt|;
name|g
operator|=
name|ck_pr_load_uint
argument_list|(
name|generation
argument_list|)
expr_stmt|;
name|probe
operator|=
name|ck_hs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|probe
argument_list|,
name|CK_HS_PROBE
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|g_p
operator|=
name|ck_pr_load_uint
argument_list|(
name|generation
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|g
operator|!=
name|g_p
condition|)
do|;
return|return
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ck_hs_remove
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
name|object
decl_stmt|;
name|struct
name|ck_hs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|slot
operator|=
name|ck_hs_map_probe
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|ck_hs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|CK_HS_PROBE
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ck_pr_store_ptr
argument_list|(
name|slot
argument_list|,
name|CK_HS_TOMBSTONE
argument_list|)
expr_stmt|;
name|map
operator|->
name|n_entries
operator|--
expr_stmt|;
name|map
operator|->
name|tombstones
operator|++
expr_stmt|;
return|return
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_move
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_hs
modifier|*
name|source
parameter_list|,
name|ck_hs_hash_cb_t
modifier|*
name|hf
parameter_list|,
name|ck_hs_compare_cb_t
modifier|*
name|compare
parameter_list|,
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|malloc
operator|==
name|NULL
operator|||
name|m
operator|->
name|free
operator|==
name|NULL
operator|||
name|hf
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hs
operator|->
name|mode
operator|=
name|source
operator|->
name|mode
expr_stmt|;
name|hs
operator|->
name|seed
operator|=
name|source
operator|->
name|seed
expr_stmt|;
name|hs
operator|->
name|map
operator|=
name|source
operator|->
name|map
expr_stmt|;
name|hs
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|hs
operator|->
name|hf
operator|=
name|hf
expr_stmt|;
name|hs
operator|->
name|compare
operator|=
name|compare
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_hs_init
parameter_list|(
name|struct
name|ck_hs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|ck_hs_hash_cb_t
modifier|*
name|hf
parameter_list|,
name|ck_hs_compare_cb_t
modifier|*
name|compare
parameter_list|,
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|n_entries
parameter_list|,
name|unsigned
name|long
name|seed
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|malloc
operator|==
name|NULL
operator|||
name|m
operator|->
name|free
operator|==
name|NULL
operator|||
name|hf
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hs
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|hs
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|hs
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
name|hs
operator|->
name|hf
operator|=
name|hf
expr_stmt|;
name|hs
operator|->
name|compare
operator|=
name|compare
expr_stmt|;
name|hs
operator|->
name|map
operator|=
name|ck_hs_map_create
argument_list|(
name|hs
argument_list|,
name|n_entries
argument_list|)
expr_stmt|;
return|return
name|hs
operator|->
name|map
operator|!=
name|NULL
return|;
block|}
end_function

end_unit

