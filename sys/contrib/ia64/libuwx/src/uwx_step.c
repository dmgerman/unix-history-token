begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002,2003 Hewlett-Packard Company  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included  * in all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_include
include|#
directive|include
file|"uwx_context.h"
end_include

begin_include
include|#
directive|include
file|"uwx_utable.h"
end_include

begin_include
include|#
directive|include
file|"uwx_uinfo.h"
end_include

begin_include
include|#
directive|include
file|"uwx_scoreboard.h"
end_include

begin_include
include|#
directive|include
file|"uwx_str.h"
end_include

begin_include
include|#
directive|include
file|"uwx_trace.h"
end_include

begin_comment
comment|/*  *  uwx_step.c  *  *  This file contains the routines for stepping from one frame  *  into its callers frame. The context for the current frame  *  is maintained inside the current unwind environment  *  (struct uwx_env), and is updated with each call to  *  uwx_step() to refer to the previous frame.  */
end_comment

begin_comment
comment|/* Forward Declarations */
end_comment

begin_function_decl
name|int
name|uwx_decode_uvec
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
modifier|*
name|uvec
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uwx_restore_reg
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|rstate
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|,
name|uint64_t
modifier|*
name|histp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uwx_restore_nat
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|rstate
parameter_list|,
name|int
name|unat
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* uwx_get_frame_info: Gets unwind info for current frame */
end_comment

begin_function
specifier|static
name|int
name|uwx_get_frame_info
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|cbstatus
decl_stmt|;
name|uint64_t
modifier|*
name|uvec
decl_stmt|;
name|uint64_t
modifier|*
name|rstate
decl_stmt|;
name|struct
name|uwx_utable_entry
name|uentry
decl_stmt|;
name|uint64_t
name|uvecout
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOENV
return|;
if|if
condition|(
name|env
operator|->
name|copyin
operator|==
literal|0
operator|||
name|env
operator|->
name|lookupip
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOCALLBACKS
return|;
if|if
condition|(
operator|(
name|env
operator|->
name|context
operator|.
name|valid_regs
operator|&
name|VALID_BASIC4
operator|)
operator|!=
name|VALID_BASIC4
condition|)
return|return
name|UWX_ERR_NOCONTEXT
return|;
name|env
operator|->
name|function_offset
operator|=
operator|-
literal|1LL
expr_stmt|;
name|env
operator|->
name|function_name
operator|=
literal|0
expr_stmt|;
name|env
operator|->
name|module_name
operator|=
literal|0
expr_stmt|;
name|uwx_reset_str_pool
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* Use the lookup IP callback routine to find out about the */
comment|/* current IP. If the predicate registers are valid, pass them */
comment|/* in the uvec. */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|context
operator|.
name|valid_regs
operator|&
operator|(
literal|1
operator|<<
name|UWX_REG_PREDS
operator|)
condition|)
block|{
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|UWX_KEY_PREDS
expr_stmt|;
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PREDS
index|]
expr_stmt|;
block|}
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|UWX_KEY_END
expr_stmt|;
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|uvec
operator|=
name|uvecout
expr_stmt|;
name|cbstatus
operator|=
call|(
modifier|*
name|env
operator|->
name|lookupip
call|)
argument_list|(
name|UWX_LKUP_LOOKUP
argument_list|,
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
argument_list|,
name|env
operator|->
name|cb_token
argument_list|,
operator|&
name|uvec
argument_list|)
expr_stmt|;
comment|/* If NOTFOUND, there's nothing we can do but return an error. */
if|if
condition|(
name|cbstatus
operator|==
name|UWX_LKUP_NOTFOUND
condition|)
block|{
name|status
operator|=
name|UWX_ERR_IPNOTFOUND
expr_stmt|;
block|}
comment|/* If the callback returns an unwind table, we need to */
comment|/* search the table for an unwind entry that describes the */
comment|/* code region of interest, then decode the unwind information */
comment|/* associated with that unwind table entry, and store the */
comment|/* resulting register state array in the unwind environment */
comment|/* block. */
elseif|else
if|if
condition|(
name|cbstatus
operator|==
name|UWX_LKUP_UTABLE
condition|)
block|{
name|status
operator|=
name|uwx_search_utable
argument_list|(
name|env
argument_list|,
name|uvec
argument_list|,
operator|&
name|uentry
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|env
operator|->
name|lookupip
argument_list|)
argument_list|(
name|UWX_LKUP_FREE
argument_list|,
literal|0
argument_list|,
name|env
operator|->
name|cb_token
argument_list|,
operator|&
name|uvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|UWX_OK
condition|)
name|status
operator|=
name|uwx_decode_uinfo
argument_list|(
name|env
argument_list|,
operator|&
name|uentry
argument_list|,
operator|&
name|rstate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|UWX_ERR_NOUENTRY
condition|)
name|status
operator|=
name|uwx_default_rstate
argument_list|(
name|env
argument_list|,
operator|&
name|rstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|UWX_OK
condition|)
name|env
operator|->
name|rstate
operator|=
name|rstate
expr_stmt|;
block|}
comment|/* If the callback returns a frame description (in the form */
comment|/* of an update vector), convert the update vector into a */
comment|/* register state array, then invoke the callback again to */
comment|/* let it free any memory it allocated. */
elseif|else
if|if
condition|(
name|cbstatus
operator|==
name|UWX_LKUP_FDESC
condition|)
block|{
name|status
operator|=
name|uwx_decode_uvec
argument_list|(
name|env
argument_list|,
name|uvec
argument_list|,
operator|&
name|rstate
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|env
operator|->
name|lookupip
argument_list|)
argument_list|(
name|UWX_LKUP_FREE
argument_list|,
literal|0
argument_list|,
name|env
operator|->
name|cb_token
argument_list|,
operator|&
name|uvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|UWX_OK
condition|)
name|env
operator|->
name|rstate
operator|=
name|rstate
expr_stmt|;
block|}
comment|/* Any other return from the callback is an error. */
else|else
block|{
name|status
operator|=
name|UWX_ERR_LOOKUPERR
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* uwx_get_sym_info: Gets symbolic info from current frame */
end_comment

begin_function
name|int
name|uwx_get_sym_info
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|char
modifier|*
modifier|*
name|modp
parameter_list|,
name|char
modifier|*
modifier|*
name|symp
parameter_list|,
name|uint64_t
modifier|*
name|offsetp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|cbstatus
decl_stmt|;
name|uint64_t
name|ip
decl_stmt|;
name|uint64_t
modifier|*
name|uvec
decl_stmt|;
name|uint64_t
name|uvecout
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOENV
return|;
if|if
condition|(
name|env
operator|->
name|copyin
operator|==
literal|0
operator|||
name|env
operator|->
name|lookupip
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOCALLBACKS
return|;
if|if
condition|(
operator|(
name|env
operator|->
name|context
operator|.
name|valid_regs
operator|&
name|VALID_BASIC4
operator|)
operator|!=
name|VALID_BASIC4
condition|)
return|return
name|UWX_ERR_NOCONTEXT
return|;
comment|/* If we haven't already obtained the frame info for the */
comment|/* current frame, get it now. */
if|if
condition|(
name|env
operator|->
name|rstate
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|uwx_get_frame_info
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
block|}
comment|/* Get the symbolic information from the lookup IP callback. */
if|if
condition|(
name|env
operator|->
name|function_name
operator|==
literal|0
condition|)
block|{
name|ip
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|function_offset
operator|>=
literal|0
condition|)
block|{
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|UWX_KEY_FUNCSTART
expr_stmt|;
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|ip
operator|-
name|env
operator|->
name|function_offset
expr_stmt|;
block|}
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
name|UWX_KEY_END
expr_stmt|;
name|uvecout
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|uvec
operator|=
name|uvecout
expr_stmt|;
name|cbstatus
operator|=
call|(
modifier|*
name|env
operator|->
name|lookupip
call|)
argument_list|(
name|UWX_LKUP_SYMBOLS
argument_list|,
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
argument_list|,
name|env
operator|->
name|cb_token
argument_list|,
operator|&
name|uvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbstatus
operator|==
name|UWX_LKUP_SYMINFO
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|uvec
index|[
name|i
index|]
operator|!=
name|UWX_KEY_END
condition|;
name|i
operator|+=
literal|2
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|uvec
index|[
name|i
index|]
condition|)
block|{
case|case
name|UWX_KEY_MODULE
case|:
name|env
operator|->
name|module_name
operator|=
name|uwx_alloc_str
argument_list|(
name|env
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|uvec
index|[
name|i
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UWX_KEY_FUNC
case|:
name|env
operator|->
name|function_name
operator|=
name|uwx_alloc_str
argument_list|(
name|env
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|uvec
index|[
name|i
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UWX_KEY_FUNCSTART
case|:
name|env
operator|->
name|function_offset
operator|=
name|ip
operator|-
name|uvec
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
call|(
name|void
call|)
argument_list|(
operator|*
name|env
operator|->
name|lookupip
argument_list|)
argument_list|(
name|UWX_LKUP_FREE
argument_list|,
literal|0
argument_list|,
name|env
operator|->
name|cb_token
argument_list|,
operator|&
name|uvec
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|modp
operator|=
name|env
operator|->
name|module_name
expr_stmt|;
operator|*
name|symp
operator|=
name|env
operator|->
name|function_name
expr_stmt|;
operator|*
name|offsetp
operator|=
name|env
operator|->
name|function_offset
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_step: Steps from the current frame to the previous frame */
end_comment

begin_function
name|int
name|uwx_step
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pfs_sol
decl_stmt|;
name|int
name|dispcode
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|uint64_t
name|fval
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|hist
decl_stmt|;
name|uint64_t
name|tempgr
index|[
name|NPRESERVEDGR
index|]
decl_stmt|;
name|int
name|needpriunat
decl_stmt|;
name|int
name|unat
decl_stmt|;
name|int
name|tempnat
decl_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOENV
return|;
if|if
condition|(
name|env
operator|->
name|copyin
operator|==
literal|0
operator|||
name|env
operator|->
name|lookupip
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOCALLBACKS
return|;
if|if
condition|(
operator|(
name|env
operator|->
name|context
operator|.
name|valid_regs
operator|&
name|VALID_BASIC4
operator|)
operator|!=
name|VALID_BASIC4
condition|)
return|return
name|UWX_ERR_NOCONTEXT
return|;
comment|/* If we haven't already obtained the frame info for the */
comment|/* current frame, get it now. */
if|if
condition|(
name|env
operator|->
name|rstate
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|uwx_get_frame_info
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
block|}
name|TRACE_S_STEP
argument_list|(
argument|env->rstate
argument_list|)
comment|/* Complete the current context by restoring the current values */
comment|/* of psp, rp, and pfs. */
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_PSP
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_PSP
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
operator|=
name|hist
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"PSP"
argument_list|,
argument|env->rstate[SBREG_PSP]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_RP
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_RP
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
operator|=
name|hist
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"RP"
argument_list|,
argument|env->rstate[SBREG_RP]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_PFS
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_PFS
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PFS
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PFS
index|]
operator|=
name|hist
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"PFS"
argument_list|,
argument|env->rstate[SBREG_PFS]
argument_list|,
argument|val
argument_list|)
block|}
comment|/* Check for bottom of stack (rp == 0). */
if|if
condition|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
operator|==
literal|0
condition|)
return|return
name|UWX_BOTTOM
return|;
comment|/* Find where the primary unat is saved, get a copy. */
comment|/* Then, as we restore the GRs, we'll merge the NaT bits into the */
comment|/* priunat register in the context. */
comment|/* (Make sure we need it, though, before we try to get it, */
comment|/* because the attempt to get it might invoke the copy-in callback. */
comment|/* We don't need the priunat unless one of GR 4-7 was */
comment|/* saved to the memory stack.) */
name|needpriunat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_GR
condition|;
name|i
operator|++
control|)
block|{
name|dispcode
operator|=
name|UWX_GET_DISP_CODE
argument_list|(
name|env
operator|->
name|rstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispcode
operator|==
name|UWX_DISP_SPREL
argument_list|(
literal|0
argument_list|)
operator|||
name|dispcode
operator|==
name|UWX_DISP_PSPREL
argument_list|(
literal|0
argument_list|)
condition|)
name|needpriunat
operator|=
literal|1
expr_stmt|;
block|}
name|unat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needpriunat
operator|&&
name|env
operator|->
name|rstate
index|[
name|SBREG_PRIUNAT
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_PRIUNAT
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|unat
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PRIUNAT
index|]
operator|=
name|hist
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"PRIUNAT"
argument_list|,
argument|env->rstate[SBREG_PRIUNAT]
argument_list|,
argument|val
argument_list|)
block|}
comment|/* Retrieve saved values of the preserved GRs into temporaries. */
name|tempnat
operator|=
operator|(
name|int
operator|)
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PRIUNAT
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_GR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|tempgr
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|uwx_restore_nat
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
argument_list|,
name|unat
argument_list|)
condition|)
name|tempnat
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
else|else
name|tempnat
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|gr
index|[
name|i
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
operator|(
name|i
operator|+
name|VALID_GR_SHIFT
operator|)
expr_stmt|;
name|TRACE_S_RESTORE_GR
argument_list|(
argument|i
argument_list|,
argument|env->rstate[SBREG_GR + i]
argument_list|,
argument|val
argument_list|)
block|}
block|}
comment|/* Now we have everything we need to step back to the previous frame. */
comment|/* Restore preserved BRs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_BR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|br
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|br
index|[
name|i
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
operator|(
name|i
operator|+
name|VALID_BR_SHIFT
operator|)
expr_stmt|;
name|TRACE_S_RESTORE_BR
argument_list|(
argument|i
argument_list|,
argument|env->rstate[SBREG_BR + i]
argument_list|,
argument|val
argument_list|)
block|}
block|}
comment|/* Restore preserved FRs. */
if|if
condition|(
name|env
operator|->
name|nsbreg
operator|==
name|NSBREG
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_FR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_FR
operator|+
name|i
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_FR
operator|+
name|i
index|]
argument_list|,
name|fval
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|fr
index|[
name|i
index|]
operator|.
name|part0
operator|=
name|fval
index|[
literal|0
index|]
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|fr
index|[
name|i
index|]
operator|.
name|part1
operator|=
name|fval
index|[
literal|1
index|]
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|fr
index|[
name|i
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_frs
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|TRACE_S_RESTORE_FR
argument_list|(
argument|i
argument_list|,
argument|env->rstate[SBREG_FR + i]
argument_list|,
argument|fval
argument_list|)
block|}
block|}
block|}
comment|/* Restore other preserved regs. */
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_PREDS
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_PREDS
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PREDS
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PREDS
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
name|UWX_REG_PREDS
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"PREDS"
argument_list|,
argument|env->rstate[SBREG_PREDS]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_RNAT
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_RNAT
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_RNAT
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_RNAT
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
name|UWX_REG_RNAT
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"RNAT"
argument_list|,
argument|env->rstate[SBREG_RNAT]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_UNAT
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_UNAT
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_UNAT
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_UNAT
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
name|UWX_REG_UNAT
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"UNAT"
argument_list|,
argument|env->rstate[SBREG_UNAT]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_FPSR
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_FPSR
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_FPSR
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_FPSR
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
name|UWX_REG_FPSR
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"FPSR"
argument_list|,
argument|env->rstate[SBREG_FPSR]
argument_list|,
argument|val
argument_list|)
block|}
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_LC
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
block|{
name|status
operator|=
name|uwx_restore_reg
argument_list|(
name|env
argument_list|,
name|env
operator|->
name|rstate
index|[
name|SBREG_LC
index|]
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|hist
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_LC
index|]
operator|=
name|val
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_LC
index|]
operator|=
name|hist
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|valid_regs
operator||=
literal|1
operator|<<
name|UWX_REG_LC
expr_stmt|;
name|TRACE_S_RESTORE_REG
argument_list|(
literal|"LC"
argument_list|,
argument|env->rstate[SBREG_LC]
argument_list|,
argument|val
argument_list|)
block|}
comment|/* Restore preserved GRs from temporaries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_GR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|env
operator|->
name|rstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|!=
name|UWX_DISP_NONE
condition|)
name|env
operator|->
name|context
operator|.
name|gr
index|[
name|i
index|]
operator|=
name|tempgr
index|[
name|i
index|]
expr_stmt|;
block|}
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PRIUNAT
index|]
operator|=
name|tempnat
expr_stmt|;
comment|/* Restore the frame markers. */
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|=
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_SP
index|]
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_SP
index|]
operator|=
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
expr_stmt|;
name|pfs_sol
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PFS
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_BSP
index|]
operator|=
name|uwx_add_to_bsp
argument_list|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_BSP
index|]
argument_list|,
operator|-
name|pfs_sol
argument_list|)
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_CFM
index|]
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PFS
index|]
expr_stmt|;
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_CFM
index|]
operator|=
name|env
operator|->
name|history
operator|.
name|special
index|[
name|UWX_REG_PFS
index|]
expr_stmt|;
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_RP
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The frame info for the new frame isn't yet available. */
name|env
operator|->
name|rstate
operator|=
literal|0
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_uvec: Converts the update vector into a register state array */
end_comment

begin_function
name|int
name|uwx_decode_uvec
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
modifier|*
name|uvec
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstate
parameter_list|)
block|{
while|while
condition|(
operator|*
name|uvec
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
operator|*
name|uvec
operator|++
condition|)
block|{
case|case
name|UWX_KEY_CONTEXT
case|:
name|env
operator|->
name|abi_context
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|uvec
operator|++
argument_list|)
expr_stmt|;
return|return
name|UWX_ABI_FRAME
return|;
default|default:
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
block|}
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_restore_reg: Restores a register according to the scoreboard */
end_comment

begin_define
define|#
directive|define
name|COPYIN_MSTACK_8
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_MSTACK, (dest), (src), \ 						DWORDSZ, env->cb_token) : \ 	(*(uint64_t *)(dest) = *(uint64_t *)(src), DWORDSZ) )
end_define

begin_function
name|int
name|uwx_restore_reg
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|rstate
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|,
name|uint64_t
modifier|*
name|histp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|uint64_t
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|regid
decl_stmt|;
name|status
operator|=
name|UWX_OK
expr_stmt|;
switch|switch
condition|(
name|UWX_GET_DISP_CODE
argument_list|(
name|rstate
argument_list|)
condition|)
block|{
case|case
name|UWX_DISP_SPPLUS
argument_list|(
literal|0
argument_list|)
case|:
operator|*
name|valp
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_SP
index|]
operator|+
name|UWX_GET_DISP_OFFSET
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
operator|*
name|histp
operator|=
name|UWX_DISP_NONE
expr_stmt|;
break|break;
case|case
name|UWX_DISP_SPREL
argument_list|(
literal|0
argument_list|)
case|:
name|p
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_SP
index|]
operator|+
name|UWX_GET_DISP_OFFSET
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
name|n
operator|=
name|COPYIN_MSTACK_8
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|DWORDSZ
condition|)
name|status
operator|=
name|UWX_ERR_COPYIN_MSTK
expr_stmt|;
operator|*
name|histp
operator|=
name|UWX_DISP_MSTK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|UWX_DISP_PSPREL
argument_list|(
literal|0
argument_list|)
case|:
name|p
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
operator|+
literal|16
operator|-
name|UWX_GET_DISP_OFFSET
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
name|n
operator|=
name|COPYIN_MSTACK_8
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|DWORDSZ
condition|)
name|status
operator|=
name|UWX_ERR_COPYIN_MSTK
expr_stmt|;
operator|*
name|histp
operator|=
name|UWX_DISP_MSTK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|UWX_DISP_REG
argument_list|(
literal|0
argument_list|)
case|:
name|regid
operator|=
name|UWX_GET_DISP_REGID
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
name|status
operator|=
name|uwx_get_reg
argument_list|(
name|env
argument_list|,
name|regid
argument_list|,
name|valp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uwx_get_spill_loc
argument_list|(
name|env
argument_list|,
name|regid
argument_list|,
name|histp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* uwx_restore_nat: Returns the saved NaT bit for a preserved GR */
end_comment

begin_function
name|int
name|uwx_restore_nat
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|rstate
parameter_list|,
name|int
name|unat
parameter_list|)
block|{
name|int
name|nat
decl_stmt|;
name|uint64_t
name|p
decl_stmt|;
name|nat
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|UWX_GET_DISP_CODE
argument_list|(
name|rstate
argument_list|)
condition|)
block|{
case|case
name|UWX_DISP_SPREL
argument_list|(
literal|0
argument_list|)
case|:
name|p
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_SP
index|]
operator|+
name|UWX_GET_DISP_OFFSET
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
name|nat
operator|=
operator|(
name|unat
operator|>>
operator|(
operator|(
operator|(
name|int
operator|)
name|p
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
operator|)
operator|)
operator|&
literal|0x01
expr_stmt|;
break|break;
case|case
name|UWX_DISP_PSPREL
argument_list|(
literal|0
argument_list|)
case|:
name|p
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_PSP
index|]
operator|+
literal|16
operator|-
name|UWX_GET_DISP_OFFSET
argument_list|(
name|rstate
argument_list|)
expr_stmt|;
name|nat
operator|=
operator|(
name|unat
operator|>>
operator|(
operator|(
operator|(
name|int
operator|)
name|p
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
operator|)
operator|)
operator|&
literal|0x01
expr_stmt|;
break|break;
case|case
name|UWX_DISP_REG
argument_list|(
literal|0
argument_list|)
case|:
operator|(
name|void
operator|)
name|uwx_get_nat
argument_list|(
name|env
argument_list|,
name|UWX_GET_DISP_REGID
argument_list|(
name|rstate
argument_list|)
argument_list|,
operator|&
name|nat
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|nat
return|;
block|}
end_function

end_unit

