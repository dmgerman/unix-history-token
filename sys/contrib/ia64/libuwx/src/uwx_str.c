begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2003 Hewlett-Packard Development Company, L.P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_include
include|#
directive|include
file|"uwx_str.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|uwx_str_pool
name|uwx_str_pool
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|free
parameter_list|(
name|p
parameter_list|)
end_define

begin_comment
comment|/* nullified */
end_comment

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|sz
parameter_list|)
value|((sz == sizeof(uwx_str_pool)) ?&uwx_str_pool : NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  uwx_str.c  *  *  This file contains the routines for maintaining a string  *  pool for the unwind environment. We preallocate enough  *  space for most purposes so that no memory allocation is  *  necessary during a normal unwind. If we do need more,  *  we use the allocate callback, if one is provided.  *  *  The string pool is reused with each call to step(),  *  and is completely freed when the unwind environment is  *  freed.  */
end_comment

begin_function
name|int
name|uwx_init_str_pool
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|env
operator|->
name|allocate_cb
operator|==
literal|0
condition|)
name|env
operator|->
name|string_pool
operator|=
operator|(
expr|struct
name|uwx_str_pool
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uwx_str_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|env
operator|->
name|string_pool
operator|=
operator|(
expr|struct
name|uwx_str_pool
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uwx_str_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|string_pool
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|env
operator|->
name|string_pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|env
operator|->
name|string_pool
operator|->
name|size
operator|=
name|STRPOOLSIZE
expr_stmt|;
name|env
operator|->
name|string_pool
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_function
name|void
name|uwx_free_str_pool
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|uwx_str_pool
modifier|*
name|pool
decl_stmt|;
name|struct
name|uwx_str_pool
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|env
operator|->
name|string_pool
init|;
name|pool
operator|!=
literal|0
condition|;
name|pool
operator|=
name|next
control|)
block|{
name|next
operator|=
name|pool
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|free_cb
operator|==
literal|0
condition|)
name|free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|uwx_alloc_str
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|uwx_str_pool
modifier|*
name|pool
decl_stmt|;
name|struct
name|uwx_str_pool
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pool
operator|=
name|env
operator|->
name|string_pool
init|;
name|pool
operator|!=
literal|0
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|prev
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|pool
operator|->
name|size
operator|-
name|pool
operator|->
name|used
operator|>=
name|len
condition|)
break|break;
block|}
if|if
condition|(
name|pool
operator|==
literal|0
condition|)
block|{
name|size
operator|=
name|STRPOOLSIZE
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|size
condition|)
name|size
operator|=
name|len
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|uwx_str_pool
argument_list|)
operator|-
name|STRPOOLSIZE
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|allocate_cb
operator|==
literal|0
condition|)
name|pool
operator|=
operator|(
expr|struct
name|uwx_str_pool
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|pool
operator|=
operator|(
expr|struct
name|uwx_str_pool
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|string_pool
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|pool
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pool
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|pool
expr_stmt|;
block|}
name|p
operator|=
name|pool
operator|->
name|pool
operator|+
name|pool
operator|->
name|used
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|pool
operator|->
name|used
operator|+=
name|len
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|uwx_reset_str_pool
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|uwx_str_pool
modifier|*
name|pool
decl_stmt|;
for|for
control|(
name|pool
operator|=
name|env
operator|->
name|string_pool
init|;
name|pool
operator|!=
literal|0
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
name|pool
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

