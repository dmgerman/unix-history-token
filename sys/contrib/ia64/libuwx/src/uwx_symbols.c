begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2003-2006 Hewlett-Packard Development Company, L.P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CLEAN_NAMESPACE
end_ifdef

begin_define
define|#
directive|define
name|fopen
value|_fopen
end_define

begin_define
define|#
directive|define
name|fseek
value|_fseek
end_define

begin_define
define|#
directive|define
name|fread
value|_fread
end_define

begin_define
define|#
directive|define
name|fclose
value|_fclose
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CLEAN_NAMESPACE */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|"uwx.h"
end_include

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CLEAN_NAMESPACE
end_ifdef

begin_comment
comment|/*  * Moved the defines above the include of stdio.h,  * so we don't need these unless that causes problems  * and we have to move them back down here.  * #define fopen _fopen  * #define fseek _fseek  * #define fread _fread  * #define fclose _fclose  * extern FILE *_fopen(const char *, const char *);  * extern int _fseek(FILE *, long int, int);  * extern size_t _fread(void *, size_t, size_t, FILE *);  * extern int _fclose(FILE *);  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CLEAN_NAMESPACE */
end_comment

begin_struct
struct|struct
name|uwx_symbol_cache
block|{
name|char
modifier|*
name|module_name
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|uint64_t
modifier|*
name|sym_values
decl_stmt|;
name|char
modifier|*
modifier|*
name|sym_names
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|int
name|uwx_read_func_symbols
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_symbol_cache
modifier|*
name|cache
parameter_list|,
name|char
modifier|*
name|module_name
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|uwx_find_symbol
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_symbol_cache
modifier|*
modifier|*
name|symbol_cache_p
parameter_list|,
name|char
modifier|*
name|module_name
parameter_list|,
name|uint64_t
name|relip
parameter_list|,
name|char
modifier|*
modifier|*
name|func_name_p
parameter_list|,
name|uint64_t
modifier|*
name|offset_p
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|best_offset
decl_stmt|;
name|char
modifier|*
name|best_name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|uwx_symbol_cache
modifier|*
name|cache
init|=
name|NULL
decl_stmt|;
comment|/* Allocate a symbol cache on first call */
if|if
condition|(
name|symbol_cache_p
operator|!=
name|NULL
condition|)
name|cache
operator|=
operator|*
name|symbol_cache_p
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
block|{
name|cache
operator|=
operator|(
expr|struct
name|uwx_symbol_cache
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uwx_symbol_cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|cache
operator|->
name|module_name
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|nsyms
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|sym_values
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|sym_names
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|strings
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symbol_cache_p
operator|!=
name|NULL
condition|)
operator|*
name|symbol_cache_p
operator|=
name|cache
expr_stmt|;
block|}
comment|/* Read function symbols from the object file */
name|status
operator|=
name|uwx_read_func_symbols
argument_list|(
name|env
argument_list|,
name|cache
argument_list|,
name|module_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
comment|/* Search for best match */
name|best_offset
operator|=
operator|~
operator|(
name|uint64_t
operator|)
literal|0
expr_stmt|;
name|best_name
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cache
operator|->
name|sym_values
index|[
name|i
index|]
operator|==
name|relip
condition|)
block|{
operator|*
name|func_name_p
operator|=
name|cache
operator|->
name|sym_names
index|[
name|i
index|]
expr_stmt|;
operator|*
name|offset_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol_cache_p
operator|==
name|NULL
condition|)
name|uwx_release_symbol_cache
argument_list|(
name|env
argument_list|,
name|cache
argument_list|)
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
if|if
condition|(
name|relip
operator|>
name|cache
operator|->
name|sym_values
index|[
name|i
index|]
condition|)
block|{
name|offset
operator|=
name|relip
operator|-
name|cache
operator|->
name|sym_values
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|best_offset
condition|)
block|{
name|best_offset
operator|=
name|offset
expr_stmt|;
name|best_name
operator|=
name|cache
operator|->
name|sym_names
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_name
operator|==
name|NULL
condition|)
return|return
name|UWX_ERR_NOSYM
return|;
if|if
condition|(
name|symbol_cache_p
operator|==
name|NULL
condition|)
name|uwx_release_symbol_cache
argument_list|(
name|env
argument_list|,
name|cache
argument_list|)
expr_stmt|;
operator|*
name|func_name_p
operator|=
name|best_name
expr_stmt|;
operator|*
name|offset_p
operator|=
name|best_offset
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_function
name|void
name|uwx_release_symbol_cache
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_symbol_cache
modifier|*
name|symbol_cache
parameter_list|)
block|{
if|if
condition|(
name|symbol_cache
operator|->
name|module_name
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|symbol_cache
operator|->
name|module_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_cache
operator|->
name|sym_values
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|symbol_cache
operator|->
name|sym_values
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_cache
operator|->
name|sym_names
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|symbol_cache
operator|->
name|sym_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_cache
operator|->
name|strings
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|symbol_cache
operator|->
name|strings
argument_list|)
expr_stmt|;
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|symbol_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ERR_NOMEM
value|UWX_ERR_NOMEM
end_define

begin_comment
comment|/* Out of memory */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_OPEN
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't open file */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_NOHEADER
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't read ELF header */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_NOTELF
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Not an ELF file */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_HEADER_SIZE
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid e_ehsize */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_INVALID_CLASS
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid EI_CLASS */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_INVALID_DATA
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid EI_DATA */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_READ_SECTHDR
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't read section headers */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_SECTHDR_SIZE
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid e_shentsize */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_READ_PROGHDR
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't read program headers */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_PROGHDR_SIZE
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid e_phentsize */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_READ_SECTION
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't read section contents */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_READ_SYMTAB
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Can't read symbol table */
end_comment

begin_define
define|#
directive|define
name|ELF_ERR_SYMTAB_SIZE
value|UWX_ERR_NOSYM
end_define

begin_comment
comment|/* Invalid sh_entsize for symtab */
end_comment

begin_struct
struct|struct
name|elf_file
block|{
name|uint64_t
name|phoff
decl_stmt|;
name|uint64_t
name|shoff
decl_stmt|;
name|uint64_t
name|text_base
decl_stmt|;
name|uint64_t
name|text_end
decl_stmt|;
name|alloc_cb
name|allocate_cb
decl_stmt|;
name|free_cb
name|free_cb
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|struct
name|elf_section
modifier|*
name|sections
decl_stmt|;
name|struct
name|elf_symbol
modifier|*
name|symbols
decl_stmt|;
name|char
modifier|*
name|symbol_strings
decl_stmt|;
name|int
name|native_data
decl_stmt|;
name|int
name|source_class
decl_stmt|;
name|int
name|source_data
decl_stmt|;
name|int
name|ehsize
decl_stmt|;
name|int
name|phentsize
decl_stmt|;
name|int
name|phnum
decl_stmt|;
name|int
name|shentsize
decl_stmt|;
name|int
name|shnum
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_section
block|{
name|uint64_t
name|flags
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint64_t
name|entsize
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|struct
name|elf_symbol
modifier|*
name|symbols
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|link
decl_stmt|;
name|int
name|info
decl_stmt|;
name|int
name|nelems
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_symbol
block|{
name|uint64_t
name|value
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
name|int
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|shndx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|elf_swap_bytes
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|template
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|char
name|temp
index|[
literal|16
index|]
decl_stmt|;
while|while
condition|(
name|sz
operator|=
operator|*
name|template
operator|++
condition|)
block|{
if|if
condition|(
name|sz
operator|>
literal|16
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|temp
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|temp
index|[
name|sz
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|buf
operator|+=
name|sz
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|elf_read_section
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|,
name|int
name|shndx
parameter_list|)
block|{
name|struct
name|elf_section
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
name|shndx
operator|<
literal|0
operator|||
name|shndx
operator|>
name|ef
operator|->
name|shnum
condition|)
return|return
literal|0
return|;
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|shndx
index|]
expr_stmt|;
comment|/* Return if section has already been read */
if|if
condition|(
name|sect
operator|->
name|contents
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
name|sect
operator|->
name|contents
operator|=
call|(
modifier|*
name|ef
operator|->
name|allocate_cb
call|)
argument_list|(
name|sect
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|ELF_ERR_NOMEM
return|;
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
operator|(
name|long
operator|)
name|sect
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|sect
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|sect
operator|->
name|size
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
name|sect
operator|->
name|size
condition|)
return|return
name|ELF_ERR_READ_SECTION
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|template_elf32_sym
index|[]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|template_elf64_sym
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|8
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elf_read_symtab_section
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|,
name|int
name|shndx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|long
name|size
decl_stmt|;
union|union
block|{
name|Elf32_Sym
name|sym32
decl_stmt|;
name|Elf64_Sym
name|sym64
decl_stmt|;
block|}
name|sym
union|;
name|struct
name|elf_section
modifier|*
name|sect
decl_stmt|;
name|struct
name|elf_symbol
modifier|*
name|syms
decl_stmt|;
name|struct
name|elf_symbol
modifier|*
name|symp
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|shndx
index|]
expr_stmt|;
comment|/* Return if section has already been read */
if|if
condition|(
name|sect
operator|->
name|symbols
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|sect
operator|->
name|entsize
operator|!=
sizeof|sizeof
argument_list|(
name|sym
operator|.
name|sym32
argument_list|)
condition|)
return|return
name|ELF_ERR_SYMTAB_SIZE
return|;
block|}
else|else
block|{
if|if
condition|(
name|sect
operator|->
name|entsize
operator|!=
sizeof|sizeof
argument_list|(
name|sym
operator|.
name|sym64
argument_list|)
condition|)
return|return
name|ELF_ERR_SYMTAB_SIZE
return|;
block|}
name|nsyms
operator|=
name|sect
operator|->
name|nelems
expr_stmt|;
name|syms
operator|=
operator|(
expr|struct
name|elf_symbol
operator|*
operator|)
call|(
modifier|*
name|ef
operator|->
name|allocate_cb
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_symbol
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
name|ELF_ERR_NOMEM
return|;
comment|/* Read the symbol table */
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
operator|(
name|long
operator|)
name|sect
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|symp
operator|=
operator|&
name|syms
index|[
name|i
index|]
expr_stmt|;
comment|/* Read the next symbol table entry */
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sym
argument_list|,
name|sect
operator|->
name|entsize
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
block|{
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|syms
argument_list|)
expr_stmt|;
return|return
name|ELF_ERR_READ_SYMTAB
return|;
block|}
comment|/* Get fields from appropriate structure */
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Swap bytes if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sym
argument_list|,
name|template_elf32_sym
argument_list|)
expr_stmt|;
name|symp
operator|->
name|name
operator|=
name|sym
operator|.
name|sym32
operator|.
name|st_name
expr_stmt|;
name|symp
operator|->
name|type
operator|=
name|sym
operator|.
name|sym32
operator|.
name|st_info
operator|&
literal|0x0f
expr_stmt|;
name|symp
operator|->
name|shndx
operator|=
name|sym
operator|.
name|sym32
operator|.
name|st_shndx
expr_stmt|;
name|symp
operator|->
name|value
operator|=
name|sym
operator|.
name|sym32
operator|.
name|st_value
expr_stmt|;
block|}
else|else
block|{
comment|/* Swap bytes if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sym
argument_list|,
name|template_elf64_sym
argument_list|)
expr_stmt|;
name|symp
operator|->
name|name
operator|=
name|sym
operator|.
name|sym64
operator|.
name|st_name
expr_stmt|;
name|symp
operator|->
name|type
operator|=
name|sym
operator|.
name|sym64
operator|.
name|st_info
operator|&
literal|0x0f
expr_stmt|;
name|symp
operator|->
name|shndx
operator|=
name|sym
operator|.
name|sym64
operator|.
name|st_shndx
expr_stmt|;
name|symp
operator|->
name|value
operator|=
name|sym
operator|.
name|sym64
operator|.
name|st_value
expr_stmt|;
block|}
name|symp
operator|->
name|namep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Read the symbol string table and convert section names */
comment|/* from string table offsets to pointers */
if|if
condition|(
name|sect
operator|->
name|link
operator|>
literal|0
operator|&&
name|sect
operator|->
name|link
operator|<
name|ef
operator|->
name|shnum
condition|)
block|{
if|if
condition|(
name|elf_read_section
argument_list|(
name|ef
argument_list|,
name|sect
operator|->
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strtab
operator|=
name|ef
operator|->
name|sections
index|[
name|sect
operator|->
name|link
index|]
operator|.
name|contents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|symp
operator|=
operator|&
name|syms
index|[
name|i
index|]
expr_stmt|;
name|symp
operator|->
name|namep
operator|=
name|strtab
operator|+
name|symp
operator|->
name|name
expr_stmt|;
block|}
name|ef
operator|->
name|symbol_strings
operator|=
name|strtab
expr_stmt|;
name|ef
operator|->
name|sections
index|[
name|sect
operator|->
name|link
index|]
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sect
operator|->
name|symbols
operator|=
name|syms
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|template_elf32_phdr
index|[]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|template_elf64_phdr
index|[]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elf_read_prog_hdrs
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|Elf32_Phdr
name|hdr32
decl_stmt|;
name|Elf64_Phdr
name|hdr64
decl_stmt|;
block|}
name|header
union|;
name|uint64_t
name|vaddr
decl_stmt|;
name|uint64_t
name|memsz
decl_stmt|;
name|uint64_t
name|unwind_base
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|ef
operator|->
name|phnum
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|ef
operator|->
name|phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr32
argument_list|)
condition|)
return|return
name|ELF_ERR_PROGHDR_SIZE
return|;
block|}
else|else
block|{
if|if
condition|(
name|ef
operator|->
name|phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr64
argument_list|)
condition|)
return|return
name|ELF_ERR_PROGHDR_SIZE
return|;
block|}
comment|/* Look for the PT_IA_64_UNWIND segment */
comment|/* (That will help us identify the text segment) */
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
operator|(
name|long
operator|)
name|ef
operator|->
name|phoff
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|phnum
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read the next program header */
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|ef
operator|->
name|phentsize
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|ELF_ERR_READ_PROGHDR
return|;
comment|/* Get fields from appropriate structure */
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf32_phdr
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|.
name|hdr32
operator|.
name|p_type
expr_stmt|;
name|vaddr
operator|=
name|header
operator|.
name|hdr32
operator|.
name|p_vaddr
expr_stmt|;
block|}
else|else
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf64_phdr
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|.
name|hdr64
operator|.
name|p_type
expr_stmt|;
name|vaddr
operator|=
name|header
operator|.
name|hdr64
operator|.
name|p_vaddr
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|PT_IA_64_UNWIND
condition|)
block|{
name|unwind_base
operator|=
name|vaddr
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now look for the PT_LOAD segment that includes the unwind segment */
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
operator|(
name|long
operator|)
name|ef
operator|->
name|phoff
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|phnum
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read the next program header */
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|ef
operator|->
name|phentsize
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|ELF_ERR_READ_PROGHDR
return|;
comment|/* Get fields from appropriate structure */
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf32_phdr
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|.
name|hdr32
operator|.
name|p_type
expr_stmt|;
name|vaddr
operator|=
name|header
operator|.
name|hdr32
operator|.
name|p_vaddr
expr_stmt|;
name|memsz
operator|=
name|header
operator|.
name|hdr32
operator|.
name|p_memsz
expr_stmt|;
block|}
else|else
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf64_phdr
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|.
name|hdr64
operator|.
name|p_type
expr_stmt|;
name|vaddr
operator|=
name|header
operator|.
name|hdr64
operator|.
name|p_vaddr
expr_stmt|;
name|memsz
operator|=
name|header
operator|.
name|hdr64
operator|.
name|p_memsz
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|PT_LOAD
operator|&&
name|vaddr
operator|<=
name|unwind_base
operator|&&
name|unwind_base
operator|<
name|vaddr
operator|+
name|memsz
condition|)
block|{
name|ef
operator|->
name|text_base
operator|=
name|vaddr
expr_stmt|;
name|ef
operator|->
name|text_end
operator|=
name|vaddr
operator|+
name|memsz
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|template_elf32_shdr
index|[]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|template_elf64_shdr
index|[]
init|=
block|{
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elf_read_sect_hdrs
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|size
decl_stmt|;
name|int
name|err
decl_stmt|;
union|union
block|{
name|Elf32_Shdr
name|hdr32
decl_stmt|;
name|Elf64_Shdr
name|hdr64
decl_stmt|;
block|}
name|header
union|;
name|struct
name|elf_section
modifier|*
name|sect
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|ef
operator|->
name|shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr32
argument_list|)
condition|)
return|return
name|ELF_ERR_SECTHDR_SIZE
return|;
block|}
else|else
block|{
if|if
condition|(
name|ef
operator|->
name|shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr64
argument_list|)
condition|)
return|return
name|ELF_ERR_SECTHDR_SIZE
return|;
block|}
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
operator|(
name|long
operator|)
name|ef
operator|->
name|shoff
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ef
operator|->
name|sections
operator|=
operator|(
expr|struct
name|elf_section
operator|*
operator|)
call|(
modifier|*
name|ef
operator|->
name|allocate_cb
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_section
argument_list|)
operator|*
name|ef
operator|->
name|shnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|sections
operator|==
name|NULL
condition|)
return|return
name|ELF_ERR_NOMEM
return|;
comment|/* Read the section header table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
comment|/* Read the next section header */
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|ef
operator|->
name|shentsize
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
block|{
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|ef
operator|->
name|sections
argument_list|)
expr_stmt|;
return|return
name|ELF_ERR_READ_SECTHDR
return|;
block|}
comment|/* Get fields from appropriate structure */
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf32_shdr
argument_list|)
expr_stmt|;
name|sect
operator|->
name|type
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_type
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_flags
expr_stmt|;
name|sect
operator|->
name|addr
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_addr
expr_stmt|;
name|sect
operator|->
name|offset
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_offset
expr_stmt|;
name|sect
operator|->
name|size
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_size
expr_stmt|;
name|sect
operator|->
name|link
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_link
expr_stmt|;
name|sect
operator|->
name|info
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_info
expr_stmt|;
name|sect
operator|->
name|entsize
operator|=
name|header
operator|.
name|hdr32
operator|.
name|sh_entsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|template_elf64_shdr
argument_list|)
expr_stmt|;
name|sect
operator|->
name|type
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_type
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_flags
expr_stmt|;
name|sect
operator|->
name|addr
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_addr
expr_stmt|;
name|sect
operator|->
name|offset
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_offset
expr_stmt|;
name|sect
operator|->
name|size
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_size
expr_stmt|;
name|sect
operator|->
name|link
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_link
expr_stmt|;
name|sect
operator|->
name|info
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_info
expr_stmt|;
name|sect
operator|->
name|entsize
operator|=
name|header
operator|.
name|hdr64
operator|.
name|sh_entsize
expr_stmt|;
block|}
name|sect
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|sect
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|entsize
operator|>
literal|0
condition|)
name|sect
operator|->
name|nelems
operator|=
name|sect
operator|->
name|size
operator|/
name|sect
operator|->
name|entsize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|template_elf32_ehdr
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|template_elf64_ehdr
index|[]
init|=
block|{
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elf_read_header
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
union|union
block|{
name|char
name|ident
index|[
name|EI_NIDENT
index|]
decl_stmt|;
name|Elf32_Ehdr
name|hdr32
decl_stmt|;
name|Elf64_Ehdr
name|hdr64
decl_stmt|;
block|}
name|header
union|;
comment|/* Read the ELF header */
name|fseek
argument_list|(
name|ef
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|header
operator|.
name|ident
argument_list|,
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
name|ELF_ERR_NOHEADER
return|;
block|}
comment|/* Verify that this is an ELF file */
if|if
condition|(
name|header
operator|.
name|ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|header
operator|.
name|ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|header
operator|.
name|ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|header
operator|.
name|ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
return|return
name|ELF_ERR_NOTELF
return|;
block|}
comment|/* Get header fields from the byte array e_ident */
comment|/* (These are independent of EI_CLASS and EI_DATA) */
name|ef
operator|->
name|source_class
operator|=
name|header
operator|.
name|ident
index|[
name|EI_CLASS
index|]
expr_stmt|;
name|ef
operator|->
name|source_data
operator|=
name|header
operator|.
name|ident
index|[
name|EI_DATA
index|]
expr_stmt|;
comment|/* Verify EI_CLASS and EI_DATA */
if|if
condition|(
name|header
operator|.
name|ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS32
operator|&&
name|header
operator|.
name|ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS64
condition|)
block|{
return|return
name|ELF_ERR_INVALID_CLASS
return|;
block|}
if|if
condition|(
name|header
operator|.
name|ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELFDATA2LSB
operator|&&
name|header
operator|.
name|ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELFDATA2MSB
condition|)
block|{
return|return
name|ELF_ERR_INVALID_DATA
return|;
block|}
comment|/* Get remaining header fields from appropriate structure */
if|if
condition|(
name|ef
operator|->
name|source_class
operator|==
name|ELFCLASS32
condition|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
operator|.
name|hdr32
operator|+
name|EI_NIDENT
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr32
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|ELF_ERR_NOHEADER
return|;
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
operator|+
name|EI_NIDENT
argument_list|,
name|template_elf32_ehdr
argument_list|)
expr_stmt|;
name|ef
operator|->
name|phoff
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_phoff
expr_stmt|;
name|ef
operator|->
name|shoff
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_shoff
expr_stmt|;
name|ef
operator|->
name|ehsize
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_ehsize
expr_stmt|;
name|ef
operator|->
name|phentsize
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_phentsize
expr_stmt|;
name|ef
operator|->
name|phnum
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_phnum
expr_stmt|;
name|ef
operator|->
name|shentsize
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_shentsize
expr_stmt|;
name|ef
operator|->
name|shnum
operator|=
name|header
operator|.
name|hdr32
operator|.
name|e_shnum
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ehsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr32
argument_list|)
condition|)
block|{
return|return
name|ELF_ERR_HEADER_SIZE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
operator|.
name|hdr64
operator|+
name|EI_NIDENT
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr64
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|ef
operator|->
name|fd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|ELF_ERR_NOHEADER
return|;
comment|/* Swap bytes in header fields if necessary */
if|if
condition|(
name|ef
operator|->
name|source_data
operator|!=
name|ef
operator|->
name|native_data
condition|)
name|elf_swap_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|header
operator|+
name|EI_NIDENT
argument_list|,
name|template_elf64_ehdr
argument_list|)
expr_stmt|;
name|ef
operator|->
name|phoff
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_phoff
expr_stmt|;
name|ef
operator|->
name|shoff
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_shoff
expr_stmt|;
name|ef
operator|->
name|ehsize
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_ehsize
expr_stmt|;
name|ef
operator|->
name|phentsize
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_phentsize
expr_stmt|;
name|ef
operator|->
name|phnum
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_phnum
expr_stmt|;
name|ef
operator|->
name|shentsize
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_shentsize
expr_stmt|;
name|ef
operator|->
name|shnum
operator|=
name|header
operator|.
name|hdr64
operator|.
name|e_shnum
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ehsize
operator|!=
sizeof|sizeof
argument_list|(
name|header
operator|.
name|hdr64
argument_list|)
condition|)
block|{
return|return
name|ELF_ERR_HEADER_SIZE
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|elf_file
modifier|*
name|elf_new
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|)
block|{
name|int
name|native_be
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_file
modifier|*
name|ef
decl_stmt|;
name|ef
operator|=
operator|(
expr|struct
name|elf_file
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Determine the native byte order */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|native_be
expr_stmt|;
name|native_be
operator|=
literal|1
expr_stmt|;
comment|/* Assume big-endian */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Sets be == 0 only if little-endian */
name|ef
operator|->
name|allocate_cb
operator|=
name|env
operator|->
name|allocate_cb
expr_stmt|;
name|ef
operator|->
name|free_cb
operator|=
name|env
operator|->
name|free_cb
expr_stmt|;
name|ef
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|native_data
operator|=
operator|(
name|native_be
condition|?
name|ELFDATA2MSB
else|:
name|ELFDATA2LSB
operator|)
expr_stmt|;
name|ef
operator|->
name|fd
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|source_class
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|source_data
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|phoff
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|shoff
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|text_base
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|text_end
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|ehsize
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|phentsize
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|phnum
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|shentsize
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|shnum
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|symbol_strings
operator|=
name|NULL
expr_stmt|;
name|ef
operator|->
name|nsyms
operator|=
literal|0
expr_stmt|;
return|return
name|ef
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_open
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ef
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|ef
operator|->
name|fd
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|fd
operator|==
name|NULL
condition|)
return|return
name|ELF_ERR_OPEN
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|elf_read_header
argument_list|(
name|ef
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|elf_read_sect_hdrs
argument_list|(
name|ef
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|elf_read_prog_hdrs
argument_list|(
name|ef
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_free_sections
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|elf_section
modifier|*
name|sect
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|contents
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|sect
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sect
operator|->
name|type
operator|==
name|SHT_SYMTAB
operator|||
name|sect
operator|->
name|type
operator|==
name|SHT_DYNSYM
operator|)
operator|&&
name|sect
operator|->
name|symbols
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|sect
operator|->
name|symbols
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|ef
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_close
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
if|if
condition|(
name|ef
operator|->
name|fd
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ef
operator|->
name|fd
argument_list|)
expr_stmt|;
name|ef
operator|->
name|fd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_free
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
name|elf_close
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|sections
operator|!=
name|NULL
condition|)
name|elf_free_sections
argument_list|(
name|ef
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ef
operator|->
name|free_cb
call|)
argument_list|(
name|ef
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_read_symbols
parameter_list|(
name|struct
name|elf_file
modifier|*
name|ef
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|elf_section
modifier|*
name|sect
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ef
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|type
operator|==
name|SHT_SYMTAB
condition|)
block|{
if|if
condition|(
name|elf_read_symtab_section
argument_list|(
name|ef
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ef
operator|->
name|symbols
operator|=
name|sect
operator|->
name|symbols
expr_stmt|;
name|ef
operator|->
name|nsyms
operator|=
name|sect
operator|->
name|nelems
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SYMBOLS
name|printf
argument_list|(
literal|"Read %d symbols from SHT_SYMTAB section\n"
argument_list|,
name|ef
operator|->
name|nsyms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMBOLS */
return|return
literal|0
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ef
operator|->
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|sect
operator|=
operator|&
name|ef
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sect
operator|->
name|type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|elf_read_symtab_section
argument_list|(
name|ef
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ef
operator|->
name|symbols
operator|=
name|sect
operator|->
name|symbols
expr_stmt|;
name|ef
operator|->
name|nsyms
operator|=
name|sect
operator|->
name|nelems
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SYMBOLS
name|printf
argument_list|(
literal|"Read %d symbols from SHT_DYNSYM section\n"
argument_list|,
name|ef
operator|->
name|nsyms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMBOLS */
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
name|UWX_ERR_NOSYM
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SYM_IS_DEFINED
parameter_list|(
name|sym
parameter_list|)
define|\
value|((sym)->shndx != SHN_UNDEF)
end_define

begin_define
define|#
directive|define
name|SYM_IS_IN_TEXT_SEGMENT
parameter_list|(
name|value
parameter_list|)
define|\
value|((value)>= ef->text_base&& (value)< ef->text_end)
end_define

begin_define
define|#
directive|define
name|SYM_HAS_INTERESTING_TYPE
parameter_list|(
name|type
parameter_list|)
value|( \ 		(type) == STT_FUNC || \ 		(type) == STT_OBJECT || \ 		(type) == STT_HP_STUB \ 		)
end_define

begin_define
define|#
directive|define
name|SYM_IS_INTERESTING
parameter_list|(
name|sym
parameter_list|)
value|( \ 		SYM_IS_DEFINED(sym)&& \ 		SYM_IS_IN_TEXT_SEGMENT((sym)->value)&& \ 		SYM_HAS_INTERESTING_TYPE((sym)->type) \ 		)
end_define

begin_function
name|int
name|uwx_read_func_symbols
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_symbol_cache
modifier|*
name|cache
parameter_list|,
name|char
modifier|*
name|module_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|elf_file
modifier|*
name|ef
decl_stmt|;
name|struct
name|elf_symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nfuncsyms
decl_stmt|;
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|uint64_t
modifier|*
name|values
decl_stmt|;
if|if
condition|(
name|module_name
operator|!=
name|NULL
operator|&&
name|cache
operator|->
name|module_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|module_name
argument_list|,
name|cache
operator|->
name|module_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|UWX_OK
return|;
if|if
condition|(
name|cache
operator|->
name|sym_names
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|cache
operator|->
name|sym_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|sym_values
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|cache
operator|->
name|sym_values
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|strings
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|env
operator|->
name|free_cb
call|)
argument_list|(
name|cache
operator|->
name|strings
argument_list|)
expr_stmt|;
name|ef
operator|=
name|elf_new
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|==
name|NULL
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|status
operator|=
name|elf_open
argument_list|(
name|ef
argument_list|,
name|module_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_NOSYM
return|;
name|status
operator|=
name|elf_read_symbols
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_NOSYM
return|;
name|nfuncsyms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|&
name|ef
operator|->
name|symbols
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|SYM_IS_INTERESTING
argument_list|(
name|sym
argument_list|)
condition|)
name|nfuncsyms
operator|++
expr_stmt|;
block|}
name|names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
name|nfuncsyms
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|==
name|NULL
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|values
operator|=
operator|(
name|uint64_t
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
name|nfuncsyms
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|&
name|ef
operator|->
name|symbols
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|SYM_IS_INTERESTING
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|nfuncsyms
condition|)
comment|/* should not happen! */
break|break;
name|names
index|[
name|j
index|]
operator|=
name|sym
operator|->
name|namep
expr_stmt|;
name|values
index|[
name|j
index|]
operator|=
name|sym
operator|->
name|value
operator|-
name|ef
operator|->
name|text_base
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|cache
operator|->
name|module_name
operator|=
operator|(
name|char
operator|*
operator|)
call|(
modifier|*
name|env
operator|->
name|allocate_cb
call|)
argument_list|(
name|strlen
argument_list|(
name|module_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|module_name
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|cache
operator|->
name|module_name
argument_list|,
name|module_name
argument_list|)
expr_stmt|;
name|cache
operator|->
name|nsyms
operator|=
name|nfuncsyms
expr_stmt|;
name|cache
operator|->
name|sym_names
operator|=
name|names
expr_stmt|;
name|cache
operator|->
name|sym_values
operator|=
name|values
expr_stmt|;
name|cache
operator|->
name|strings
operator|=
name|ef
operator|->
name|symbol_strings
expr_stmt|;
name|ef
operator|->
name|symbol_strings
operator|=
name|NULL
expr_stmt|;
block|}
name|elf_close
argument_list|(
name|ef
argument_list|)
expr_stmt|;
name|elf_free
argument_list|(
name|ef
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SYMBOLS
name|printf
argument_list|(
literal|"Cached %d interesting symbols\n"
argument_list|,
name|nfuncsyms
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SYMBOLS */
return|return
name|UWX_OK
return|;
block|}
end_function

end_unit

