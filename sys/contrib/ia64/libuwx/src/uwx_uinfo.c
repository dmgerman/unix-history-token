begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002,2003 Hewlett-Packard Company  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included  * in all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_include
include|#
directive|include
file|"uwx_uinfo.h"
end_include

begin_include
include|#
directive|include
file|"uwx_utable.h"
end_include

begin_include
include|#
directive|include
file|"uwx_scoreboard.h"
end_include

begin_include
include|#
directive|include
file|"uwx_bstream.h"
end_include

begin_include
include|#
directive|include
file|"uwx_trace.h"
end_include

begin_include
include|#
directive|include
file|"uwx_swap.h"
end_include

begin_function_decl
name|int
name|uwx_count_ones
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  uwx_uinfo.c  *  *  This file contains the routines for reading and decoding  *  the unwind information block.   *  *  The main entry point, uwx_decode_uinfo(), is given a pointer  *  to an unwind table entry and a pointer (passed by reference)  *  to be filled in with a pointer to an update vector. It will  *  read and decode the unwind descriptors contained in the  *  unwind information block, then build the register state array,  *  which describes the actions necessary to step from the current  *  frame to the previous one.  */
end_comment

begin_define
define|#
directive|define
name|COPYIN_UINFO_4
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						WORDSZ, env->cb_token) : \ 	(*(uint32_t *)(dest) = *(uint32_t *)(src), WORDSZ) )
end_define

begin_define
define|#
directive|define
name|COPYIN_UINFO_8
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						DWORDSZ, env->cb_token) : \ 	(*(uint64_t *)(dest) = *(uint64_t *)(src), DWORDSZ) )
end_define

begin_comment
comment|/* uwx_default_rstate: Returns the default register state for a leaf routine */
end_comment

begin_function
name|int
name|uwx_default_rstate
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstatep
parameter_list|)
block|{
name|struct
name|uwx_scoreboard
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|uwx_init_scoreboards
argument_list|(
name|env
argument_list|)
expr_stmt|;
operator|*
name|rstatep
operator|=
name|sb
operator|->
name|rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_uinfo: Decodes unwind info region */
end_comment

begin_function
name|int
name|uwx_decode_uinfo
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|rstatep
parameter_list|)
block|{
name|uint64_t
name|uinfohdr
decl_stmt|;
name|unsigned
name|int
name|ulen
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|uwx_bstream
name|bstream
decl_stmt|;
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
decl_stmt|;
name|int
name|ip_slot
decl_stmt|;
name|int
name|cur_slot
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|uwx_rhdr
name|rhdr
decl_stmt|;
comment|/* Remember the offset from the start of the function */
comment|/* to the current IP. This helps the client find */
comment|/* the symbolic information. */
name|env
operator|->
name|function_offset
operator|=
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|-
name|uentry
operator|->
name|code_start
expr_stmt|;
comment|/* Read the unwind info header using the copyin callback. */
comment|/* (If we're reading a 32-bit unwind table, we need to */
comment|/* read the header as two 32-bit pieces to preserve the */
comment|/* guarantee that we always call copyin for aligned */
comment|/* 4-byte or 8-byte chunks.) */
comment|/* Then compute the length of the unwind descriptor */
comment|/* region and initialize a byte stream to read it. */
if|if
condition|(
name|uentry
operator|->
name|unwind_flags
operator|&
name|UNWIND_TBL_32BIT
condition|)
block|{
name|len
operator|=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
argument_list|,
name|uentry
operator|->
name|unwind_info
argument_list|)
expr_stmt|;
name|len
operator|+=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
operator|+
name|WORDSZ
argument_list|,
name|uentry
operator|->
name|unwind_info
operator|+
name|WORDSZ
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
name|COPYIN_UINFO_8
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uinfohdr
argument_list|,
name|uentry
operator|->
name|unwind_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|DWORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UINFO
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
name|uwx_swap8
argument_list|(
operator|&
name|uinfohdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|uentry
operator|->
name|unwind_flags
operator|&
name|UNWIND_TBL_32BIT
condition|)
name|ulen
operator|=
name|UNW_LENGTH
argument_list|(
name|uinfohdr
argument_list|)
operator|*
name|WORDSZ
expr_stmt|;
else|else
name|ulen
operator|=
name|UNW_LENGTH
argument_list|(
name|uinfohdr
argument_list|)
operator|*
name|DWORDSZ
expr_stmt|;
name|uwx_init_bstream
argument_list|(
operator|&
name|bstream
argument_list|,
name|env
argument_list|,
name|uentry
operator|->
name|unwind_info
operator|+
name|DWORDSZ
argument_list|,
name|ulen
argument_list|,
name|UWX_COPYIN_UINFO
argument_list|)
expr_stmt|;
name|TRACE_R_UIB
argument_list|(
argument|uentry
argument_list|,
argument|ulen
argument_list|)
comment|/* Create an initial scoreboard for tracking the unwind state. */
name|scoreboard
operator|=
name|uwx_init_scoreboards
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* Prepare to read and decode the unwind regions described */
comment|/* by the unwind info block. Find the target "ip" slot */
comment|/* relative to the beginning of the region. The lower 4 bits */
comment|/* of the actual IP encode the slot number within a bundle. */
name|cur_slot
operator|=
literal|0
expr_stmt|;
name|ip_slot
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|&
operator|~
literal|0x0fLL
operator|)
operator|-
name|uentry
operator|->
name|code_start
argument_list|)
operator|/
name|BUNDLESZ
operator|*
name|SLOTSPERBUNDLE
operator|+
call|(
name|unsigned
name|int
call|)
argument_list|(
name|env
operator|->
name|context
operator|.
name|special
index|[
name|UWX_REG_IP
index|]
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Loop over the regions in the unwind info block. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Decode the next region header. */
comment|/* We have an error if we reach the end of the info block, */
comment|/* since we should have found our target ip slot by then. */
comment|/* We also have an error if the next byte isn't a region */
comment|/* header record. */
name|status
operator|=
name|uwx_decode_rhdr
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
operator|&
name|rhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
comment|/* If a prologue region, get a new scoreboard, pushing */
comment|/* the previous one onto the prologue stack. Then read */
comment|/* and decode the prologue region records. */
if|if
condition|(
name|rhdr
operator|.
name|is_prologue
condition|)
block|{
name|scoreboard
operator|=
name|uwx_new_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|)
expr_stmt|;
if|if
condition|(
name|scoreboard
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_NOMEM
return|;
name|status
operator|=
name|uwx_decode_prologue
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
name|scoreboard
argument_list|,
operator|&
name|rhdr
argument_list|,
name|ip_slot
argument_list|)
expr_stmt|;
block|}
comment|/* If a body region, read and decode the body region */
comment|/* records. If the body has an epilogue count, */
comment|/* uwx_decode_body will note that in the region header */
comment|/* record for use at the bottom of the loop. */
else|else
block|{
name|status
operator|=
name|uwx_decode_body
argument_list|(
name|env
argument_list|,
operator|&
name|bstream
argument_list|,
name|scoreboard
argument_list|,
operator|&
name|rhdr
argument_list|,
name|ip_slot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
name|status
return|;
name|TRACE_R_DUMP_SB
argument_list|(
argument|scoreboard
argument_list|,
argument|rhdr
argument_list|,
argument|cur_slot
argument_list|,
argument|ip_slot
argument_list|)
comment|/* If the target ip slot is within this region, we're done. */
comment|/* Return the scoreboard's register state array. */
if|if
condition|(
name|ip_slot
operator|<
name|rhdr
operator|.
name|rlen
condition|)
block|{
operator|*
name|rstatep
operator|=
name|scoreboard
operator|->
name|rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
comment|/* Otherwise, update the current ip slot, pop the */
comment|/* scoreboard stack based on the epilogue count, */
comment|/* and loop back around for the next region. */
name|cur_slot
operator|+=
name|rhdr
operator|.
name|rlen
expr_stmt|;
name|ip_slot
operator|-=
name|rhdr
operator|.
name|rlen
expr_stmt|;
if|if
condition|(
name|rhdr
operator|.
name|ecount
operator|>
literal|0
condition|)
block|{
name|scoreboard
operator|=
name|uwx_pop_scoreboards
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|rhdr
operator|.
name|ecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|scoreboard
operator|==
literal|0
condition|)
return|return
name|UWX_ERR_PROLOG_UF
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* uwx_decode_rhdr: Decodes a region header record */
end_comment

begin_function
name|int
name|uwx_decode_rhdr
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|)
block|{
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Get the first byte of the next descriptor record. */
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_NOUDESC
return|;
comment|/* Initialize region header record. */
name|rhdr
operator|->
name|is_prologue
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|grsave
operator|=
literal|0
expr_stmt|;
name|rhdr
operator|->
name|ecount
operator|=
literal|0
expr_stmt|;
comment|/* Format R1 */
if|if
condition|(
name|b0
operator|<
literal|0x40
condition|)
block|{
if|if
condition|(
operator|(
name|b0
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(R1) prologue"
argument_list|,
argument|b0
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(R1) body"
argument_list|,
argument|b0
argument_list|)
block|}
name|rhdr
operator|->
name|rlen
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
block|}
comment|/* Format R2 */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0x60
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_RHDR_2L
argument_list|(
literal|"(R2) prologue_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|val
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
name|rhdr
operator|->
name|rlen
operator|=
operator|(
name|unsigned
name|int
operator|)
name|val
expr_stmt|;
name|rhdr
operator|->
name|mask
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x07
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|rhdr
operator|->
name|grsave
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
block|}
comment|/* Format R3 */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
if|if
condition|(
operator|(
name|b0
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|TRACE_I_DECODE_RHDR_1L
argument_list|(
literal|"(R3) prologue"
argument_list|,
argument|b0
argument_list|,
argument|val
argument_list|)
name|rhdr
operator|->
name|is_prologue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TRACE_I_DECODE_RHDR_1L
argument_list|(
literal|"(R3) body"
argument_list|,
argument|b0
argument_list|,
argument|val
argument_list|)
block|}
name|rhdr
operator|->
name|rlen
operator|=
operator|(
name|unsigned
name|int
operator|)
name|val
expr_stmt|;
block|}
comment|/* Otherwise, not a region header record. */
else|else
block|{
name|TRACE_I_DECODE_RHDR_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_prologue: Decodes a prologue region */
end_comment

begin_function
name|int
name|uwx_decode_prologue
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|,
name|int
name|ip_slot
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|int
name|b2
decl_stmt|;
name|int
name|b3
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|parm1
decl_stmt|;
name|uint64_t
name|parm2
decl_stmt|;
name|uint64_t
name|newrstate
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|tspill
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|priunat_mem_rstate
decl_stmt|;
name|int
name|t_priunat_mem
decl_stmt|;
name|unsigned
name|int
name|gr_mem_mask
decl_stmt|;
name|unsigned
name|int
name|br_mem_mask
decl_stmt|;
name|unsigned
name|int
name|fr_mem_mask
decl_stmt|;
name|unsigned
name|int
name|gr_gr_mask
decl_stmt|;
name|unsigned
name|int
name|br_gr_mask
decl_stmt|;
name|int
name|ngr
decl_stmt|;
name|int
name|nbr
decl_stmt|;
name|int
name|nfr
decl_stmt|;
name|unsigned
name|int
name|spill_base
decl_stmt|;
name|unsigned
name|int
name|gr_base
decl_stmt|;
name|unsigned
name|int
name|br_base
decl_stmt|;
name|unsigned
name|int
name|fr_base
decl_stmt|;
comment|/* Initialize an array of register states from the current */
comment|/* scoreboard, along with a parallel array of spill times. */
comment|/* We use this as a temporary scoreboard, then update the */
comment|/* real scoreboard at the end of the procedure. */
comment|/* We initialize the spill time to (rhdr.rlen - 1) so that */
comment|/* spills without a "when" descriptor will take effect */
comment|/* at the end of the prologue region. */
comment|/* (Boundary condition: all actions in a zero-length prologue */
comment|/* will appear to have happened in the instruction slot */
comment|/* immediately preceding the prologue.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
block|}
name|priunat_mem_rstate
operator|=
name|UWX_DISP_NONE
expr_stmt|;
name|t_priunat_mem
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
name|fr_mem_mask
operator|=
literal|0
expr_stmt|;
name|gr_mem_mask
operator|=
literal|0
expr_stmt|;
name|br_mem_mask
operator|=
literal|0
expr_stmt|;
name|gr_gr_mask
operator|=
literal|0
expr_stmt|;
name|br_gr_mask
operator|=
literal|0
expr_stmt|;
name|nfr
operator|=
literal|0
expr_stmt|;
name|ngr
operator|=
literal|0
expr_stmt|;
name|nbr
operator|=
literal|0
expr_stmt|;
name|spill_base
operator|=
literal|0
expr_stmt|;
comment|/* If prologue_gr header record supplied mask and grsave, */
comment|/* record these in the scoreboard. */
name|reg
operator|=
name|rhdr
operator|->
name|grsave
expr_stmt|;
name|mask
operator|=
name|rhdr
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|mask
operator|&
literal|0x8
condition|)
block|{
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x4
condition|)
block|{
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x2
condition|)
block|{
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x1
condition|)
block|{
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
comment|/* Read prologue descriptor records until */
comment|/* we hit another region header. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
comment|/* Return the last byte read to the byte stream, since it's */
comment|/* really the first byte of the next region header record. */
if|if
condition|(
name|b0
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|uwx_unget_byte
argument_list|(
name|bstream
argument_list|,
name|b0
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|b0
operator|&
literal|0x70
operator|)
operator|>>
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* 1000 xxxx */
case|case
literal|1
case|:
comment|/* 1001 xxxx */
comment|/* Format P1 (br_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P1) br_mem"
argument_list|,
argument|b0
argument_list|)
name|br_mem_mask
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1010 xxxx */
comment|/* Format P2 (br_gr) */
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P2) br_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|mask
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x0f
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|reg
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
name|br_gr_mask
operator|=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_BR
operator|&&
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x01
condition|)
block|{
name|newrstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* 1011 xxxx */
comment|/* Format P3 */
if|if
condition|(
name|b0
operator|<
literal|0xb8
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|r
operator|=
operator|(
operator|(
name|b0
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|b1
operator|>>
literal|7
operator|)
expr_stmt|;
name|reg
operator|=
name|b1
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
comment|/* psp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) psp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* rp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* pfs_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) pfs_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* preds_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) preds_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* unat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) unat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* lc_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) lc_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* rp_br */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rp_br"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_BR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* rnat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) rnat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* bsp_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) bsp_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|9
case|:
comment|/* bspstore_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) bspstore_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
comment|/* Don't track BSPSTORE yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|10
case|:
comment|/* fpsr_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) fpsr_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* priunat_gr */
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) priunat_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
name|newrstate
index|[
name|SBREG_PRIUNAT
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TRACE_I_DECODE_PROLOGUE_2
argument_list|(
literal|"(P3) ??"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Format P4 (spill_mask) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xb8
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P4) spill_mask"
argument_list|,
argument|b0
argument_list|)
comment|/* The spill_mask descriptor is followed by */
comment|/* an imask field whose length is determined */
comment|/* by the region length: there are two mask */
comment|/* bits per instruction slot in the region. */
comment|/* We decode these bits two at a time, counting */
comment|/* the number of FRs, GRs, and BRs that are */
comment|/* saved up to the slot of interest. Other */
comment|/* descriptors describe which sets of these */
comment|/* registers are spilled, and we put those */
comment|/* two pieces of information together at the */
comment|/* end of the main loop. */
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|t
operator|<
name|rhdr
operator|->
name|rlen
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
operator|(
name|t
operator|+
name|i
operator|)
operator|<
name|ip_slot
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|b1
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x00
case|:
break|break;
case|case
literal|0x40
case|:
name|nfr
operator|++
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|ngr
operator|++
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|nbr
operator|++
expr_stmt|;
break|break;
block|}
name|b1
operator|=
name|b1
operator|<<
literal|2
expr_stmt|;
block|}
name|t
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Format P5 (frgr_mem) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xb9
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_4
argument_list|(
literal|"(P5) frgr_mem"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|,
argument|b3
argument_list|)
name|gr_mem_mask
operator|=
name|b1
operator|>>
literal|4
expr_stmt|;
name|fr_mem_mask
operator|=
operator|(
operator|(
name|b1
operator|&
literal|0x0f
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|b2
operator|<<
literal|8
operator|)
operator||
name|b3
expr_stmt|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* 1100 xxxx */
comment|/* Format P6 (fr_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P6) fr_mem"
argument_list|,
argument|b0
argument_list|)
name|fr_mem_mask
operator|=
name|b0
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* 1101 xxxx */
comment|/* Format P6 (gr_mem) */
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(P6) gr_mem"
argument_list|,
argument|b0
argument_list|)
name|gr_mem_mask
operator|=
name|b0
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* 1110 xxxx */
comment|/* Format P7 */
name|r
operator|=
name|b0
operator|&
literal|0xf
expr_stmt|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
comment|/* mem_stack_f */
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_1LL
argument_list|(
literal|"(P7) mem_stack_f"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|,
argument|parm2
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPPLUS
argument_list|(
name|parm2
operator|*
literal|16
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_PSP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* mem_stack_v */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) mem_stack_v"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PSP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* spill_base */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) spill_base"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|spill_base
operator|=
literal|4
operator|*
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* psp_sprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) psp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* rp_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) rp_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_RP
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* rp_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) rp_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* pfs_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) pfs_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PFS
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* pfs_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) pfs_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* preds_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) preds_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PREDS
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* preds_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) preds_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* lc_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) lc_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_LC
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* lc_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) lc_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* unat_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) unat_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_UNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* unat_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) unat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* fpsr_when */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) fpsr_when"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_FPSR
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* fpsr_psprel */
name|TRACE_I_DECODE_PROLOGUE_1L
argument_list|(
literal|"(P7) fpsr_psprel"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|7
case|:
comment|/* 1111 xxxx */
comment|/* Format P8 */
if|if
condition|(
name|b0
operator|==
literal|0xf0
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
switch|switch
condition|(
name|b1
condition|)
block|{
case|case
literal|1
case|:
comment|/* rp_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RP
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* pfs_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) pfs_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PFS
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* preds_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) preds_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_PREDS
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* lc_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) lc_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_LC
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* unat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) unat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_UNAT
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* fpsr_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) fpsr_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_FPSR
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* bsp_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|8
case|:
comment|/* bsp_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|9
case|:
comment|/* bsp_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bsp_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|10
case|:
comment|/* bspstore_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|11
case|:
comment|/* bspstore_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|12
case|:
comment|/* bspstore_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) bspstore_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
comment|/* Don't track BSP yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
break|break;
case|case
literal|13
case|:
comment|/* rnat_when */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_when"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_RNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* rnat_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* rnat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) rnat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|newrstate
index|[
name|SBREG_RNAT
index|]
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* priunat_when_gr */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_when_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|tspill
index|[
name|SBREG_PRIUNAT
index|]
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
case|case
literal|17
case|:
comment|/* priunat_psprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_psprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|priunat_mem_rstate
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
comment|/* priunat_sprel */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_sprel"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|priunat_mem_rstate
operator|=
name|UWX_DISP_SPREL
argument_list|(
name|parm1
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
comment|/* priunat_when_mem */
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) priunat_when_mem"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
name|t_priunat_mem
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
break|break;
default|default:
name|TRACE_I_DECODE_PROLOGUE_2L
argument_list|(
literal|"(P8) ??"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|parm1
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Format P9 (gr_gr) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf1
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_3
argument_list|(
literal|"(P9) gr_gr"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
name|mask
operator|=
name|b1
operator|&
literal|0x0f
expr_stmt|;
name|reg
operator|=
name|b2
operator|&
literal|0x7f
expr_stmt|;
name|gr_gr_mask
operator|=
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSB_GR
operator|&&
name|mask
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x01
condition|)
block|{
name|newrstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_REG
argument_list|(
name|UWX_REG_GR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|++
expr_stmt|;
block|}
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
block|}
comment|/* Format X1 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf9
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X1)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X2 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfa
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X2)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X3 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfb
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X3)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X4 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfc
condition|)
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(X4)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format P10 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xff
condition|)
block|{
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_PROLOGUE_3
argument_list|(
literal|"(P10) abi"
argument_list|,
argument|b0
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
name|env
operator|->
name|abi_context
operator|=
operator|(
name|b1
operator|<<
literal|8
operator|)
operator||
name|b2
expr_stmt|;
return|return
name|UWX_ABI_FRAME
return|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_PROLOGUE_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
break|break;
block|}
block|}
comment|/* Process the masks of spilled GRs, FRs, and BRs to */
comment|/* determine when and where each register was saved. */
name|fr_base
operator|=
name|spill_base
operator|+
literal|16
operator|*
name|uwx_count_ones
argument_list|(
name|fr_mem_mask
argument_list|)
expr_stmt|;
name|br_base
operator|=
name|fr_base
operator|+
literal|8
operator|*
name|uwx_count_ones
argument_list|(
name|br_mem_mask
argument_list|)
expr_stmt|;
name|gr_base
operator|=
name|br_base
operator|+
literal|8
operator|*
name|uwx_count_ones
argument_list|(
name|gr_mem_mask
argument_list|)
expr_stmt|;
name|TRACE_I_DECODE_PROLOGUE_SPILL_BASE
argument_list|(
argument|spill_base
argument_list|)
name|TRACE_I_DECODE_PROLOGUE_MASKS
argument_list|(
argument|gr_mem_mask
argument_list|,
argument|gr_gr_mask
argument_list|)
name|TRACE_I_DECODE_PROLOGUE_NSPILL
argument_list|(
argument|ngr
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ngr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_GR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gr_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|gr_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|gr_base
operator|-=
literal|8
expr_stmt|;
name|ngr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gr_gr_mask
operator|&
literal|1
condition|)
block|{
name|tspill
index|[
name|SBREG_GR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ngr
operator|--
expr_stmt|;
block|}
name|gr_gr_mask
operator|=
name|gr_gr_mask
operator|>>
literal|1
expr_stmt|;
name|gr_mem_mask
operator|=
name|gr_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nbr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_BR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|br_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|br_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|br_base
operator|-=
literal|8
expr_stmt|;
name|nbr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|br_gr_mask
operator|&
literal|1
condition|)
block|{
name|tspill
index|[
name|SBREG_BR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|nbr
operator|--
expr_stmt|;
block|}
name|br_gr_mask
operator|=
name|br_gr_mask
operator|>>
literal|1
expr_stmt|;
name|br_mem_mask
operator|=
name|br_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nfr
operator|>
literal|0
operator|&&
name|i
operator|<=
name|NSB_FR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fr_mem_mask
operator|&
literal|1
condition|)
block|{
name|newrstate
index|[
name|SBREG_FR
operator|+
name|i
index|]
operator|=
name|UWX_DISP_PSPREL
argument_list|(
name|fr_base
argument_list|)
expr_stmt|;
name|tspill
index|[
name|SBREG_FR
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fr_base
operator|-=
literal|16
expr_stmt|;
name|nfr
operator|--
expr_stmt|;
block|}
name|fr_mem_mask
operator|=
name|fr_mem_mask
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Update the scoreboard. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip_slot
operator|>
name|tspill
index|[
name|i
index|]
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|newrstate
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|priunat_mem_rstate
operator|!=
name|UWX_DISP_NONE
operator|&&
name|ip_slot
operator|>
name|t_priunat_mem
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_PRIUNAT
index|]
operator|=
name|priunat_mem_rstate
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_function
name|int
name|uwx_count_ones
parameter_list|(
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x55555555
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xaaaaaaaa
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x33333333
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xcccccccc
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x0f0f0f0f
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xf0f0f0f0
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|&
literal|0x00ff00ff
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xff00ff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|mask
operator|&
literal|0x0000ffff
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* uwx_decode_body: Decodes a body region */
end_comment

begin_function
name|int
name|uwx_decode_body
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|struct
name|uwx_bstream
modifier|*
name|bstream
parameter_list|,
name|struct
name|uwx_scoreboard
modifier|*
name|scoreboard
parameter_list|,
name|struct
name|uwx_rhdr
modifier|*
name|rhdr
parameter_list|,
name|int
name|ip_slot
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|b0
decl_stmt|;
name|int
name|b1
decl_stmt|;
name|int
name|b2
decl_stmt|;
name|int
name|b3
decl_stmt|;
name|int
name|label
decl_stmt|;
name|int
name|ecount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|parm1
decl_stmt|;
name|uint64_t
name|parm2
decl_stmt|;
name|uint64_t
name|newrstate
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|tspill
index|[
name|NSBREG
index|]
decl_stmt|;
name|int
name|t_sp_restore
decl_stmt|;
comment|/* Initialize an array of register states from the current */
comment|/* scoreboard, along with a parallel array of spill times. */
comment|/* We use this as a temporary scoreboard, then update the */
comment|/* real scoreboard at the end of the procedure. */
comment|/* We initialize the spill time to (rhdr.rlen - 1) so that */
comment|/* spills without a "when" descriptor will take effect */
comment|/* at the end of the prologue region. */
comment|/* (Boundary condition: all actions in a zero-length prologue */
comment|/* will appear to have happened in the instruction slot */
comment|/* immediately preceding the prologue.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
block|}
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
literal|1
expr_stmt|;
comment|/* Read body descriptor records until */
comment|/* we hit another region header. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|b0
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b0
operator|<
literal|0x80
condition|)
block|{
comment|/* Return the last byte read to the byte stream, since it's */
comment|/* really the first byte of the next region header record. */
if|if
condition|(
name|b0
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|uwx_unget_byte
argument_list|(
name|bstream
argument_list|,
name|b0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Format B1 (label_state) */
if|if
condition|(
name|b0
operator|<
literal|0xa0
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(B1) label_state"
argument_list|,
argument|b0
argument_list|)
name|label
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_label_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Format B1 (copy_state)  */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0xc0
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(B1) copy_state"
argument_list|,
argument|b0
argument_list|)
name|label
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_copy_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
expr_stmt|;
block|}
block|}
comment|/* Format B2 (epilogue) */
elseif|else
if|if
condition|(
name|b0
operator|<
literal|0xe0
condition|)
block|{
name|ecount
operator|=
name|b0
operator|&
literal|0x1f
expr_stmt|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B2) epilogue"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|rhdr
operator|->
name|ecount
operator|=
name|ecount
operator|+
literal|1
expr_stmt|;
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
block|}
comment|/* Format B3 (epilogue) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xe0
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1LL
argument_list|(
literal|"(B3) epilogue"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|,
argument|parm2
argument_list|)
name|t_sp_restore
operator|=
name|rhdr
operator|->
name|rlen
operator|-
operator|(
name|unsigned
name|int
operator|)
name|parm1
expr_stmt|;
name|rhdr
operator|->
name|ecount
operator|=
operator|(
name|unsigned
name|int
operator|)
name|parm2
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Format B4 (label_state) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf0
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B4) label_state"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|label
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
name|status
operator|=
name|uwx_label_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* Format B4 (copy_state) */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf8
condition|)
block|{
name|status
operator|=
name|uwx_get_uleb128
argument_list|(
name|bstream
argument_list|,
operator|&
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|TRACE_I_DECODE_BODY_1L
argument_list|(
literal|"(B4) copy_state"
argument_list|,
argument|b0
argument_list|,
argument|parm1
argument_list|)
name|label
operator|=
operator|(
name|int
operator|)
name|parm1
expr_stmt|;
name|status
operator|=
name|uwx_copy_scoreboard
argument_list|(
name|env
argument_list|,
name|scoreboard
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|UWX_OK
condition|)
return|return
operator|(
name|status
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
name|newrstate
index|[
name|i
index|]
operator|=
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
expr_stmt|;
name|tspill
index|[
name|i
index|]
operator|=
name|rhdr
operator|->
name|rlen
expr_stmt|;
block|}
block|}
comment|/* Format X1 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xf9
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X1)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X2 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfa
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X2)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X3 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfb
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X3)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Format X4 */
elseif|else
if|if
condition|(
name|b0
operator|==
literal|0xfc
condition|)
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(X4)"
argument_list|,
argument|b0
argument_list|)
name|b1
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b2
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
name|b3
operator|=
name|uwx_get_byte
argument_list|(
name|bstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
operator|<
literal|0
condition|)
return|return
name|UWX_ERR_BADUDESC
return|;
comment|/* Don't support X-format descriptors yet */
return|return
name|UWX_ERR_CANTUNWIND
return|;
block|}
comment|/* Invalid descriptor record */
else|else
block|{
name|TRACE_I_DECODE_BODY_1
argument_list|(
literal|"(?)"
argument_list|,
argument|b0
argument_list|)
return|return
name|UWX_ERR_BADUDESC
return|;
block|}
block|}
comment|/* Update the scoreboard. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip_slot
operator|>
name|tspill
index|[
name|i
index|]
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|newrstate
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If we've passed the point in the epilogue where sp */
comment|/* is restored, update the scoreboard entry for PSP */
comment|/* and reset any entries for registers saved in memory. */
if|if
condition|(
name|ip_slot
operator|>
name|t_sp_restore
condition|)
block|{
name|scoreboard
operator|->
name|rstate
index|[
name|SBREG_PSP
index|]
operator|=
name|UWX_DISP_SPPLUS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|env
operator|->
name|nsbreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|UWX_GET_DISP_CODE
argument_list|(
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
argument_list|)
operator|==
name|UWX_DISP_SPREL
argument_list|(
literal|0
argument_list|)
operator|||
name|UWX_GET_DISP_CODE
argument_list|(
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
argument_list|)
operator|==
name|UWX_DISP_PSPREL
argument_list|(
literal|0
argument_list|)
condition|)
name|scoreboard
operator|->
name|rstate
index|[
name|i
index|]
operator|=
name|UWX_DISP_NONE
expr_stmt|;
block|}
block|}
return|return
name|UWX_OK
return|;
block|}
end_function

end_unit

