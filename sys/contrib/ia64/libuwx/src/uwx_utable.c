begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2003-2006 Hewlett-Packard Development Company, L.P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|"uwx_env.h"
end_include

begin_include
include|#
directive|include
file|"uwx_utable.h"
end_include

begin_include
include|#
directive|include
file|"uwx_swap.h"
end_include

begin_include
include|#
directive|include
file|"uwx_trace.h"
end_include

begin_comment
comment|/*  *  uwx_utable.c  *  *  This file contains the routines for searching an unwind table.  *  The main entry point, uwx_search_utable(), gets the  *  necessary information from the lookup ip callback's result  *  vector, determines whether the table is 32-bit or 64-bit,  *  then invokes the binary search routine for that format.  */
end_comment

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
name|int
name|uwx_search_utable32
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint32_t
name|ip
parameter_list|,
name|uint32_t
name|text_base
parameter_list|,
name|uint32_t
name|unwind_start
parameter_list|,
name|uint32_t
name|unwind_end
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uwx_search_utable64
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|ip
parameter_list|,
name|uint64_t
name|text_base
parameter_list|,
name|uint64_t
name|unwind_start
parameter_list|,
name|uint64_t
name|unwind_end
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* uwx_search_utable: Searches an unwind table for IP in current context */
end_comment

begin_function
name|int
name|uwx_search_utable
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|ip
parameter_list|,
name|uint64_t
modifier|*
name|uvec
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|)
block|{
name|uint64_t
name|text_base
decl_stmt|;
name|uint64_t
name|unwind_flags
decl_stmt|;
name|uint64_t
name|unwind_start
decl_stmt|;
name|uint64_t
name|unwind_end
decl_stmt|;
name|int
name|keys
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Get unwind table information from the result vector. */
comment|/* Make sure all three required values are given. */
name|keys
operator|=
literal|0
expr_stmt|;
name|text_base
operator|=
literal|0
expr_stmt|;
name|unwind_flags
operator|=
literal|0
expr_stmt|;
name|unwind_start
operator|=
literal|0
expr_stmt|;
name|unwind_end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|uvec
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
operator|*
name|uvec
operator|++
condition|)
block|{
case|case
name|UWX_KEY_TBASE
case|:
name|keys
operator||=
literal|1
expr_stmt|;
name|env
operator|->
name|text_base
operator|=
name|text_base
operator|=
operator|*
name|uvec
operator|++
expr_stmt|;
break|break;
case|case
name|UWX_KEY_UFLAGS
case|:
name|unwind_flags
operator|=
operator|*
name|uvec
operator|++
expr_stmt|;
break|break;
case|case
name|UWX_KEY_USTART
case|:
name|keys
operator||=
literal|2
expr_stmt|;
name|unwind_start
operator|=
operator|*
name|uvec
operator|++
expr_stmt|;
break|break;
case|case
name|UWX_KEY_UEND
case|:
name|keys
operator||=
literal|4
expr_stmt|;
name|unwind_end
operator|=
operator|*
name|uvec
operator|++
expr_stmt|;
break|break;
case|case
name|UWX_KEY_GP
case|:
name|uwx_set_reg
argument_list|(
name|env
argument_list|,
name|UWX_REG_GP
argument_list|,
operator|*
name|uvec
operator|++
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|UWX_ERR_BADKEY
return|;
block|}
block|}
if|if
condition|(
name|keys
operator|!=
literal|7
condition|)
return|return
name|UWX_ERR_BADKEY
return|;
comment|/* Copy the unwind flags into the unwind entry. */
comment|/* (uwx_decode_uinfo needs to know whether it's 32-bit or 64-bit.) */
name|uentry
operator|->
name|unwind_flags
operator|=
name|unwind_flags
expr_stmt|;
comment|/* Call the appropriate binary search routine. */
if|if
condition|(
name|unwind_flags
operator|&
name|UNWIND_TBL_32BIT
condition|)
name|status
operator|=
name|uwx_search_utable32
argument_list|(
name|env
argument_list|,
operator|(
name|uint32_t
operator|)
name|ip
argument_list|,
operator|(
name|uint32_t
operator|)
name|text_base
argument_list|,
operator|(
name|uint32_t
operator|)
name|unwind_start
argument_list|,
operator|(
name|uint32_t
operator|)
name|unwind_end
argument_list|,
name|uentry
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|uwx_search_utable64
argument_list|(
name|env
argument_list|,
name|ip
argument_list|,
name|text_base
argument_list|,
name|unwind_start
argument_list|,
name|unwind_end
argument_list|,
name|uentry
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* uwx_search_utable32: Binary search of 32-bit unwind table */
end_comment

begin_define
define|#
directive|define
name|COPYIN_UINFO_4
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \ 	(*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						WORDSZ, env->cb_token) : \ 	(*(uint32_t *)(dest) = *(uint32_t *)(src), WORDSZ) )
end_define

begin_define
define|#
directive|define
name|SWIZZLE
parameter_list|(
name|x
parameter_list|)
value|(((uint64_t)((x)& 0xc0000000)<< 31) | (x))
end_define

begin_function
name|int
name|uwx_search_utable32
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint32_t
name|ip
parameter_list|,
name|uint32_t
name|text_base
parameter_list|,
name|uint32_t
name|unwind_start
parameter_list|,
name|uint32_t
name|unwind_end
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|)
block|{
name|int
name|lb
decl_stmt|;
name|int
name|ub
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint32_t
name|code_start
decl_stmt|;
name|uint32_t
name|code_end
decl_stmt|;
name|uint32_t
name|unwind_info
decl_stmt|;
comment|/* Since the unwind table uses segment-relative offsets, convert */
comment|/* the IP in the current context to a segment-relative offset. */
name|ip
operator|-=
name|text_base
expr_stmt|;
name|TRACE_T_SEARCH32
argument_list|(
argument|ip
argument_list|)
comment|/* Standard binary search. */
comment|/* Might modify this to do interpolation in the future. */
name|lb
operator|=
literal|0
expr_stmt|;
name|ub
operator|=
operator|(
name|unwind_end
operator|-
name|unwind_start
operator|)
operator|/
operator|(
literal|3
operator|*
name|WORDSZ
operator|)
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ub
operator|>
name|lb
condition|)
block|{
name|mid
operator|=
operator|(
name|lb
operator|+
name|ub
operator|)
operator|/
literal|2
expr_stmt|;
name|len
operator|=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|code_start
argument_list|,
call|(
name|uintptr_t
call|)
argument_list|(
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|WORDSZ
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|code_end
argument_list|,
call|(
name|uintptr_t
call|)
argument_list|(
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|WORDSZ
operator|+
name|WORDSZ
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
name|WORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UTBL
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
block|{
name|uwx_swap4
argument_list|(
operator|&
name|code_start
argument_list|)
expr_stmt|;
name|uwx_swap4
argument_list|(
operator|&
name|code_end
argument_list|)
expr_stmt|;
block|}
name|TRACE_T_BINSEARCH32
argument_list|(
argument|lb
argument_list|,
argument|ub
argument_list|,
argument|mid
argument_list|,
argument|code_start
argument_list|,
argument|code_end
argument_list|)
if|if
condition|(
name|ip
operator|>=
name|code_end
condition|)
name|lb
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|<
name|code_start
condition|)
name|ub
operator|=
name|mid
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|ub
operator|<=
name|lb
condition|)
return|return
name|UWX_ERR_NOUENTRY
return|;
name|len
operator|=
name|COPYIN_UINFO_4
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|unwind_info
argument_list|,
call|(
name|uintptr_t
call|)
argument_list|(
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|WORDSZ
operator|+
literal|2
operator|*
name|WORDSZ
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|WORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UTBL
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
name|uwx_swap4
argument_list|(
operator|&
name|unwind_info
argument_list|)
expr_stmt|;
name|uentry
operator|->
name|ptr_size
operator|=
name|WORDSZ
expr_stmt|;
name|uentry
operator|->
name|code_start
operator|=
name|SWIZZLE
argument_list|(
name|text_base
operator|+
name|code_start
argument_list|)
expr_stmt|;
name|uentry
operator|->
name|code_end
operator|=
name|SWIZZLE
argument_list|(
name|text_base
operator|+
name|code_end
argument_list|)
expr_stmt|;
name|uentry
operator|->
name|unwind_info
operator|=
name|SWIZZLE
argument_list|(
name|text_base
operator|+
name|unwind_info
argument_list|)
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

begin_comment
comment|/* uwx_search_utable64: Binary search of 64-bit unwind table */
end_comment

begin_define
define|#
directive|define
name|COPYIN_UINFO_8
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|(env->remote? \       (*env->copyin)(UWX_COPYIN_UINFO, (dest), (src), \ 						DWORDSZ, env->cb_token) : \       (*(uint64_t *)(intptr_t)(dest) = *(uint64_t *)(intptr_t)(src), DWORDSZ) )
end_define

begin_function
name|int
name|uwx_search_utable64
parameter_list|(
name|struct
name|uwx_env
modifier|*
name|env
parameter_list|,
name|uint64_t
name|ip
parameter_list|,
name|uint64_t
name|text_base
parameter_list|,
name|uint64_t
name|unwind_start
parameter_list|,
name|uint64_t
name|unwind_end
parameter_list|,
name|struct
name|uwx_utable_entry
modifier|*
name|uentry
parameter_list|)
block|{
name|int
name|lb
decl_stmt|;
name|int
name|ub
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint64_t
name|code_start
decl_stmt|;
name|uint64_t
name|code_end
decl_stmt|;
name|uint64_t
name|unwind_info
decl_stmt|;
comment|/* Since the unwind table uses segment-relative offsets, convert */
comment|/* the IP in the current context to a segment-relative offset. */
name|ip
operator|-=
name|text_base
expr_stmt|;
comment|/* Standard binary search. */
comment|/* Might modify this to do interpolation in the future. */
name|lb
operator|=
literal|0
expr_stmt|;
name|ub
operator|=
operator|(
name|unwind_end
operator|-
name|unwind_start
operator|)
operator|/
operator|(
literal|3
operator|*
name|DWORDSZ
operator|)
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ub
operator|>
name|lb
condition|)
block|{
name|mid
operator|=
operator|(
name|lb
operator|+
name|ub
operator|)
operator|/
literal|2
expr_stmt|;
name|len
operator|=
name|COPYIN_UINFO_8
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|code_start
argument_list|,
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|DWORDSZ
argument_list|)
expr_stmt|;
name|len
operator|+=
name|COPYIN_UINFO_8
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|code_end
argument_list|,
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|DWORDSZ
operator|+
name|DWORDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
name|DWORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UTBL
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
block|{
name|uwx_swap8
argument_list|(
operator|&
name|code_start
argument_list|)
expr_stmt|;
name|uwx_swap8
argument_list|(
operator|&
name|code_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|>=
name|code_end
condition|)
name|lb
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|<
name|code_start
condition|)
name|ub
operator|=
name|mid
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|ub
operator|<=
name|lb
condition|)
return|return
name|UWX_ERR_NOUENTRY
return|;
name|len
operator|=
name|COPYIN_UINFO_8
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|unwind_info
argument_list|,
name|unwind_start
operator|+
name|mid
operator|*
literal|3
operator|*
name|DWORDSZ
operator|+
literal|2
operator|*
name|DWORDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|DWORDSZ
condition|)
return|return
name|UWX_ERR_COPYIN_UTBL
return|;
if|if
condition|(
name|env
operator|->
name|byte_swap
condition|)
name|uwx_swap8
argument_list|(
operator|&
name|unwind_info
argument_list|)
expr_stmt|;
name|uentry
operator|->
name|ptr_size
operator|=
name|DWORDSZ
expr_stmt|;
name|uentry
operator|->
name|code_start
operator|=
name|text_base
operator|+
name|code_start
expr_stmt|;
name|uentry
operator|->
name|code_end
operator|=
name|text_base
operator|+
name|code_end
expr_stmt|;
name|uentry
operator|->
name|unwind_info
operator|=
name|text_base
operator|+
name|unwind_info
expr_stmt|;
return|return
name|UWX_OK
return|;
block|}
end_function

end_unit

