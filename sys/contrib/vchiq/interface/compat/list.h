begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: list.h,v 1.5 2014/08/20 15:26:52 riastradh Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2013 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Taylor R. Campbell.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Notes on porting:  *  * - LIST_HEAD(x) means a declaration `struct list_head x =  *   LIST_HEAD_INIT(x)' in Linux, but something else in NetBSD.  *   Replace by the expansion.  *  * - The `_rcu' routines here are not actually pserialize(9)-safe.  *   They need dependent read memory barriers added.  Please fix this  *   if you need to use them with pserialize(9).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LINUX_LIST_H_
end_ifndef

begin_define
define|#
directive|define
name|_LINUX_LIST_H_
end_define

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_define
define|#
directive|define
name|container_of
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|({								\ 	__typeof(((type *)0)->member) *_p = (ptr);		\ 	(type *)((char *)_p - offsetof(type, member));		\ })
end_define

begin_comment
comment|/*  * Doubly-linked lists.  */
end_comment

begin_struct
struct|struct
name|list_head
block|{
name|struct
name|list_head
modifier|*
name|prev
decl_stmt|;
name|struct
name|list_head
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIST_HEAD_INIT
parameter_list|(
name|name
parameter_list|)
value|{ .prev =&(name), .next =&(name) }
end_define

begin_function
specifier|static
specifier|inline
name|void
name|INIT_LIST_HEAD
parameter_list|(
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|head
operator|->
name|prev
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|list_head
modifier|*
name|list_first
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
name|head
operator|->
name|next
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|list_head
modifier|*
name|list_last
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
name|head
operator|->
name|prev
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|list_head
modifier|*
name|list_next
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|next
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|list_head
modifier|*
name|list_prev
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|prev
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|list_empty
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
return|return
operator|(
name|head
operator|->
name|next
operator|==
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|list_is_singular
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
name|list_empty
argument_list|(
name|head
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|head
operator|->
name|next
operator|!=
name|head
operator|->
name|prev
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__list_add_between
parameter_list|(
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
name|struct
name|list_head
modifier|*
name|node
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
block|{
name|prev
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_add
parameter_list|(
name|struct
name|list_head
modifier|*
name|node
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_add_between
argument_list|(
name|head
argument_list|,
name|node
argument_list|,
name|head
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_add_tail
parameter_list|(
name|struct
name|list_head
modifier|*
name|node
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|__list_add_between
argument_list|(
name|head
operator|->
name|prev
argument_list|,
name|node
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_del
parameter_list|(
name|struct
name|list_head
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|prev
operator|->
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__list_splice_between
parameter_list|(
name|struct
name|list_head
modifier|*
name|prev
parameter_list|,
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|first
init|=
name|list
operator|->
name|next
decl_stmt|;
name|struct
name|list_head
modifier|*
name|last
init|=
name|list
operator|->
name|prev
decl_stmt|;
name|first
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_splice
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
name|__list_splice_between
argument_list|(
name|head
argument_list|,
name|list
argument_list|,
name|head
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_splice_tail
parameter_list|(
specifier|const
name|struct
name|list_head
modifier|*
name|list
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list_empty
argument_list|(
name|list
argument_list|)
condition|)
name|__list_splice_between
argument_list|(
name|head
operator|->
name|prev
argument_list|,
name|list
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_move
parameter_list|(
name|struct
name|list_head
modifier|*
name|node
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|list_del
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
name|node
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_move_tail
parameter_list|(
name|struct
name|list_head
modifier|*
name|node
parameter_list|,
name|struct
name|list_head
modifier|*
name|head
parameter_list|)
block|{
name|list_del
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|node
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_replace
parameter_list|(
name|struct
name|list_head
modifier|*
name|old
parameter_list|,
name|struct
name|list_head
modifier|*
name|new
parameter_list|)
block|{
name|new
operator|->
name|prev
operator|=
name|old
operator|->
name|prev
expr_stmt|;
name|old
operator|->
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|->
name|prev
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|list_del_init
parameter_list|(
name|struct
name|list_head
modifier|*
name|node
parameter_list|)
block|{
name|list_del
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|list_entry
parameter_list|(
name|PTR
parameter_list|,
name|TYPE
parameter_list|,
name|FIELD
parameter_list|)
value|container_of(PTR, TYPE, FIELD)
end_define

begin_define
define|#
directive|define
name|list_first_entry
parameter_list|(
name|PTR
parameter_list|,
name|TYPE
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|list_entry(list_first((PTR)), TYPE, FIELD)
end_define

begin_define
define|#
directive|define
name|list_last_entry
parameter_list|(
name|PTR
parameter_list|,
name|TYPE
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|list_entry(list_last((PTR)), TYPE, FIELD)
end_define

begin_define
define|#
directive|define
name|list_next_entry
parameter_list|(
name|ENTRY
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|list_entry(list_next(&(ENTRY)->FIELD), typeof(*(ENTRY)), FIELD)
end_define

begin_define
define|#
directive|define
name|list_prev_entry
parameter_list|(
name|ENTRY
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|list_entry(list_prev(&(ENTRY)->FIELD), typeof(*(ENTRY)), FIELD)
end_define

begin_define
define|#
directive|define
name|list_for_each
parameter_list|(
name|VAR
parameter_list|,
name|HEAD
parameter_list|)
define|\
value|for ((VAR) = list_first((HEAD));				\ 		(VAR) != (HEAD);					\ 		(VAR) = list_next((VAR)))
end_define

begin_define
define|#
directive|define
name|list_for_each_safe
parameter_list|(
name|VAR
parameter_list|,
name|NEXT
parameter_list|,
name|HEAD
parameter_list|)
define|\
value|for ((VAR) = list_first((HEAD));				\ 		((VAR) != (HEAD))&& ((NEXT) = list_next((VAR)), 1);	\ 		(VAR) = (NEXT))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry
parameter_list|(
name|VAR
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for ((VAR) = list_entry(list_first((HEAD)), typeof(*(VAR)), FIELD); \&(VAR)->FIELD != (HEAD);				\ 		(VAR) = list_entry(list_next(&(VAR)->FIELD), typeof(*(VAR)), \ 		    FIELD))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry_reverse
parameter_list|(
name|VAR
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for ((VAR) = list_entry(list_last((HEAD)), typeof(*(VAR)), FIELD); \&(VAR)->FIELD != (HEAD);				\ 		(VAR) = list_entry(list_prev(&(VAR)->FIELD), typeof(*(VAR)), \ 		    FIELD))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry_safe
parameter_list|(
name|VAR
parameter_list|,
name|NEXT
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for ((VAR) = list_entry(list_first((HEAD)), typeof(*(VAR)), FIELD); \ 		(&(VAR)->FIELD != (HEAD))&&				\ 		    ((NEXT) = list_entry(list_next(&(VAR)->FIELD),	\ 			typeof(*(VAR)), FIELD), 1);			\ 		(VAR) = (NEXT))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry_continue
parameter_list|(
name|VAR
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for ((VAR) = list_next_entry((VAR), FIELD);			\&(VAR)->FIELD != (HEAD);				\ 		(VAR) = list_next_entry((VAR), FIELD))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry_continue_reverse
parameter_list|(
name|VAR
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for ((VAR) = list_prev_entry((VAR), FIELD);			\&(VAR)->FIELD != (HEAD);				\ 		(VAR) = list_prev_entry((VAR), FIELD))
end_define

begin_define
define|#
directive|define
name|list_for_each_entry_safe_from
parameter_list|(
name|VAR
parameter_list|,
name|NEXT
parameter_list|,
name|HEAD
parameter_list|,
name|FIELD
parameter_list|)
define|\
value|for (;								\ 		(&(VAR)->FIELD != (HEAD))&&				\ 		    ((NEXT) = list_next_entry((VAR), FIELD));		\ 		(VAR) = (NEXT))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LINUX_LIST_H_ */
end_comment

end_unit

