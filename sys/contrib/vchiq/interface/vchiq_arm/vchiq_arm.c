begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2014 Raspberry Pi (Trading) Ltd. All rights reserved.  * Copyright (c) 2010-2012 Broadcom. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the above-listed copyright holders may not be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2, as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"vchiq_core.h"
end_include

begin_include
include|#
directive|include
file|"vchiq_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"vchiq_arm.h"
end_include

begin_define
define|#
directive|define
name|DEVICE_NAME
value|"vchiq"
end_define

begin_comment
comment|/* Override the default prefix, which would be vchiq_arm (from the filename) */
end_comment

begin_undef
undef|#
directive|undef
name|MODULE_PARAM_PREFIX
end_undef

begin_define
define|#
directive|define
name|MODULE_PARAM_PREFIX
value|DEVICE_NAME "."
end_define

begin_define
define|#
directive|define
name|VCHIQ_MINOR
value|0
end_define

begin_comment
comment|/* Some per-instance constants */
end_comment

begin_define
define|#
directive|define
name|MAX_COMPLETIONS
value|16
end_define

begin_define
define|#
directive|define
name|MAX_SERVICES
value|64
end_define

begin_define
define|#
directive|define
name|MAX_ELEMENTS
value|8
end_define

begin_define
define|#
directive|define
name|MSG_QUEUE_SIZE
value|64
end_define

begin_define
define|#
directive|define
name|KEEPALIVE_VER
value|1
end_define

begin_define
define|#
directive|define
name|KEEPALIVE_VER_MIN
value|KEEPALIVE_VER
end_define

begin_comment
comment|/* Run time control of log level, based on KERN_XXX level. */
end_comment

begin_decl_stmt
name|int
name|vchiq_arm_log_level
init|=
name|VCHIQ_LOG_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vchiq_susp_log_level
init|=
name|VCHIQ_LOG_ERROR
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SUSPEND_TIMER_TIMEOUT_MS
value|100
end_define

begin_define
define|#
directive|define
name|SUSPEND_RETRY_TIMER_TIMEOUT_MS
value|1000
end_define

begin_define
define|#
directive|define
name|VC_SUSPEND_NUM_OFFSET
value|3
end_define

begin_comment
comment|/* number of values before idle which are -ve */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suspend_state_names
index|[]
init|=
block|{
literal|"VC_SUSPEND_FORCE_CANCELED"
block|,
literal|"VC_SUSPEND_REJECTED"
block|,
literal|"VC_SUSPEND_FAILED"
block|,
literal|"VC_SUSPEND_IDLE"
block|,
literal|"VC_SUSPEND_REQUESTED"
block|,
literal|"VC_SUSPEND_IN_PROGRESS"
block|,
literal|"VC_SUSPEND_SUSPENDED"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VC_RESUME_NUM_OFFSET
value|1
end_define

begin_comment
comment|/* number of values before idle which are -ve */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|resume_state_names
index|[]
init|=
block|{
literal|"VC_RESUME_FAILED"
block|,
literal|"VC_RESUME_IDLE"
block|,
literal|"VC_RESUME_REQUESTED"
block|,
literal|"VC_RESUME_IN_PROGRESS"
block|,
literal|"VC_RESUME_RESUMED"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times we allow force suspend to timeout before actually ** _forcing_ suspend.  This is to cater for SW which fails to release vchiq ** correctly - we don't want to prevent ARM suspend indefinitely in this case. */
end_comment

begin_define
define|#
directive|define
name|FORCE_SUSPEND_FAIL_MAX
value|8
end_define

begin_comment
comment|/* The time in ms allowed for videocore to go idle when force suspend has been  * requested */
end_comment

begin_define
define|#
directive|define
name|FORCE_SUSPEND_TIMEOUT_MS
value|200
end_define

begin_function_decl
specifier|static
name|void
name|suspend_timer_callback
parameter_list|(
name|unsigned
name|long
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|int
name|vchiq_proc_add_instance
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vchiq_proc_remove_instance
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|user_service_struct
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service
decl_stmt|;
name|void
modifier|*
name|userdata
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|char
name|is_vchi
decl_stmt|;
name|char
name|dequeue_pending
decl_stmt|;
name|char
name|close_pending
decl_stmt|;
name|int
name|message_available_pos
decl_stmt|;
name|int
name|msg_insert
decl_stmt|;
name|int
name|msg_remove
decl_stmt|;
name|struct
name|semaphore
name|insert_event
decl_stmt|;
name|struct
name|semaphore
name|remove_event
decl_stmt|;
name|struct
name|semaphore
name|close_event
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|msg_queue
index|[
name|MSG_QUEUE_SIZE
index|]
decl_stmt|;
block|}
name|USER_SERVICE_T
typedef|;
end_typedef

begin_struct
struct|struct
name|bulk_waiter_node
block|{
name|struct
name|bulk_waiter
name|bulk_waiter
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|vchiq_instance_struct
block|{
name|VCHIQ_STATE_T
modifier|*
name|state
decl_stmt|;
name|VCHIQ_COMPLETION_DATA_T
name|completions
index|[
name|MAX_COMPLETIONS
index|]
decl_stmt|;
name|int
name|completion_insert
decl_stmt|;
name|int
name|completion_remove
decl_stmt|;
name|struct
name|semaphore
name|insert_event
decl_stmt|;
name|struct
name|semaphore
name|remove_event
decl_stmt|;
name|struct
name|mutex
name|completion_mutex
decl_stmt|;
name|int
name|connected
decl_stmt|;
name|int
name|closing
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|mark
decl_stmt|;
name|int
name|use_close_delivered
decl_stmt|;
name|int
name|trace
decl_stmt|;
name|struct
name|list_head
name|bulk_waiter_list
decl_stmt|;
name|struct
name|mutex
name|bulk_waiter_list_mutex
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|VCHIQ_DEBUGFS_NODE_T
name|proc_entry
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|dump_context_struct
block|{
name|char
name|__user
modifier|*
name|buf
decl_stmt|;
name|size_t
name|actual
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|loff_t
name|offset
decl_stmt|;
block|}
name|DUMP_CONTEXT_T
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|vchiq_cdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VCHIQ_STATE_T
name|g_state
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_SPINLOCK
argument_list|(
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ioctl_names
index|[]
init|=
block|{
literal|"CONNECT"
block|,
literal|"SHUTDOWN"
block|,
literal|"CREATE_SERVICE"
block|,
literal|"REMOVE_SERVICE"
block|,
literal|"QUEUE_MESSAGE"
block|,
literal|"QUEUE_BULK_TRANSMIT"
block|,
literal|"QUEUE_BULK_RECEIVE"
block|,
literal|"AWAIT_COMPLETION"
block|,
literal|"DEQUEUE_MESSAGE"
block|,
literal|"GET_CLIENT_ID"
block|,
literal|"GET_CONFIG"
block|,
literal|"CLOSE_SERVICE"
block|,
literal|"USE_SERVICE"
block|,
literal|"RELEASE_SERVICE"
block|,
literal|"SET_SERVICE_OPTION"
block|,
literal|"DUMP_PHYS_MEM"
block|,
literal|"LIB_VERSION"
block|,
literal|"CLOSE_DELIVERED"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|vchiq_static_assert
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|ioctl_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ioctl_names
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
operator|(
name|VCHIQ_IOC_MAX
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|vchiq_ehtag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|vchiq_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|vchiq_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|vchiq_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|vchiq_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|vchiq_ioctl
block|,
operator|.
name|d_open
operator|=
name|vchiq_open
block|,
operator|.
name|d_close
operator|=
name|vchiq_close
block|,
operator|.
name|d_name
operator|=
name|DEVICE_NAME
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_phys_mem(void *virt_addr, uint32_t num_bytes);
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************** * *   add_completion * ***************************************************************************/
end_comment

begin_function
specifier|static
name|VCHIQ_STATUS_T
name|add_completion
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|,
name|VCHIQ_REASON_T
name|reason
parameter_list|,
name|VCHIQ_HEADER_T
modifier|*
name|header
parameter_list|,
name|USER_SERVICE_T
modifier|*
name|user_service
parameter_list|,
name|void
modifier|*
name|bulk_userdata
parameter_list|)
block|{
name|VCHIQ_COMPLETION_DATA_T
modifier|*
name|completion
decl_stmt|;
name|DEBUG_INITIALISE
argument_list|(
argument|g_state.local
argument_list|)
while|while
condition|(
name|instance
operator|->
name|completion_insert
operator|==
operator|(
name|instance
operator|->
name|completion_remove
operator|+
name|MAX_COMPLETIONS
operator|)
condition|)
block|{
comment|/* Out of space - wait for the client */
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|vchiq_log_trace
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"add_completion - completion queue full"
argument_list|)
expr_stmt|;
name|DEBUG_COUNT
argument_list|(
name|COMPLETION_QUEUE_FULL_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|down_interruptible
argument_list|(
operator|&
name|instance
operator|->
name|remove_event
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback interrupted"
argument_list|)
expr_stmt|;
return|return
name|VCHIQ_RETRY
return|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|closing
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback closing"
argument_list|)
expr_stmt|;
return|return
name|VCHIQ_ERROR
return|;
block|}
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
block|}
name|completion
operator|=
operator|&
name|instance
operator|->
name|completions
index|[
name|instance
operator|->
name|completion_insert
operator|&
operator|(
name|MAX_COMPLETIONS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|completion
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|completion
operator|->
name|reason
operator|=
name|reason
expr_stmt|;
comment|/* N.B. service_userdata is updated while processing AWAIT_COMPLETION */
name|completion
operator|->
name|service_userdata
operator|=
name|user_service
operator|->
name|service
expr_stmt|;
name|completion
operator|->
name|bulk_userdata
operator|=
name|bulk_userdata
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|VCHIQ_SERVICE_CLOSED
condition|)
block|{
comment|/* Take an extra reference, to be held until 		   this CLOSED notification is delivered. */
name|lock_service
argument_list|(
name|user_service
operator|->
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|->
name|use_close_delivered
condition|)
name|user_service
operator|->
name|close_pending
operator|=
literal|1
expr_stmt|;
block|}
comment|/* A write barrier is needed here to ensure that the entire completion 		record is written out before the insert point. */
name|wmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|VCHIQ_MESSAGE_AVAILABLE
condition|)
name|user_service
operator|->
name|message_available_pos
operator|=
name|instance
operator|->
name|completion_insert
expr_stmt|;
name|instance
operator|->
name|completion_insert
operator|++
expr_stmt|;
name|up
argument_list|(
operator|&
name|instance
operator|->
name|insert_event
argument_list|)
expr_stmt|;
return|return
name|VCHIQ_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   service_callback * ***************************************************************************/
end_comment

begin_function
specifier|static
name|VCHIQ_STATUS_T
name|service_callback
parameter_list|(
name|VCHIQ_REASON_T
name|reason
parameter_list|,
name|VCHIQ_HEADER_T
modifier|*
name|header
parameter_list|,
name|VCHIQ_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
name|bulk_userdata
parameter_list|)
block|{
comment|/* How do we ensure the callback goes to the right client? 	** The service_user data points to a USER_SERVICE_T record containing 	** the original callback and the user state structure, which contains a 	** circular buffer for completion records. 	*/
name|USER_SERVICE_T
modifier|*
name|user_service
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|DEBUG_INITIALISE
argument_list|(
argument|g_state.local
argument_list|)
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|service
operator|=
name|handle_to_service
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|service
argument_list|)
expr_stmt|;
name|user_service
operator|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
expr_stmt|;
name|instance
operator|=
name|user_service
operator|->
name|instance
expr_stmt|;
if|if
condition|(
operator|!
name|instance
operator|||
name|instance
operator|->
name|closing
condition|)
return|return
name|VCHIQ_SUCCESS
return|;
name|vchiq_log_trace
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback - service %lx(%d,%p), reason %d, header %lx, "
literal|"instance %lx, bulk_userdata %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|user_service
argument_list|,
name|service
operator|->
name|localport
argument_list|,
name|user_service
operator|->
name|userdata
argument_list|,
name|reason
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|instance
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bulk_userdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|&&
name|user_service
operator|->
name|is_vchi
condition|)
block|{
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
while|while
condition|(
name|user_service
operator|->
name|msg_insert
operator|==
operator|(
name|user_service
operator|->
name|msg_remove
operator|+
name|MSG_QUEUE_SIZE
operator|)
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|DEBUG_COUNT
argument_list|(
name|MSG_QUEUE_FULL_COUNT
argument_list|)
expr_stmt|;
name|vchiq_log_trace
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback - msg queue full"
argument_list|)
expr_stmt|;
comment|/* If there is no MESSAGE_AVAILABLE in the completion 			** queue, add one 			*/
if|if
condition|(
operator|(
name|user_service
operator|->
name|message_available_pos
operator|-
name|instance
operator|->
name|completion_remove
operator|)
operator|<
literal|0
condition|)
block|{
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"Inserting extra MESSAGE_AVAILABLE"
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|status
operator|=
name|add_completion
argument_list|(
name|instance
argument_list|,
name|reason
argument_list|,
name|NULL
argument_list|,
name|user_service
argument_list|,
name|bulk_userdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|down_interruptible
argument_list|(
operator|&
name|user_service
operator|->
name|remove_event
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback interrupted"
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
return|return
name|VCHIQ_RETRY
return|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|->
name|closing
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"service_callback closing"
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
return|return
name|VCHIQ_ERROR
return|;
block|}
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
block|}
name|user_service
operator|->
name|msg_queue
index|[
name|user_service
operator|->
name|msg_insert
operator|&
operator|(
name|MSG_QUEUE_SIZE
operator|-
literal|1
operator|)
index|]
operator|=
name|header
expr_stmt|;
name|user_service
operator|->
name|msg_insert
operator|++
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|user_service
operator|->
name|insert_event
argument_list|)
expr_stmt|;
comment|/* If there is a thread waiting in DEQUEUE_MESSAGE, or if 		** there is a MESSAGE_AVAILABLE in the completion queue then 		** bypass the completion queue. 		*/
if|if
condition|(
operator|(
operator|(
name|user_service
operator|->
name|message_available_pos
operator|-
name|instance
operator|->
name|completion_remove
operator|)
operator|>=
literal|0
operator|)
operator|||
name|user_service
operator|->
name|dequeue_pending
condition|)
block|{
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
name|user_service
operator|->
name|dequeue_pending
operator|=
literal|0
expr_stmt|;
return|return
name|VCHIQ_SUCCESS
return|;
block|}
name|header
operator|=
name|NULL
expr_stmt|;
block|}
name|DEBUG_TRACE
argument_list|(
name|SERVICE_CALLBACK_LINE
argument_list|)
expr_stmt|;
return|return
name|add_completion
argument_list|(
name|instance
argument_list|,
name|reason
argument_list|,
name|header
argument_list|,
name|user_service
argument_list|,
name|bulk_userdata
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   user_service_free * ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|user_service_free
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
name|userdata
decl_stmt|;
name|_sema_destroy
argument_list|(
operator|&
name|user_service
operator|->
name|insert_event
argument_list|)
expr_stmt|;
name|_sema_destroy
argument_list|(
operator|&
name|user_service
operator|->
name|remove_event
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|user_service
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   close_delivered * ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|close_delivered
parameter_list|(
name|USER_SERVICE_T
modifier|*
name|user_service
parameter_list|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"close_delivered(handle=%x)"
argument_list|,
name|user_service
operator|->
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_service
operator|->
name|close_pending
condition|)
block|{
comment|/* Allow the underlying service to be culled */
name|unlock_service
argument_list|(
name|user_service
operator|->
name|service
argument_list|)
expr_stmt|;
comment|/* Wake the user-thread blocked in close_ or remove_service */
name|up
argument_list|(
operator|&
name|user_service
operator|->
name|close_event
argument_list|)
expr_stmt|;
name|user_service
operator|->
name|close_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_ioctl * ***************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|vchiq_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|cdev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DEBUG_INITIALISE
argument_list|(
argument|g_state.local
argument_list|)
if|if
condition|(
operator|(
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|instance
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"vchiq_ioctl: devfs_get_cdevpriv failed: error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* XXXBSD: HACK! */
define|#
directive|define
name|_IOC_NR
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
define|#
directive|define
name|_IOC_TYPE
parameter_list|(
name|x
parameter_list|)
value|IOCGROUP(x)
name|vchiq_log_trace
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq_ioctl - instance %x, cmd %s, arg %p"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|instance
argument_list|,
operator|(
operator|(
name|_IOC_TYPE
argument_list|(
name|cmd
argument_list|)
operator|==
name|VCHIQ_IOC_MAGIC
operator|)
operator|&&
operator|(
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
operator|<=
name|VCHIQ_IOC_MAX
operator|)
operator|)
condition|?
name|ioctl_names
index|[
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
index|]
else|:
literal|"<invalid>"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VCHIQ_IOC_SHUTDOWN
case|:
if|if
condition|(
operator|!
name|instance
operator|->
name|connected
condition|)
break|break;
comment|/* Remove all services */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|service
operator|=
name|next_service_by_instance
argument_list|(
name|instance
operator|->
name|state
argument_list|,
name|instance
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|vchiq_remove_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
break|break;
block|}
name|service
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
block|{
comment|/* Wake the completion thread and ask it to exit */
name|instance
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|up
argument_list|(
operator|&
name|instance
operator|->
name|insert_event
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_CONNECT
case|:
if|if
condition|(
name|instance
operator|->
name|connected
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rc
operator|=
name|lmutex_lock_interruptible
argument_list|(
operator|&
name|instance
operator|->
name|state
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq: connect: could not lock mutex for "
literal|"state %d: %d"
argument_list|,
name|instance
operator|->
name|state
operator|->
name|id
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINTR
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|vchiq_connect_internal
argument_list|(
name|instance
operator|->
name|state
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|state
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
name|instance
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
else|else
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq: could not connect: %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCHIQ_IOC_CREATE_SERVICE
case|:
block|{
name|VCHIQ_CREATE_SERVICE_T
name|args
decl_stmt|;
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|userdata
decl_stmt|;
name|int
name|srvstate
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|user_service
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|USER_SERVICE_T
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_service
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|args
operator|.
name|is_open
condition|)
block|{
if|if
condition|(
operator|!
name|instance
operator|->
name|connected
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOTCONN
expr_stmt|;
name|kfree
argument_list|(
name|user_service
argument_list|)
expr_stmt|;
break|break;
block|}
name|srvstate
operator|=
name|VCHIQ_SRVSTATE_OPENING
expr_stmt|;
block|}
else|else
block|{
name|srvstate
operator|=
name|instance
operator|->
name|connected
condition|?
name|VCHIQ_SRVSTATE_LISTENING
else|:
name|VCHIQ_SRVSTATE_HIDDEN
expr_stmt|;
block|}
name|userdata
operator|=
name|args
operator|.
name|params
operator|.
name|userdata
expr_stmt|;
name|args
operator|.
name|params
operator|.
name|callback
operator|=
name|service_callback
expr_stmt|;
name|args
operator|.
name|params
operator|.
name|userdata
operator|=
name|user_service
expr_stmt|;
name|service
operator|=
name|vchiq_add_service_internal
argument_list|(
name|instance
operator|->
name|state
argument_list|,
operator|&
name|args
operator|.
name|params
argument_list|,
name|srvstate
argument_list|,
name|instance
argument_list|,
name|user_service_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
block|{
name|user_service
operator|->
name|service
operator|=
name|service
expr_stmt|;
name|user_service
operator|->
name|userdata
operator|=
name|userdata
expr_stmt|;
name|user_service
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|user_service
operator|->
name|is_vchi
operator|=
operator|(
name|args
operator|.
name|is_vchi
operator|!=
literal|0
operator|)
expr_stmt|;
name|user_service
operator|->
name|dequeue_pending
operator|=
literal|0
expr_stmt|;
name|user_service
operator|->
name|close_pending
operator|=
literal|0
expr_stmt|;
name|user_service
operator|->
name|message_available_pos
operator|=
name|instance
operator|->
name|completion_remove
operator|-
literal|1
expr_stmt|;
name|user_service
operator|->
name|msg_insert
operator|=
literal|0
expr_stmt|;
name|user_service
operator|->
name|msg_remove
operator|=
literal|0
expr_stmt|;
name|_sema_init
argument_list|(
operator|&
name|user_service
operator|->
name|insert_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_sema_init
argument_list|(
operator|&
name|user_service
operator|->
name|remove_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_sema_init
argument_list|(
operator|&
name|user_service
operator|->
name|close_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|is_open
condition|)
block|{
name|status
operator|=
name|vchiq_open_service_internal
argument_list|(
name|service
argument_list|,
name|instance
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_remove_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
operator|(
name|status
operator|==
name|VCHIQ_RETRY
operator|)
condition|?
operator|-
name|EINTR
else|:
operator|-
name|EIO
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|VCHIQ_IOCTL_DEBUG
name|printf
argument_list|(
literal|"%s: [CREATE SERVICE] handle = %08x\n"
argument_list|,
name|__func__
argument_list|,
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|VCHIQ_CREATE_SERVICE_T
operator|*
operator|)
name|arg
operator|)
operator|->
name|handle
operator|)
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|service
operator|->
name|handle
argument_list|,
sizeof|sizeof
argument_list|(
name|service
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|-
name|EEXIST
expr_stmt|;
name|kfree
argument_list|(
name|user_service
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VCHIQ_IOC_CLOSE_SERVICE
case|:
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|handle
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VCHIQ_IOCTL_DEBUG
name|printf
argument_list|(
literal|"%s: [CLOSE SERVICE] handle = %08x\n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
comment|/* close_pending is false on first entry, and when the                            wait in vchiq_close_service has been interrupted. */
if|if
condition|(
operator|!
name|user_service
operator|->
name|close_pending
condition|)
block|{
name|status
operator|=
name|vchiq_close_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
break|break;
block|}
comment|/* close_pending is true once the underlying service 			   has been closed until the client library calls the 			   CLOSE_DELIVERED ioctl, signalling close_event. */
if|if
condition|(
name|user_service
operator|->
name|close_pending
operator|&&
name|down_interruptible
argument_list|(
operator|&
name|user_service
operator|->
name|close_event
argument_list|)
condition|)
name|status
operator|=
name|VCHIQ_RETRY
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_REMOVE_SERVICE
case|:
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|handle
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VCHIQ_IOCTL_DEBUG
name|printf
argument_list|(
literal|"%s: [REMOVE SERVICE] handle = %08x\n"
argument_list|,
name|__func__
argument_list|,
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
comment|/* close_pending is false on first entry, and when the                            wait in vchiq_close_service has been interrupted. */
if|if
condition|(
operator|!
name|user_service
operator|->
name|close_pending
condition|)
block|{
name|status
operator|=
name|vchiq_remove_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
break|break;
block|}
comment|/* close_pending is true once the underlying service 			   has been closed until the client library calls the 			   CLOSE_DELIVERED ioctl, signalling close_event. */
if|if
condition|(
name|user_service
operator|->
name|close_pending
operator|&&
name|down_interruptible
argument_list|(
operator|&
name|user_service
operator|->
name|close_event
argument_list|)
condition|)
name|status
operator|=
name|VCHIQ_RETRY
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_USE_SERVICE
case|:
case|case
name|VCHIQ_IOC_RELEASE_SERVICE
case|:
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|handle
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VCHIQ_IOCTL_DEBUG
name|printf
argument_list|(
literal|"%s: [%s SERVICE] handle = %08x\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|==
name|VCHIQ_IOC_USE_SERVICE
condition|?
literal|"USE"
else|:
literal|"RELEASE"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
operator|(
name|cmd
operator|==
name|VCHIQ_IOC_USE_SERVICE
operator|)
condition|?
name|vchiq_use_service_internal
argument_list|(
name|service
argument_list|)
else|:
name|vchiq_release_service_internal
argument_list|(
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: cmd %s returned error %d for "
literal|"service %c%c%c%c:%8x"
argument_list|,
name|__func__
argument_list|,
operator|(
name|cmd
operator|==
name|VCHIQ_IOC_USE_SERVICE
operator|)
condition|?
literal|"VCHIQ_IOC_USE_SERVICE"
else|:
literal|"VCHIQ_IOC_RELEASE_SERVICE"
argument_list|,
name|status
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service
operator|->
name|base
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service
operator|->
name|client_id
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_QUEUE_MESSAGE
case|:
block|{
name|VCHIQ_QUEUE_MESSAGE_T
name|args
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VCHIQ_IOCTL_DEBUG
name|printf
argument_list|(
literal|"%s: [QUEUE MESSAGE] handle = %08x\n"
argument_list|,
name|__func__
argument_list|,
name|args
operator|.
name|handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|args
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|service
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|args
operator|.
name|count
operator|<=
name|MAX_ELEMENTS
operator|)
condition|)
block|{
comment|/* Copy elements into kernel space */
name|VCHIQ_ELEMENT_T
name|elements
index|[
name|MAX_ELEMENTS
index|]
decl_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
name|elements
argument_list|,
name|args
operator|.
name|elements
argument_list|,
name|args
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
name|VCHIQ_ELEMENT_T
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|status
operator|=
name|vchiq_queue_message
argument_list|(
name|args
operator|.
name|handle
argument_list|,
name|elements
argument_list|,
name|args
operator|.
name|count
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VCHIQ_IOC_QUEUE_BULK_TRANSMIT
case|:
case|case
name|VCHIQ_IOC_QUEUE_BULK_RECEIVE
case|:
block|{
name|VCHIQ_QUEUE_BULK_TRANSFER_T
name|args
decl_stmt|;
name|struct
name|bulk_waiter_node
modifier|*
name|waiter
init|=
name|NULL
decl_stmt|;
name|VCHIQ_BULK_DIR_T
name|dir
init|=
operator|(
name|cmd
operator|==
name|VCHIQ_IOC_QUEUE_BULK_TRANSMIT
operator|)
condition|?
name|VCHIQ_BULK_TRANSMIT
else|:
name|VCHIQ_BULK_RECEIVE
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|args
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|args
operator|.
name|mode
operator|==
name|VCHIQ_BULK_MODE_BLOCKING
condition|)
block|{
name|waiter
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bulk_waiter_node
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|waiter
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|userdata
operator|=
operator|&
name|waiter
operator|->
name|bulk_waiter
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|.
name|mode
operator|==
name|VCHIQ_BULK_MODE_WAITING
condition|)
block|{
name|struct
name|list_head
modifier|*
name|pos
decl_stmt|;
name|lmutex_lock
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list_mutex
argument_list|)
expr_stmt|;
name|list_for_each
argument_list|(
argument|pos
argument_list|,
argument|&instance->bulk_waiter_list
argument_list|)
block|{
if|if
condition|(
name|list_entry
argument_list|(
name|pos
argument_list|,
expr|struct
name|bulk_waiter_node
argument_list|,
name|list
argument_list|)
operator|->
name|pid
operator|==
name|current
operator|->
name|p_pid
condition|)
block|{
name|waiter
operator|=
name|list_entry
argument_list|(
name|pos
argument_list|,
expr|struct
name|bulk_waiter_node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|waiter
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"no bulk_waiter found for pid %d"
argument_list|,
name|current
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ESRCH
expr_stmt|;
break|break;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"found bulk_waiter %x for pid %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|waiter
argument_list|,
name|current
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|args
operator|.
name|userdata
operator|=
operator|&
name|waiter
operator|->
name|bulk_waiter
expr_stmt|;
block|}
name|status
operator|=
name|vchiq_bulk_transfer
argument_list|(
name|args
operator|.
name|handle
argument_list|,
name|VCHI_MEM_HANDLE_INVALID
argument_list|,
name|args
operator|.
name|data
argument_list|,
name|args
operator|.
name|size
argument_list|,
name|args
operator|.
name|userdata
argument_list|,
name|args
operator|.
name|mode
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|waiter
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|!=
name|VCHIQ_RETRY
operator|)
operator|||
name|fatal_signal_pending
argument_list|(
name|current
argument_list|)
operator|||
operator|!
name|waiter
operator|->
name|bulk_waiter
operator|.
name|bulk
condition|)
block|{
if|if
condition|(
name|waiter
operator|->
name|bulk_waiter
operator|.
name|bulk
condition|)
block|{
comment|/* Cancel the signal when the transfer 				** completes. */
name|spin_lock
argument_list|(
operator|&
name|bulk_waiter_spinlock
argument_list|)
expr_stmt|;
name|waiter
operator|->
name|bulk_waiter
operator|.
name|bulk
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|bulk_waiter_spinlock
argument_list|)
expr_stmt|;
block|}
name|_sema_destroy
argument_list|(
operator|&
name|waiter
operator|->
name|bulk_waiter
operator|.
name|event
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|waiter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|VCHIQ_BULK_MODE_T
name|mode_waiting
init|=
name|VCHIQ_BULK_MODE_WAITING
decl_stmt|;
name|waiter
operator|->
name|pid
operator|=
name|current
operator|->
name|p_pid
expr_stmt|;
name|lmutex_lock
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list_mutex
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|waiter
operator|->
name|list
argument_list|,
operator|&
name|instance
operator|->
name|bulk_waiter_list
argument_list|)
expr_stmt|;
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list_mutex
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"saved bulk_waiter %x for pid %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|waiter
argument_list|,
name|current
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
name|VCHIQ_QUEUE_BULK_TRANSFER_T
operator|*
operator|)
name|arg
operator|)
operator|->
name|mode
operator|)
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|mode_waiting
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_waiting
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VCHIQ_IOC_AWAIT_COMPLETION
case|:
block|{
name|VCHIQ_AWAIT_COMPLETION_T
name|args
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance
operator|->
name|connected
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|lmutex_lock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|instance
operator|->
name|completion_remove
operator|==
name|instance
operator|->
name|completion_insert
operator|)
operator|&&
operator|!
name|instance
operator|->
name|closing
condition|)
block|{
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|down_interruptible
argument_list|(
operator|&
name|instance
operator|->
name|insert_event
argument_list|)
expr_stmt|;
name|lmutex_lock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"AWAIT_COMPLETION interrupted"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINTR
expr_stmt|;
break|break;
block|}
block|}
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
comment|/* A read memory barrier is needed to stop prefetch of a stale 		** completion record 		*/
name|rmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|int
name|msgbufcount
init|=
name|args
operator|.
name|msgbufcount
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|args
operator|.
name|count
condition|;
name|count
operator|++
control|)
block|{
name|VCHIQ_COMPLETION_DATA_T
modifier|*
name|completion
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service1
decl_stmt|;
name|USER_SERVICE_T
modifier|*
name|user_service
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
if|if
condition|(
name|instance
operator|->
name|completion_remove
operator|==
name|instance
operator|->
name|completion_insert
condition|)
break|break;
name|completion
operator|=
operator|&
name|instance
operator|->
name|completions
index|[
name|instance
operator|->
name|completion_remove
operator|&
operator|(
name|MAX_COMPLETIONS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|service1
operator|=
name|completion
operator|->
name|service_userdata
expr_stmt|;
name|user_service
operator|=
name|service1
operator|->
name|base
operator|.
name|userdata
expr_stmt|;
name|completion
operator|->
name|service_userdata
operator|=
name|user_service
operator|->
name|userdata
expr_stmt|;
name|header
operator|=
name|completion
operator|->
name|header
expr_stmt|;
if|if
condition|(
name|header
condition|)
block|{
name|void
name|__user
modifier|*
name|msgbuf
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|msglen
operator|=
name|header
operator|->
name|size
operator|+
sizeof|sizeof
argument_list|(
name|VCHIQ_HEADER_T
argument_list|)
expr_stmt|;
comment|/* This must be a VCHIQ-style service */
if|if
condition|(
name|args
operator|.
name|msgbufsize
operator|<
name|msglen
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"header %x: msgbufsize"
literal|" %x< msglen %x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|header
argument_list|,
name|args
operator|.
name|msgbufsize
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"invalid message "
literal|"size\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msgbufcount
operator|<=
literal|0
condition|)
comment|/* Stall here for lack of a 						** buffer for the message. */
break|break;
comment|/* Get the pointer from user space */
name|msgbufcount
operator|--
expr_stmt|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|msgbuf
argument_list|,
operator|(
specifier|const
name|void
name|__user
operator|*
operator|)
operator|&
name|args
operator|.
name|msgbufs
index|[
name|msgbufcount
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
break|break;
block|}
comment|/* Copy the message to user space */
if|if
condition|(
name|copy_to_user
argument_list|(
name|msgbuf
argument_list|,
name|header
argument_list|,
name|msglen
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
break|break;
block|}
comment|/* Now it has been copied, the message 					** can be released. */
name|vchiq_release_message
argument_list|(
name|service1
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
comment|/* The completion must point to the 					** msgbuf. */
name|completion
operator|->
name|header
operator|=
name|msgbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|completion
operator|->
name|reason
operator|==
name|VCHIQ_SERVICE_CLOSED
operator|)
operator|&&
operator|!
name|instance
operator|->
name|use_close_delivered
condition|)
name|unlock_service
argument_list|(
name|service1
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
operator|(
operator|(
name|size_t
operator|)
name|args
operator|.
name|buf
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|VCHIQ_COMPLETION_DATA_T
argument_list|)
operator|)
argument_list|,
name|completion
argument_list|,
sizeof|sizeof
argument_list|(
name|VCHIQ_COMPLETION_DATA_T
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
break|break;
block|}
name|instance
operator|->
name|completion_remove
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|msgbufcount
operator|!=
name|args
operator|.
name|msgbufcount
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
operator|&
operator|(
operator|(
name|VCHIQ_AWAIT_COMPLETION_T
operator|*
operator|)
name|arg
operator|)
operator|->
name|msgbufcount
argument_list|,
operator|&
name|msgbufcount
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbufcount
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|args
operator|.
name|count
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
operator|&
operator|(
operator|(
name|VCHIQ_AWAIT_COMPLETION_T
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|&
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|up
argument_list|(
operator|&
name|instance
operator|->
name|remove_event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
name|instance
operator|->
name|closing
condition|)
name|ret
operator|=
operator|-
name|ENOTCONN
expr_stmt|;
comment|/*  		 * XXXBSD: ioctl return codes are not negative as in linux, so 		 * we can not indicate success with positive number of passed  		 * messages 		 */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|AWAIT_COMPLETION_LINE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_DEQUEUE_MESSAGE
case|:
block|{
name|VCHIQ_DEQUEUE_MESSAGE_T
name|args
decl_stmt|;
name|USER_SERVICE_T
modifier|*
name|user_service
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
name|DEBUG_TRACE
argument_list|(
name|DEQUEUE_MESSAGE_LINE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|args
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|user_service
operator|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
expr_stmt|;
if|if
condition|(
name|user_service
operator|->
name|is_vchi
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_service
operator|->
name|msg_remove
operator|==
name|user_service
operator|->
name|msg_insert
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|.
name|blocking
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|DEQUEUE_MESSAGE_LINE
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|user_service
operator|->
name|dequeue_pending
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|DEBUG_TRACE
argument_list|(
name|DEQUEUE_MESSAGE_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|down_interruptible
argument_list|(
operator|&
name|user_service
operator|->
name|insert_event
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"DEQUEUE_MESSAGE interrupted"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINTR
expr_stmt|;
break|break;
block|}
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|user_service
operator|->
name|msg_remove
operator|==
name|user_service
operator|->
name|msg_insert
condition|)
do|;
if|if
condition|(
name|ret
condition|)
break|break;
block|}
name|BUG_ON
argument_list|(
call|(
name|int
call|)
argument_list|(
name|user_service
operator|->
name|msg_insert
operator|-
name|user_service
operator|->
name|msg_remove
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|header
operator|=
name|user_service
operator|->
name|msg_queue
index|[
name|user_service
operator|->
name|msg_remove
operator|&
operator|(
name|MSG_QUEUE_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|user_service
operator|->
name|msg_remove
operator|++
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|user_service
operator|->
name|remove_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|-
name|ENOTCONN
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|size
operator|<=
name|args
operator|.
name|bufsize
condition|)
block|{
comment|/* Copy to user space if msgbuf is not NULL */
if|if
condition|(
operator|(
name|args
operator|.
name|buf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|copy_to_user
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
name|args
operator|.
name|buf
argument_list|,
name|header
operator|->
name|data
argument_list|,
name|header
operator|->
name|size
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|args
operator|.
name|bufsize
operator|=
name|header
operator|->
name|size
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|vchiq_release_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"header %x: bufsize %x< size %x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|header
argument_list|,
name|args
operator|.
name|bufsize
argument_list|,
name|header
operator|->
name|size
argument_list|)
expr_stmt|;
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"invalid size\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EMSGSIZE
expr_stmt|;
block|}
name|DEBUG_TRACE
argument_list|(
name|DEQUEUE_MESSAGE_LINE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_GET_CLIENT_ID
case|:
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|handle
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vchiq_get_client_id
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_GET_CONFIG
case|:
block|{
name|VCHIQ_GET_CONFIG_T
name|args
decl_stmt|;
name|VCHIQ_CONFIG_T
name|config
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|config_size
operator|>
sizeof|sizeof
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|vchiq_get_config
argument_list|(
name|instance
argument_list|,
name|args
operator|.
name|config_size
argument_list|,
operator|&
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
operator|(
name|void
name|__user
operator|*
operator|)
name|args
operator|.
name|pconfig
argument_list|,
operator|&
name|config
argument_list|,
name|args
operator|.
name|config_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|VCHIQ_IOC_SET_SERVICE_OPTION
case|:
block|{
name|VCHIQ_SET_SERVICE_OPTION_T
name|args
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|find_service_for_instance
argument_list|(
name|instance
argument_list|,
name|args
operator|.
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|vchiq_set_service_option
argument_list|(
name|args
operator|.
name|handle
argument_list|,
name|args
operator|.
name|option
argument_list|,
name|args
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_DUMP_PHYS_MEM
case|:
block|{
name|VCHIQ_DUMP_MEM_T
name|args
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|args
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IMPLEMENT ME: %s:%d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|dump_phys_mem(args.virt_addr, args.num_bytes);
endif|#
directive|endif
block|}
break|break;
case|case
name|VCHIQ_IOC_LIB_VERSION
case|:
block|{
name|unsigned
name|int
name|lib_version
init|=
operator|(
name|unsigned
name|int
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|lib_version
operator|<
name|VCHIQ_VERSION_MIN
condition|)
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|lib_version
operator|>=
name|VCHIQ_VERSION_CLOSE_DELIVERED
condition|)
name|instance
operator|->
name|use_close_delivered
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|VCHIQ_IOC_CLOSE_DELIVERED
case|:
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|handle
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|service
operator|=
name|find_closed_service_for_instance
argument_list|(
name|instance
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
name|close_delivered
argument_list|(
name|user_service
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
operator|-
name|ENOTTY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|service
condition|)
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|VCHIQ_ERROR
condition|)
name|ret
operator|=
operator|-
name|EIO
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|VCHIQ_RETRY
condition|)
name|ret
operator|=
operator|-
name|EINTR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|==
name|VCHIQ_SUCCESS
operator|)
operator|&&
operator|(
name|ret
operator|<
literal|0
operator|)
operator|&&
operator|(
name|ret
operator|!=
operator|-
name|EINTR
operator|)
operator|&&
operator|(
name|ret
operator|!=
operator|-
name|EWOULDBLOCK
operator|)
condition|)
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"  ioctl instance %lx, cmd %s -> status %d, %d"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|instance
argument_list|,
operator|(
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
operator|<=
name|VCHIQ_IOC_MAX
operator|)
condition|?
name|ioctl_names
index|[
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
index|]
else|:
literal|"<invalid>"
argument_list|,
name|status
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|vchiq_log_trace
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"  ioctl instance %lx, cmd %s -> status %d, %d"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|instance
argument_list|,
operator|(
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
operator|<=
name|VCHIQ_IOC_MAX
operator|)
condition|?
name|ioctl_names
index|[
name|_IOC_NR
argument_list|(
name|cmd
argument_list|)
index|]
else|:
literal|"<invalid>"
argument_list|,
name|status
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* XXXBSD: report BSD-style error to userland */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|instance_dtr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|kfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_open * ***************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|vchiq_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq_open"
argument_list|)
expr_stmt|;
comment|/* XXXBSD: do we really need this check? */
if|if
condition|(
literal|1
condition|)
block|{
name|VCHIQ_STATE_T
modifier|*
name|state
init|=
name|vchiq_get_state
argument_list|()
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq has no connection to VideoCore"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOTCONN
return|;
block|}
name|instance
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|instance
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|instance
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* XXXBSD: PID or thread ID? */
name|instance
operator|->
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ret
operator|=
name|vchiq_proc_add_instance
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|kfree
argument_list|(
name|instance
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
endif|#
directive|endif
name|_sema_init
argument_list|(
operator|&
name|instance
operator|->
name|insert_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_sema_init
argument_list|(
operator|&
name|instance
operator|->
name|remove_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lmutex_init
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
name|lmutex_init
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|instance
operator|->
name|bulk_waiter_list
argument_list|)
expr_stmt|;
name|devfs_set_cdevpriv
argument_list|(
name|instance
argument_list|,
name|instance_dtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"Unknown minor device"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_release * ***************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|vchiq_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|,
name|int
name|fmt
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|VCHIQ_STATE_T
modifier|*
name|state
init|=
name|vchiq_get_state
argument_list|()
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|instance
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"devfs_get_cdevpriv failed: error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq_release: instance=%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|ret
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Ensure videocore is awake to allow termination. */
name|vchiq_use_internal
argument_list|(
name|instance
operator|->
name|state
argument_list|,
name|NULL
argument_list|,
name|USE_TYPE_VCHIQ
argument_list|)
expr_stmt|;
name|lmutex_lock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
comment|/* Wake the completion thread and ask it to exit */
name|instance
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|up
argument_list|(
operator|&
name|instance
operator|->
name|insert_event
argument_list|)
expr_stmt|;
name|lmutex_unlock
argument_list|(
operator|&
name|instance
operator|->
name|completion_mutex
argument_list|)
expr_stmt|;
comment|/* Wake the slot handler if the completion queue is full. */
name|up
argument_list|(
operator|&
name|instance
operator|->
name|remove_event
argument_list|)
expr_stmt|;
comment|/* Mark all services for termination... */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|service
operator|=
name|next_service_by_instance
argument_list|(
name|state
argument_list|,
name|instance
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
comment|/* Wake the slot handler if the msg queue is full. */
name|up
argument_list|(
operator|&
name|user_service
operator|->
name|remove_event
argument_list|)
expr_stmt|;
name|vchiq_terminate_service_internal
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
comment|/* ...and wait for them to die */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|service
operator|=
name|next_service_by_instance
argument_list|(
name|state
argument_list|,
name|instance
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
name|down
argument_list|(
operator|&
name|service
operator|->
name|remove_event
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|service
operator|->
name|srvstate
operator|!=
name|VCHIQ_SRVSTATE_FREE
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
while|while
condition|(
name|user_service
operator|->
name|msg_remove
operator|!=
name|user_service
operator|->
name|msg_insert
condition|)
block|{
name|VCHIQ_HEADER_T
modifier|*
name|header
init|=
name|user_service
operator|->
name|msg_queue
index|[
name|user_service
operator|->
name|msg_remove
operator|&
operator|(
name|MSG_QUEUE_SIZE
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|user_service
operator|->
name|msg_remove
operator|++
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
condition|)
name|vchiq_release_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
comment|/* Release any closed services */
while|while
condition|(
name|instance
operator|->
name|completion_remove
operator|!=
name|instance
operator|->
name|completion_insert
condition|)
block|{
name|VCHIQ_COMPLETION_DATA_T
modifier|*
name|completion
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service1
decl_stmt|;
name|completion
operator|=
operator|&
name|instance
operator|->
name|completions
index|[
name|instance
operator|->
name|completion_remove
operator|&
operator|(
name|MAX_COMPLETIONS
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|service1
operator|=
name|completion
operator|->
name|service_userdata
expr_stmt|;
if|if
condition|(
name|completion
operator|->
name|reason
operator|==
name|VCHIQ_SERVICE_CLOSED
condition|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
comment|/* Wake any blocked user-thread */
if|if
condition|(
name|instance
operator|->
name|use_close_delivered
condition|)
name|up
argument_list|(
operator|&
name|user_service
operator|->
name|close_event
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service1
argument_list|)
expr_stmt|;
block|}
name|instance
operator|->
name|completion_remove
operator|++
expr_stmt|;
block|}
comment|/* Release the PEER service count. */
name|vchiq_release_internal
argument_list|(
name|instance
operator|->
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|struct
name|list_head
modifier|*
name|pos
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|list_for_each_safe
argument_list|(
argument|pos
argument_list|,
argument|next
argument_list|,
argument|&instance->bulk_waiter_list
argument_list|)
block|{
name|struct
name|bulk_waiter_node
modifier|*
name|waiter
decl_stmt|;
name|waiter
operator|=
name|list_entry
argument_list|(
name|pos
argument_list|,
expr|struct
name|bulk_waiter_node
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"bulk_waiter - cleaned up %x "
literal|"for pid %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|waiter
argument_list|,
name|waiter
operator|->
name|pid
argument_list|)
expr_stmt|;
name|_sema_destroy
argument_list|(
operator|&
name|waiter
operator|->
name|bulk_waiter
operator|.
name|event
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|waiter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"Unknown minor device"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENXIO
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_dump * ***************************************************************************/
end_comment

begin_function
name|void
name|vchiq_dump
parameter_list|(
name|void
modifier|*
name|dump_context
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|DUMP_CONTEXT_T
modifier|*
name|context
init|=
operator|(
name|DUMP_CONTEXT_T
operator|*
operator|)
name|dump_context
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|actual
operator|<
name|context
operator|->
name|space
condition|)
block|{
name|int
name|copy_bytes
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|offset
operator|>
literal|0
condition|)
block|{
name|int
name|skip_bytes
init|=
name|min
argument_list|(
name|len
argument_list|,
operator|(
name|int
operator|)
name|context
operator|->
name|offset
argument_list|)
decl_stmt|;
name|str
operator|+=
name|skip_bytes
expr_stmt|;
name|len
operator|-=
name|skip_bytes
expr_stmt|;
name|context
operator|->
name|offset
operator|-=
name|skip_bytes
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|offset
operator|>
literal|0
condition|)
return|return;
block|}
name|copy_bytes
operator|=
name|min
argument_list|(
name|len
argument_list|,
call|(
name|int
call|)
argument_list|(
name|context
operator|->
name|space
operator|-
name|context
operator|->
name|actual
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_bytes
operator|==
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
name|context
operator|->
name|buf
operator|+
name|context
operator|->
name|actual
argument_list|,
name|str
argument_list|,
name|copy_bytes
argument_list|)
expr_stmt|;
name|context
operator|->
name|actual
operator|+=
name|copy_bytes
expr_stmt|;
name|len
operator|-=
name|copy_bytes
expr_stmt|;
comment|/* If tne terminating NUL is included in the length, then it 		** marks the end of a line and should be replaced with a 		** carriage return. */
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|str
index|[
name|copy_bytes
operator|-
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|char
name|cr
init|=
literal|'\n'
decl_stmt|;
name|memcpy
argument_list|(
name|context
operator|->
name|buf
operator|+
name|context
operator|->
name|actual
operator|-
literal|1
argument_list|,
operator|&
name|cr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_dump_platform_instance_state * ***************************************************************************/
end_comment

begin_function
name|void
name|vchiq_dump_platform_instances
parameter_list|(
name|void
modifier|*
name|dump_context
parameter_list|)
block|{
name|VCHIQ_STATE_T
modifier|*
name|state
init|=
name|vchiq_get_state
argument_list|()
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* There is no list of instances, so instead scan all services, 		marking those that have been dumped. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|unused_service
condition|;
name|i
operator|++
control|)
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|state
operator|->
name|services
index|[
name|i
index|]
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
if|if
condition|(
name|service
operator|&&
operator|(
name|service
operator|->
name|base
operator|.
name|callback
operator|==
name|service_callback
operator|)
condition|)
block|{
name|instance
operator|=
name|service
operator|->
name|instance
expr_stmt|;
if|if
condition|(
name|instance
condition|)
name|instance
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|unused_service
condition|;
name|i
operator|++
control|)
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|state
operator|->
name|services
index|[
name|i
index|]
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
if|if
condition|(
name|service
operator|&&
operator|(
name|service
operator|->
name|base
operator|.
name|callback
operator|==
name|service_callback
operator|)
condition|)
block|{
name|instance
operator|=
name|service
operator|->
name|instance
expr_stmt|;
if|if
condition|(
name|instance
operator|&&
operator|!
name|instance
operator|->
name|mark
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Instance %x: pid %d,%s completions "
literal|"%d/%d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|instance
argument_list|,
name|instance
operator|->
name|pid
argument_list|,
name|instance
operator|->
name|connected
condition|?
literal|" connected, "
else|:
literal|""
argument_list|,
name|instance
operator|->
name|completion_insert
operator|-
name|instance
operator|->
name|completion_remove
argument_list|,
name|MAX_COMPLETIONS
argument_list|)
expr_stmt|;
name|vchiq_dump
argument_list|(
name|dump_context
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|instance
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_dump_platform_service_state * ***************************************************************************/
end_comment

begin_function
name|void
name|vchiq_dump_platform_service_state
parameter_list|(
name|void
modifier|*
name|dump_context
parameter_list|,
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
name|USER_SERVICE_T
modifier|*
name|user_service
init|=
operator|(
name|USER_SERVICE_T
operator|*
operator|)
name|service
operator|->
name|base
operator|.
name|userdata
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"  instance %x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|service
operator|->
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|service
operator|->
name|base
operator|.
name|callback
operator|==
name|service_callback
operator|)
operator|&&
name|user_service
operator|->
name|is_vchi
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|", %d/%d messages"
argument_list|,
name|user_service
operator|->
name|msg_insert
operator|-
name|user_service
operator|->
name|msg_remove
argument_list|,
name|MSG_QUEUE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_service
operator|->
name|dequeue_pending
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|" (dequeue pending)"
argument_list|)
expr_stmt|;
block|}
name|vchiq_dump
argument_list|(
name|dump_context
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/**************************************************************************** * *   dump_user_mem * ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dump_phys_mem
parameter_list|(
name|void
modifier|*
name|virt_addr
parameter_list|,
name|uint32_t
name|num_bytes
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint8_t
modifier|*
name|end_virt_addr
init|=
name|virt_addr
operator|+
name|num_bytes
decl_stmt|;
name|int
name|num_pages
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|end_offset
decl_stmt|;
name|int
name|page_idx
decl_stmt|;
name|int
name|prev_idx
decl_stmt|;
name|struct
name|page
modifier|*
name|page
decl_stmt|;
name|struct
name|page
modifier|*
modifier|*
name|pages
decl_stmt|;
name|uint8_t
modifier|*
name|kmapped_virt_ptr
decl_stmt|;
comment|/* Align virtAddr and endVirtAddr to 16 byte boundaries. */
name|virt_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|virt_addr
operator|&
operator|~
literal|0x0fuL
operator|)
expr_stmt|;
name|end_virt_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|end_virt_addr
operator|+
literal|15uL
operator|)
operator|&
operator|~
literal|0x0fuL
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|virt_addr
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|end_offset
operator|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|end_virt_addr
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|num_pages
operator|=
operator|(
name|offset
operator|+
name|num_bytes
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
name|pages
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page
operator|*
argument_list|)
operator|*
name|num_pages
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
operator|==
name|NULL
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"Unable to allocation memory for %d pages\n"
argument_list|,
name|num_pages
argument_list|)
expr_stmt|;
return|return;
block|}
name|down_read
argument_list|(
operator|&
name|current
operator|->
name|mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
name|rc
operator|=
name|get_user_pages
argument_list|(
name|current
argument_list|,
comment|/* task */
name|current
operator|->
name|mm
argument_list|,
comment|/* mm */
operator|(
name|unsigned
name|long
operator|)
name|virt_addr
argument_list|,
comment|/* start */
name|num_pages
argument_list|,
comment|/* len */
literal|0
argument_list|,
comment|/* write */
literal|0
argument_list|,
comment|/* force */
name|pages
argument_list|,
comment|/* pages (array of page pointers) */
name|NULL
argument_list|)
expr_stmt|;
comment|/* vmas */
name|up_read
argument_list|(
operator|&
name|current
operator|->
name|mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
name|prev_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|page
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|page_offset
init|=
name|offset
operator|%
name|PAGE_SIZE
decl_stmt|;
name|page_idx
operator|=
name|offset
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|page_idx
operator|!=
name|prev_idx
condition|)
block|{
if|if
condition|(
name|page
operator|!=
name|NULL
condition|)
name|kunmap
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|=
name|pages
index|[
name|page_idx
index|]
expr_stmt|;
name|kmapped_virt_ptr
operator|=
name|kmap
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|prev_idx
operator|=
name|page_idx
expr_stmt|;
block|}
if|if
condition|(
name|vchiq_arm_log_level
operator|>=
name|VCHIQ_LOG_TRACE
condition|)
name|vchiq_log_dump_mem
argument_list|(
literal|"ph"
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|unsigned
name|long
operator|)
operator|&
name|kmapped_virt_ptr
index|[
name|page_offset
index|]
argument_list|,
operator|&
name|kmapped_virt_ptr
index|[
name|page_offset
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|!=
name|NULL
condition|)
name|kunmap
argument_list|(
name|page
argument_list|)
expr_stmt|;
for|for
control|(
name|page_idx
operator|=
literal|0
init|;
name|page_idx
operator|<
name|num_pages
condition|;
name|page_idx
operator|++
control|)
name|page_cache_release
argument_list|(
name|pages
index|[
name|page_idx
index|]
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pages
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_read * ***************************************************************************/
end_comment

begin_function
specifier|static
name|ssize_t
name|vchiq_read
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|,
name|loff_t
modifier|*
name|ppos
parameter_list|)
block|{
name|DUMP_CONTEXT_T
name|context
decl_stmt|;
name|context
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|context
operator|.
name|actual
operator|=
literal|0
expr_stmt|;
name|context
operator|.
name|space
operator|=
name|count
expr_stmt|;
name|context
operator|.
name|offset
operator|=
operator|*
name|ppos
expr_stmt|;
name|vchiq_dump_state
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|g_state
argument_list|)
expr_stmt|;
operator|*
name|ppos
operator|+=
name|context
operator|.
name|actual
expr_stmt|;
return|return
name|context
operator|.
name|actual
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|VCHIQ_STATE_T
modifier|*
name|vchiq_get_state
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|g_state
operator|.
name|remote
operator|==
name|NULL
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: g_state.remote == NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|g_state
operator|.
name|remote
operator|->
name|initialised
operator|!=
literal|1
condition|)
name|printk
argument_list|(
name|KERN_NOTICE
literal|"%s: g_state.remote->initialised != 1 (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|g_state
operator|.
name|remote
operator|->
name|initialised
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|g_state
operator|.
name|remote
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|g_state
operator|.
name|remote
operator|->
name|initialised
operator|==
literal|1
operator|)
operator|)
condition|?
operator|&
name|g_state
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Autosuspend related functionality  */
end_comment

begin_function
name|int
name|vchiq_videocore_wanted
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
comment|/* autosuspend not supported - always return wanted */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|arm_state
operator|->
name|blocked_count
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|arm_state
operator|->
name|videocore_use_count
condition|)
comment|/* usage count zero - check for override unless we're forcing */
if|if
condition|(
name|arm_state
operator|->
name|resume_blocked
condition|)
return|return
literal|0
return|;
else|else
return|return
name|vchiq_platform_videocore_wanted
argument_list|(
name|state
argument_list|)
return|;
else|else
comment|/* non-zero usage count - videocore still required */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|VCHIQ_STATUS_T
name|vchiq_keepalive_vchiq_callback
parameter_list|(
name|VCHIQ_REASON_T
name|reason
parameter_list|,
name|VCHIQ_HEADER_T
modifier|*
name|header
parameter_list|,
name|VCHIQ_SERVICE_HANDLE_T
name|service_user
parameter_list|,
name|void
modifier|*
name|bulk_user
parameter_list|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s callback reason %d"
argument_list|,
name|__func__
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vchiq_keepalive_thread_func
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|VCHIQ_STATE_T
modifier|*
name|state
init|=
operator|(
name|VCHIQ_STATE_T
operator|*
operator|)
name|v
decl_stmt|;
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|VCHIQ_SERVICE_HANDLE_T
name|ka_handle
decl_stmt|;
name|VCHIQ_SERVICE_PARAMS_T
name|params
init|=
block|{
operator|.
name|fourcc
operator|=
name|VCHIQ_MAKE_FOURCC
argument_list|(
literal|'K'
argument_list|,
literal|'E'
argument_list|,
literal|'E'
argument_list|,
literal|'P'
argument_list|)
block|,
operator|.
name|callback
operator|=
name|vchiq_keepalive_vchiq_callback
block|,
operator|.
name|version
operator|=
name|KEEPALIVE_VER
block|,
operator|.
name|version_min
operator|=
name|KEEPALIVE_VER_MIN
block|}
decl_stmt|;
name|status
operator|=
name|vchiq_initialise
argument_list|(
operator|&
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s vchiq_initialise failed %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|status
operator|=
name|vchiq_connect
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s vchiq_connect failed %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|shutdown
goto|;
block|}
name|status
operator|=
name|vchiq_add_service
argument_list|(
name|instance
argument_list|,
operator|&
name|params
argument_list|,
operator|&
name|ka_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s vchiq_open_service failed %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|shutdown
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|rc
init|=
literal|0
decl_stmt|,
name|uc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wait_for_completion_interruptible
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_evt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s interrupted"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|flush_signals
argument_list|(
name|current
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* read and clear counters.  Do release_count then use_count to 		 * prevent getting more releases than uses */
name|rc
operator|=
name|atomic_xchg
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_release_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uc
operator|=
name|atomic_xchg
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call use/release service the requisite number of times. 		 * Process use before release so use counts don't go negative */
while|while
condition|(
name|uc
operator|--
condition|)
block|{
name|atomic_inc
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_ack_count
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_use_service
argument_list|(
name|ka_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s vchiq_use_service error %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|rc
operator|--
condition|)
block|{
name|status
operator|=
name|vchiq_release_service
argument_list|(
name|ka_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s vchiq_release_service error %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|shutdown
label|:
name|vchiq_shutdown
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|exit
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_arm_init_state
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|,
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
if|if
condition|(
name|arm_state
condition|)
block|{
name|rwlock_init
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_evt
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_ack_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_release_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
expr_stmt|;
comment|/* Initialise to 'done' state.  We only want to block on resume 		 * completion while videocore is suspended. */
name|set_resume_state
argument_list|(
name|arm_state
argument_list|,
name|VC_RESUME_RESUMED
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|resume_blocker
argument_list|)
expr_stmt|;
comment|/* Initialise to 'done' state.  We only want to block on this 		 * completion while resume is blocked */
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|resume_blocker
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|blocked_blocker
argument_list|)
expr_stmt|;
comment|/* Initialise to 'done' state.  We only want to block on this 		 * completion while things are waiting on the resume blocker */
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|blocked_blocker
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer_timeout
operator|=
name|SUSPEND_TIMER_TIMEOUT_MS
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer_running
operator|=
literal|0
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|arm_state
operator|->
name|suspend_timer
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer
operator|.
name|data
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer
operator|.
name|function
operator|=
name|suspend_timer_callback
expr_stmt|;
name|arm_state
operator|->
name|first_connect
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* ** Functions to modify the state variables; **	set_suspend_state **	set_resume_state ** ** There are more state variables than we might like, so ensure they remain in ** step.  Suspend and resume state are maintained separately, since most of ** these state machines can operate independently.  However, there are a few ** states where state transitions in one state machine cause a reset to the ** other state machine.  In addition, there are some completion events which ** need to occur on state machine reset and end-state(s), so these are also ** dealt with in these functions. ** ** In all states we set the state variable according to the input, but in some ** cases we perform additional steps outlined below; ** ** VC_SUSPEND_IDLE - Initialise the suspend completion at the same time. **			The suspend completion is completed after any suspend **			attempt.  When we reset the state machine we also reset **			the completion.  This reset occurs when videocore is **			resumed, and also if we initiate suspend after a suspend **			failure. ** ** VC_SUSPEND_IN_PROGRESS - This state is considered the point of no return for **			suspend - ie from this point on we must try to suspend **			before resuming can occur.  We therefore also reset the **			resume state machine to VC_RESUME_IDLE in this state. ** ** VC_SUSPEND_SUSPENDED - Suspend has completed successfully. Also call **			complete_all on the suspend completion to notify **			anything waiting for suspend to happen. ** ** VC_SUSPEND_REJECTED - Videocore rejected suspend. Videocore will also **			initiate resume, so no need to alter resume state. **			We call complete_all on the suspend completion to notify **			of suspend rejection. ** ** VC_SUSPEND_FAILED - We failed to initiate videocore suspend.  We notify the **			suspend completion and reset the resume state machine. ** ** VC_RESUME_IDLE - Initialise the resume completion at the same time.  The **			resume completion is in it's 'done' state whenever **			videcore is running.  Therfore, the VC_RESUME_IDLE state **			implies that videocore is suspended. **			Hence, any thread which needs to wait until videocore is **			running can wait on this completion - it will only block **			if videocore is suspended. ** ** VC_RESUME_RESUMED - Resume has completed successfully.  Videocore is running. **			Call complete_all on the resume completion to unblock **			any threads waiting for resume.	 Also reset the suspend **			state machine to it's idle state. ** ** VC_RESUME_FAILED - Currently unused - no mechanism to fail resume exists. */
end_comment

begin_function
name|void
name|set_suspend_state
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|,
name|enum
name|vc_suspend_status
name|new_state
parameter_list|)
block|{
comment|/* set the state in all cases */
name|arm_state
operator|->
name|vc_suspend_state
operator|=
name|new_state
expr_stmt|;
comment|/* state specific additional actions */
switch|switch
condition|(
name|new_state
condition|)
block|{
case|case
name|VC_SUSPEND_FORCE_CANCELED
case|:
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_REJECTED
case|:
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_FAILED
case|:
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|vc_resume_state
operator|=
name|VC_RESUME_RESUMED
expr_stmt|;
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_IDLE
case|:
comment|/* TODO: reinit_completion */
name|INIT_COMPLETION
argument_list|(
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_REQUESTED
case|:
break|break;
case|case
name|VC_SUSPEND_IN_PROGRESS
case|:
name|set_resume_state
argument_list|(
name|arm_state
argument_list|,
name|VC_RESUME_IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_SUSPENDED
case|:
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|set_resume_state
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|,
name|enum
name|vc_resume_status
name|new_state
parameter_list|)
block|{
comment|/* set the state in all cases */
name|arm_state
operator|->
name|vc_resume_state
operator|=
name|new_state
expr_stmt|;
comment|/* state specific additional actions */
switch|switch
condition|(
name|new_state
condition|)
block|{
case|case
name|VC_RESUME_FAILED
case|:
break|break;
case|case
name|VC_RESUME_IDLE
case|:
comment|/* TODO: reinit_completion */
name|INIT_COMPLETION
argument_list|(
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_RESUME_REQUESTED
case|:
break|break;
case|case
name|VC_RESUME_IN_PROGRESS
case|:
break|break;
case|case
name|VC_RESUME_RESUMED
case|:
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
expr_stmt|;
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_IDLE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* should be called with the write lock held */
end_comment

begin_function
specifier|inline
name|void
name|start_suspend_timer
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|)
block|{
name|del_timer
argument_list|(
operator|&
name|arm_state
operator|->
name|suspend_timer
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer
operator|.
name|expires
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|arm_state
operator|->
name|suspend_timer_timeout
argument_list|)
expr_stmt|;
name|add_timer
argument_list|(
operator|&
name|arm_state
operator|->
name|suspend_timer
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer_running
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* should be called with the write lock held */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|stop_suspend_timer
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|)
block|{
if|if
condition|(
name|arm_state
operator|->
name|suspend_timer_running
condition|)
block|{
name|del_timer
argument_list|(
operator|&
name|arm_state
operator|->
name|suspend_timer
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|suspend_timer_running
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|need_resume
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
return|return
operator|(
name|arm_state
operator|->
name|vc_suspend_state
operator|>
name|VC_SUSPEND_IDLE
operator|)
operator|&&
operator|(
name|arm_state
operator|->
name|vc_resume_state
operator|<
name|VC_RESUME_REQUESTED
operator|)
operator|&&
name|vchiq_videocore_wanted
argument_list|(
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|block_resume
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|)
block|{
name|int
name|status
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
specifier|const
name|unsigned
name|long
name|timeout_val
init|=
name|msecs_to_jiffies
argument_list|(
name|FORCE_SUSPEND_TIMEOUT_MS
argument_list|)
decl_stmt|;
name|int
name|resume_count
init|=
literal|0
decl_stmt|;
comment|/* Allow any threads which were blocked by the last force suspend to 	 * complete if they haven't already.  Only give this one shot; if 	 * blocked_count is incremented after blocked_blocker is completed 	 * (which only happens when blocked_count hits 0) then those threads 	 * will have to wait until next time around */
if|if
condition|(
name|arm_state
operator|->
name|blocked_count
condition|)
block|{
comment|/* TODO: reinit_completion */
name|INIT_COMPLETION
argument_list|(
name|arm_state
operator|->
name|blocked_blocker
argument_list|)
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s wait for previously "
literal|"blocked clients"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_completion_interruptible_timeout
argument_list|(
operator|&
name|arm_state
operator|->
name|blocked_blocker
argument_list|,
name|timeout_val
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s wait for "
literal|"previously blocked clients failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_ERROR
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s previously blocked "
literal|"clients resumed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
block|}
comment|/* We need to wait for resume to complete if it's in process */
while|while
condition|(
name|arm_state
operator|->
name|vc_resume_state
operator|!=
name|VC_RESUME_RESUMED
operator|&&
name|arm_state
operator|->
name|vc_resume_state
operator|>
name|VC_RESUME_IDLE
condition|)
block|{
if|if
condition|(
name|resume_count
operator|>
literal|1
condition|)
block|{
name|status
operator|=
name|VCHIQ_ERROR
expr_stmt|;
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s waited too "
literal|"many times for resume"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s wait for resume"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_completion_interruptible_timeout
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|,
name|timeout_val
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s wait for "
literal|"resume failed (%s)"
argument_list|,
name|__func__
argument_list|,
name|resume_state_names
index|[
name|arm_state
operator|->
name|vc_resume_state
operator|+
name|VC_RESUME_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_ERROR
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s resumed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|resume_count
operator|++
expr_stmt|;
block|}
comment|/* TODO: reinit_completion */
name|INIT_COMPLETION
argument_list|(
name|arm_state
operator|->
name|resume_blocker
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|resume_blocked
operator|=
literal|1
expr_stmt|;
name|out
label|:
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unblock_resume
parameter_list|(
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
parameter_list|)
block|{
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|resume_blocker
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|resume_blocked
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initiate suspend via slot handler. Should be called with the write lock  * held */
end_comment

begin_function
name|VCHIQ_STATUS_T
name|vchiq_arm_vcsuspend
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|VCHIQ_ERROR
decl_stmt|;
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_SUCCESS
expr_stmt|;
switch|switch
condition|(
name|arm_state
operator|->
name|vc_suspend_state
condition|)
block|{
case|case
name|VC_SUSPEND_REQUESTED
case|:
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: suspend already "
literal|"requested"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_SUSPEND_IN_PROGRESS
case|:
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: suspend already in "
literal|"progress"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We don't expect to be in other states, so log but continue 		 * anyway */
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s unexpected suspend state %s"
argument_list|,
name|__func__
argument_list|,
name|suspend_state_names
index|[
name|arm_state
operator|->
name|vc_suspend_state
operator|+
name|VC_SUSPEND_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|VC_SUSPEND_REJECTED
case|:
case|case
name|VC_SUSPEND_FAILED
case|:
comment|/* Ensure any idle state actions have been run */
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_IDLE
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|VC_SUSPEND_IDLE
case|:
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: suspending"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_REQUESTED
argument_list|)
expr_stmt|;
comment|/* kick the slot handler thread to initiate suspend */
name|request_poll
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|vchiq_platform_check_suspend
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|int
name|susp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|==
name|VC_SUSPEND_REQUESTED
operator|&&
name|arm_state
operator|->
name|vc_resume_state
operator|==
name|VC_RESUME_RESUMED
condition|)
block|{
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_IN_PROGRESS
argument_list|)
expr_stmt|;
name|susp
operator|=
literal|1
expr_stmt|;
block|}
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|susp
condition|)
name|vchiq_platform_suspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|output_timeout_error
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|char
name|service_err
index|[
literal|50
index|]
init|=
literal|""
decl_stmt|;
name|int
name|vc_use_count
init|=
name|arm_state
operator|->
name|videocore_use_count
decl_stmt|;
name|int
name|active_services
init|=
name|state
operator|->
name|unused_service
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
operator|->
name|videocore_use_count
condition|)
block|{
name|snprintf
argument_list|(
name|service_err
argument_list|,
literal|50
argument_list|,
literal|" Videocore usecount is 0"
argument_list|)
expr_stmt|;
goto|goto
name|output_msg
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_services
condition|;
name|i
operator|++
control|)
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service_ptr
init|=
name|state
operator|->
name|services
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|service_ptr
operator|&&
name|service_ptr
operator|->
name|service_use_count
operator|&&
operator|(
name|service_ptr
operator|->
name|srvstate
operator|!=
name|VCHIQ_SRVSTATE_FREE
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|service_err
argument_list|,
literal|50
argument_list|,
literal|" %c%c%c%c(%8x) service has "
literal|"use count %d%s"
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service_ptr
operator|->
name|base
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service_ptr
operator|->
name|client_id
argument_list|,
name|service_ptr
operator|->
name|service_use_count
argument_list|,
name|service_ptr
operator|->
name|service_use_count
operator|==
name|vc_use_count
condition|?
literal|""
else|:
literal|" (+ more)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|output_msg
label|:
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"timed out waiting for vc suspend (%d).%s"
argument_list|,
name|arm_state
operator|->
name|autosuspend_override
argument_list|,
name|service_err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to get videocore into suspended state, regardless of autosuspend state. ** We don't actually force suspend, since videocore may get into a bad state ** if we force suspend at a bad time.  Instead, we wait for autosuspend to ** determine a good point to suspend.  If this doesn't happen within 100ms we ** report failure. ** ** Returns VCHIQ_SUCCESS if videocore suspended successfully, VCHIQ_RETRY if ** videocore failed to suspend in time or VCHIQ_ERROR if interrupted. */
end_comment

begin_function
name|VCHIQ_STATUS_T
name|vchiq_arm_force_suspend
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
init|=
name|VCHIQ_ERROR
decl_stmt|;
name|long
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|repeat
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|block_resume
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|==
name|VC_SUSPEND_SUSPENDED
condition|)
block|{
comment|/* Already suspended - just block resume and exit */
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s already suspended"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_SUCCESS
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
elseif|else
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|<=
name|VC_SUSPEND_IDLE
condition|)
block|{
comment|/* initiate suspend immediately in the case that we're waiting 		 * for the timeout */
name|stop_suspend_timer
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vchiq_videocore_wanted
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s videocore "
literal|"idle, initiating suspend"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_arm_vcsuspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arm_state
operator|->
name|autosuspend_override
operator|<
name|FORCE_SUSPEND_FAIL_MAX
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s letting "
literal|"videocore go idle"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s failed too "
literal|"many times - attempting suspend"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_arm_vcsuspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s videocore suspend "
literal|"in progress - wait for completion"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_SUCCESS
expr_stmt|;
block|}
comment|/* Wait for suspend to happen due to system idle (not forced..) */
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
goto|goto
name|unblock_resume
goto|;
do|do
block|{
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|wait_for_completion_interruptible_timeout
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_suspend_complete
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|FORCE_SUSPEND_TIMEOUT_MS
argument_list|)
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s "
literal|"interrupted waiting for suspend"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_ERROR
expr_stmt|;
goto|goto
name|unblock_resume
goto|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|>
name|VC_SUSPEND_IDLE
condition|)
block|{
comment|/* Repeat timeout once if in progress */
if|if
condition|(
name|repeat
operator|<
literal|0
condition|)
block|{
name|repeat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|arm_state
operator|->
name|autosuspend_override
operator|++
expr_stmt|;
name|output_timeout_error
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|status
operator|=
name|VCHIQ_RETRY
expr_stmt|;
goto|goto
name|unblock_resume
goto|;
block|}
block|}
do|while
condition|(
literal|0
operator|<
operator|(
name|repeat
operator|--
operator|)
condition|)
do|;
comment|/* Check and report state in case we need to abort ARM suspend */
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|!=
name|VC_SUSPEND_SUSPENDED
condition|)
block|{
name|status
operator|=
name|VCHIQ_RETRY
expr_stmt|;
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s videocore suspend failed (state %s)"
argument_list|,
name|__func__
argument_list|,
name|suspend_state_names
index|[
name|arm_state
operator|->
name|vc_suspend_state
operator|+
name|VC_SUSPEND_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
comment|/* Reset the state only if it's still in an error state. 		 * Something could have already initiated another suspend. */
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|<
name|VC_SUSPEND_IDLE
condition|)
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_IDLE
argument_list|)
expr_stmt|;
goto|goto
name|unblock_resume
goto|;
block|}
comment|/* successfully suspended - unlock and exit */
goto|goto
name|unlock
goto|;
name|unblock_resume
label|:
comment|/* all error states need to unblock resume before exit */
name|unblock_resume
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
name|unlock
label|:
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit %d"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|vchiq_check_suspend
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|!=
name|VC_SUSPEND_SUSPENDED
operator|&&
name|arm_state
operator|->
name|first_connect
operator|&&
operator|!
name|vchiq_videocore_wanted
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|vchiq_arm_vcsuspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|vchiq_arm_allow_resume
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|int
name|resume
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|unblock_resume
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
name|resume
operator|=
name|vchiq_check_resume
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume
condition|)
block|{
if|if
condition|(
name|wait_for_completion_interruptible
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
operator|<
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s interrupted"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* failed, cannot accurately derive suspend 			 * state, so exit early. */
goto|goto
name|out
goto|;
block|}
block|}
name|read_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|==
name|VC_SUSPEND_SUSPENDED
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: Videocore remains suspended"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: Videocore resumed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|read_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit %d"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This function should be called with the write lock held */
end_comment

begin_function
name|int
name|vchiq_check_resume
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|int
name|resume
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_resume
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|set_resume_state
argument_list|(
name|arm_state
argument_list|,
name|VC_RESUME_REQUESTED
argument_list|)
expr_stmt|;
name|request_poll
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|resume
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
name|void
name|vchiq_platform_check_resume
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_state
operator|->
name|wake_address
operator|==
literal|0
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: already awake"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|arm_state
operator|->
name|vc_resume_state
operator|==
name|VC_RESUME_IN_PROGRESS
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: already resuming"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|arm_state
operator|->
name|vc_resume_state
operator|==
name|VC_RESUME_REQUESTED
condition|)
block|{
name|set_resume_state
argument_list|(
name|arm_state
argument_list|,
name|VC_RESUME_IN_PROGRESS
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s: not resuming (resume state %s)"
argument_list|,
name|__func__
argument_list|,
name|resume_state_names
index|[
name|arm_state
operator|->
name|vc_resume_state
operator|+
name|VC_RESUME_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
name|unlock
label|:
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|vchiq_platform_resume
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|VCHIQ_STATUS_T
name|vchiq_use_internal
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|,
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|,
name|enum
name|USE_TYPE_E
name|use_type
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
name|char
name|entity
index|[
literal|16
index|]
decl_stmt|;
name|int
modifier|*
name|entity_uc
decl_stmt|;
name|int
name|local_uc
decl_stmt|,
name|local_entity_uc
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_type
operator|==
name|USE_TYPE_VCHIQ
condition|)
block|{
name|snprintf
argument_list|(
name|entity
argument_list|,
sizeof|sizeof
argument_list|(
name|entity
argument_list|)
argument_list|,
literal|"VCHIQ:   "
argument_list|)
expr_stmt|;
name|entity_uc
operator|=
operator|&
name|arm_state
operator|->
name|peer_use_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|service
condition|)
block|{
name|snprintf
argument_list|(
name|entity
argument_list|,
sizeof|sizeof
argument_list|(
name|entity
argument_list|)
argument_list|,
literal|"%c%c%c%c:%8x"
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service
operator|->
name|base
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service
operator|->
name|client_id
argument_list|)
expr_stmt|;
name|entity_uc
operator|=
operator|&
name|service
operator|->
name|service_use_count
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s null service "
literal|"ptr"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VCHIQ_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|arm_state
operator|->
name|resume_blocked
condition|)
block|{
comment|/* If we call 'use' while force suspend is waiting for suspend, 		 * then we're about to block the thread which the force is 		 * waiting to complete, so we're bound to just time out. In this 		 * case, set the suspend state such that the wait will be 		 * canceled, so we can complete as quickly as possible. */
if|if
condition|(
name|arm_state
operator|->
name|resume_blocked
operator|&&
name|arm_state
operator|->
name|vc_suspend_state
operator|==
name|VC_SUSPEND_IDLE
condition|)
block|{
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_FORCE_CANCELED
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If suspend is already in progress then we need to block */
if|if
condition|(
operator|!
name|try_wait_for_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|resume_blocker
argument_list|)
condition|)
block|{
comment|/* Indicate that there are threads waiting on the resume 			 * blocker.  These need to be allowed to complete before 			 * a _second_ call to force suspend can complete, 			 * otherwise low priority threads might never actually 			 * continue */
name|arm_state
operator|->
name|blocked_count
operator|++
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s resume "
literal|"blocked - waiting..."
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_completion_killable
argument_list|(
operator|&
name|arm_state
operator|->
name|resume_blocker
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s "
literal|"wait for resume blocker interrupted"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VCHIQ_ERROR
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|blocked_count
operator|--
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s resume "
literal|"unblocked"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|arm_state
operator|->
name|blocked_count
operator|==
literal|0
condition|)
name|complete_all
argument_list|(
operator|&
name|arm_state
operator|->
name|blocked_blocker
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_suspend_timer
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
name|local_uc
operator|=
operator|++
name|arm_state
operator|->
name|videocore_use_count
expr_stmt|;
name|local_entity_uc
operator|=
operator|++
operator|(
operator|*
name|entity_uc
operator|)
expr_stmt|;
comment|/* If there's a pending request which hasn't yet been serviced then 	 * just clear it.  If we're past VC_SUSPEND_REQUESTED state then 	 * vc_resume_complete will block until we either resume or fail to 	 * suspend */
if|if
condition|(
name|arm_state
operator|->
name|vc_suspend_state
operator|<=
name|VC_SUSPEND_REQUESTED
condition|)
name|set_suspend_state
argument_list|(
name|arm_state
argument_list|,
name|VC_SUSPEND_IDLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|use_type
operator|!=
name|USE_TYPE_SERVICE_NO_RESUME
operator|)
operator|&&
name|need_resume
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|set_resume_state
argument_list|(
name|arm_state
argument_list|,
name|VC_RESUME_REQUESTED
argument_list|)
expr_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s count %d, state count %d"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|,
name|local_entity_uc
argument_list|,
name|local_uc
argument_list|)
expr_stmt|;
name|request_poll
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s count %d, state count %d"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|,
operator|*
name|entity_uc
argument_list|,
name|local_uc
argument_list|)
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
comment|/* Completion is in a done state when we're not suspended, so this won't 	 * block for the non-suspended case. */
if|if
condition|(
operator|!
name|try_wait_for_completion
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
condition|)
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s wait for resume"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_completion_killable
argument_list|(
operator|&
name|arm_state
operator|->
name|vc_resume_complete
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s wait for "
literal|"resume interrupted"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VCHIQ_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s resumed"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|VCHIQ_SUCCESS
condition|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
name|long
name|ack_cnt
init|=
name|atomic_xchg
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_ack_count
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|ack_cnt
operator|&&
operator|(
name|status
operator|==
name|VCHIQ_SUCCESS
operator|)
condition|)
block|{
comment|/* Send the use notify to videocore */
name|status
operator|=
name|vchiq_send_remote_use_active
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
name|ack_cnt
operator|--
expr_stmt|;
else|else
name|atomic_add
argument_list|(
name|ack_cnt
argument_list|,
operator|&
name|arm_state
operator|->
name|ka_use_ack_count
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit %d"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_release_internal
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|,
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_SUCCESS
decl_stmt|;
name|char
name|entity
index|[
literal|16
index|]
decl_stmt|;
name|int
modifier|*
name|entity_uc
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|snprintf
argument_list|(
name|entity
argument_list|,
sizeof|sizeof
argument_list|(
name|entity
argument_list|)
argument_list|,
literal|"%c%c%c%c:%8x"
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service
operator|->
name|base
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service
operator|->
name|client_id
argument_list|)
expr_stmt|;
name|entity_uc
operator|=
operator|&
name|service
operator|->
name|service_use_count
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|entity
argument_list|,
sizeof|sizeof
argument_list|(
name|entity
argument_list|)
argument_list|,
literal|"PEER:   "
argument_list|)
expr_stmt|;
name|entity_uc
operator|=
operator|&
name|arm_state
operator|->
name|peer_use_count
expr_stmt|;
block|}
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arm_state
operator|->
name|videocore_use_count
operator|||
operator|!
operator|(
operator|*
name|entity_uc
operator|)
condition|)
block|{
comment|/* Don't use BUG_ON - don't allow user thread to crash kernel */
name|WARN_ON
argument_list|(
operator|!
name|arm_state
operator|->
name|videocore_use_count
argument_list|)
expr_stmt|;
name|WARN_ON
argument_list|(
operator|!
operator|(
operator|*
name|entity_uc
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VCHIQ_ERROR
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
operator|--
name|arm_state
operator|->
name|videocore_use_count
expr_stmt|;
operator|--
operator|(
operator|*
name|entity_uc
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|vchiq_videocore_wanted
argument_list|(
name|state
argument_list|)
condition|)
block|{
if|if
condition|(
name|vchiq_platform_use_suspend_timer
argument_list|()
operator|&&
operator|!
name|arm_state
operator|->
name|resume_blocked
condition|)
block|{
comment|/* Only use the timer if we're not trying to force 			 * suspend (=> resume_blocked) */
name|start_suspend_timer
argument_list|(
name|arm_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s count %d, state count %d - suspending"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|,
operator|*
name|entity_uc
argument_list|,
name|arm_state
operator|->
name|videocore_use_count
argument_list|)
expr_stmt|;
name|vchiq_arm_vcsuspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s %s count %d, state count %d"
argument_list|,
name|__func__
argument_list|,
name|entity
argument_list|,
operator|*
name|entity_uc
argument_list|,
name|arm_state
operator|->
name|videocore_use_count
argument_list|)
expr_stmt|;
name|unlock
label|:
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s exit %d"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|vchiq_on_remote_use
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_use_count
argument_list|)
expr_stmt|;
name|complete
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_evt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vchiq_on_remote_release
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_release_count
argument_list|)
expr_stmt|;
name|complete
argument_list|(
operator|&
name|arm_state
operator|->
name|ka_evt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_use_service_internal
parameter_list|(
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
return|return
name|vchiq_use_internal
argument_list|(
name|service
operator|->
name|state
argument_list|,
name|service
argument_list|,
name|USE_TYPE_SERVICE
argument_list|)
return|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_release_service_internal
parameter_list|(
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
return|return
name|vchiq_release_internal
argument_list|(
name|service
operator|->
name|state
argument_list|,
name|service
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|suspend_timer_callback
parameter_list|(
name|unsigned
name|long
name|context
parameter_list|)
block|{
name|VCHIQ_STATE_T
modifier|*
name|state
init|=
operator|(
name|VCHIQ_STATE_T
operator|*
operator|)
name|context
decl_stmt|;
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arm_state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s - suspend timer expired - check suspend"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vchiq_check_suspend
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|out
label|:
return|return;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_use_service_no_resume
parameter_list|(
name|VCHIQ_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_ERROR
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|find_service_by_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|ret
operator|=
name|vchiq_use_internal
argument_list|(
name|service
operator|->
name|state
argument_list|,
name|service
argument_list|,
name|USE_TYPE_SERVICE_NO_RESUME
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_use_service
parameter_list|(
name|VCHIQ_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_ERROR
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|find_service_by_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|ret
operator|=
name|vchiq_use_internal
argument_list|(
name|service
operator|->
name|state
argument_list|,
name|service
argument_list|,
name|USE_TYPE_SERVICE
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_release_service
parameter_list|(
name|VCHIQ_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_ERROR
decl_stmt|;
name|VCHIQ_SERVICE_T
modifier|*
name|service
init|=
name|find_service_by_handle
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|ret
operator|=
name|vchiq_release_internal
argument_list|(
name|service
operator|->
name|state
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|vchiq_dump_service_use_state
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* Only dump 64 services */
specifier|static
specifier|const
name|int
name|local_max_services
init|=
literal|64
decl_stmt|;
comment|/* If there's more than 64 services, only dump ones with 	 * non-zero counts */
name|int
name|only_nonzero
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|nz
init|=
literal|"<-- preventing suspend"
decl_stmt|;
name|enum
name|vc_suspend_status
name|vc_suspend_state
decl_stmt|;
name|enum
name|vc_resume_status
name|vc_resume_state
decl_stmt|;
name|int
name|peer_count
decl_stmt|;
name|int
name|vc_use_count
decl_stmt|;
name|int
name|active_services
decl_stmt|;
struct|struct
name|service_data_struct
block|{
name|int
name|fourcc
decl_stmt|;
name|int
name|clientid
decl_stmt|;
name|int
name|use_count
decl_stmt|;
block|}
name|service_data
index|[
name|local_max_services
index|]
struct|;
if|if
condition|(
operator|!
name|arm_state
condition|)
return|return;
name|read_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|vc_suspend_state
operator|=
name|arm_state
operator|->
name|vc_suspend_state
expr_stmt|;
name|vc_resume_state
operator|=
name|arm_state
operator|->
name|vc_resume_state
expr_stmt|;
name|peer_count
operator|=
name|arm_state
operator|->
name|peer_use_count
expr_stmt|;
name|vc_use_count
operator|=
name|arm_state
operator|->
name|videocore_use_count
expr_stmt|;
name|active_services
operator|=
name|state
operator|->
name|unused_service
expr_stmt|;
if|if
condition|(
name|active_services
operator|>
name|local_max_services
condition|)
name|only_nonzero
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|active_services
operator|)
operator|&&
operator|(
name|j
operator|<
name|local_max_services
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service_ptr
init|=
name|state
operator|->
name|services
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|service_ptr
condition|)
continue|continue;
if|if
condition|(
name|only_nonzero
operator|&&
operator|!
name|service_ptr
operator|->
name|service_use_count
condition|)
continue|continue;
if|if
condition|(
name|service_ptr
operator|->
name|srvstate
operator|!=
name|VCHIQ_SRVSTATE_FREE
condition|)
block|{
name|service_data
index|[
name|j
index|]
operator|.
name|fourcc
operator|=
name|service_ptr
operator|->
name|base
operator|.
name|fourcc
expr_stmt|;
name|service_data
index|[
name|j
index|]
operator|.
name|clientid
operator|=
name|service_ptr
operator|->
name|client_id
expr_stmt|;
name|service_data
index|[
name|j
operator|++
index|]
operator|.
name|use_count
operator|=
name|service_ptr
operator|->
name|service_use_count
expr_stmt|;
block|}
block|}
name|read_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"-- Videcore suspend state: %s --"
argument_list|,
name|suspend_state_names
index|[
name|vc_suspend_state
operator|+
name|VC_SUSPEND_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"-- Videcore resume state: %s --"
argument_list|,
name|resume_state_names
index|[
name|vc_resume_state
operator|+
name|VC_RESUME_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_nonzero
condition|)
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"Too many active "
literal|"services (%d).  Only dumping up to first %d services "
literal|"with non-zero use-count"
argument_list|,
name|active_services
argument_list|,
name|local_max_services
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"----- %c%c%c%c:%d service count %d %s"
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service_data
index|[
name|i
index|]
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service_data
index|[
name|i
index|]
operator|.
name|clientid
argument_list|,
name|service_data
index|[
name|i
index|]
operator|.
name|use_count
argument_list|,
name|service_data
index|[
name|i
index|]
operator|.
name|use_count
condition|?
name|nz
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"----- VCHIQ use count count %d"
argument_list|,
name|peer_count
argument_list|)
expr_stmt|;
name|vchiq_log_warning
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"--- Overall vchiq instance use count %d"
argument_list|,
name|vc_use_count
argument_list|)
expr_stmt|;
name|vchiq_dump_platform_use_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VCHIQ_STATUS_T
name|vchiq_check_service
parameter_list|(
name|VCHIQ_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
decl_stmt|;
name|VCHIQ_STATUS_T
name|ret
init|=
name|VCHIQ_ERROR
decl_stmt|;
if|if
condition|(
operator|!
name|service
operator|||
operator|!
name|service
operator|->
name|state
condition|)
goto|goto
name|out
goto|;
name|vchiq_log_trace
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|arm_state
operator|=
name|vchiq_platform_get_arm_state
argument_list|(
name|service
operator|->
name|state
argument_list|)
expr_stmt|;
name|read_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|->
name|service_use_count
condition|)
name|ret
operator|=
name|VCHIQ_SUCCESS
expr_stmt|;
name|read_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|VCHIQ_ERROR
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%s ERROR - %c%c%c%c:%8x service count %d, "
literal|"state count %d, videocore suspend state %s"
argument_list|,
name|__func__
argument_list|,
name|VCHIQ_FOURCC_AS_4CHARS
argument_list|(
name|service
operator|->
name|base
operator|.
name|fourcc
argument_list|)
argument_list|,
name|service
operator|->
name|client_id
argument_list|,
name|service
operator|->
name|service_use_count
argument_list|,
name|arm_state
operator|->
name|videocore_use_count
argument_list|,
name|suspend_state_names
index|[
name|arm_state
operator|->
name|vc_suspend_state
operator|+
name|VC_SUSPEND_NUM_OFFSET
index|]
argument_list|)
expr_stmt|;
name|vchiq_dump_service_use_state
argument_list|(
name|service
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* stub functions */
end_comment

begin_function
name|void
name|vchiq_on_remote_use_active
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|)
block|{
operator|(
name|void
operator|)
name|state
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vchiq_platform_conn_state_changed
parameter_list|(
name|VCHIQ_STATE_T
modifier|*
name|state
parameter_list|,
name|VCHIQ_CONNSTATE_T
name|oldstate
parameter_list|,
name|VCHIQ_CONNSTATE_T
name|newstate
parameter_list|)
block|{
name|VCHIQ_ARM_STATE_T
modifier|*
name|arm_state
init|=
name|vchiq_platform_get_arm_state
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|vchiq_log_info
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"%d: %s->%s"
argument_list|,
name|state
operator|->
name|id
argument_list|,
name|get_conn_state_name
argument_list|(
name|oldstate
argument_list|)
argument_list|,
name|get_conn_state_name
argument_list|(
name|newstate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|conn_state
operator|==
name|VCHIQ_CONNSTATE_CONNECTED
condition|)
block|{
name|write_lock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arm_state
operator|->
name|first_connect
condition|)
block|{
name|char
name|threadname
index|[
literal|10
index|]
decl_stmt|;
name|arm_state
operator|->
name|first_connect
operator|=
literal|1
expr_stmt|;
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|threadname
argument_list|,
sizeof|sizeof
argument_list|(
name|threadname
argument_list|)
argument_list|,
literal|"VCHIQka-%d"
argument_list|,
name|state
operator|->
name|id
argument_list|)
expr_stmt|;
name|arm_state
operator|->
name|ka_thread
operator|=
name|vchiq_thread_create
argument_list|(
operator|&
name|vchiq_keepalive_thread_func
argument_list|,
operator|(
name|void
operator|*
operator|)
name|state
argument_list|,
name|threadname
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_state
operator|->
name|ka_thread
operator|==
name|NULL
condition|)
block|{
name|vchiq_log_error
argument_list|(
name|vchiq_susp_log_level
argument_list|,
literal|"vchiq: FATAL: couldn't create thread %s"
argument_list|,
name|threadname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wake_up_process
argument_list|(
name|arm_state
operator|->
name|ka_thread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|write_unlock_bh
argument_list|(
operator|&
name|arm_state
operator|->
name|susp_res_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * *   vchiq_init - called when the module is loaded. * ***************************************************************************/
end_comment

begin_function_decl
name|int
name|__init
name|vchiq_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|__init
name|vchiq_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* create proc entries */
name|err
operator|=
name|vchiq_proc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|failed_proc_init
goto|;
endif|#
directive|endif
name|vchiq_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|vchiq_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"vchiq"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vchiq_cdev
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to create /dev/vchiq"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENXIO
operator|)
return|;
block|}
name|spin_lock_init
argument_list|(
operator|&
name|msg_queue_spinlock
argument_list|)
expr_stmt|;
name|err
operator|=
name|vchiq_platform_init
argument_list|(
operator|&
name|g_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|failed_platform_init
goto|;
name|vchiq_log_info
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"vchiq: initialised - version %d (min %d)"
argument_list|,
name|VCHIQ_VERSION
argument_list|,
name|VCHIQ_VERSION_MIN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|failed_platform_init
label|:
if|if
condition|(
name|vchiq_cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|vchiq_cdev
argument_list|)
expr_stmt|;
name|vchiq_cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|vchiq_log_warning
argument_list|(
name|vchiq_arm_log_level
argument_list|,
literal|"could not load vchiq"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|vchiq_instance_get_use_count
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|)
block|{
name|VCHIQ_SERVICE_T
modifier|*
name|service
decl_stmt|;
name|int
name|use_count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|service
operator|=
name|next_service_by_instance
argument_list|(
name|instance
operator|->
name|state
argument_list|,
name|instance
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|use_count
operator|+=
name|service
operator|->
name|service_use_count
expr_stmt|;
name|unlock_service
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
return|return
name|use_count
return|;
block|}
end_function

begin_comment
comment|/* read the per-process use-count */
end_comment

begin_function
specifier|static
name|int
name|proc_read_use_count
parameter_list|(
name|char
modifier|*
name|page
parameter_list|,
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|eof
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
init|=
name|data
decl_stmt|;
name|int
name|len
decl_stmt|,
name|use_count
decl_stmt|;
name|use_count
operator|=
name|vchiq_instance_get_use_count
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|page
operator|+
name|off
argument_list|,
name|count
argument_list|,
literal|"%d\n"
argument_list|,
name|use_count
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* add an instance (process) to the proc entries */
end_comment

begin_function
specifier|static
name|int
name|vchiq_proc_add_instance
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|)
block|{
name|char
name|pidstr
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|proc_dir_entry
modifier|*
name|top
decl_stmt|,
modifier|*
name|use_count
decl_stmt|;
name|struct
name|proc_dir_entry
modifier|*
name|clients
init|=
name|vchiq_clients_top
argument_list|()
decl_stmt|;
name|int
name|pid
init|=
name|instance
operator|->
name|pid
decl_stmt|;
name|snprintf
argument_list|(
name|pidstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pidstr
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|top
operator|=
name|proc_mkdir
argument_list|(
name|pidstr
argument_list|,
name|clients
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
goto|goto
name|fail_top
goto|;
name|use_count
operator|=
name|create_proc_read_entry
argument_list|(
literal|"use_count"
argument_list|,
literal|0444
argument_list|,
name|top
argument_list|,
name|proc_read_use_count
argument_list|,
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_count
condition|)
goto|goto
name|fail_use_count
goto|;
name|instance
operator|->
name|proc_entry
operator|=
name|top
expr_stmt|;
return|return
literal|0
return|;
name|fail_use_count
label|:
name|remove_proc_entry
argument_list|(
name|top
operator|->
name|name
argument_list|,
name|clients
argument_list|)
expr_stmt|;
name|fail_top
label|:
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vchiq_proc_remove_instance
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|)
block|{
name|struct
name|proc_dir_entry
modifier|*
name|clients
init|=
name|vchiq_clients_top
argument_list|()
decl_stmt|;
name|remove_proc_entry
argument_list|(
literal|"use_count"
argument_list|,
name|instance
operator|->
name|proc_entry
argument_list|)
expr_stmt|;
name|remove_proc_entry
argument_list|(
name|instance
operator|->
name|proc_entry
operator|->
name|name
argument_list|,
name|clients
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************** * *   vchiq_exit - called when the module is unloaded. * ***************************************************************************/
end_comment

begin_function_decl
name|void
name|vchiq_exit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|vchiq_exit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vchiq_ehtag
operator|==
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|dev_clone
argument_list|,
name|vchiq_ehtag
argument_list|)
expr_stmt|;
name|vchiq_ehtag
operator|=
name|NULL
expr_stmt|;
name|vchiq_platform_exit
argument_list|(
operator|&
name|g_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|vchiq_cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|vchiq_cdev
argument_list|)
expr_stmt|;
name|vchiq_cdev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

end_unit

