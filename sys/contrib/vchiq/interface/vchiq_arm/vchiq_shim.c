begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2010-2012 Broadcom. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the above-listed copyright holders may not be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * ALTERNATIVELY, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2, as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<interface/compat/vchi_bsd.h>
end_include

begin_include
include|#
directive|include
file|"interface/vchi/vchi.h"
end_include

begin_include
include|#
directive|include
file|"vchiq.h"
end_include

begin_include
include|#
directive|include
file|"vchiq_core.h"
end_include

begin_include
include|#
directive|include
file|"vchiq_util.h"
end_include

begin_define
define|#
directive|define
name|vchiq_status_to_vchi
parameter_list|(
name|status
parameter_list|)
value|((int32_t)status)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|VCHIQ_SERVICE_HANDLE_T
name|handle
decl_stmt|;
name|VCHIU_QUEUE_T
name|queue
decl_stmt|;
name|VCHI_CALLBACK_T
name|callback
decl_stmt|;
name|void
modifier|*
name|callback_param
decl_stmt|;
block|}
name|SHIM_SERVICE_T
typedef|;
end_typedef

begin_comment
comment|/* ----------------------------------------------------------------------  * return pointer to the mphi message driver function table  * -------------------------------------------------------------------- */
end_comment

begin_function
specifier|const
name|VCHI_MESSAGE_DRIVER_T
modifier|*
name|vchi_mphi_message_driver_func_table
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  * return a pointer to the 'single' connection driver fops  * -------------------------------------------------------------------- */
end_comment

begin_function
specifier|const
name|VCHI_CONNECTION_API_T
modifier|*
name|single_get_func_table
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|VCHI_CONNECTION_T
modifier|*
name|vchi_create_connection
parameter_list|(
specifier|const
name|VCHI_CONNECTION_API_T
modifier|*
name|function_table
parameter_list|,
specifier|const
name|VCHI_MESSAGE_DRIVER_T
modifier|*
name|low_level
parameter_list|)
block|{
operator|(
name|void
operator|)
name|function_table
expr_stmt|;
operator|(
name|void
operator|)
name|low_level
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/***********************************************************  * Name: vchi_msg_peek  *  * Arguments:  const VCHI_SERVICE_HANDLE_T handle,  *             void **data,  *             uint32_t *msg_size,    *             VCHI_FLAGS_T flags  *  * Description: Routine to return a pointer to the current message (to allow in  *              place processing). The message can be removed using  *              vchi_msg_remove when you're finished  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_msg_peek
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|uint32_t
modifier|*
name|msg_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
name|WARN_ON
argument_list|(
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_NONE
operator|)
operator|&&
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|VCHI_FLAGS_NONE
condition|)
if|if
condition|(
name|vchiu_queue_is_empty
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|header
operator|=
name|vchiu_queue_peek
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|header
operator|->
name|data
expr_stmt|;
operator|*
name|msg_size
operator|=
name|header
operator|->
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_msg_peek
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_msg_remove  *  * Arguments:  const VCHI_SERVICE_HANDLE_T handle,  *  * Description: Routine to remove a message (after it has been read with  *              vchi_msg_peek)  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_msg_remove
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
name|header
operator|=
name|vchiu_queue_pop
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
expr_stmt|;
name|vchiq_release_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_msg_remove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_msg_queue  *  * Arguments:  VCHI_SERVICE_HANDLE_T handle,  *             const void *data,  *             uint32_t data_size,  *             VCHI_FLAGS_T flags,  *             void *msg_handle,  *  * Description: Thin wrapper to queue a message onto a connection  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_msg_queue
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|data_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|,
name|void
modifier|*
name|msg_handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_ELEMENT_T
name|element
init|=
block|{
name|data
block|,
name|data_size
block|}
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
operator|(
name|void
operator|)
name|msg_handle
expr_stmt|;
name|WARN_ON
argument_list|(
name|flags
operator|!=
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_queue_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
operator|&
name|element
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* vchiq_queue_message() may return VCHIQ_RETRY, so we need to 	** implement a retry mechanism since this function is supposed 	** to block until queued 	*/
while|while
condition|(
name|status
operator|==
name|VCHIQ_RETRY
condition|)
block|{
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_queue_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
operator|&
name|element
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_msg_queue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_bulk_queue_receive  *  * Arguments:  VCHI_BULK_HANDLE_T handle,  *             void *data_dst,  *             const uint32_t data_size,  *             VCHI_FLAGS_T flags  *             void *bulk_handle  *  * Description: Routine to setup a rcv buffer  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_bulk_queue_receive
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
name|data_dst
parameter_list|,
name|uint32_t
name|data_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|,
name|void
modifier|*
name|bulk_handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_BULK_MODE_T
name|mode
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|flags
condition|)
block|{
case|case
name|VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE
operator||
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
case|:
name|WARN_ON
argument_list|(
operator|!
name|service
operator|->
name|callback
argument_list|)
expr_stmt|;
name|mode
operator|=
name|VCHIQ_BULK_MODE_CALLBACK
expr_stmt|;
break|break;
case|case
name|VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE
case|:
name|mode
operator|=
name|VCHIQ_BULK_MODE_BLOCKING
expr_stmt|;
break|break;
case|case
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
case|:
case|case
name|VCHI_FLAGS_NONE
case|:
name|mode
operator|=
name|VCHIQ_BULK_MODE_NOCALLBACK
expr_stmt|;
break|break;
default|default:
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"unsupported message\n"
argument_list|)
expr_stmt|;
return|return
name|vchiq_status_to_vchi
argument_list|(
name|VCHIQ_ERROR
argument_list|)
return|;
block|}
name|status
operator|=
name|vchiq_bulk_receive
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|data_dst
argument_list|,
name|data_size
argument_list|,
name|bulk_handle
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* vchiq_bulk_receive() may return VCHIQ_RETRY, so we need to 	** implement a retry mechanism since this function is supposed 	** to block until queued 	*/
while|while
condition|(
name|status
operator|==
name|VCHIQ_RETRY
condition|)
block|{
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_bulk_receive
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|data_dst
argument_list|,
name|data_size
argument_list|,
name|bulk_handle
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_bulk_queue_receive
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_bulk_queue_transmit  *  * Arguments:  VCHI_BULK_HANDLE_T handle,  *             void *data_src,  *             uint32_t data_size,  *             VCHI_FLAGS_T flags,  *             void *bulk_handle  *  * Description: Routine to transmit some data  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_bulk_queue_transmit
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
name|data_src
parameter_list|,
name|uint32_t
name|data_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|,
name|void
modifier|*
name|bulk_handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_BULK_MODE_T
name|mode
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|flags
condition|)
block|{
case|case
name|VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE
operator||
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
case|:
name|WARN_ON
argument_list|(
operator|!
name|service
operator|->
name|callback
argument_list|)
expr_stmt|;
name|mode
operator|=
name|VCHIQ_BULK_MODE_CALLBACK
expr_stmt|;
break|break;
case|case
name|VCHI_FLAGS_BLOCK_UNTIL_DATA_READ
case|:
case|case
name|VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE
case|:
name|mode
operator|=
name|VCHIQ_BULK_MODE_BLOCKING
expr_stmt|;
break|break;
case|case
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
case|:
case|case
name|VCHI_FLAGS_NONE
case|:
name|mode
operator|=
name|VCHIQ_BULK_MODE_NOCALLBACK
expr_stmt|;
break|break;
default|default:
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"unsupported message\n"
argument_list|)
expr_stmt|;
return|return
name|vchiq_status_to_vchi
argument_list|(
name|VCHIQ_ERROR
argument_list|)
return|;
block|}
name|status
operator|=
name|vchiq_bulk_transmit
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|data_src
argument_list|,
name|data_size
argument_list|,
name|bulk_handle
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* vchiq_bulk_transmit() may return VCHIQ_RETRY, so we need to 	** implement a retry mechanism since this function is supposed 	** to block until queued 	*/
while|while
condition|(
name|status
operator|==
name|VCHIQ_RETRY
condition|)
block|{
name|msleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|vchiq_bulk_transmit
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|data_src
argument_list|,
name|data_size
argument_list|,
name|bulk_handle
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_bulk_queue_transmit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_msg_dequeue  *  * Arguments:  VCHI_SERVICE_HANDLE_T handle,  *             void *data,  *             uint32_t max_data_size_to_read,  *             uint32_t *actual_msg_size  *             VCHI_FLAGS_T flags  *  * Description: Routine to dequeue a message into the supplied buffer  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_msg_dequeue
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|max_data_size_to_read
parameter_list|,
name|uint32_t
modifier|*
name|actual_msg_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
name|WARN_ON
argument_list|(
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_NONE
operator|)
operator|&&
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|VCHI_FLAGS_NONE
condition|)
if|if
condition|(
name|vchiu_queue_is_empty
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|header
operator|=
name|vchiu_queue_pop
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|header
operator|->
name|data
argument_list|,
name|header
operator|->
name|size
operator|<
name|max_data_size_to_read
condition|?
name|header
operator|->
name|size
else|:
name|max_data_size_to_read
argument_list|)
expr_stmt|;
operator|*
name|actual_msg_size
operator|=
name|header
operator|->
name|size
expr_stmt|;
name|vchiq_release_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_msg_dequeue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_msg_queuev  *  * Arguments:  VCHI_SERVICE_HANDLE_T handle,  *             VCHI_MSG_VECTOR_T *vector,  *             uint32_t count,  *             VCHI_FLAGS_T flags,  *             void *msg_handle  *  * Description: Thin wrapper to queue a message onto a connection  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_expr_stmt
name|vchiq_static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|VCHI_MSG_VECTOR_T
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|VCHIQ_ELEMENT_T
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vchiq_static_assert
argument_list|(
name|offsetof
argument_list|(
name|VCHI_MSG_VECTOR_T
argument_list|,
name|vec_base
argument_list|)
operator|==
name|offsetof
argument_list|(
name|VCHIQ_ELEMENT_T
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vchiq_static_assert
argument_list|(
name|offsetof
argument_list|(
name|VCHI_MSG_VECTOR_T
argument_list|,
name|vec_len
argument_list|)
operator|==
name|offsetof
argument_list|(
name|VCHIQ_ELEMENT_T
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int32_t
name|vchi_msg_queuev
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|VCHI_MSG_VECTOR_T
modifier|*
name|vector
parameter_list|,
name|uint32_t
name|count
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|,
name|void
modifier|*
name|msg_handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
operator|(
name|void
operator|)
name|msg_handle
expr_stmt|;
name|WARN_ON
argument_list|(
name|flags
operator|!=
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|)
expr_stmt|;
return|return
name|vchiq_status_to_vchi
argument_list|(
name|vchiq_queue_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
operator|(
specifier|const
name|VCHIQ_ELEMENT_T
operator|*
operator|)
name|vector
argument_list|,
name|count
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_msg_queuev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_held_msg_release  *  * Arguments:  VCHI_HELD_MSG_T *message  *  * Description: Routine to release a held message (after it has been read with  *              vchi_msg_hold)  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_held_msg_release
parameter_list|(
name|VCHI_HELD_MSG_T
modifier|*
name|message
parameter_list|)
block|{
name|vchiq_release_message
argument_list|(
operator|(
name|VCHIQ_SERVICE_HANDLE_T
operator|)
name|message
operator|->
name|service
argument_list|,
operator|(
name|VCHIQ_HEADER_T
operator|*
operator|)
name|message
operator|->
name|message
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***********************************************************  * Name: vchi_msg_hold  *  * Arguments:  VCHI_SERVICE_HANDLE_T handle,  *             void **data,  *             uint32_t *msg_size,  *             VCHI_FLAGS_T flags,  *             VCHI_HELD_MSG_T *message_handle  *  * Description: Routine to return a pointer to the current message (to allow  *              in place processing). The message is dequeued - don't forget  *              to release the message using vchi_held_msg_release when you're  *              finished.  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_msg_hold
parameter_list|(
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|uint32_t
modifier|*
name|msg_size
parameter_list|,
name|VCHI_FLAGS_T
name|flags
parameter_list|,
name|VCHI_HELD_MSG_T
modifier|*
name|message_handle
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
name|VCHIQ_HEADER_T
modifier|*
name|header
decl_stmt|;
name|WARN_ON
argument_list|(
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_NONE
operator|)
operator|&&
operator|(
name|flags
operator|!=
name|VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|VCHI_FLAGS_NONE
condition|)
if|if
condition|(
name|vchiu_queue_is_empty
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|header
operator|=
name|vchiu_queue_pop
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|header
operator|->
name|data
expr_stmt|;
operator|*
name|msg_size
operator|=
name|header
operator|->
name|size
expr_stmt|;
name|message_handle
operator|->
name|service
operator|=
operator|(
expr|struct
name|opaque_vchi_service_t
operator|*
operator|)
name|service
operator|->
name|handle
expr_stmt|;
name|message_handle
operator|->
name|message
operator|=
name|header
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***********************************************************  * Name: vchi_initialise  *  * Arguments: VCHI_INSTANCE_T *instance_handle  *            VCHI_CONNECTION_T **connections  *            const uint32_t num_connections  *  * Description: Initialises the hardware but does not transmit anything  *              When run as a Host App this will be called twice hence the need  *              to malloc the state information  *  * Returns: 0 if successful, failure otherwise  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_initialise
parameter_list|(
name|VCHI_INSTANCE_T
modifier|*
name|instance_handle
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
name|status
operator|=
name|vchiq_initialise
argument_list|(
operator|&
name|instance
argument_list|)
expr_stmt|;
operator|*
name|instance_handle
operator|=
operator|(
name|VCHI_INSTANCE_T
operator|)
name|instance
expr_stmt|;
return|return
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_initialise
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_connect  *  * Arguments: VCHI_CONNECTION_T **connections  *            const uint32_t num_connections  *            VCHI_INSTANCE_T instance_handle)  *  * Description: Starts the command service on each connection,  *              causing INIT messages to be pinged back and forth  *  * Returns: 0 if successful, failure otherwise  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_connect
parameter_list|(
name|VCHI_CONNECTION_T
modifier|*
modifier|*
name|connections
parameter_list|,
specifier|const
name|uint32_t
name|num_connections
parameter_list|,
name|VCHI_INSTANCE_T
name|instance_handle
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
init|=
operator|(
name|VCHIQ_INSTANCE_T
operator|)
name|instance_handle
decl_stmt|;
operator|(
name|void
operator|)
name|connections
expr_stmt|;
operator|(
name|void
operator|)
name|num_connections
expr_stmt|;
return|return
name|vchiq_connect
argument_list|(
name|instance
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_connect
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_disconnect  *  * Arguments: VCHI_INSTANCE_T instance_handle  *  * Description: Stops the command service on each connection,  *              causing DE-INIT messages to be pinged back and forth  *  * Returns: 0 if successful, failure otherwise  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_disconnect
parameter_list|(
name|VCHI_INSTANCE_T
name|instance_handle
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
init|=
operator|(
name|VCHIQ_INSTANCE_T
operator|)
name|instance_handle
decl_stmt|;
return|return
name|vchiq_status_to_vchi
argument_list|(
name|vchiq_shutdown
argument_list|(
name|instance
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_disconnect
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_service_open  * Name: vchi_service_create  *  * Arguments: VCHI_INSTANCE_T *instance_handle  *            SERVICE_CREATION_T *setup,  *            VCHI_SERVICE_HANDLE_T *handle  *  * Description: Routine to open a service  *  * Returns: int32_t - success == 0  *  ***********************************************************/
end_comment

begin_function
specifier|static
name|VCHIQ_STATUS_T
name|shim_callback
parameter_list|(
name|VCHIQ_REASON_T
name|reason
parameter_list|,
name|VCHIQ_HEADER_T
modifier|*
name|header
parameter_list|,
name|VCHIQ_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|void
modifier|*
name|bulk_user
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|VCHIQ_GET_SERVICE_USERDATA
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|service
operator|->
name|callback
condition|)
goto|goto
name|release
goto|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|VCHIQ_MESSAGE_AVAILABLE
case|:
name|vchiu_queue_push
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_MSG_AVAILABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
break|break;
case|case
name|VCHIQ_BULK_TRANSMIT_DONE
case|:
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_BULK_SENT
argument_list|,
name|bulk_user
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCHIQ_BULK_RECEIVE_DONE
case|:
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_BULK_RECEIVED
argument_list|,
name|bulk_user
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCHIQ_SERVICE_CLOSED
case|:
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_SERVICE_CLOSED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCHIQ_SERVICE_OPENED
case|:
comment|/* No equivalent VCHI reason */
break|break;
case|case
name|VCHIQ_BULK_TRANSMIT_ABORTED
case|:
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_BULK_TRANSMIT_ABORTED
argument_list|,
name|bulk_user
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCHIQ_BULK_RECEIVE_ABORTED
case|:
name|service
operator|->
name|callback
argument_list|(
name|service
operator|->
name|callback_param
argument_list|,
name|VCHI_CALLBACK_BULK_RECEIVE_ABORTED
argument_list|,
name|bulk_user
argument_list|)
expr_stmt|;
break|break;
default|default:
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"not supported\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
label|:
name|vchiq_release_message
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|done
label|:
return|return
name|VCHIQ_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|SHIM_SERVICE_T
modifier|*
name|service_alloc
parameter_list|(
name|VCHIQ_INSTANCE_T
name|instance
parameter_list|,
name|SERVICE_CREATION_T
modifier|*
name|setup
parameter_list|)
block|{
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SHIM_SERVICE_T
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|instance
expr_stmt|;
if|if
condition|(
name|service
condition|)
block|{
if|if
condition|(
name|vchiu_queue_init
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|,
literal|64
argument_list|)
condition|)
block|{
name|service
operator|->
name|callback
operator|=
name|setup
operator|->
name|callback
expr_stmt|;
name|service
operator|->
name|callback_param
operator|=
name|setup
operator|->
name|callback_param
expr_stmt|;
block|}
else|else
block|{
name|kfree
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|service
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|service_free
parameter_list|(
name|SHIM_SERVICE_T
modifier|*
name|service
parameter_list|)
block|{
if|if
condition|(
name|service
condition|)
block|{
name|vchiu_queue_delete
argument_list|(
operator|&
name|service
operator|->
name|queue
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int32_t
name|vchi_service_open
parameter_list|(
name|VCHI_INSTANCE_T
name|instance_handle
parameter_list|,
name|SERVICE_CREATION_T
modifier|*
name|setup
parameter_list|,
name|VCHI_SERVICE_HANDLE_T
modifier|*
name|handle
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
init|=
operator|(
name|VCHIQ_INSTANCE_T
operator|)
name|instance_handle
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
name|service_alloc
argument_list|(
name|instance
argument_list|,
name|setup
argument_list|)
decl_stmt|;
operator|*
name|handle
operator|=
operator|(
name|VCHI_SERVICE_HANDLE_T
operator|)
name|service
expr_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|VCHIQ_SERVICE_PARAMS_T
name|params
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|fourcc
operator|=
name|setup
operator|->
name|service_id
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|shim_callback
expr_stmt|;
name|params
operator|.
name|userdata
operator|=
name|service
expr_stmt|;
name|params
operator|.
name|version
operator|=
name|setup
operator|->
name|version
operator|.
name|version
expr_stmt|;
name|params
operator|.
name|version_min
operator|=
name|setup
operator|->
name|version
operator|.
name|version_min
expr_stmt|;
name|status
operator|=
name|vchiq_open_service
argument_list|(
name|instance
argument_list|,
operator|&
name|params
argument_list|,
operator|&
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|service_free
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
operator|*
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|service
operator|!=
name|NULL
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int32_t
name|vchi_service_create
parameter_list|(
name|VCHI_INSTANCE_T
name|instance_handle
parameter_list|,
name|SERVICE_CREATION_T
modifier|*
name|setup
parameter_list|,
name|VCHI_SERVICE_HANDLE_T
modifier|*
name|handle
parameter_list|)
block|{
name|VCHIQ_INSTANCE_T
name|instance
init|=
operator|(
name|VCHIQ_INSTANCE_T
operator|)
name|instance_handle
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
name|service_alloc
argument_list|(
name|instance
argument_list|,
name|setup
argument_list|)
decl_stmt|;
operator|*
name|handle
operator|=
operator|(
name|VCHI_SERVICE_HANDLE_T
operator|)
name|service
expr_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|VCHIQ_SERVICE_PARAMS_T
name|params
decl_stmt|;
name|VCHIQ_STATUS_T
name|status
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|fourcc
operator|=
name|setup
operator|->
name|service_id
expr_stmt|;
name|params
operator|.
name|callback
operator|=
name|shim_callback
expr_stmt|;
name|params
operator|.
name|userdata
operator|=
name|service
expr_stmt|;
name|params
operator|.
name|version
operator|=
name|setup
operator|->
name|version
operator|.
name|version
expr_stmt|;
name|params
operator|.
name|version_min
operator|=
name|setup
operator|->
name|version
operator|.
name|version_min
expr_stmt|;
name|status
operator|=
name|vchiq_add_service
argument_list|(
name|instance
argument_list|,
operator|&
name|params
argument_list|,
operator|&
name|service
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|VCHIQ_SUCCESS
condition|)
block|{
name|service_free
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
operator|*
name|handle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|service
operator|!=
name|NULL
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_create
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int32_t
name|vchi_service_close
parameter_list|(
specifier|const
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|vchiq_close_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
block|{
name|service_free
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_close
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int32_t
name|vchi_service_destroy
parameter_list|(
specifier|const
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|vchiq_remove_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|VCHIQ_SUCCESS
condition|)
block|{
name|service_free
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_destroy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int32_t
name|vchi_get_peer_version
parameter_list|(
specifier|const
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|,
name|short
modifier|*
name|peer_version
parameter_list|)
block|{
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|service
condition|)
block|{
name|VCHIQ_STATUS_T
name|status
init|=
name|vchiq_get_peer_version
argument_list|(
name|service
operator|->
name|handle
argument_list|,
name|peer_version
argument_list|)
decl_stmt|;
name|ret
operator|=
name|vchiq_status_to_vchi
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_get_peer_version
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/* ----------------------------------------------------------------------  * read a uint32_t from buffer.  * network format is defined to be little endian  * -------------------------------------------------------------------- */
end_comment

begin_function
name|uint32_t
name|vchi_readbuf_uint32
parameter_list|(
specifier|const
name|void
modifier|*
name|_ptr
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|_ptr
decl_stmt|;
return|return
name|ptr
index|[
literal|0
index|]
operator||
operator|(
name|ptr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ptr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ptr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  * write a uint32_t to buffer.  * network format is defined to be little endian  * -------------------------------------------------------------------- */
end_comment

begin_function
name|void
name|vchi_writebuf_uint32
parameter_list|(
name|void
modifier|*
name|_ptr
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|_ptr
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  * read a uint16_t from buffer.  * network format is defined to be little endian  * -------------------------------------------------------------------- */
end_comment

begin_function
name|uint16_t
name|vchi_readbuf_uint16
parameter_list|(
specifier|const
name|void
modifier|*
name|_ptr
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|_ptr
decl_stmt|;
return|return
name|ptr
index|[
literal|0
index|]
operator||
operator|(
name|ptr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ----------------------------------------------------------------------  * write a uint16_t into the buffer.  * network format is defined to be little endian  * -------------------------------------------------------------------- */
end_comment

begin_function
name|void
name|vchi_writebuf_uint16
parameter_list|(
name|void
modifier|*
name|_ptr
parameter_list|,
name|uint16_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|_ptr
decl_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|value
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***********************************************************  * Name: vchi_service_use  *  * Arguments: const VCHI_SERVICE_HANDLE_T handle  *  * Description: Routine to increment refcount on a service  *  * Returns: void  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_service_use
parameter_list|(
specifier|const
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|service
condition|)
name|ret
operator|=
name|vchiq_status_to_vchi
argument_list|(
name|vchiq_use_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_use
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/***********************************************************  * Name: vchi_service_release  *  * Arguments: const VCHI_SERVICE_HANDLE_T handle  *  * Description: Routine to decrement refcount on a service  *  * Returns: void  *  ***********************************************************/
end_comment

begin_function
name|int32_t
name|vchi_service_release
parameter_list|(
specifier|const
name|VCHI_SERVICE_HANDLE_T
name|handle
parameter_list|)
block|{
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|SHIM_SERVICE_T
modifier|*
name|service
init|=
operator|(
name|SHIM_SERVICE_T
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|service
condition|)
name|ret
operator|=
name|vchiq_status_to_vchi
argument_list|(
name|vchiq_release_service
argument_list|(
name|service
operator|->
name|handle
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|vchi_service_release
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

