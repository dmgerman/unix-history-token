begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Intel Corporation.  All rights reserved.  * Copyright (c) 2004 Topspin Corporation.  All rights reserved.  * Copyright (c) 2004, 2005 Voltaire Corporation.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.  * Copyright (c) 2005 Network Appliance, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<contrib/rdma/iw_cm.h>
end_include

begin_enum
enum|enum
name|iw_cm_state
block|{
name|IW_CM_STATE_IDLE
block|,
comment|/* unbound, inactive */
name|IW_CM_STATE_LISTEN
block|,
comment|/* listen waiting for connect */
name|IW_CM_STATE_CONN_RECV
block|,
comment|/* inbound waiting for user accept */
name|IW_CM_STATE_CONN_SENT
block|,
comment|/* outbound waiting for peer accept */
name|IW_CM_STATE_ESTABLISHED
block|,
comment|/* established */
name|IW_CM_STATE_CLOSING
block|,
comment|/* disconnect */
name|IW_CM_STATE_DESTROYING
comment|/* object being deleted */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|iwcm_id_private
block|{
name|struct
name|iw_cm_id
name|id
decl_stmt|;
name|enum
name|iw_cm_state
name|state
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|void
modifier|*
name|destroy_comp
decl_stmt|;
name|void
modifier|*
name|connect_wait
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|iwcm_work
argument_list|)
name|work_list
expr_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
specifier|volatile
name|int
name|refcount
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|iwcm_work
argument_list|)
name|work_free_list
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IWCM_F_CALLBACK_DESTROY
value|1
end_define

begin_define
define|#
directive|define
name|IWCM_F_CONNECT_WAIT
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|iwcm_wq
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|iwcm_work
block|{
name|struct
name|task
name|task
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|iwcm_work
argument_list|)
name|list
expr_stmt|;
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|iwcm_work
argument_list|)
name|free_list
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The following services provide a mechanism for pre-allocating iwcm_work  * elements.  The design pre-allocates them  based on the cm_id type:  *	LISTENING IDS: 	Get enough elements preallocated to handle the  *			listen backlog.  *	ACTIVE IDS:	4: CONNECT_REPLY, ESTABLISHED, DISCONNECT, CLOSE  *	PASSIVE IDS:	3: ESTABLISHED, DISCONNECT, CLOSE  *  * Allocating them in connect and listen avoids having to deal  * with allocation failures on the event upcall from the provider (which  * is called in the interrupt context).  *  * One exception is when creating the cm_id for incoming connection requests.  * There are two cases:  * 1) in the event upcall, cm_event_handler(), for a listening cm_id.  If  *    the backlog is exceeded, then no more connection request events will  *    be processed.  cm_event_handler() returns ENOMEM in this case.  Its up  *    to the provider to reject the connection request.  * 2) in the connection request workqueue handler, cm_conn_req_handler().  *    If work elements cannot be allocated for the new connect request cm_id,  *    then IWCM will call the provider reject method.  This is ok since  *    cm_conn_req_handler() runs in the workqueue thread context.  */
end_comment

begin_function
specifier|static
name|struct
name|iwcm_work
modifier|*
name|get_work
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
condition|)
return|return
name|NULL
return|;
name|work
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|,
name|work
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
return|return
name|work
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_work
parameter_list|(
name|struct
name|iwcm_work
modifier|*
name|work
parameter_list|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|work
operator|->
name|cm_id
operator|->
name|work_free_list
argument_list|,
name|work
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dealloc_work_entries
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|e
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|e
argument_list|,
argument|&cm_id_priv->work_free_list
argument_list|,
argument|free_list
argument_list|,
argument|tmp
argument_list|)
name|free
argument_list|(
name|e
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_work_entries
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
name|PANIC_IF
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|work
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwcm_work
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
block|{
name|dealloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|work
operator|->
name|cm_id
operator|=
name|cm_id_priv
expr_stmt|;
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Save private data from incoming connection requests to  * iw_cm_event, so the low level driver doesn't have to. Adjust  * the event ptr to point to the local copy.  */
end_comment

begin_function
specifier|static
name|int
name|copy_private_data
parameter_list|(
name|struct
name|iw_cm_event
modifier|*
name|event
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|event
operator|->
name|private_data_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|event
operator|->
name|private_data
argument_list|,
name|p
argument_list|,
name|event
operator|->
name|private_data_len
argument_list|)
expr_stmt|;
name|event
operator|->
name|private_data
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cm_id
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|dealloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cm_id_priv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a reference on cm_id. If the last reference is being  * released, enable the waiting thread (in iw_destroy_cm_id) to  * get woken up, and return 1 if a thread is already waiting.  */
end_comment

begin_function
specifier|static
name|int
name|iwcm_deref_id
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|PANIC_IF
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|destroy_comp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_ref
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_ref
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
operator|&&
name|isset
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CALLBACK_DESTROY
argument_list|)
condition|)
block|{
name|PANIC_IF
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|cm_event_handler
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|iw_cm_id
modifier|*
name|iw_create_cm_id
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|iw_cm_handler
name|cm_handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|KASSERT
argument_list|(
name|so
argument_list|,
operator|(
literal|"iw_create_cm_id called with NULL socket!"
operator|)
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cm_id_priv
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cm_id_priv
condition|)
return|return
name|ERR_PTR
argument_list|(
name|ENOMEM
argument_list|)
return|;
name|bzero
argument_list|(
name|cm_id_priv
argument_list|,
sizeof|sizeof
expr|*
name|cm_id_priv
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
operator|=
name|cm_handler
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|event_handler
operator|=
name|cm_event_handler
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|add_ref
operator|=
name|add_ref
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|rem_ref
operator|=
name|rem_ref
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|so
operator|=
name|so
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
literal|"cm_id_priv"
argument_list|,
name|NULL
argument_list|,
name|MTX_DUPOK
operator||
name|MTX_DEF
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
expr_stmt|;
return|return
operator|&
name|cm_id_priv
operator|->
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwcm_modify_qp_err
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ib_qp_attr
name|qp_attr
decl_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|IB_QPS_ERR
expr_stmt|;
return|return
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
operator|&
name|qp_attr
argument_list|,
name|IB_QP_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is really the RDMAC CLOSING state. It is most similar to the  * IB SQD QP state.  */
end_comment

begin_function
specifier|static
name|int
name|iwcm_modify_qp_sqd
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ib_qp_attr
name|qp_attr
decl_stmt|;
name|PANIC_IF
argument_list|(
name|qp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|IB_QPS_SQD
expr_stmt|;
return|return
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
operator|&
name|qp_attr
argument_list|,
name|IB_QP_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- CLOSING  *  * Block if a passive or active connection is currently being processed. Then  * process the event as follows:  * - If we are ESTABLISHED, move to CLOSING and modify the QP state  *   based on the abrupt flag  * - If the connection is already in the CLOSING or IDLE state, the peer is  *   disconnecting concurrently with us and we've already seen the  *   DISCONNECT event -- ignore the request and return 0  * - Disconnect on a listening endpoint returns EINVAL  */
end_comment

begin_function
name|int
name|iw_cm_disconnect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|abrupt
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
init|=
name|NULL
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Wait if we're currently in a connect or accept downcall */
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
condition|)
name|msleep
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"iwcm connect1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CLOSING
expr_stmt|;
comment|/* QP could be<nul> for user-mode client */
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
name|qp
operator|=
name|cm_id_priv
operator|->
name|qp
expr_stmt|;
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_LISTEN
case|:
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CLOSING
case|:
comment|/* remote peer closed first */
case|case
name|IW_CM_STATE_IDLE
case|:
comment|/* accept or connect returned !0 */
break|break;
case|case
name|IW_CM_STATE_CONN_RECV
case|:
comment|/* 		 * App called disconnect before/without calling accept after 		 * connect_request event delivered. 		 */
break|break;
case|case
name|IW_CM_STATE_CONN_SENT
case|:
comment|/* Can only get here if wait above fails */
default|default:
name|panic
argument_list|(
literal|"just cuz"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
block|{
if|if
condition|(
name|abrupt
condition|)
name|ret
operator|=
name|iwcm_modify_qp_err
argument_list|(
name|qp
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|iwcm_modify_qp_sqd
argument_list|(
name|qp
argument_list|)
expr_stmt|;
comment|/* 		 * If both sides are disconnecting the QP could 		 * already be in ERR or SQD states 		 */
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- DESTROYING  *  * Clean up all resources associated with the connection and release  * the initial reference taken by iw_create_cm_id.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_cm_id
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Wait if we're currently in a connect or accept downcall. A 	 * listening endpoint should never block here. 	 */
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
condition|)
name|msleep
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"iwcm connect2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_LISTEN
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* destroy the listening endpoint */
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|destroy_listen
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Abrupt close of the connection */
operator|(
name|void
operator|)
name|iwcm_modify_qp_err
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CLOSING
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CONN_RECV
case|:
comment|/* 		 * App called destroy before/without calling accept after 		 * receiving connection request event notification or 		 * returned non zero from the event callback function. 		 * In either case, must tell the provider to reject. 		 */
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_DESTROYING
case|:
default|default:
name|panic
argument_list|(
literal|"just cuz"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is only called by the application thread and cannot  * be called by the event thread. The function will wait for all  * references to be released on the cm_id and then free the cm_id  * object.  */
end_comment

begin_function
name|void
name|iw_destroy_cm_id
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|isset
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CALLBACK_DESTROY
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
condition|)
name|msleep
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|destroy_comp
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"iwcm destroy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- LISTEN  *  * Start listening for connect requests. Generates one CONNECT_REQUEST  * event for each inbound connect request.  */
end_comment

begin_function
name|int
name|iw_cm_listen
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_LISTEN
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|create_listen
argument_list|(
name|cm_id
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- IDLE  *  * Rejects an inbound connection request. No events are generated.  */
end_comment

begin_function
name|int
name|iw_cm_reject
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
specifier|const
name|void
modifier|*
name|private_data
parameter_list|,
name|u8
name|private_data_len
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|reject
argument_list|(
name|cm_id
argument_list|,
name|private_data
argument_list|,
name|private_data_len
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- ESTABLISHED  *  * Accepts an inbound connection request and generates an ESTABLISHED  * event. Callers of iw_cm_disconnect and iw_destroy_cm_id will block  * until the ESTABLISHED event is received from the provider.  */
end_comment

begin_function
name|int
name|iw_cm_accept
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|iw_param
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Get the ib_qp given the QPN */
name|qp
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|get_qp
argument_list|(
name|cm_id
operator|->
name|device
argument_list|,
name|iw_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|add_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|accept
argument_list|(
name|cm_id
argument_list|,
name|iw_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* An error on accept precludes provider events */
name|PANIC_IF
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Active Side: CM_ID<-- CONN_SENT  *  * If successful, results in the generation of a CONNECT_REPLY  * event. iw_cm_disconnect and iw_cm_destroy will block until the  * CONNECT_REPLY event is received from the provider.  */
end_comment

begin_function
name|int
name|iw_cm_connect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|iw_param
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|setbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_IDLE
condition|)
block|{
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Get the ib_qp given the QPN */
name|qp
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|get_qp
argument_list|(
name|cm_id
operator|->
name|device
argument_list|,
name|iw_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|add_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CONN_SENT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|connect
argument_list|(
name|cm_id
argument_list|,
name|iw_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|PANIC_IF
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_SENT
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Passive Side: new CM_ID<-- CONN_RECV  *  * Handles an inbound connect request. The function creates a new  * iw_cm_id to represent the new connection and inherits the client  * callback function and other attributes from the listening parent.  *  * The work item contains a pointer to the listen_cm_id and the event. The  * listen_cm_id contains the client cm_handler, context and  * device. These are copied when the device is cloned. The event  * contains the new four tuple.  *  * An error on the child should not affect the parent, so this  * function does not return a value.  */
end_comment

begin_function
specifier|static
name|void
name|cm_conn_req_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|listen_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|struct
name|iw_cm_id
modifier|*
name|cm_id
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * The provider should never generate a connection request 	 * event with a bad status. 	 */
name|PANIC_IF
argument_list|(
name|iw_event
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * We could be destroying the listening id. If so, ignore this 	 * upcall. 	 */
name|mtx_lock
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_LISTEN
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cm_id
operator|=
name|iw_create_cm_id
argument_list|(
name|listen_id_priv
operator|->
name|id
operator|.
name|device
argument_list|,
name|iw_event
operator|->
name|so
argument_list|,
name|listen_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|,
name|listen_id_priv
operator|->
name|id
operator|.
name|context
argument_list|)
expr_stmt|;
comment|/* If the cm_id could not be created, ignore the request */
if|if
condition|(
name|IS_ERR
argument_list|(
name|cm_id
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|cm_id
operator|->
name|provider_data
operator|=
name|iw_event
operator|->
name|provider_data
expr_stmt|;
name|cm_id
operator|->
name|local_addr
operator|=
name|iw_event
operator|->
name|local_addr
expr_stmt|;
name|cm_id
operator|->
name|remote_addr
operator|=
name|iw_event
operator|->
name|remote_addr
expr_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CONN_RECV
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|iw_cm_reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iw_destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Call the client CM handler */
name|ret
operator|=
name|cm_id
operator|->
name|cm_handler
argument_list|(
name|cm_id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|iw_cm_reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CALLBACK_DESTROY
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
condition|)
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|iw_event
operator|->
name|private_data_len
condition|)
name|free
argument_list|(
name|iw_event
operator|->
name|private_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Passive Side: CM_ID<-- ESTABLISHED  *  * The provider generated an ESTABLISHED event which means that  * the MPA negotion has completed successfully and we are now in MPA  * FPDU mode.  *  * This event can only be received in the CONN_RECV state. If the  * remote peer closed, the ESTABLISHED event would be received followed  * by the CLOSE event. If the app closes, it will block until we wake  * it up after processing this event.  */
end_comment

begin_function
specifier|static
name|int
name|cm_conn_est_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * We clear the CONNECT_WAIT bit here to allow the callback 	 * function to call iw_cm_disconnect. Calling iw_destroy_cm_id 	 * from a callback handler is not allowed. 	 */
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_ESTABLISHED
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Active Side: CM_ID<-- ESTABLISHED  *  * The app has called connect and is waiting for the established event to  * post it's requests to the server. This event will wake up anyone  * blocked in iw_cm_disconnect or iw_destroy_id.  */
end_comment

begin_function
specifier|static
name|int
name|cm_conn_rep_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the connect wait bit so a callback function calling 	 * iw_cm_disconnect will not wait and deadlock this thread 	 */
name|clrbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CONNECT_WAIT
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_SENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw_event
operator|->
name|status
operator|==
name|IW_CM_EVENT_STATUS_ACCEPTED
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|local_addr
operator|=
name|iw_event
operator|->
name|local_addr
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|remote_addr
operator|=
name|iw_event
operator|->
name|remote_addr
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_ESTABLISHED
expr_stmt|;
block|}
else|else
block|{
comment|/* REJECTED or RESET */
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw_event
operator|->
name|private_data_len
condition|)
name|free
argument_list|(
name|iw_event
operator|->
name|private_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Wake up waiters on connect complete */
name|wakeup
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- CLOSING  *  * If in the ESTABLISHED state, move to CLOSING.  */
end_comment

begin_function
specifier|static
name|void
name|cm_disconnect_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|==
name|IW_CM_STATE_ESTABLISHED
condition|)
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CLOSING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- IDLE  *  * If in the ESTBLISHED or CLOSING states, the QP will have have been  * moved by the provider to the ERR state. Disassociate the CM_ID from  * the QP,  move to IDLE, and remove the 'connected' reference.  *  * If in some other state, the cm_id was destroyed asynchronously.  * This is the last reference that will result in waking up  * the app thread blocked in iw_destroy_cm_id.  */
end_comment

begin_function
specifier|static
name|int
name|cm_close_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
case|case
name|IW_CM_STATE_CLOSING
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_DESTROYING
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"just cuz"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_event
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|iw_event
operator|->
name|event
condition|)
block|{
case|case
name|IW_CM_EVENT_CONNECT_REQUEST
case|:
name|cm_conn_req_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_CONNECT_REPLY
case|:
name|ret
operator|=
name|cm_conn_rep_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_ESTABLISHED
case|:
name|ret
operator|=
name|cm_conn_est_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_DISCONNECT
case|:
name|cm_disconnect_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_CLOSE
case|:
name|ret
operator|=
name|cm_close_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"just cuz"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Process events on the work_list for the cm_id. If the callback  * function requests that the cm_id be deleted, a flag is set in the  * cm_id flags to indicate that when the last reference is  * removed, the cm_id is to be destroyed. This is necessary to  * distinguish between an object that will be destroyed by the app  * thread asleep on the destroy_comp list vs. an object destroyed  * here synchronously when the last reference is removed.  */
end_comment

begin_function
specifier|static
name|void
name|cm_work_handler
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
init|=
name|context
decl_stmt|;
name|struct
name|iw_cm_event
name|levent
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
init|=
name|work
operator|->
name|cm_id
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|empty
operator|=
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|empty
condition|)
block|{
name|work
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|,
name|work
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|empty
operator|=
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|levent
operator|=
name|work
operator|->
name|event
expr_stmt|;
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|process_event
argument_list|(
name|cm_id_priv
argument_list|,
operator|&
name|levent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CALLBACK_DESTROY
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|PANIC_IF
argument_list|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
condition|)
block|{
if|if
condition|(
name|isset
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|,
name|IWCM_F_CALLBACK_DESTROY
argument_list|)
condition|)
block|{
name|PANIC_IF
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called on interrupt context. Schedule events on  * the iwcm_wq thread to allow callback functions to downcall into  * the CM and/or block.  Events are queued to a per-CM_ID  * work_list. If this is the first event on the work_list, the work  * element is also queued on the iwcm_wq thread.  *  * Each event holds a reference on the cm_id. Until the last posted  * event has been delivered and processed, the cm_id cannot be  * deleted.  *  * Returns:  * 	      0	- the event was handled.  *	ENOMEM	- the event was not handled due to lack of resources.  */
end_comment

begin_function
specifier|static
name|int
name|cm_event_handler
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|work
operator|=
name|get_work
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|work
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|cm_work_handler
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|work
operator|->
name|cm_id
operator|=
name|cm_id_priv
expr_stmt|;
name|work
operator|->
name|event
operator|=
operator|*
name|iw_event
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|event
operator|.
name|event
operator|==
name|IW_CM_EVENT_CONNECT_REQUEST
operator|||
name|work
operator|->
name|event
operator|.
name|event
operator|==
name|IW_CM_EVENT_CONNECT_REPLY
operator|)
operator|&&
name|work
operator|->
name|event
operator|.
name|private_data_len
condition|)
block|{
name|ret
operator|=
name|copy_private_data
argument_list|(
operator|&
name|work
operator|->
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|atomic_add_acq_int
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|,
name|work
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|iwcm_wq
argument_list|,
operator|&
name|work
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|,
name|work
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwcm_init_qp_init_attr
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_CONN_RECV
case|:
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
operator|*
name|qp_attr_mask
operator|=
name|IB_QP_STATE
operator||
name|IB_QP_ACCESS_FLAGS
expr_stmt|;
name|qp_attr
operator|->
name|qp_access_flags
operator|=
name|IB_ACCESS_LOCAL_WRITE
operator||
name|IB_ACCESS_REMOTE_WRITE
operator||
name|IB_ACCESS_REMOTE_READ
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwcm_init_qp_rts_attr
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_CONN_RECV
case|:
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
operator|*
name|qp_attr_mask
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|iw_cm_init_qp_attr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|qp_attr
operator|->
name|qp_state
condition|)
block|{
case|case
name|IB_QPS_INIT
case|:
case|case
name|IB_QPS_RTR
case|:
name|ret
operator|=
name|iwcm_init_qp_init_attr
argument_list|(
name|cm_id_priv
argument_list|,
name|qp_attr
argument_list|,
name|qp_attr_mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPS_RTS
case|:
name|ret
operator|=
name|iwcm_init_qp_rts_attr
argument_list|(
name|cm_id_priv
argument_list|,
name|qp_attr
argument_list|,
name|qp_attr_mask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_cm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|iwcm_wq
operator|=
name|taskqueue_create
argument_list|(
literal|"iw_cm_wq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|iwcm_wq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwcm_wq
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|iwcm_wq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"iw_cm_wq thread"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iw_cm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|taskqueue_free
argument_list|(
name|iwcm_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_cm_load
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|printf
argument_list|(
literal|"Loading rdma_iwcm.\n"
argument_list|)
expr_stmt|;
name|iw_cm_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
name|printf
argument_list|(
literal|"Unloading rdma_iwcm.\n"
argument_list|)
expr_stmt|;
name|iw_cm_cleanup
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mod_data
init|=
block|{
literal|"rdma_iwcm"
block|,
name|iw_cm_load
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|rdma_iwcm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|rdma_iwcm
argument_list|,
name|rdma_core
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|rdma_iwcm
argument_list|,
name|mod_data
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

