begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * lifted from fs/ncpfs/getopt.c  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/**  *	krping_getopt - option parser  *	@caller: name of the caller, for error messages  *	@options: the options string  *	@opts: an array of&struct option entries controlling parser operations  *	@optopt: output; will contain the current option  *	@optarg: output; will contain the value (if one exists)  *	@flag: output; may be NULL; should point to a long for or'ing flags  *	@value: output; may be NULL; will be overwritten with the integer value  *		of the current argument.  *  *	Helper to parse options on the format used by mount ("a=b,c=d,e,f").  *	Returns opts->val if a matching entry in the 'opts' array is found,  *	0 when no more tokens are found, -1 if an error is encountered.  */
end_comment

begin_function
name|int
name|krping_getopt
parameter_list|(
specifier|const
name|char
modifier|*
name|caller
parameter_list|,
name|char
modifier|*
modifier|*
name|options
parameter_list|,
specifier|const
name|struct
name|krping_option
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
modifier|*
name|optopt
parameter_list|,
name|char
modifier|*
modifier|*
name|optarg
parameter_list|,
name|unsigned
name|long
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
name|options
argument_list|,
literal|","
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|*
name|token
operator|==
literal|'\0'
condition|)
do|;
if|if
condition|(
name|optopt
condition|)
operator|*
name|optopt
operator|=
name|token
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|strchr
argument_list|(
name|token
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|optarg
operator|=
name|val
expr_stmt|;
for|for
control|(
init|;
name|opts
operator|->
name|name
condition|;
name|opts
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|name
argument_list|,
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|val
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|has_arg
operator|&
name|OPT_NOPARAM
condition|)
block|{
return|return
name|opts
operator|->
name|val
return|;
block|}
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: the %s option requires "
literal|"an argument\n"
argument_list|,
name|caller
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|opts
operator|->
name|has_arg
operator|&
name|OPT_INT
condition|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
operator|*
name|value
operator|=
name|simple_strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|v
condition|)
block|{
return|return
name|opts
operator|->
name|val
return|;
block|}
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: invalid numeric value "
literal|"in %s=%s\n"
argument_list|,
name|caller
argument_list|,
name|token
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|-
name|EDOM
return|;
block|}
if|if
condition|(
name|opts
operator|->
name|has_arg
operator|&
name|OPT_STRING
condition|)
block|{
return|return
name|opts
operator|->
name|val
return|;
block|}
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: unexpected argument %s to the "
literal|"%s option\n"
argument_list|,
name|caller
argument_list|,
name|val
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: Unrecognized option %s\n"
argument_list|,
name|caller
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
operator|-
name|EOPNOTSUPP
return|;
block|}
end_function

end_unit

