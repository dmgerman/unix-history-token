begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * BSD LICENSE  *  * Copyright (c) 2015-2017 Amazon.com, Inc. or its affiliates.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in  * the documentation and/or other materials provided with the  * distribution.  * * Neither the name of copyright holder nor the names of its  * contributors may be used to endorse or promote products derived  * from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ena_com.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENA_INTERNAL
end_ifdef

begin_include
include|#
directive|include
file|"ena_gen_info.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* Timeout in micro-sec */
end_comment

begin_define
define|#
directive|define
name|ADMIN_CMD_TIMEOUT_US
value|(3000000)
end_define

begin_define
define|#
directive|define
name|ENA_ASYNC_QUEUE_DEPTH
value|16
end_define

begin_define
define|#
directive|define
name|ENA_ADMIN_QUEUE_DEPTH
value|32
end_define

begin_define
define|#
directive|define
name|MIN_ENA_VER
value|(((ENA_COMMON_SPEC_VERSION_MAJOR)<< \ 		ENA_REGS_VERSION_MAJOR_VERSION_SHIFT) \ 		| (ENA_COMMON_SPEC_VERSION_MINOR))
end_define

begin_define
define|#
directive|define
name|ENA_CTRL_MAJOR
value|0
end_define

begin_define
define|#
directive|define
name|ENA_CTRL_MINOR
value|0
end_define

begin_define
define|#
directive|define
name|ENA_CTRL_SUB_MINOR
value|1
end_define

begin_define
define|#
directive|define
name|MIN_ENA_CTRL_VER
define|\
value|(((ENA_CTRL_MAJOR)<< \ 	(ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_SHIFT)) | \ 	((ENA_CTRL_MINOR)<< \ 	(ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_SHIFT)) | \ 	(ENA_CTRL_SUB_MINOR))
end_define

begin_define
define|#
directive|define
name|ENA_DMA_ADDR_TO_UINT32_LOW
parameter_list|(
name|x
parameter_list|)
value|((u32)((u64)(x)))
end_define

begin_define
define|#
directive|define
name|ENA_DMA_ADDR_TO_UINT32_HIGH
parameter_list|(
name|x
parameter_list|)
value|((u32)(((u64)(x))>> 32))
end_define

begin_define
define|#
directive|define
name|ENA_MMIO_READ_TIMEOUT
value|0xFFFFFFFF
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_enum
enum|enum
name|ena_cmd_status
block|{
name|ENA_CMD_SUBMITTED
block|,
name|ENA_CMD_COMPLETED
block|,
comment|/* Abort - canceled by the driver */
name|ENA_CMD_ABORTED
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ena_comp_ctx
block|{
name|ena_wait_event_t
name|wait_event
decl_stmt|;
name|struct
name|ena_admin_acq_entry
modifier|*
name|user_cqe
decl_stmt|;
name|u32
name|comp_size
decl_stmt|;
name|enum
name|ena_cmd_status
name|status
decl_stmt|;
comment|/* status from the device */
name|u8
name|comp_status
decl_stmt|;
name|u8
name|cmd_opcode
decl_stmt|;
name|bool
name|occupied
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ena_com_stats_ctx
block|{
name|struct
name|ena_admin_aq_get_stats_cmd
name|get_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_get_stats_resp
name|get_resp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|ena_com_mem_addr_set
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_common_mem_addr
modifier|*
name|ena_addr
parameter_list|,
name|dma_addr_t
name|addr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|addr
operator|&
name|GENMASK_ULL
argument_list|(
name|ena_dev
operator|->
name|dma_addr_bits
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|addr
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"dma address has more bits that the device supports\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|ena_addr
operator|->
name|mem_addr_low
operator|=
operator|(
name|u32
operator|)
name|addr
expr_stmt|;
name|ena_addr
operator|->
name|mem_addr_high
operator|=
operator|(
name|u64
operator|)
name|addr
operator|>>
literal|32
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_admin_init_sq
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|queue
parameter_list|)
block|{
name|struct
name|ena_com_admin_sq
modifier|*
name|sq
init|=
operator|&
name|queue
operator|->
name|sq
decl_stmt|;
name|u16
name|size
init|=
name|ADMIN_SQ_SIZE
argument_list|(
name|queue
operator|->
name|q_depth
argument_list|)
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|queue
operator|->
name|q_dmadev
argument_list|,
name|size
argument_list|,
name|sq
operator|->
name|entries
argument_list|,
name|sq
operator|->
name|dma_addr
argument_list|,
name|sq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sq
operator|->
name|entries
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|sq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|sq
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
name|sq
operator|->
name|db_addr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_admin_init_cq
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|queue
parameter_list|)
block|{
name|struct
name|ena_com_admin_cq
modifier|*
name|cq
init|=
operator|&
name|queue
operator|->
name|cq
decl_stmt|;
name|u16
name|size
init|=
name|ADMIN_CQ_SIZE
argument_list|(
name|queue
operator|->
name|q_depth
argument_list|)
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|queue
operator|->
name|q_dmadev
argument_list|,
name|size
argument_list|,
name|cq
operator|->
name|entries
argument_list|,
name|cq
operator|->
name|dma_addr
argument_list|,
name|cq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cq
operator|->
name|entries
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|cq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|cq
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_admin_init_aenq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ena_aenq_handlers
modifier|*
name|aenq_handlers
parameter_list|)
block|{
name|struct
name|ena_com_aenq
modifier|*
name|aenq
init|=
operator|&
name|dev
operator|->
name|aenq
decl_stmt|;
name|u32
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|,
name|aenq_caps
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|dev
operator|->
name|aenq
operator|.
name|q_depth
operator|=
name|ENA_ASYNC_QUEUE_DEPTH
expr_stmt|;
name|size
operator|=
name|ADMIN_AENQ_SIZE
argument_list|(
name|ENA_ASYNC_QUEUE_DEPTH
argument_list|)
expr_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|aenq
operator|->
name|entries
argument_list|,
name|aenq
operator|->
name|dma_addr
argument_list|,
name|aenq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aenq
operator|->
name|entries
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|aenq
operator|->
name|head
operator|=
name|aenq
operator|->
name|q_depth
expr_stmt|;
name|aenq
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
name|addr_low
operator|=
name|ENA_DMA_ADDR_TO_UINT32_LOW
argument_list|(
name|aenq
operator|->
name|dma_addr
argument_list|)
expr_stmt|;
name|addr_high
operator|=
name|ENA_DMA_ADDR_TO_UINT32_HIGH
argument_list|(
name|aenq
operator|->
name|dma_addr
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
name|addr_low
argument_list|,
name|dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AENQ_BASE_LO_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
name|addr_high
argument_list|,
name|dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AENQ_BASE_HI_OFF
argument_list|)
expr_stmt|;
name|aenq_caps
operator|=
literal|0
expr_stmt|;
name|aenq_caps
operator||=
name|dev
operator|->
name|aenq
operator|.
name|q_depth
operator|&
name|ENA_REGS_AENQ_CAPS_AENQ_DEPTH_MASK
expr_stmt|;
name|aenq_caps
operator||=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_aenq_entry
argument_list|)
operator|<<
name|ENA_REGS_AENQ_CAPS_AENQ_ENTRY_SIZE_SHIFT
operator|)
operator|&
name|ENA_REGS_AENQ_CAPS_AENQ_ENTRY_SIZE_MASK
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
name|aenq_caps
argument_list|,
name|dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AENQ_CAPS_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|aenq_handlers
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"aenq handlers pointer is NULL\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|aenq
operator|->
name|aenq_handlers
operator|=
name|aenq_handlers
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|comp_ctxt_release
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|queue
parameter_list|,
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
parameter_list|)
block|{
name|comp_ctx
operator|->
name|occupied
operator|=
name|false
expr_stmt|;
name|ATOMIC32_DEC
argument_list|(
operator|&
name|queue
operator|->
name|outstanding_cmds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ena_comp_ctx
modifier|*
name|get_comp_ctxt
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|queue
parameter_list|,
name|u16
name|command_id
parameter_list|,
name|bool
name|capture
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|command_id
operator|>=
name|queue
operator|->
name|q_depth
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"command id is larger than the queue size. cmd_id: %u queue size %d\n"
argument_list|,
name|command_id
argument_list|,
name|queue
operator|->
name|q_depth
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|queue
operator|->
name|comp_ctx
index|[
name|command_id
index|]
operator|.
name|occupied
operator|&&
name|capture
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Completion context is occupied\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|capture
condition|)
block|{
name|ATOMIC32_INC
argument_list|(
operator|&
name|queue
operator|->
name|outstanding_cmds
argument_list|)
expr_stmt|;
name|queue
operator|->
name|comp_ctx
index|[
name|command_id
index|]
operator|.
name|occupied
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|&
name|queue
operator|->
name|comp_ctx
index|[
name|command_id
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ena_comp_ctx
modifier|*
name|__ena_com_submit_admin_cmd
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|,
name|struct
name|ena_admin_aq_entry
modifier|*
name|cmd
parameter_list|,
name|size_t
name|cmd_size_in_bytes
parameter_list|,
name|struct
name|ena_admin_acq_entry
modifier|*
name|comp
parameter_list|,
name|size_t
name|comp_size_in_bytes
parameter_list|)
block|{
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|u16
name|tail_masked
decl_stmt|,
name|cmd_id
decl_stmt|;
name|u16
name|queue_size_mask
decl_stmt|;
name|u16
name|cnt
decl_stmt|;
name|queue_size_mask
operator|=
name|admin_queue
operator|->
name|q_depth
operator|-
literal|1
expr_stmt|;
name|tail_masked
operator|=
name|admin_queue
operator|->
name|sq
operator|.
name|tail
operator|&
name|queue_size_mask
expr_stmt|;
comment|/* In case of queue FULL */
name|cnt
operator|=
name|admin_queue
operator|->
name|sq
operator|.
name|tail
operator|-
name|admin_queue
operator|->
name|sq
operator|.
name|head
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|admin_queue
operator|->
name|q_depth
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"admin queue is FULL (tail %d head %d depth: %d)\n"
argument_list|,
name|admin_queue
operator|->
name|sq
operator|.
name|tail
argument_list|,
name|admin_queue
operator|->
name|sq
operator|.
name|head
argument_list|,
name|admin_queue
operator|->
name|q_depth
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|out_of_space
operator|++
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|ENA_COM_NO_SPACE
argument_list|)
return|;
block|}
name|cmd_id
operator|=
name|admin_queue
operator|->
name|curr_cmd_id
expr_stmt|;
name|cmd
operator|->
name|aq_common_descriptor
operator|.
name|flags
operator||=
name|admin_queue
operator|->
name|sq
operator|.
name|phase
operator|&
name|ENA_ADMIN_AQ_COMMON_DESC_PHASE_MASK
expr_stmt|;
name|cmd
operator|->
name|aq_common_descriptor
operator|.
name|command_id
operator||=
name|cmd_id
operator|&
name|ENA_ADMIN_AQ_COMMON_DESC_COMMAND_ID_MASK
expr_stmt|;
name|comp_ctx
operator|=
name|get_comp_ctxt
argument_list|(
name|admin_queue
argument_list|,
name|cmd_id
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|comp_ctx
argument_list|)
condition|)
return|return
name|ERR_PTR
argument_list|(
name|ENA_COM_INVAL
argument_list|)
return|;
name|comp_ctx
operator|->
name|status
operator|=
name|ENA_CMD_SUBMITTED
expr_stmt|;
name|comp_ctx
operator|->
name|comp_size
operator|=
operator|(
name|u32
operator|)
name|comp_size_in_bytes
expr_stmt|;
name|comp_ctx
operator|->
name|user_cqe
operator|=
name|comp
expr_stmt|;
name|comp_ctx
operator|->
name|cmd_opcode
operator|=
name|cmd
operator|->
name|aq_common_descriptor
operator|.
name|opcode
expr_stmt|;
name|ENA_WAIT_EVENT_CLEAR
argument_list|(
name|comp_ctx
operator|->
name|wait_event
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|admin_queue
operator|->
name|sq
operator|.
name|entries
index|[
name|tail_masked
index|]
argument_list|,
name|cmd
argument_list|,
name|cmd_size_in_bytes
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|curr_cmd_id
operator|=
operator|(
name|admin_queue
operator|->
name|curr_cmd_id
operator|+
literal|1
operator|)
operator|&
name|queue_size_mask
expr_stmt|;
name|admin_queue
operator|->
name|sq
operator|.
name|tail
operator|++
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|submitted_cmd
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|admin_queue
operator|->
name|sq
operator|.
name|tail
operator|&
name|queue_size_mask
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|admin_queue
operator|->
name|sq
operator|.
name|phase
operator|=
operator|!
name|admin_queue
operator|->
name|sq
operator|.
name|phase
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|admin_queue
operator|->
name|bus
argument_list|,
name|admin_queue
operator|->
name|sq
operator|.
name|tail
argument_list|,
name|admin_queue
operator|->
name|sq
operator|.
name|db_addr
argument_list|)
expr_stmt|;
return|return
name|comp_ctx
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ena_com_init_comp_ctxt
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|queue
parameter_list|)
block|{
name|size_t
name|size
init|=
name|queue
operator|->
name|q_depth
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_comp_ctx
argument_list|)
decl_stmt|;
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|u16
name|i
decl_stmt|;
name|queue
operator|->
name|comp_ctx
operator|=
name|ENA_MEM_ALLOC
argument_list|(
name|queue
operator|->
name|q_dmadev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|queue
operator|->
name|comp_ctx
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queue
operator|->
name|q_depth
condition|;
name|i
operator|++
control|)
block|{
name|comp_ctx
operator|=
name|get_comp_ctxt
argument_list|(
name|queue
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_ctx
condition|)
name|ENA_WAIT_EVENT_INIT
argument_list|(
name|comp_ctx
operator|->
name|wait_event
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ena_comp_ctx
modifier|*
name|ena_com_submit_admin_cmd
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|,
name|struct
name|ena_admin_aq_entry
modifier|*
name|cmd
parameter_list|,
name|size_t
name|cmd_size_in_bytes
parameter_list|,
name|struct
name|ena_admin_acq_entry
modifier|*
name|comp
parameter_list|,
name|size_t
name|comp_size_in_bytes
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|admin_queue
operator|->
name|running_state
argument_list|)
condition|)
block|{
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|ENA_COM_NO_DEVICE
argument_list|)
return|;
block|}
name|comp_ctx
operator|=
name|__ena_com_submit_admin_cmd
argument_list|(
name|admin_queue
argument_list|,
name|cmd
argument_list|,
name|cmd_size_in_bytes
argument_list|,
name|comp
argument_list|,
name|comp_size_in_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|IS_ERR
argument_list|(
name|comp_ctx
argument_list|)
argument_list|)
condition|)
name|admin_queue
operator|->
name|running_state
operator|=
name|false
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|comp_ctx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_init_io_sq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_create_io_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|dev_node
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|io_sq
operator|->
name|desc_addr
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_sq
operator|->
name|desc_addr
argument_list|)
argument_list|)
expr_stmt|;
name|io_sq
operator|->
name|desc_entry_size
operator|=
operator|(
name|io_sq
operator|->
name|direction
operator|==
name|ENA_COM_IO_QUEUE_DIRECTION_TX
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|ena_eth_io_tx_desc
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|ena_eth_io_rx_desc
argument_list|)
expr_stmt|;
name|size
operator|=
name|io_sq
operator|->
name|desc_entry_size
operator|*
name|io_sq
operator|->
name|q_depth
expr_stmt|;
name|io_sq
operator|->
name|bus
operator|=
name|ena_dev
operator|->
name|bus
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|mem_queue_type
operator|==
name|ENA_ADMIN_PLACEMENT_POLICY_HOST
condition|)
block|{
name|ENA_MEM_ALLOC_COHERENT_NODE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|phys_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|mem_handle
argument_list|,
name|ctx
operator|->
name|numa_node
argument_list|,
name|dev_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
condition|)
block|{
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|phys_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|mem_handle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ENA_MEM_ALLOC_NODE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
argument_list|,
name|ctx
operator|->
name|numa_node
argument_list|,
name|dev_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
condition|)
block|{
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
operator|=
name|ENA_MEM_ALLOC
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|io_sq
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|io_sq
operator|->
name|next_to_comp
operator|=
literal|0
expr_stmt|;
name|io_sq
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_init_io_cq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_create_io_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|prev_node
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|io_cq
operator|->
name|cdesc_addr
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|io_cq
operator|->
name|cdesc_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the basic completion descriptor for Rx */
name|io_cq
operator|->
name|cdesc_entry_size_in_bytes
operator|=
operator|(
name|io_cq
operator|->
name|direction
operator|==
name|ENA_COM_IO_QUEUE_DIRECTION_TX
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|ena_eth_io_tx_cdesc
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|ena_eth_io_rx_cdesc_base
argument_list|)
expr_stmt|;
name|size
operator|=
name|io_cq
operator|->
name|cdesc_entry_size_in_bytes
operator|*
name|io_cq
operator|->
name|q_depth
expr_stmt|;
name|io_cq
operator|->
name|bus
operator|=
name|ena_dev
operator|->
name|bus
expr_stmt|;
name|ENA_MEM_ALLOC_COHERENT_NODE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|phys_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|mem_handle
argument_list|,
name|ctx
operator|->
name|numa_node
argument_list|,
name|prev_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
condition|)
block|{
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|phys_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|mem_handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory allocation failed"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|io_cq
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
name|io_cq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_handle_single_admin_completion
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|,
name|struct
name|ena_admin_acq_entry
modifier|*
name|cqe
parameter_list|)
block|{
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|u16
name|cmd_id
decl_stmt|;
name|cmd_id
operator|=
name|cqe
operator|->
name|acq_common_descriptor
operator|.
name|command
operator|&
name|ENA_ADMIN_ACQ_COMMON_DESC_COMMAND_ID_MASK
expr_stmt|;
name|comp_ctx
operator|=
name|get_comp_ctxt
argument_list|(
name|admin_queue
argument_list|,
name|cmd_id
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|comp_ctx
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"comp_ctx is NULL. Changing the admin queue running state\n"
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|running_state
operator|=
name|false
expr_stmt|;
return|return;
block|}
name|comp_ctx
operator|->
name|status
operator|=
name|ENA_CMD_COMPLETED
expr_stmt|;
name|comp_ctx
operator|->
name|comp_status
operator|=
name|cqe
operator|->
name|acq_common_descriptor
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|comp_ctx
operator|->
name|user_cqe
condition|)
name|memcpy
argument_list|(
name|comp_ctx
operator|->
name|user_cqe
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cqe
argument_list|,
name|comp_ctx
operator|->
name|comp_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|admin_queue
operator|->
name|polling
condition|)
name|ENA_WAIT_EVENT_SIGNAL
argument_list|(
name|comp_ctx
operator|->
name|wait_event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_handle_admin_completion
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|)
block|{
name|struct
name|ena_admin_acq_entry
modifier|*
name|cqe
init|=
name|NULL
decl_stmt|;
name|u16
name|comp_num
init|=
literal|0
decl_stmt|;
name|u16
name|head_masked
decl_stmt|;
name|u8
name|phase
decl_stmt|;
name|head_masked
operator|=
name|admin_queue
operator|->
name|cq
operator|.
name|head
operator|&
operator|(
name|admin_queue
operator|->
name|q_depth
operator|-
literal|1
operator|)
expr_stmt|;
name|phase
operator|=
name|admin_queue
operator|->
name|cq
operator|.
name|phase
expr_stmt|;
name|cqe
operator|=
operator|&
name|admin_queue
operator|->
name|cq
operator|.
name|entries
index|[
name|head_masked
index|]
expr_stmt|;
comment|/* Go over all the completions */
while|while
condition|(
operator|(
name|cqe
operator|->
name|acq_common_descriptor
operator|.
name|flags
operator|&
name|ENA_ADMIN_ACQ_COMMON_DESC_PHASE_MASK
operator|)
operator|==
name|phase
condition|)
block|{
comment|/* Do not read the rest of the completion entry before the 		 * phase bit was validated 		 */
name|rmb
argument_list|()
expr_stmt|;
name|ena_com_handle_single_admin_completion
argument_list|(
name|admin_queue
argument_list|,
name|cqe
argument_list|)
expr_stmt|;
name|head_masked
operator|++
expr_stmt|;
name|comp_num
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|head_masked
operator|==
name|admin_queue
operator|->
name|q_depth
argument_list|)
condition|)
block|{
name|head_masked
operator|=
literal|0
expr_stmt|;
name|phase
operator|=
operator|!
name|phase
expr_stmt|;
block|}
name|cqe
operator|=
operator|&
name|admin_queue
operator|->
name|cq
operator|.
name|entries
index|[
name|head_masked
index|]
expr_stmt|;
block|}
name|admin_queue
operator|->
name|cq
operator|.
name|head
operator|+=
name|comp_num
expr_stmt|;
name|admin_queue
operator|->
name|cq
operator|.
name|phase
operator|=
name|phase
expr_stmt|;
name|admin_queue
operator|->
name|sq
operator|.
name|head
operator|+=
name|comp_num
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|completed_cmd
operator|+=
name|comp_num
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_comp_status_to_errno
parameter_list|(
name|u8
name|comp_status
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|comp_status
operator|!=
literal|0
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"admin command failed[%u]\n"
argument_list|,
name|comp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|comp_status
operator|>
name|ENA_ADMIN_UNKNOWN_ERROR
argument_list|)
condition|)
return|return
name|ENA_COM_INVAL
return|;
switch|switch
condition|(
name|comp_status
condition|)
block|{
case|case
name|ENA_ADMIN_SUCCESS
case|:
return|return
literal|0
return|;
case|case
name|ENA_ADMIN_RESOURCE_ALLOCATION_FAILURE
case|:
return|return
name|ENA_COM_NO_MEM
return|;
case|case
name|ENA_ADMIN_UNSUPPORTED_OPCODE
case|:
return|return
name|ENA_COM_PERMISSION
return|;
case|case
name|ENA_ADMIN_BAD_OPCODE
case|:
case|case
name|ENA_ADMIN_MALFORMED_REQUEST
case|:
case|case
name|ENA_ADMIN_ILLEGAL_PARAMETER
case|:
case|case
name|ENA_ADMIN_UNKNOWN_ERROR
case|:
return|return
name|ENA_COM_INVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_wait_and_process_admin_cq_polling
parameter_list|(
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
parameter_list|,
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|timeout
operator|=
name|ENA_GET_SYSTEM_TIMEOUT
argument_list|(
name|admin_queue
operator|->
name|completion_timeout
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ena_com_handle_admin_completion
argument_list|(
name|admin_queue
argument_list|)
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_ctx
operator|->
name|status
operator|!=
name|ENA_CMD_SUBMITTED
condition|)
break|break;
if|if
condition|(
name|ENA_TIME_EXPIRE
argument_list|(
name|timeout
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Wait for completion (polling) timeout\n"
argument_list|)
expr_stmt|;
comment|/* ENA didn't have any completion */
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|no_completion
operator|++
expr_stmt|;
name|admin_queue
operator|->
name|running_state
operator|=
name|false
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENA_COM_TIMER_EXPIRED
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ENA_MSLEEP
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|comp_ctx
operator|->
name|status
operator|==
name|ENA_CMD_ABORTED
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Command was aborted\n"
argument_list|)
expr_stmt|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|aborted_cmd
operator|++
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENA_COM_NO_DEVICE
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ENA_WARN
argument_list|(
name|comp_ctx
operator|->
name|status
operator|!=
name|ENA_CMD_COMPLETED
argument_list|,
literal|"Invalid comp status %d\n"
argument_list|,
name|comp_ctx
operator|->
name|status
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_comp_status_to_errno
argument_list|(
name|comp_ctx
operator|->
name|comp_status
argument_list|)
expr_stmt|;
name|err
label|:
name|comp_ctxt_release
argument_list|(
name|admin_queue
argument_list|,
name|comp_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_wait_and_process_admin_cq_interrupts
parameter_list|(
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
parameter_list|,
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ENA_WAIT_EVENT_WAIT
argument_list|(
name|comp_ctx
operator|->
name|wait_event
argument_list|,
name|admin_queue
operator|->
name|completion_timeout
argument_list|)
expr_stmt|;
comment|/* In case the command wasn't completed find out the root cause. 	 * There might be 2 kinds of errors 	 * 1) No completion (timeout reached) 	 * 2) There is completion but the device didn't get any msi-x interrupt. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|comp_ctx
operator|->
name|status
operator|==
name|ENA_CMD_SUBMITTED
argument_list|)
condition|)
block|{
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ena_com_handle_admin_completion
argument_list|(
name|admin_queue
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|stats
operator|.
name|no_completion
operator|++
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_ctx
operator|->
name|status
operator|==
name|ENA_CMD_COMPLETED
condition|)
name|ena_trc_err
argument_list|(
literal|"The ena device have completion but the driver didn't receive any MSI-X interrupt (cmd %d)\n"
argument_list|,
name|comp_ctx
operator|->
name|cmd_opcode
argument_list|)
expr_stmt|;
else|else
name|ena_trc_err
argument_list|(
literal|"The ena device doesn't send any completion for the admin cmd %d status %d\n"
argument_list|,
name|comp_ctx
operator|->
name|cmd_opcode
argument_list|,
name|comp_ctx
operator|->
name|status
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|running_state
operator|=
name|false
expr_stmt|;
name|ret
operator|=
name|ENA_COM_TIMER_EXPIRED
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|ena_com_comp_status_to_errno
argument_list|(
name|comp_ctx
operator|->
name|comp_status
argument_list|)
expr_stmt|;
name|err
label|:
name|comp_ctxt_release
argument_list|(
name|admin_queue
argument_list|,
name|comp_ctx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This method read the hardware device register through posting writes  * and waiting for response  * On timeout the function will return ENA_MMIO_READ_TIMEOUT  */
end_comment

begin_function
specifier|static
name|u32
name|ena_com_reg_bar_read32
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|offset
parameter_list|)
block|{
name|struct
name|ena_com_mmio_read
modifier|*
name|mmio_read
init|=
operator|&
name|ena_dev
operator|->
name|mmio_read
decl_stmt|;
specifier|volatile
name|struct
name|ena_admin_ena_mmio_req_read_less_resp
modifier|*
name|read_resp
init|=
name|mmio_read
operator|->
name|read_resp
decl_stmt|;
name|u32
name|mmio_read_reg
decl_stmt|,
name|timeout
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ENA_MIGHT_SLEEP
argument_list|()
expr_stmt|;
name|timeout
operator|=
name|mmio_read
operator|->
name|reg_read_to
condition|?
else|:
name|ENA_REG_READ_TIMEOUT
expr_stmt|;
comment|/* If readless is disabled, perform regular read */
if|if
condition|(
operator|!
name|mmio_read
operator|->
name|readless_supported
condition|)
return|return
name|ENA_REG_READ32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|offset
argument_list|)
return|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|mmio_read
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mmio_read
operator|->
name|seq_num
operator|++
expr_stmt|;
name|read_resp
operator|->
name|req_id
operator|=
name|mmio_read
operator|->
name|seq_num
operator|+
literal|0xDEAD
expr_stmt|;
name|mmio_read_reg
operator|=
operator|(
name|offset
operator|<<
name|ENA_REGS_MMIO_REG_READ_REG_OFF_SHIFT
operator|)
operator|&
name|ENA_REGS_MMIO_REG_READ_REG_OFF_MASK
expr_stmt|;
name|mmio_read_reg
operator||=
name|mmio_read
operator|->
name|seq_num
operator|&
name|ENA_REGS_MMIO_REG_READ_REQ_ID_MASK
expr_stmt|;
comment|/* make sure read_resp->req_id get updated before the hw can write 	 * there 	 */
name|wmb
argument_list|()
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|mmio_read_reg
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_MMIO_REG_READ_OFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|read_resp
operator|->
name|req_id
operator|==
name|mmio_read
operator|->
name|seq_num
condition|)
break|break;
name|ENA_UDELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|==
name|timeout
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"reading reg failed for timeout. expected: req id[%hu] offset[%hu] actual: req id[%hu] offset[%hu]\n"
argument_list|,
name|mmio_read
operator|->
name|seq_num
argument_list|,
name|offset
argument_list|,
name|read_resp
operator|->
name|req_id
argument_list|,
name|read_resp
operator|->
name|reg_off
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENA_MMIO_READ_TIMEOUT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|read_resp
operator|->
name|reg_off
operator|!=
name|offset
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Read failure: wrong offset provided"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENA_MMIO_READ_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|read_resp
operator|->
name|reg_val
expr_stmt|;
block|}
name|err
label|:
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|mmio_read
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* There are two types to wait for completion.  * Polling mode - wait until the completion is available.  * Async mode - wait on wait queue until the completion is ready  * (or the timeout expired).  * It is expected that the IRQ called ena_com_handle_admin_completion  * to mark the completions.  */
end_comment

begin_function
specifier|static
name|int
name|ena_com_wait_and_process_admin_cq
parameter_list|(
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
parameter_list|,
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|)
block|{
if|if
condition|(
name|admin_queue
operator|->
name|polling
condition|)
return|return
name|ena_com_wait_and_process_admin_cq_polling
argument_list|(
name|comp_ctx
argument_list|,
name|admin_queue
argument_list|)
return|;
return|return
name|ena_com_wait_and_process_admin_cq_interrupts
argument_list|(
name|comp_ctx
argument_list|,
name|admin_queue
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_destroy_io_sq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_aq_destroy_sq_cmd
name|destroy_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_destroy_sq_resp_desc
name|destroy_resp
decl_stmt|;
name|u8
name|direction
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|destroy_cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|direction
operator|==
name|ENA_COM_IO_QUEUE_DIRECTION_TX
condition|)
name|direction
operator|=
name|ENA_ADMIN_SQ_DIRECTION_TX
expr_stmt|;
else|else
name|direction
operator|=
name|ENA_ADMIN_SQ_DIRECTION_RX
expr_stmt|;
name|destroy_cmd
operator|.
name|sq
operator|.
name|sq_identity
operator||=
operator|(
name|direction
operator|<<
name|ENA_ADMIN_SQ_SQ_DIRECTION_SHIFT
operator|)
operator|&
name|ENA_ADMIN_SQ_SQ_DIRECTION_MASK
expr_stmt|;
name|destroy_cmd
operator|.
name|sq
operator|.
name|sq_idx
operator|=
name|io_sq
operator|->
name|idx
expr_stmt|;
name|destroy_cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_DESTROY_SQ
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|destroy_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|destroy_resp
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|&&
operator|(
name|ret
operator|!=
name|ENA_COM_NO_DEVICE
operator|)
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"failed to destroy io sq error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_io_queue_free
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
parameter_list|,
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
condition|)
block|{
name|size
operator|=
name|io_cq
operator|->
name|cdesc_entry_size_in_bytes
operator|*
name|io_cq
operator|->
name|q_depth
expr_stmt|;
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|phys_addr
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|mem_handle
argument_list|)
expr_stmt|;
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
condition|)
block|{
name|size
operator|=
name|io_sq
operator|->
name|desc_entry_size
operator|*
name|io_sq
operator|->
name|q_depth
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|mem_queue_type
operator|==
name|ENA_ADMIN_PLACEMENT_POLICY_HOST
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|phys_addr
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|mem_handle
argument_list|)
expr_stmt|;
else|else
name|ENA_MEM_FREE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
argument_list|)
expr_stmt|;
name|io_sq
operator|->
name|desc_addr
operator|.
name|virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_reset_state
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
name|timeout
parameter_list|,
name|u16
name|exp_state
parameter_list|)
block|{
name|u32
name|val
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timeout
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_DEV_STS_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|val
operator|==
name|ENA_MMIO_READ_TIMEOUT
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reg read timeout occurred\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|ENA_REGS_DEV_STS_RESET_IN_PROGRESS_MASK
operator|)
operator|==
name|exp_state
condition|)
return|return
literal|0
return|;
comment|/* The resolution of the timeout is 100ms */
name|ENA_MSLEEP
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ena_com_check_supported_feature_id
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_admin_aq_feature_id
name|feature_id
parameter_list|)
block|{
name|u32
name|feature_mask
init|=
literal|1
operator|<<
name|feature_id
decl_stmt|;
comment|/* Device attributes is always supported */
if|if
condition|(
operator|(
name|feature_id
operator|!=
name|ENA_ADMIN_DEVICE_ATTRIBUTES
operator|)
operator|&&
operator|!
operator|(
name|ena_dev
operator|->
name|supported_features
operator|&
name|feature_mask
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_get_feature_ex
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_admin_get_feat_resp
modifier|*
name|get_resp
parameter_list|,
name|enum
name|ena_admin_aq_feature_id
name|feature_id
parameter_list|,
name|dma_addr_t
name|control_buf_dma_addr
parameter_list|,
name|u32
name|control_buff_size
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_get_feat_cmd
name|get_cmd
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|feature_id
argument_list|)
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|feature_id
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|memset
argument_list|(
operator|&
name|get_cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|get_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|admin_queue
operator|=
operator|&
name|ena_dev
operator|->
name|admin_queue
expr_stmt|;
name|get_cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_GET_FEATURE
expr_stmt|;
if|if
condition|(
name|control_buff_size
condition|)
name|get_cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
name|ENA_ADMIN_AQ_COMMON_DESC_CTRL_DATA_INDIRECT_MASK
expr_stmt|;
else|else
name|get_cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_cmd
operator|.
name|control_buffer
operator|.
name|address
argument_list|,
name|control_buf_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|get_cmd
operator|.
name|control_buffer
operator|.
name|length
operator|=
name|control_buff_size
expr_stmt|;
name|get_cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|feature_id
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|get_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|get_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
name|get_resp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|get_resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to submit get_feature command %d error: %d\n"
argument_list|,
name|feature_id
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_get_feature
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_admin_get_feat_resp
modifier|*
name|get_resp
parameter_list|,
name|enum
name|ena_admin_aq_feature_id
name|feature_id
parameter_list|)
block|{
return|return
name|ena_com_get_feature_ex
argument_list|(
name|ena_dev
argument_list|,
name|get_resp
argument_list|,
name|feature_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_hash_key_allocate
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_key
argument_list|)
argument_list|,
name|rss
operator|->
name|hash_key
argument_list|,
name|rss
operator|->
name|hash_key_dma_addr
argument_list|,
name|rss
operator|->
name|hash_key_mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rss
operator|->
name|hash_key
argument_list|)
condition|)
return|return
name|ENA_COM_NO_MEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_hash_key_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
if|if
condition|(
name|rss
operator|->
name|hash_key
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_key
argument_list|)
argument_list|,
name|rss
operator|->
name|hash_key
argument_list|,
name|rss
operator|->
name|hash_key_dma_addr
argument_list|,
name|rss
operator|->
name|hash_key_mem_handle
argument_list|)
expr_stmt|;
name|rss
operator|->
name|hash_key
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_hash_ctrl_init
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_ctrl
argument_list|)
argument_list|,
name|rss
operator|->
name|hash_ctrl
argument_list|,
name|rss
operator|->
name|hash_ctrl_dma_addr
argument_list|,
name|rss
operator|->
name|hash_ctrl_mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rss
operator|->
name|hash_ctrl
argument_list|)
condition|)
return|return
name|ENA_COM_NO_MEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_hash_ctrl_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
if|if
condition|(
name|rss
operator|->
name|hash_ctrl
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_ctrl
argument_list|)
argument_list|,
name|rss
operator|->
name|hash_ctrl
argument_list|,
name|rss
operator|->
name|hash_ctrl_dma_addr
argument_list|,
name|rss
operator|->
name|hash_ctrl_mem_handle
argument_list|)
expr_stmt|;
name|rss
operator|->
name|hash_ctrl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_indirect_table_allocate
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|log_size
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|size_t
name|tbl_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_REDIRECTION_TABLE_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|get_resp
operator|.
name|u
operator|.
name|ind_table
operator|.
name|min_size
operator|>
name|log_size
operator|)
operator|||
operator|(
name|get_resp
operator|.
name|u
operator|.
name|ind_table
operator|.
name|max_size
operator|<
name|log_size
operator|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"indirect table size doesn't fit. requested size: %d while min is:%d and max %d\n"
argument_list|,
literal|1
operator|<<
name|log_size
argument_list|,
literal|1
operator|<<
name|get_resp
operator|.
name|u
operator|.
name|ind_table
operator|.
name|min_size
argument_list|,
literal|1
operator|<<
name|get_resp
operator|.
name|u
operator|.
name|ind_table
operator|.
name|max_size
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|tbl_size
operator|=
operator|(
literal|1ULL
operator|<<
name|log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_rss_ind_table_entry
argument_list|)
expr_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|tbl_size
argument_list|,
name|rss
operator|->
name|rss_ind_tbl
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_dma_addr
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rss
operator|->
name|rss_ind_tbl
argument_list|)
condition|)
goto|goto
name|mem_err1
goto|;
name|tbl_size
operator|=
operator|(
literal|1ULL
operator|<<
name|log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
expr_stmt|;
name|rss
operator|->
name|host_rss_ind_tbl
operator|=
name|ENA_MEM_ALLOC
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|tbl_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rss
operator|->
name|host_rss_ind_tbl
argument_list|)
condition|)
goto|goto
name|mem_err2
goto|;
name|rss
operator|->
name|tbl_log_size
operator|=
name|log_size
expr_stmt|;
return|return
literal|0
return|;
name|mem_err2
label|:
name|tbl_size
operator|=
operator|(
literal|1ULL
operator|<<
name|log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_rss_ind_table_entry
argument_list|)
expr_stmt|;
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|tbl_size
argument_list|,
name|rss
operator|->
name|rss_ind_tbl
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_dma_addr
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_mem_handle
argument_list|)
expr_stmt|;
name|rss
operator|->
name|rss_ind_tbl
operator|=
name|NULL
expr_stmt|;
name|mem_err1
label|:
name|rss
operator|->
name|tbl_log_size
operator|=
literal|0
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_indirect_table_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|size_t
name|tbl_size
init|=
operator|(
literal|1ULL
operator|<<
name|rss
operator|->
name|tbl_log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_rss_ind_table_entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|rss
operator|->
name|rss_ind_tbl
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|tbl_size
argument_list|,
name|rss
operator|->
name|rss_ind_tbl
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_dma_addr
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_mem_handle
argument_list|)
expr_stmt|;
name|rss
operator|->
name|rss_ind_tbl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rss
operator|->
name|host_rss_ind_tbl
condition|)
name|ENA_MEM_FREE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|rss
operator|->
name|host_rss_ind_tbl
argument_list|)
expr_stmt|;
name|rss
operator|->
name|host_rss_ind_tbl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_create_io_sq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
parameter_list|,
name|u16
name|cq_idx
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_aq_create_sq_cmd
name|create_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_create_sq_resp_desc
name|cmd_completion
decl_stmt|;
name|u8
name|direction
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|create_cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|create_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|create_cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_CREATE_SQ
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|direction
operator|==
name|ENA_COM_IO_QUEUE_DIRECTION_TX
condition|)
name|direction
operator|=
name|ENA_ADMIN_SQ_DIRECTION_TX
expr_stmt|;
else|else
name|direction
operator|=
name|ENA_ADMIN_SQ_DIRECTION_RX
expr_stmt|;
name|create_cmd
operator|.
name|sq_identity
operator||=
operator|(
name|direction
operator|<<
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_SQ_DIRECTION_SHIFT
operator|)
operator|&
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_SQ_DIRECTION_MASK
expr_stmt|;
name|create_cmd
operator|.
name|sq_caps_2
operator||=
name|io_sq
operator|->
name|mem_queue_type
operator|&
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_PLACEMENT_POLICY_MASK
expr_stmt|;
name|create_cmd
operator|.
name|sq_caps_2
operator||=
operator|(
name|ENA_ADMIN_COMPLETION_POLICY_DESC
operator|<<
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_COMPLETION_POLICY_SHIFT
operator|)
operator|&
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_COMPLETION_POLICY_MASK
expr_stmt|;
name|create_cmd
operator|.
name|sq_caps_3
operator||=
name|ENA_ADMIN_AQ_CREATE_SQ_CMD_IS_PHYSICALLY_CONTIGUOUS_MASK
expr_stmt|;
name|create_cmd
operator|.
name|cq_idx
operator|=
name|cq_idx
expr_stmt|;
name|create_cmd
operator|.
name|sq_depth
operator|=
name|io_sq
operator|->
name|q_depth
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|mem_queue_type
operator|==
name|ENA_ADMIN_PLACEMENT_POLICY_HOST
condition|)
block|{
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|create_cmd
operator|.
name|sq_ba
argument_list|,
name|io_sq
operator|->
name|desc_addr
operator|.
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|create_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|create_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|cmd_completion
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_completion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to create IO SQ. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|io_sq
operator|->
name|idx
operator|=
name|cmd_completion
operator|.
name|sq_idx
expr_stmt|;
name|io_sq
operator|->
name|db_addr
operator|=
operator|(
name|u32
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|reg_bar
operator|+
operator|(
name|uintptr_t
operator|)
name|cmd_completion
operator|.
name|sq_doorbell_offset
operator|)
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|mem_queue_type
operator|==
name|ENA_ADMIN_PLACEMENT_POLICY_DEV
condition|)
block|{
name|io_sq
operator|->
name|header_addr
operator|=
operator|(
name|u8
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|mem_bar
operator|+
name|cmd_completion
operator|.
name|llq_headers_offset
operator|)
expr_stmt|;
name|io_sq
operator|->
name|desc_addr
operator|.
name|pbuf_dev_addr
operator|=
operator|(
name|u8
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|mem_bar
operator|+
name|cmd_completion
operator|.
name|llq_descriptors_offset
operator|)
expr_stmt|;
block|}
name|ena_trc_dbg
argument_list|(
literal|"created sq[%u], depth[%u]\n"
argument_list|,
name|io_sq
operator|->
name|idx
argument_list|,
name|io_sq
operator|->
name|q_depth
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_ind_tbl_convert_to_device
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|u16
name|qid
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
operator|<<
name|rss
operator|->
name|tbl_log_size
condition|;
name|i
operator|++
control|)
block|{
name|qid
operator|=
name|rss
operator|->
name|host_rss_ind_tbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
name|ENA_TOTAL_NUM_QUEUES
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|io_sq
operator|=
operator|&
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|qid
index|]
expr_stmt|;
if|if
condition|(
name|io_sq
operator|->
name|direction
operator|!=
name|ENA_COM_IO_QUEUE_DIRECTION_RX
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|rss
operator|->
name|rss_ind_tbl
index|[
name|i
index|]
operator|.
name|cq_idx
operator|=
name|io_sq
operator|->
name|idx
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_ind_tbl_convert_from_device
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|u16
name|dev_idx_to_host_tbl
index|[
name|ENA_TOTAL_NUM_QUEUES
index|]
init|=
block|{
operator|(
name|u16
operator|)
operator|-
literal|1
block|}
decl_stmt|;
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|u8
name|idx
decl_stmt|;
name|u16
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENA_TOTAL_NUM_QUEUES
condition|;
name|i
operator|++
control|)
name|dev_idx_to_host_tbl
index|[
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|i
index|]
operator|.
name|idx
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
operator|<<
name|rss
operator|->
name|tbl_log_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rss
operator|->
name|rss_ind_tbl
index|[
name|i
index|]
operator|.
name|cq_idx
operator|>
name|ENA_TOTAL_NUM_QUEUES
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|idx
operator|=
operator|(
name|u8
operator|)
name|rss
operator|->
name|rss_ind_tbl
index|[
name|i
index|]
operator|.
name|cq_idx
expr_stmt|;
if|if
condition|(
name|dev_idx_to_host_tbl
index|[
name|idx
index|]
operator|>
name|ENA_TOTAL_NUM_QUEUES
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|rss
operator|->
name|host_rss_ind_tbl
index|[
name|i
index|]
operator|=
name|dev_idx_to_host_tbl
index|[
name|idx
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_com_init_interrupt_moderation_table
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ena_intr_moder_entry
argument_list|)
operator|*
name|ENA_INTR_MAX_NUM_OF_LEVELS
expr_stmt|;
name|ena_dev
operator|->
name|intr_moder_tbl
operator|=
name|ENA_MEM_ALLOC
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ena_dev
operator|->
name|intr_moder_tbl
condition|)
return|return
name|ENA_COM_NO_MEM
return|;
name|ena_com_config_default_interrupt_moderation_table
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ena_com_update_intr_delay_resolution
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|intr_delay_resolution
parameter_list|)
block|{
name|struct
name|ena_intr_moder_entry
modifier|*
name|intr_moder_tbl
init|=
name|ena_dev
operator|->
name|intr_moder_tbl
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|intr_delay_resolution
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Illegal intr_delay_resolution provided. Going to use default 1 usec resolution\n"
argument_list|)
expr_stmt|;
name|intr_delay_resolution
operator|=
literal|1
expr_stmt|;
block|}
name|ena_dev
operator|->
name|intr_delay_resolution
operator|=
name|intr_delay_resolution
expr_stmt|;
comment|/* update Rx */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENA_INTR_MAX_NUM_OF_LEVELS
condition|;
name|i
operator|++
control|)
name|intr_moder_tbl
index|[
name|i
index|]
operator|.
name|intr_moder_interval
operator|/=
name|intr_delay_resolution
expr_stmt|;
comment|/* update Tx */
name|ena_dev
operator|->
name|intr_moder_tx_interval
operator|/=
name|intr_delay_resolution
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*******************************      API       ******************************/
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|int
name|ena_com_execute_admin_command
parameter_list|(
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
parameter_list|,
name|struct
name|ena_admin_aq_entry
modifier|*
name|cmd
parameter_list|,
name|size_t
name|cmd_size
parameter_list|,
name|struct
name|ena_admin_acq_entry
modifier|*
name|comp
parameter_list|,
name|size_t
name|comp_size
parameter_list|)
block|{
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|comp_ctx
operator|=
name|ena_com_submit_admin_cmd
argument_list|(
name|admin_queue
argument_list|,
name|cmd
argument_list|,
name|cmd_size
argument_list|,
name|comp
argument_list|,
name|comp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|IS_ERR
argument_list|(
name|comp_ctx
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|comp_ctx
operator|==
name|ERR_PTR
argument_list|(
name|ENA_COM_NO_DEVICE
argument_list|)
condition|)
name|ena_trc_dbg
argument_list|(
literal|"Failed to submit command [%ld]\n"
argument_list|,
name|PTR_ERR
argument_list|(
name|comp_ctx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ena_trc_err
argument_list|(
literal|"Failed to submit command [%ld]\n"
argument_list|,
name|PTR_ERR
argument_list|(
name|comp_ctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PTR_ERR
argument_list|(
name|comp_ctx
argument_list|)
return|;
block|}
name|ret
operator|=
name|ena_com_wait_and_process_admin_cq
argument_list|(
name|comp_ctx
argument_list|,
name|admin_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|admin_queue
operator|->
name|running_state
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to process command. ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|ena_trc_dbg
argument_list|(
literal|"Failed to process command. ret = %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_create_io_cq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_aq_create_cq_cmd
name|create_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_create_cq_resp_desc
name|cmd_completion
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|create_cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|create_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|create_cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_CREATE_CQ
expr_stmt|;
name|create_cmd
operator|.
name|cq_caps_2
operator||=
operator|(
name|io_cq
operator|->
name|cdesc_entry_size_in_bytes
operator|/
literal|4
operator|)
operator|&
name|ENA_ADMIN_AQ_CREATE_CQ_CMD_CQ_ENTRY_SIZE_WORDS_MASK
expr_stmt|;
name|create_cmd
operator|.
name|cq_caps_1
operator||=
name|ENA_ADMIN_AQ_CREATE_CQ_CMD_INTERRUPT_MODE_ENABLED_MASK
expr_stmt|;
name|create_cmd
operator|.
name|msix_vector
operator|=
name|io_cq
operator|->
name|msix_vector
expr_stmt|;
name|create_cmd
operator|.
name|cq_depth
operator|=
name|io_cq
operator|->
name|q_depth
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|create_cmd
operator|.
name|cq_ba
argument_list|,
name|io_cq
operator|->
name|cdesc_addr
operator|.
name|phys_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|create_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|create_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|cmd_completion
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd_completion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to create IO CQ. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|io_cq
operator|->
name|idx
operator|=
name|cmd_completion
operator|.
name|cq_idx
expr_stmt|;
name|io_cq
operator|->
name|unmask_reg
operator|=
operator|(
name|u32
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|reg_bar
operator|+
name|cmd_completion
operator|.
name|cq_interrupt_unmask_register_offset
operator|)
expr_stmt|;
if|if
condition|(
name|cmd_completion
operator|.
name|cq_head_db_register_offset
condition|)
name|io_cq
operator|->
name|cq_head_db_reg
operator|=
operator|(
name|u32
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|reg_bar
operator|+
name|cmd_completion
operator|.
name|cq_head_db_register_offset
operator|)
expr_stmt|;
if|if
condition|(
name|cmd_completion
operator|.
name|numa_node_register_offset
condition|)
name|io_cq
operator|->
name|numa_node_cfg_reg
operator|=
operator|(
name|u32
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|reg_bar
operator|+
name|cmd_completion
operator|.
name|numa_node_register_offset
operator|)
expr_stmt|;
name|ena_trc_dbg
argument_list|(
literal|"created cq[%u], depth[%u]\n"
argument_list|,
name|io_cq
operator|->
name|idx
argument_list|,
name|io_cq
operator|->
name|q_depth
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_io_handlers
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|qid
parameter_list|,
name|struct
name|ena_com_io_sq
modifier|*
modifier|*
name|io_sq
parameter_list|,
name|struct
name|ena_com_io_cq
modifier|*
modifier|*
name|io_cq
parameter_list|)
block|{
if|if
condition|(
name|qid
operator|>=
name|ENA_TOTAL_NUM_QUEUES
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Invalid queue number %d but the max is %d\n"
argument_list|,
name|qid
argument_list|,
name|ENA_TOTAL_NUM_QUEUES
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
operator|*
name|io_sq
operator|=
operator|&
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|qid
index|]
expr_stmt|;
operator|*
name|io_cq
operator|=
operator|&
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|qid
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_abort_admin_commands
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_comp_ctx
modifier|*
name|comp_ctx
decl_stmt|;
name|u16
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|admin_queue
operator|->
name|comp_ctx
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|admin_queue
operator|->
name|q_depth
condition|;
name|i
operator|++
control|)
block|{
name|comp_ctx
operator|=
name|get_comp_ctxt
argument_list|(
name|admin_queue
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|comp_ctx
argument_list|)
condition|)
break|break;
name|comp_ctx
operator|->
name|status
operator|=
name|ENA_CMD_ABORTED
expr_stmt|;
name|ENA_WAIT_EVENT_SIGNAL
argument_list|(
name|comp_ctx
operator|->
name|wait_event
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ena_com_wait_for_abort_completion
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|ATOMIC32_READ
argument_list|(
operator|&
name|admin_queue
operator|->
name|outstanding_cmds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ENA_MSLEEP
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_destroy_io_cq
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_aq_destroy_cq_cmd
name|destroy_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_destroy_cq_resp_desc
name|destroy_resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|destroy_cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_cmd
operator|.
name|cq_idx
operator|=
name|io_cq
operator|->
name|idx
expr_stmt|;
name|destroy_cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_DESTROY_CQ
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|destroy_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|destroy_resp
argument_list|,
sizeof|sizeof
argument_list|(
name|destroy_resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|&&
operator|(
name|ret
operator|!=
name|ENA_COM_NO_DEVICE
operator|)
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to destroy IO CQ. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|ena_com_get_admin_running_state
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
return|return
name|ena_dev
operator|->
name|admin_queue
operator|.
name|running_state
return|;
block|}
end_function

begin_function
name|void
name|ena_com_set_admin_running_state
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|bool
name|state
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|ENA_SPINLOCK_LOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ena_dev
operator|->
name|admin_queue
operator|.
name|running_state
operator|=
name|state
expr_stmt|;
name|ENA_SPINLOCK_UNLOCK
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ena_com_admin_aenq_enable
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|u16
name|depth
init|=
name|ena_dev
operator|->
name|aenq
operator|.
name|q_depth
decl_stmt|;
name|ENA_WARN
argument_list|(
name|ena_dev
operator|->
name|aenq
operator|.
name|head
operator|!=
name|depth
argument_list|,
literal|"Invalid AENQ state\n"
argument_list|)
expr_stmt|;
comment|/* Init head_db to mark that all entries in the queue 	 * are initially available 	 */
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|depth
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AENQ_HEAD_DB_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_set_aenq_config
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
name|groups_flag
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_AENQ_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ena_trc_info
argument_list|(
literal|"Can't get aenq configuration\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|get_resp
operator|.
name|u
operator|.
name|aenq
operator|.
name|supported_groups
operator|&
name|groups_flag
operator|)
operator|!=
name|groups_flag
condition|)
block|{
name|ena_trc_warn
argument_list|(
literal|"Trying to set unsupported aenq events. supported flag: %x asked flag: %x\n"
argument_list|,
name|get_resp
operator|.
name|u
operator|.
name|aenq
operator|.
name|supported_groups
argument_list|,
name|groups_flag
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|admin_queue
operator|=
operator|&
name|ena_dev
operator|->
name|admin_queue
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_AENQ_CONFIG
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|aenq
operator|.
name|enabled_groups
operator|=
name|groups_flag
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to config AENQ ret: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_dma_width
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|u32
name|caps
init|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_CAPS_OFF
argument_list|)
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|caps
operator|==
name|ENA_MMIO_READ_TIMEOUT
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reg read timeout occurred\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
name|width
operator|=
operator|(
name|caps
operator|&
name|ENA_REGS_CAPS_DMA_ADDR_WIDTH_MASK
operator|)
operator|>>
name|ENA_REGS_CAPS_DMA_ADDR_WIDTH_SHIFT
expr_stmt|;
name|ena_trc_dbg
argument_list|(
literal|"ENA dma width: %d\n"
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|<
literal|32
operator|)
operator|||
name|width
operator|>
name|ENA_MAX_PHYS_ADDR_SIZE_BITS
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"DMA width illegal value: %d\n"
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|ena_dev
operator|->
name|dma_addr_bits
operator|=
name|width
expr_stmt|;
return|return
name|width
return|;
block|}
end_function

begin_function
name|int
name|ena_com_validate_version
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|u32
name|ver
decl_stmt|;
name|u32
name|ctrl_ver
decl_stmt|;
name|u32
name|ctrl_ver_masked
decl_stmt|;
comment|/* Make sure the ENA version and the controller version are at least 	 * as the driver expects 	 */
name|ver
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_VERSION_OFF
argument_list|)
expr_stmt|;
name|ctrl_ver
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_CONTROLLER_VERSION_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|ver
operator|==
name|ENA_MMIO_READ_TIMEOUT
operator|)
operator|||
operator|(
name|ctrl_ver
operator|==
name|ENA_MMIO_READ_TIMEOUT
operator|)
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reg read timeout occurred\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
name|ena_trc_info
argument_list|(
literal|"ena device version: %d.%d\n"
argument_list|,
operator|(
name|ver
operator|&
name|ENA_REGS_VERSION_MAJOR_VERSION_MASK
operator|)
operator|>>
name|ENA_REGS_VERSION_MAJOR_VERSION_SHIFT
argument_list|,
name|ver
operator|&
name|ENA_REGS_VERSION_MINOR_VERSION_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|<
name|MIN_ENA_VER
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"ENA version is lower than the minimal version the driver supports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ena_trc_info
argument_list|(
literal|"ena controller version: %d.%d.%d implementation version %d\n"
argument_list|,
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_MASK
operator|)
operator|>>
name|ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_SHIFT
argument_list|,
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_MASK
operator|)
operator|>>
name|ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_SHIFT
argument_list|,
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_SUBMINOR_VERSION_MASK
operator|)
argument_list|,
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_IMPL_ID_MASK
operator|)
operator|>>
name|ENA_REGS_CONTROLLER_VERSION_IMPL_ID_SHIFT
argument_list|)
expr_stmt|;
name|ctrl_ver_masked
operator|=
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_MAJOR_VERSION_MASK
operator|)
operator||
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_MINOR_VERSION_MASK
operator|)
operator||
operator|(
name|ctrl_ver
operator|&
name|ENA_REGS_CONTROLLER_VERSION_SUBMINOR_VERSION_MASK
operator|)
expr_stmt|;
comment|/* Validate the ctrl version without the implementation ID */
if|if
condition|(
name|ctrl_ver_masked
operator|<
name|MIN_ENA_CTRL_VER
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"ENA ctrl version is lower than the minimal ctrl version the driver supports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_admin_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_com_admin_cq
modifier|*
name|cq
init|=
operator|&
name|admin_queue
operator|->
name|cq
decl_stmt|;
name|struct
name|ena_com_admin_sq
modifier|*
name|sq
init|=
operator|&
name|admin_queue
operator|->
name|sq
decl_stmt|;
name|struct
name|ena_com_aenq
modifier|*
name|aenq
init|=
operator|&
name|ena_dev
operator|->
name|aenq
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|ENA_WAIT_EVENT_DESTROY
argument_list|(
name|admin_queue
operator|->
name|comp_ctx
operator|->
name|wait_event
argument_list|)
expr_stmt|;
name|ENA_SPINLOCK_DESTROY
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_queue
operator|->
name|comp_ctx
condition|)
name|ENA_MEM_FREE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|admin_queue
operator|->
name|comp_ctx
argument_list|)
expr_stmt|;
name|admin_queue
operator|->
name|comp_ctx
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|ADMIN_SQ_SIZE
argument_list|(
name|admin_queue
operator|->
name|q_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|entries
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|sq
operator|->
name|entries
argument_list|,
name|sq
operator|->
name|dma_addr
argument_list|,
name|sq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
name|sq
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|ADMIN_CQ_SIZE
argument_list|(
name|admin_queue
operator|->
name|q_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|cq
operator|->
name|entries
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|cq
operator|->
name|entries
argument_list|,
name|cq
operator|->
name|dma_addr
argument_list|,
name|cq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
name|cq
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|ADMIN_AENQ_SIZE
argument_list|(
name|aenq
operator|->
name|q_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|ena_dev
operator|->
name|aenq
operator|.
name|entries
condition|)
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|size
argument_list|,
name|aenq
operator|->
name|entries
argument_list|,
name|aenq
operator|->
name|dma_addr
argument_list|,
name|aenq
operator|->
name|mem_handle
argument_list|)
expr_stmt|;
name|aenq
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ena_com_set_admin_polling_mode
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|bool
name|polling
parameter_list|)
block|{
name|ena_dev
operator|->
name|admin_queue
operator|.
name|polling
operator|=
name|polling
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_mmio_reg_read_request_init
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_mmio_read
modifier|*
name|mmio_read
init|=
operator|&
name|ena_dev
operator|->
name|mmio_read
decl_stmt|;
name|ENA_SPINLOCK_INIT
argument_list|(
name|mmio_read
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mmio_read
operator|->
name|read_resp
argument_list|)
argument_list|,
name|mmio_read
operator|->
name|read_resp
argument_list|,
name|mmio_read
operator|->
name|read_resp_dma_addr
argument_list|,
name|mmio_read
operator|->
name|read_resp_mem_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mmio_read
operator|->
name|read_resp
argument_list|)
condition|)
return|return
name|ENA_COM_NO_MEM
return|;
name|ena_com_mmio_reg_read_request_write_dev_addr
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|mmio_read
operator|->
name|read_resp
operator|->
name|req_id
operator|=
literal|0x0
expr_stmt|;
name|mmio_read
operator|->
name|seq_num
operator|=
literal|0x0
expr_stmt|;
name|mmio_read
operator|->
name|readless_supported
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_set_mmio_read_mode
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|bool
name|readless_supported
parameter_list|)
block|{
name|struct
name|ena_com_mmio_read
modifier|*
name|mmio_read
init|=
operator|&
name|ena_dev
operator|->
name|mmio_read
decl_stmt|;
name|mmio_read
operator|->
name|readless_supported
operator|=
name|readless_supported
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ena_com_mmio_reg_read_request_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_mmio_read
modifier|*
name|mmio_read
init|=
operator|&
name|ena_dev
operator|->
name|mmio_read
decl_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
literal|0x0
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_MMIO_RESP_LO_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
literal|0x0
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_MMIO_RESP_HI_OFF
argument_list|)
expr_stmt|;
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mmio_read
operator|->
name|read_resp
argument_list|)
argument_list|,
name|mmio_read
operator|->
name|read_resp
argument_list|,
name|mmio_read
operator|->
name|read_resp_dma_addr
argument_list|,
name|mmio_read
operator|->
name|read_resp_mem_handle
argument_list|)
expr_stmt|;
name|mmio_read
operator|->
name|read_resp
operator|=
name|NULL
expr_stmt|;
name|ENA_SPINLOCK_DESTROY
argument_list|(
name|mmio_read
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ena_com_mmio_reg_read_request_write_dev_addr
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_mmio_read
modifier|*
name|mmio_read
init|=
operator|&
name|ena_dev
operator|->
name|mmio_read
decl_stmt|;
name|u32
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|;
name|addr_low
operator|=
name|ENA_DMA_ADDR_TO_UINT32_LOW
argument_list|(
name|mmio_read
operator|->
name|read_resp_dma_addr
argument_list|)
expr_stmt|;
name|addr_high
operator|=
name|ENA_DMA_ADDR_TO_UINT32_HIGH
argument_list|(
name|mmio_read
operator|->
name|read_resp_dma_addr
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_low
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_MMIO_RESP_LO_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_high
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_MMIO_RESP_HI_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_admin_init
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_aenq_handlers
modifier|*
name|aenq_handlers
parameter_list|,
name|bool
name|init_spinlock
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|u32
name|aq_caps
decl_stmt|,
name|acq_caps
decl_stmt|,
name|dev_sts
decl_stmt|,
name|addr_low
decl_stmt|,
name|addr_high
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|ENA_INTERNAL
name|ena_trc_info
argument_list|(
literal|"ena_defs : Version:[%s] Build date [%s]"
argument_list|,
name|ENA_GEN_COMMIT
argument_list|,
name|ENA_GEN_DATE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev_sts
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_DEV_STS_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|dev_sts
operator|==
name|ENA_MMIO_READ_TIMEOUT
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reg read timeout occurred\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dev_sts
operator|&
name|ENA_REGS_DEV_STS_READY_MASK
operator|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Device isn't ready, abort com init\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_NO_DEVICE
return|;
block|}
name|admin_queue
operator|->
name|q_depth
operator|=
name|ENA_ADMIN_QUEUE_DEPTH
expr_stmt|;
name|admin_queue
operator|->
name|bus
operator|=
name|ena_dev
operator|->
name|bus
expr_stmt|;
name|admin_queue
operator|->
name|q_dmadev
operator|=
name|ena_dev
operator|->
name|dmadev
expr_stmt|;
name|admin_queue
operator|->
name|polling
operator|=
name|false
expr_stmt|;
name|admin_queue
operator|->
name|curr_cmd_id
operator|=
literal|0
expr_stmt|;
name|ATOMIC32_SET
argument_list|(
operator|&
name|admin_queue
operator|->
name|outstanding_cmds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_spinlock
condition|)
name|ENA_SPINLOCK_INIT
argument_list|(
name|admin_queue
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_init_comp_ctxt
argument_list|(
name|admin_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ena_com_admin_init_sq
argument_list|(
name|admin_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ena_com_admin_init_cq
argument_list|(
name|admin_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|admin_queue
operator|->
name|sq
operator|.
name|db_addr
operator|=
operator|(
name|u32
name|__iomem
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AQ_DB_OFF
operator|)
expr_stmt|;
name|addr_low
operator|=
name|ENA_DMA_ADDR_TO_UINT32_LOW
argument_list|(
name|admin_queue
operator|->
name|sq
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
name|addr_high
operator|=
name|ENA_DMA_ADDR_TO_UINT32_HIGH
argument_list|(
name|admin_queue
operator|->
name|sq
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_low
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AQ_BASE_LO_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_high
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AQ_BASE_HI_OFF
argument_list|)
expr_stmt|;
name|addr_low
operator|=
name|ENA_DMA_ADDR_TO_UINT32_LOW
argument_list|(
name|admin_queue
operator|->
name|cq
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
name|addr_high
operator|=
name|ENA_DMA_ADDR_TO_UINT32_HIGH
argument_list|(
name|admin_queue
operator|->
name|cq
operator|.
name|dma_addr
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_low
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_ACQ_BASE_LO_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|addr_high
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_ACQ_BASE_HI_OFF
argument_list|)
expr_stmt|;
name|aq_caps
operator|=
literal|0
expr_stmt|;
name|aq_caps
operator||=
name|admin_queue
operator|->
name|q_depth
operator|&
name|ENA_REGS_AQ_CAPS_AQ_DEPTH_MASK
expr_stmt|;
name|aq_caps
operator||=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_aq_entry
argument_list|)
operator|<<
name|ENA_REGS_AQ_CAPS_AQ_ENTRY_SIZE_SHIFT
operator|)
operator|&
name|ENA_REGS_AQ_CAPS_AQ_ENTRY_SIZE_MASK
expr_stmt|;
name|acq_caps
operator|=
literal|0
expr_stmt|;
name|acq_caps
operator||=
name|admin_queue
operator|->
name|q_depth
operator|&
name|ENA_REGS_ACQ_CAPS_ACQ_DEPTH_MASK
expr_stmt|;
name|acq_caps
operator||=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_acq_entry
argument_list|)
operator|<<
name|ENA_REGS_ACQ_CAPS_ACQ_ENTRY_SIZE_SHIFT
operator|)
operator|&
name|ENA_REGS_ACQ_CAPS_ACQ_ENTRY_SIZE_MASK
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|aq_caps
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AQ_CAPS_OFF
argument_list|)
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|acq_caps
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_ACQ_CAPS_OFF
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_admin_init_aenq
argument_list|(
name|ena_dev
argument_list|,
name|aenq_handlers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|admin_queue
operator|->
name|running_state
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
name|ena_com_admin_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_create_io_queue
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_create_io_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|qid
operator|>=
name|ENA_TOTAL_NUM_QUEUES
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Qid (%d) is bigger than max num of queues (%d)\n"
argument_list|,
name|ctx
operator|->
name|qid
argument_list|,
name|ENA_TOTAL_NUM_QUEUES
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|io_sq
operator|=
operator|&
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|ctx
operator|->
name|qid
index|]
expr_stmt|;
name|io_cq
operator|=
operator|&
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|ctx
operator|->
name|qid
index|]
expr_stmt|;
name|memset
argument_list|(
name|io_sq
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io_sq
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|io_cq
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|io_cq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init CQ */
name|io_cq
operator|->
name|q_depth
operator|=
name|ctx
operator|->
name|queue_size
expr_stmt|;
name|io_cq
operator|->
name|direction
operator|=
name|ctx
operator|->
name|direction
expr_stmt|;
name|io_cq
operator|->
name|qid
operator|=
name|ctx
operator|->
name|qid
expr_stmt|;
name|io_cq
operator|->
name|msix_vector
operator|=
name|ctx
operator|->
name|msix_vector
expr_stmt|;
name|io_sq
operator|->
name|q_depth
operator|=
name|ctx
operator|->
name|queue_size
expr_stmt|;
name|io_sq
operator|->
name|direction
operator|=
name|ctx
operator|->
name|direction
expr_stmt|;
name|io_sq
operator|->
name|qid
operator|=
name|ctx
operator|->
name|qid
expr_stmt|;
name|io_sq
operator|->
name|mem_queue_type
operator|=
name|ctx
operator|->
name|mem_queue_type
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|direction
operator|==
name|ENA_COM_IO_QUEUE_DIRECTION_TX
condition|)
comment|/* header length is limited to 8 bits */
name|io_sq
operator|->
name|tx_max_header_size
operator|=
name|ENA_MIN32
argument_list|(
name|ena_dev
operator|->
name|tx_max_header_size
argument_list|,
name|SZ_256
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_init_io_sq
argument_list|(
name|ena_dev
argument_list|,
name|ctx
argument_list|,
name|io_sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ena_com_init_io_cq
argument_list|(
name|ena_dev
argument_list|,
name|ctx
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ena_com_create_io_cq
argument_list|(
name|ena_dev
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|ena_com_create_io_sq
argument_list|(
name|ena_dev
argument_list|,
name|io_sq
argument_list|,
name|io_cq
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|destroy_io_cq
goto|;
return|return
literal|0
return|;
name|destroy_io_cq
label|:
name|ena_com_destroy_io_cq
argument_list|(
name|ena_dev
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
name|error
label|:
name|ena_com_io_queue_free
argument_list|(
name|ena_dev
argument_list|,
name|io_sq
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ena_com_destroy_io_queue
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|qid
parameter_list|)
block|{
name|struct
name|ena_com_io_sq
modifier|*
name|io_sq
decl_stmt|;
name|struct
name|ena_com_io_cq
modifier|*
name|io_cq
decl_stmt|;
if|if
condition|(
name|qid
operator|>=
name|ENA_TOTAL_NUM_QUEUES
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Qid (%d) is bigger than max num of queues (%d)\n"
argument_list|,
name|qid
argument_list|,
name|ENA_TOTAL_NUM_QUEUES
argument_list|)
expr_stmt|;
return|return;
block|}
name|io_sq
operator|=
operator|&
name|ena_dev
operator|->
name|io_sq_queues
index|[
name|qid
index|]
expr_stmt|;
name|io_cq
operator|=
operator|&
name|ena_dev
operator|->
name|io_cq_queues
index|[
name|qid
index|]
expr_stmt|;
name|ena_com_destroy_io_sq
argument_list|(
name|ena_dev
argument_list|,
name|io_sq
argument_list|)
expr_stmt|;
name|ena_com_destroy_io_cq
argument_list|(
name|ena_dev
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
name|ena_com_io_queue_free
argument_list|(
name|ena_dev
argument_list|,
name|io_sq
argument_list|,
name|io_cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_get_link_params
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_admin_get_feat_resp
modifier|*
name|resp
parameter_list|)
block|{
return|return
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
name|resp
argument_list|,
name|ENA_ADMIN_LINK_CONFIG
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_dev_attr_feat
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_dev_get_features_ctx
modifier|*
name|get_feat_ctx
parameter_list|)
block|{
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_DEVICE_ATTRIBUTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|dev_attr
argument_list|,
operator|&
name|get_resp
operator|.
name|u
operator|.
name|dev_attr
argument_list|,
sizeof|sizeof
argument_list|(
name|get_resp
operator|.
name|u
operator|.
name|dev_attr
argument_list|)
argument_list|)
expr_stmt|;
name|ena_dev
operator|->
name|supported_features
operator|=
name|get_resp
operator|.
name|u
operator|.
name|dev_attr
operator|.
name|supported_features
expr_stmt|;
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_MAX_QUEUES_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|max_queues
argument_list|,
operator|&
name|get_resp
operator|.
name|u
operator|.
name|max_queue
argument_list|,
sizeof|sizeof
argument_list|(
name|get_resp
operator|.
name|u
operator|.
name|max_queue
argument_list|)
argument_list|)
expr_stmt|;
name|ena_dev
operator|->
name|tx_max_header_size
operator|=
name|get_resp
operator|.
name|u
operator|.
name|max_queue
operator|.
name|max_header_size
expr_stmt|;
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_AENQ_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|aenq
argument_list|,
operator|&
name|get_resp
operator|.
name|u
operator|.
name|aenq
argument_list|,
sizeof|sizeof
argument_list|(
name|get_resp
operator|.
name|u
operator|.
name|aenq
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_STATELESS_OFFLOAD_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
name|memcpy
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|offload
argument_list|,
operator|&
name|get_resp
operator|.
name|u
operator|.
name|offload
argument_list|,
sizeof|sizeof
argument_list|(
name|get_resp
operator|.
name|u
operator|.
name|offload
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Driver hints isn't mandatory admin command. So in case the 	 * command isn't supported set driver hints to 0 	 */
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_HW_HINTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|memcpy
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|hw_hints
argument_list|,
operator|&
name|get_resp
operator|.
name|u
operator|.
name|hw_hints
argument_list|,
sizeof|sizeof
argument_list|(
name|get_resp
operator|.
name|u
operator|.
name|hw_hints
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|==
name|ENA_COM_PERMISSION
condition|)
name|memset
argument_list|(
operator|&
name|get_feat_ctx
operator|->
name|hw_hints
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|get_feat_ctx
operator|->
name|hw_hints
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|rc
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_admin_q_comp_intr_handler
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|ena_com_handle_admin_completion
argument_list|(
operator|&
name|ena_dev
operator|->
name|admin_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ena_handle_specific_aenq_event:  * return the handler that is relevant to the specific event group  */
end_comment

begin_function
specifier|static
name|ena_aenq_handler
name|ena_com_get_specific_aenq_cb
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|group
parameter_list|)
block|{
name|struct
name|ena_aenq_handlers
modifier|*
name|aenq_handlers
init|=
name|dev
operator|->
name|aenq
operator|.
name|aenq_handlers
decl_stmt|;
if|if
condition|(
operator|(
name|group
operator|<
name|ENA_MAX_HANDLERS
operator|)
operator|&&
name|aenq_handlers
operator|->
name|handlers
index|[
name|group
index|]
condition|)
return|return
name|aenq_handlers
operator|->
name|handlers
index|[
name|group
index|]
return|;
return|return
name|aenq_handlers
operator|->
name|unimplemented_handler
return|;
block|}
end_function

begin_comment
comment|/* ena_aenq_intr_handler:  * handles the aenq incoming events.  * pop events from the queue and apply the specific handler  */
end_comment

begin_function
name|void
name|ena_com_aenq_intr_handler
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ena_admin_aenq_entry
modifier|*
name|aenq_e
decl_stmt|;
name|struct
name|ena_admin_aenq_common_desc
modifier|*
name|aenq_common
decl_stmt|;
name|struct
name|ena_com_aenq
modifier|*
name|aenq
init|=
operator|&
name|dev
operator|->
name|aenq
decl_stmt|;
name|ena_aenq_handler
name|handler_cb
decl_stmt|;
name|u16
name|masked_head
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u8
name|phase
decl_stmt|;
name|masked_head
operator|=
name|aenq
operator|->
name|head
operator|&
operator|(
name|aenq
operator|->
name|q_depth
operator|-
literal|1
operator|)
expr_stmt|;
name|phase
operator|=
name|aenq
operator|->
name|phase
expr_stmt|;
name|aenq_e
operator|=
operator|&
name|aenq
operator|->
name|entries
index|[
name|masked_head
index|]
expr_stmt|;
comment|/* Get first entry */
name|aenq_common
operator|=
operator|&
name|aenq_e
operator|->
name|aenq_common_desc
expr_stmt|;
comment|/* Go over all the events */
while|while
condition|(
operator|(
name|aenq_common
operator|->
name|flags
operator|&
name|ENA_ADMIN_AENQ_COMMON_DESC_PHASE_MASK
operator|)
operator|==
name|phase
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"AENQ! Group[%x] Syndrom[%x] timestamp: [%jus]\n"
argument_list|,
name|aenq_common
operator|->
name|group
argument_list|,
name|aenq_common
operator|->
name|syndrom
argument_list|,
operator|(
name|u64
operator|)
name|aenq_common
operator|->
name|timestamp_low
operator|+
operator|(
operator|(
name|u64
operator|)
name|aenq_common
operator|->
name|timestamp_high
operator|<<
literal|32
operator|)
argument_list|)
expr_stmt|;
comment|/* Handle specific event*/
name|handler_cb
operator|=
name|ena_com_get_specific_aenq_cb
argument_list|(
name|dev
argument_list|,
name|aenq_common
operator|->
name|group
argument_list|)
expr_stmt|;
name|handler_cb
argument_list|(
name|data
argument_list|,
name|aenq_e
argument_list|)
expr_stmt|;
comment|/* call the actual event handler*/
comment|/* Get next event entry */
name|masked_head
operator|++
expr_stmt|;
name|processed
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|masked_head
operator|==
name|aenq
operator|->
name|q_depth
argument_list|)
condition|)
block|{
name|masked_head
operator|=
literal|0
expr_stmt|;
name|phase
operator|=
operator|!
name|phase
expr_stmt|;
block|}
name|aenq_e
operator|=
operator|&
name|aenq
operator|->
name|entries
index|[
name|masked_head
index|]
expr_stmt|;
name|aenq_common
operator|=
operator|&
name|aenq_e
operator|->
name|aenq_common_desc
expr_stmt|;
block|}
name|aenq
operator|->
name|head
operator|+=
name|processed
expr_stmt|;
name|aenq
operator|->
name|phase
operator|=
name|phase
expr_stmt|;
comment|/* Don't update aenq doorbell if there weren't any processed events */
if|if
condition|(
operator|!
name|processed
condition|)
return|return;
comment|/* write the aenq doorbell after all AENQ descriptors were read */
name|mb
argument_list|()
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|dev
operator|->
name|bus
argument_list|,
operator|(
name|u32
operator|)
name|aenq
operator|->
name|head
argument_list|,
name|dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_AENQ_HEAD_DB_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_dev_reset
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|u32
name|stat
decl_stmt|,
name|timeout
decl_stmt|,
name|cap
decl_stmt|,
name|reset_val
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|stat
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_DEV_STS_OFF
argument_list|)
expr_stmt|;
name|cap
operator|=
name|ena_com_reg_bar_read32
argument_list|(
name|ena_dev
argument_list|,
name|ENA_REGS_CAPS_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|stat
operator|==
name|ENA_MMIO_READ_TIMEOUT
operator|)
operator|||
operator|(
name|cap
operator|==
name|ENA_MMIO_READ_TIMEOUT
operator|)
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reg read32 timeout occurred\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_TIMER_EXPIRED
return|;
block|}
if|if
condition|(
operator|(
name|stat
operator|&
name|ENA_REGS_DEV_STS_READY_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Device isn't ready, can't reset device\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|timeout
operator|=
operator|(
name|cap
operator|&
name|ENA_REGS_CAPS_RESET_TIMEOUT_MASK
operator|)
operator|>>
name|ENA_REGS_CAPS_RESET_TIMEOUT_SHIFT
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Invalid timeout value\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
comment|/* start reset */
name|reset_val
operator|=
name|ENA_REGS_DEV_CTL_DEV_RESET_MASK
expr_stmt|;
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
name|reset_val
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_DEV_CTL_OFF
argument_list|)
expr_stmt|;
comment|/* Write again the MMIO read request address */
name|ena_com_mmio_reg_read_request_write_dev_addr
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|rc
operator|=
name|wait_for_reset_state
argument_list|(
name|ena_dev
argument_list|,
name|timeout
argument_list|,
name|ENA_REGS_DEV_STS_RESET_IN_PROGRESS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reset indication didn't turn on\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* reset done */
name|ENA_REG_WRITE32
argument_list|(
name|ena_dev
operator|->
name|bus
argument_list|,
literal|0
argument_list|,
name|ena_dev
operator|->
name|reg_bar
operator|+
name|ENA_REGS_DEV_CTL_OFF
argument_list|)
expr_stmt|;
name|rc
operator|=
name|wait_for_reset_state
argument_list|(
name|ena_dev
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Reset indication didn't turn off\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|timeout
operator|=
operator|(
name|cap
operator|&
name|ENA_REGS_CAPS_ADMIN_CMD_TO_MASK
operator|)
operator|>>
name|ENA_REGS_CAPS_ADMIN_CMD_TO_SHIFT
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
comment|/* the resolution of timeout reg is 100ms */
name|ena_dev
operator|->
name|admin_queue
operator|.
name|completion_timeout
operator|=
name|timeout
operator|*
literal|100000
expr_stmt|;
else|else
name|ena_dev
operator|->
name|admin_queue
operator|.
name|completion_timeout
operator|=
name|ADMIN_CMD_TIMEOUT_US
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ena_get_dev_stats
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_com_stats_ctx
modifier|*
name|ctx
parameter_list|,
name|enum
name|ena_admin_get_stats_type
name|type
parameter_list|)
block|{
name|struct
name|ena_admin_aq_get_stats_cmd
modifier|*
name|get_cmd
init|=
operator|&
name|ctx
operator|->
name|get_cmd
decl_stmt|;
name|struct
name|ena_admin_acq_get_stats_resp
modifier|*
name|get_resp
init|=
operator|&
name|ctx
operator|->
name|get_resp
decl_stmt|;
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|admin_queue
operator|=
operator|&
name|ena_dev
operator|->
name|admin_queue
expr_stmt|;
name|get_cmd
operator|->
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_GET_STATS
expr_stmt|;
name|get_cmd
operator|->
name|aq_common_descriptor
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|get_cmd
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
name|get_cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|get_cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
name|get_resp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|get_resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to get stats. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_dev_basic_stats
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_admin_basic_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|ena_com_stats_ctx
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_get_dev_stats
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|ctx
argument_list|,
name|ENA_ADMIN_GET_STATS_TYPE_BASIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
condition|)
name|memcpy
argument_list|(
name|stats
argument_list|,
operator|&
name|ctx
operator|.
name|get_resp
operator|.
name|basic_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|.
name|get_resp
operator|.
name|basic_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_set_dev_mtu
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_MTU
argument_list|)
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|ENA_ADMIN_MTU
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|admin_queue
operator|=
operator|&
name|ena_dev
operator|->
name|admin_queue
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_MTU
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|mtu
operator|.
name|mtu
operator|=
name|mtu
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to set mtu %d. error: %d\n"
argument_list|,
name|mtu
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_offload_settings
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|struct
name|ena_admin_feature_offload_desc
modifier|*
name|offload
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|resp
decl_stmt|;
name|ret
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|resp
argument_list|,
name|ENA_ADMIN_STATELESS_OFFLOAD_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to get offload capabilities %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memcpy
argument_list|(
name|offload
argument_list|,
operator|&
name|resp
operator|.
name|u
operator|.
name|offload
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|u
operator|.
name|offload
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_set_hash_function
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_RSS_HASH_FUNCTION
argument_list|)
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|ENA_ADMIN_RSS_HASH_FUNCTION
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
comment|/* Validate hash function is supported */
name|ret
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_HASH_FUNCTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|get_resp
operator|.
name|u
operator|.
name|flow_hash_func
operator|.
name|supported_func
operator|&
operator|(
literal|1
operator|<<
name|rss
operator|->
name|hash_func
operator|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Func hash %d isn't supported by device, abort\n"
argument_list|,
name|rss
operator|->
name|hash_func
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
name|ENA_ADMIN_AQ_COMMON_DESC_CTRL_DATA_INDIRECT_MASK
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_RSS_HASH_FUNCTION
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|flow_hash_func
operator|.
name|init_val
operator|=
name|rss
operator|->
name|hash_init_val
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|flow_hash_func
operator|.
name|selected_func
operator|=
literal|1
operator|<<
name|rss
operator|->
name|hash_func
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|cmd
operator|.
name|control_buffer
operator|.
name|address
argument_list|,
name|rss
operator|->
name|hash_key_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cmd
operator|.
name|control_buffer
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to set hash function %d. error: %d\n"
argument_list|,
name|rss
operator|->
name|hash_func
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_fill_hash_function
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_admin_hash_functions
name|func
parameter_list|,
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|u16
name|key_len
parameter_list|,
name|u32
name|init_val
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|struct
name|ena_admin_feature_rss_flow_hash_control
modifier|*
name|hash_key
init|=
name|rss
operator|->
name|hash_key
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Make sure size is a mult of DWs */
if|if
condition|(
name|unlikely
argument_list|(
name|key_len
operator|&
literal|0x3
argument_list|)
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|rc
operator|=
name|ena_com_get_feature_ex
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_HASH_FUNCTION
argument_list|,
name|rss
operator|->
name|hash_key_dma_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|func
operator|)
operator|&
name|get_resp
operator|.
name|u
operator|.
name|flow_hash_func
operator|.
name|supported_func
operator|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Flow hash function %d isn't supported\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|ENA_ADMIN_TOEPLITZ
case|:
if|if
condition|(
name|key_len
operator|>
sizeof|sizeof
argument_list|(
name|hash_key
operator|->
name|key
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"key len (%hu) is bigger than the max supported (%zu)\n"
argument_list|,
name|key_len
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_key
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|memcpy
argument_list|(
name|hash_key
operator|->
name|key
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|rss
operator|->
name|hash_init_val
operator|=
name|init_val
expr_stmt|;
name|hash_key
operator|->
name|keys_num
operator|=
name|key_len
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|ENA_ADMIN_CRC32
case|:
name|rss
operator|->
name|hash_init_val
operator|=
name|init_val
expr_stmt|;
break|break;
default|default:
name|ena_trc_err
argument_list|(
literal|"Invalid hash function (%d)\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
name|rc
operator|=
name|ena_com_set_hash_function
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* Restore the old function */
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
name|ena_com_get_hash_function
argument_list|(
name|ena_dev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_hash_function
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_admin_hash_functions
modifier|*
name|func
parameter_list|,
name|u8
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|struct
name|ena_admin_feature_rss_flow_hash_control
modifier|*
name|hash_key
init|=
name|rss
operator|->
name|hash_key
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_com_get_feature_ex
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_HASH_FUNCTION
argument_list|,
name|rss
operator|->
name|hash_key_dma_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
name|rss
operator|->
name|hash_func
operator|=
name|get_resp
operator|.
name|u
operator|.
name|flow_hash_func
operator|.
name|selected_func
expr_stmt|;
if|if
condition|(
name|func
condition|)
operator|*
name|func
operator|=
name|rss
operator|->
name|hash_func
expr_stmt|;
if|if
condition|(
name|key
condition|)
name|memcpy
argument_list|(
name|key
argument_list|,
name|hash_key
operator|->
name|key
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|hash_key
operator|->
name|keys_num
argument_list|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_get_hash_ctrl
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_admin_flow_hash_proto
name|proto
parameter_list|,
name|u16
modifier|*
name|fields
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_com_get_feature_ex
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_HASH_INPUT
argument_list|,
name|rss
operator|->
name|hash_ctrl_dma_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rss
operator|->
name|hash_ctrl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|fields
condition|)
operator|*
name|fields
operator|=
name|rss
operator|->
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|proto
index|]
operator|.
name|fields
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_set_hash_ctrl
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_feature_rss_hash_control
modifier|*
name|hash_ctrl
init|=
name|rss
operator|->
name|hash_ctrl
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_RSS_HASH_INPUT
argument_list|)
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|ENA_ADMIN_RSS_HASH_INPUT
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
name|ENA_ADMIN_AQ_COMMON_DESC_CTRL_DATA_INDIRECT_MASK
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_RSS_HASH_INPUT
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|flow_hash_input
operator|.
name|enabled_input_sort
operator|=
name|ENA_ADMIN_FEATURE_RSS_FLOW_HASH_INPUT_L3_SORT_MASK
operator||
name|ENA_ADMIN_FEATURE_RSS_FLOW_HASH_INPUT_L4_SORT_MASK
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|cmd
operator|.
name|control_buffer
operator|.
name|address
argument_list|,
name|rss
operator|->
name|hash_ctrl_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cmd
operator|.
name|control_buffer
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hash_ctrl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to set hash input. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_set_default_hash_ctrl
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_feature_rss_hash_control
modifier|*
name|hash_ctrl
init|=
name|rss
operator|->
name|hash_ctrl
decl_stmt|;
name|u16
name|available_fields
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
comment|/* Get the supported hash input */
name|rc
operator|=
name|ena_com_get_hash_ctrl
argument_list|(
name|ena_dev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_TCP4
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
operator||
name|ENA_ADMIN_RSS_L4_DP
operator||
name|ENA_ADMIN_RSS_L4_SP
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_UDP4
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
operator||
name|ENA_ADMIN_RSS_L4_DP
operator||
name|ENA_ADMIN_RSS_L4_SP
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_TCP6
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
operator||
name|ENA_ADMIN_RSS_L4_DP
operator||
name|ENA_ADMIN_RSS_L4_SP
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_UDP6
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
operator||
name|ENA_ADMIN_RSS_L4_DP
operator||
name|ENA_ADMIN_RSS_L4_SP
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_IP4
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_IP6
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_IP4_FRAG
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L3_SA
operator||
name|ENA_ADMIN_RSS_L3_DA
expr_stmt|;
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|ENA_ADMIN_RSS_NOT_IP
index|]
operator|.
name|fields
operator|=
name|ENA_ADMIN_RSS_L2_DA
operator||
name|ENA_ADMIN_RSS_L2_SA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENA_ADMIN_RSS_PROTO_NUM
condition|;
name|i
operator|++
control|)
block|{
name|available_fields
operator|=
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|i
index|]
operator|.
name|fields
operator|&
name|hash_ctrl
operator|->
name|supported_fields
index|[
name|i
index|]
operator|.
name|fields
expr_stmt|;
if|if
condition|(
name|available_fields
operator|!=
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|i
index|]
operator|.
name|fields
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"hash control doesn't support all the desire configuration. proto %x supported %x selected %x\n"
argument_list|,
name|i
argument_list|,
name|hash_ctrl
operator|->
name|supported_fields
index|[
name|i
index|]
operator|.
name|fields
argument_list|,
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|i
index|]
operator|.
name|fields
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
block|}
name|rc
operator|=
name|ena_com_set_hash_ctrl
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* In case of failure, restore the old hash ctrl */
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
name|ena_com_get_hash_ctrl
argument_list|(
name|ena_dev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|ena_com_fill_hash_ctrl
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_admin_flow_hash_proto
name|proto
parameter_list|,
name|u16
name|hash_fields
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_feature_rss_hash_control
modifier|*
name|hash_ctrl
init|=
name|rss
operator|->
name|hash_ctrl
decl_stmt|;
name|u16
name|supported_fields
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|proto
operator|>=
name|ENA_ADMIN_RSS_PROTO_NUM
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Invalid proto num (%u)\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_INVAL
return|;
block|}
comment|/* Get the ctrl table */
name|rc
operator|=
name|ena_com_get_hash_ctrl
argument_list|(
name|ena_dev
argument_list|,
name|proto
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
comment|/* Make sure all the fields are supported */
name|supported_fields
operator|=
name|hash_ctrl
operator|->
name|supported_fields
index|[
name|proto
index|]
operator|.
name|fields
expr_stmt|;
if|if
condition|(
operator|(
name|hash_fields
operator|&
name|supported_fields
operator|)
operator|!=
name|hash_fields
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"proto %d doesn't support the required fields %x. supports only: %x\n"
argument_list|,
name|proto
argument_list|,
name|hash_fields
argument_list|,
name|supported_fields
argument_list|)
expr_stmt|;
block|}
name|hash_ctrl
operator|->
name|selected_fields
index|[
name|proto
index|]
operator|.
name|fields
operator|=
name|hash_fields
expr_stmt|;
name|rc
operator|=
name|ena_com_set_hash_ctrl
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
comment|/* In case of failure, restore the old hash ctrl */
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
name|ena_com_get_hash_ctrl
argument_list|(
name|ena_dev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_indirect_table_fill_entry
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|entry_idx
parameter_list|,
name|u16
name|entry_value
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|entry_idx
operator|>=
operator|(
literal|1
operator|<<
name|rss
operator|->
name|tbl_log_size
operator|)
argument_list|)
condition|)
return|return
name|ENA_COM_INVAL
return|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|entry_value
operator|>
name|ENA_TOTAL_NUM_QUEUES
operator|)
argument_list|)
condition|)
return|return
name|ENA_COM_INVAL
return|;
name|rss
operator|->
name|host_rss_ind_tbl
index|[
name|entry_idx
index|]
operator|=
name|entry_value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_indirect_table_set
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
init|=
operator|&
name|ena_dev
operator|->
name|admin_queue
decl_stmt|;
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_RSS_REDIRECTION_TABLE_CONFIG
argument_list|)
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|ENA_ADMIN_RSS_REDIRECTION_TABLE_CONFIG
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_PERMISSION
return|;
block|}
name|ret
operator|=
name|ena_com_ind_tbl_convert_to_device
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to convert host indirection table to device table\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|flags
operator|=
name|ENA_ADMIN_AQ_COMMON_DESC_CTRL_DATA_INDIRECT_MASK
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_RSS_REDIRECTION_TABLE_CONFIG
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|ind_table
operator|.
name|size
operator|=
name|rss
operator|->
name|tbl_log_size
expr_stmt|;
name|cmd
operator|.
name|u
operator|.
name|ind_table
operator|.
name|inline_index
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|cmd
operator|.
name|control_buffer
operator|.
name|address
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cmd
operator|.
name|control_buffer
operator|.
name|length
operator|=
operator|(
literal|1ULL
operator|<<
name|rss
operator|->
name|tbl_log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_rss_ind_table_entry
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to set indirect table. error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ena_com_indirect_table_get
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
modifier|*
name|ind_tbl
parameter_list|)
block|{
name|struct
name|ena_rss
modifier|*
name|rss
init|=
operator|&
name|ena_dev
operator|->
name|rss
decl_stmt|;
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|u32
name|tbl_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|tbl_size
operator|=
operator|(
literal|1ULL
operator|<<
name|rss
operator|->
name|tbl_log_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ena_admin_rss_ind_table_entry
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_com_get_feature_ex
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_RSS_REDIRECTION_TABLE_CONFIG
argument_list|,
name|rss
operator|->
name|rss_ind_tbl_dma_addr
argument_list|,
name|tbl_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
if|if
condition|(
operator|!
name|ind_tbl
condition|)
return|return
literal|0
return|;
name|rc
operator|=
name|ena_com_ind_tbl_convert_from_device
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
return|return
name|rc
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|rss
operator|->
name|tbl_log_size
operator|)
condition|;
name|i
operator|++
control|)
name|ind_tbl
index|[
name|i
index|]
operator|=
name|rss
operator|->
name|host_rss_ind_tbl
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_rss_init
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u16
name|indr_tbl_log_size
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ena_dev
operator|->
name|rss
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|ena_dev
operator|->
name|rss
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ena_com_indirect_table_allocate
argument_list|(
name|ena_dev
argument_list|,
name|indr_tbl_log_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
goto|goto
name|err_indr_tbl
goto|;
name|rc
operator|=
name|ena_com_hash_key_allocate
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
goto|goto
name|err_hash_key
goto|;
name|rc
operator|=
name|ena_com_hash_ctrl_init
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|rc
argument_list|)
condition|)
goto|goto
name|err_hash_ctrl
goto|;
return|return
literal|0
return|;
name|err_hash_ctrl
label|:
name|ena_com_hash_key_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|err_hash_key
label|:
name|ena_com_indirect_table_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|err_indr_tbl
label|:
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ena_com_rss_destroy
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|ena_com_indirect_table_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_hash_key_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|ena_com_hash_ctrl_destroy
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ena_dev
operator|->
name|rss
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|ena_dev
operator|->
name|rss
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_allocate_host_info
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_host_attribute
modifier|*
name|host_attr
init|=
operator|&
name|ena_dev
operator|->
name|host_attr
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|SZ_4K
argument_list|,
name|host_attr
operator|->
name|host_info
argument_list|,
name|host_attr
operator|->
name|host_info_dma_addr
argument_list|,
name|host_attr
operator|->
name|host_info_dma_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|host_attr
operator|->
name|host_info
argument_list|)
condition|)
return|return
name|ENA_COM_NO_MEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_allocate_debug_area
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
name|debug_area_size
parameter_list|)
block|{
name|struct
name|ena_host_attribute
modifier|*
name|host_attr
init|=
operator|&
name|ena_dev
operator|->
name|host_attr
decl_stmt|;
name|ENA_MEM_ALLOC_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|debug_area_size
argument_list|,
name|host_attr
operator|->
name|debug_area_virt_addr
argument_list|,
name|host_attr
operator|->
name|debug_area_dma_addr
argument_list|,
name|host_attr
operator|->
name|debug_area_dma_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|host_attr
operator|->
name|debug_area_virt_addr
argument_list|)
condition|)
block|{
name|host_attr
operator|->
name|debug_area_size
operator|=
literal|0
expr_stmt|;
return|return
name|ENA_COM_NO_MEM
return|;
block|}
name|host_attr
operator|->
name|debug_area_size
operator|=
name|debug_area_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_delete_host_info
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_host_attribute
modifier|*
name|host_attr
init|=
operator|&
name|ena_dev
operator|->
name|host_attr
decl_stmt|;
if|if
condition|(
name|host_attr
operator|->
name|host_info
condition|)
block|{
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|SZ_4K
argument_list|,
name|host_attr
operator|->
name|host_info
argument_list|,
name|host_attr
operator|->
name|host_info_dma_addr
argument_list|,
name|host_attr
operator|->
name|host_info_dma_handle
argument_list|)
expr_stmt|;
name|host_attr
operator|->
name|host_info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ena_com_delete_debug_area
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_host_attribute
modifier|*
name|host_attr
init|=
operator|&
name|ena_dev
operator|->
name|host_attr
decl_stmt|;
if|if
condition|(
name|host_attr
operator|->
name|debug_area_virt_addr
condition|)
block|{
name|ENA_MEM_FREE_COHERENT
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|host_attr
operator|->
name|debug_area_size
argument_list|,
name|host_attr
operator|->
name|debug_area_virt_addr
argument_list|,
name|host_attr
operator|->
name|debug_area_dma_addr
argument_list|,
name|host_attr
operator|->
name|debug_area_dma_handle
argument_list|)
expr_stmt|;
name|host_attr
operator|->
name|debug_area_virt_addr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ena_com_set_host_attributes
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_host_attribute
modifier|*
name|host_attr
init|=
operator|&
name|ena_dev
operator|->
name|host_attr
decl_stmt|;
name|struct
name|ena_com_admin_queue
modifier|*
name|admin_queue
decl_stmt|;
name|struct
name|ena_admin_set_feat_cmd
name|cmd
decl_stmt|;
name|struct
name|ena_admin_set_feat_resp
name|resp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Host attribute config is called before ena_com_get_dev_attr_feat 	 * so ena_com can't check if the feature is supported. 	 */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|admin_queue
operator|=
operator|&
name|ena_dev
operator|->
name|admin_queue
expr_stmt|;
name|cmd
operator|.
name|aq_common_descriptor
operator|.
name|opcode
operator|=
name|ENA_ADMIN_SET_FEATURE
expr_stmt|;
name|cmd
operator|.
name|feat_common
operator|.
name|feature_id
operator|=
name|ENA_ADMIN_HOST_ATTR_CONFIG
expr_stmt|;
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|cmd
operator|.
name|u
operator|.
name|host_attr
operator|.
name|debug_ba
argument_list|,
name|host_attr
operator|->
name|debug_area_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|ena_com_mem_addr_set
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|cmd
operator|.
name|u
operator|.
name|host_attr
operator|.
name|os_info_ba
argument_list|,
name|host_attr
operator|->
name|host_info_dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"memory address set failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cmd
operator|.
name|u
operator|.
name|host_attr
operator|.
name|debug_area_size
operator|=
name|host_attr
operator|->
name|debug_area_size
expr_stmt|;
name|ret
operator|=
name|ena_com_execute_admin_command
argument_list|(
name|admin_queue
argument_list|,
operator|(
expr|struct
name|ena_admin_aq_entry
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
expr|struct
name|ena_admin_acq_entry
operator|*
operator|)
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
argument_list|)
condition|)
name|ena_trc_err
argument_list|(
literal|"Failed to set host attributes: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Interrupt moderation */
end_comment

begin_function
name|bool
name|ena_com_interrupt_moderation_supported
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
return|return
name|ena_com_check_supported_feature_id
argument_list|(
name|ena_dev
argument_list|,
name|ENA_ADMIN_INTERRUPT_MODERATION
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ena_com_update_nonadaptive_moderation_interval_tx
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
name|tx_coalesce_usecs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ena_dev
operator|->
name|intr_delay_resolution
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Illegal interrupt delay granularity value\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_FAULT
return|;
block|}
name|ena_dev
operator|->
name|intr_moder_tx_interval
operator|=
name|tx_coalesce_usecs
operator|/
name|ena_dev
operator|->
name|intr_delay_resolution
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ena_com_update_nonadaptive_moderation_interval_rx
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|u32
name|rx_coalesce_usecs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ena_dev
operator|->
name|intr_delay_resolution
condition|)
block|{
name|ena_trc_err
argument_list|(
literal|"Illegal interrupt delay granularity value\n"
argument_list|)
expr_stmt|;
return|return
name|ENA_COM_FAULT
return|;
block|}
comment|/* We use LOWEST entry of moderation table for storing 	 * nonadaptive interrupt coalescing values 	 */
name|ena_dev
operator|->
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOWEST
index|]
operator|.
name|intr_moder_interval
operator|=
name|rx_coalesce_usecs
operator|/
name|ena_dev
operator|->
name|intr_delay_resolution
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_destroy_interrupt_moderation
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
if|if
condition|(
name|ena_dev
operator|->
name|intr_moder_tbl
condition|)
name|ENA_MEM_FREE
argument_list|(
name|ena_dev
operator|->
name|dmadev
argument_list|,
name|ena_dev
operator|->
name|intr_moder_tbl
argument_list|)
expr_stmt|;
name|ena_dev
operator|->
name|intr_moder_tbl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ena_com_init_interrupt_moderation
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_admin_get_feat_resp
name|get_resp
decl_stmt|;
name|u16
name|delay_resolution
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ena_com_get_feature
argument_list|(
name|ena_dev
argument_list|,
operator|&
name|get_resp
argument_list|,
name|ENA_ADMIN_INTERRUPT_MODERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|ENA_COM_PERMISSION
condition|)
block|{
name|ena_trc_dbg
argument_list|(
literal|"Feature %d isn't supported\n"
argument_list|,
name|ENA_ADMIN_INTERRUPT_MODERATION
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ena_trc_err
argument_list|(
literal|"Failed to get interrupt moderation admin cmd. rc: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* no moderation supported, disable adaptive support */
name|ena_com_disable_adaptive_moderation
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|rc
operator|=
name|ena_com_init_interrupt_moderation_table
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|err
goto|;
comment|/* if moderation is supported by device we set adaptive moderation */
name|delay_resolution
operator|=
name|get_resp
operator|.
name|u
operator|.
name|intr_moderation
operator|.
name|intr_delay_resolution
expr_stmt|;
name|ena_com_update_intr_delay_resolution
argument_list|(
name|ena_dev
argument_list|,
name|delay_resolution
argument_list|)
expr_stmt|;
name|ena_com_enable_adaptive_moderation
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|ena_com_destroy_interrupt_moderation
argument_list|(
name|ena_dev
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ena_com_config_default_interrupt_moderation_table
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_intr_moder_entry
modifier|*
name|intr_moder_tbl
init|=
name|ena_dev
operator|->
name|intr_moder_tbl
decl_stmt|;
if|if
condition|(
operator|!
name|intr_moder_tbl
condition|)
return|return;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOWEST
index|]
operator|.
name|intr_moder_interval
operator|=
name|ENA_INTR_LOWEST_USECS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOWEST
index|]
operator|.
name|pkts_per_interval
operator|=
name|ENA_INTR_LOWEST_PKTS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOWEST
index|]
operator|.
name|bytes_per_interval
operator|=
name|ENA_INTR_LOWEST_BYTES
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOW
index|]
operator|.
name|intr_moder_interval
operator|=
name|ENA_INTR_LOW_USECS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOW
index|]
operator|.
name|pkts_per_interval
operator|=
name|ENA_INTR_LOW_PKTS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOW
index|]
operator|.
name|bytes_per_interval
operator|=
name|ENA_INTR_LOW_BYTES
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_MID
index|]
operator|.
name|intr_moder_interval
operator|=
name|ENA_INTR_MID_USECS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_MID
index|]
operator|.
name|pkts_per_interval
operator|=
name|ENA_INTR_MID_PKTS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_MID
index|]
operator|.
name|bytes_per_interval
operator|=
name|ENA_INTR_MID_BYTES
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGH
index|]
operator|.
name|intr_moder_interval
operator|=
name|ENA_INTR_HIGH_USECS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGH
index|]
operator|.
name|pkts_per_interval
operator|=
name|ENA_INTR_HIGH_PKTS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGH
index|]
operator|.
name|bytes_per_interval
operator|=
name|ENA_INTR_HIGH_BYTES
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGHEST
index|]
operator|.
name|intr_moder_interval
operator|=
name|ENA_INTR_HIGHEST_USECS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGHEST
index|]
operator|.
name|pkts_per_interval
operator|=
name|ENA_INTR_HIGHEST_PKTS
expr_stmt|;
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_HIGHEST
index|]
operator|.
name|bytes_per_interval
operator|=
name|ENA_INTR_HIGHEST_BYTES
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|ena_com_get_nonadaptive_moderation_interval_tx
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
return|return
name|ena_dev
operator|->
name|intr_moder_tx_interval
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|ena_com_get_nonadaptive_moderation_interval_rx
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|)
block|{
name|struct
name|ena_intr_moder_entry
modifier|*
name|intr_moder_tbl
init|=
name|ena_dev
operator|->
name|intr_moder_tbl
decl_stmt|;
if|if
condition|(
name|intr_moder_tbl
condition|)
return|return
name|intr_moder_tbl
index|[
name|ENA_INTR_MODER_LOWEST
index|]
operator|.
name|intr_moder_interval
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ena_com_init_intr_moderation_entry
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_intr_moder_level
name|level
parameter_list|,
name|struct
name|ena_intr_moder_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ena_intr_moder_entry
modifier|*
name|intr_moder_tbl
init|=
name|ena_dev
operator|->
name|intr_moder_tbl
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|ENA_INTR_MAX_NUM_OF_LEVELS
condition|)
return|return;
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|intr_moder_interval
operator|=
name|entry
operator|->
name|intr_moder_interval
expr_stmt|;
if|if
condition|(
name|ena_dev
operator|->
name|intr_delay_resolution
condition|)
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|intr_moder_interval
operator|/=
name|ena_dev
operator|->
name|intr_delay_resolution
expr_stmt|;
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|pkts_per_interval
operator|=
name|entry
operator|->
name|pkts_per_interval
expr_stmt|;
comment|/* use hardcoded value until ethtool supports bytecount parameter */
if|if
condition|(
name|entry
operator|->
name|bytes_per_interval
operator|!=
name|ENA_INTR_BYTE_COUNT_NOT_SUPPORTED
condition|)
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|bytes_per_interval
operator|=
name|entry
operator|->
name|bytes_per_interval
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ena_com_get_intr_moderation_entry
parameter_list|(
name|struct
name|ena_com_dev
modifier|*
name|ena_dev
parameter_list|,
name|enum
name|ena_intr_moder_level
name|level
parameter_list|,
name|struct
name|ena_intr_moder_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ena_intr_moder_entry
modifier|*
name|intr_moder_tbl
init|=
name|ena_dev
operator|->
name|intr_moder_tbl
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|ENA_INTR_MAX_NUM_OF_LEVELS
condition|)
return|return;
name|entry
operator|->
name|intr_moder_interval
operator|=
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|intr_moder_interval
expr_stmt|;
if|if
condition|(
name|ena_dev
operator|->
name|intr_delay_resolution
condition|)
name|entry
operator|->
name|intr_moder_interval
operator|*=
name|ena_dev
operator|->
name|intr_delay_resolution
expr_stmt|;
name|entry
operator|->
name|pkts_per_interval
operator|=
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|pkts_per_interval
expr_stmt|;
name|entry
operator|->
name|bytes_per_interval
operator|=
name|intr_moder_tbl
index|[
name|level
index|]
operator|.
name|bytes_per_interval
expr_stmt|;
block|}
end_function

end_unit

