begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_if
if|#
directive|if
name|ATH_WOW_OFFLOAD
end_if

begin_function
name|void
name|ar9300_wowoffload_prep
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|ah_mcast_filter_l32_set
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_mcast_filter_u32_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_wowoffload_post
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_mcast_filter_l32_set
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL0
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|ahp
operator|->
name|ah_mcast_filter_l32_set
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_mcast_filter_u32_set
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|ahp
operator|->
name|ah_mcast_filter_u32_set
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCAST_FIL1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_mcast_filter_l32_set
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_mcast_filter_u32_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_wowoffload_add_mcast_filter
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
modifier|*
name|mc_addr
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|u_int8_t
name|pos
decl_stmt|,
name|high32
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|val
argument_list|,
operator|&
name|mc_addr
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|val
argument_list|,
operator|&
name|mc_addr
index|[
literal|3
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|high32
operator|=
name|pos
operator|&
literal|0x20
expr_stmt|;
name|reg
operator|=
name|high32
condition|?
name|AR_MCAST_FIL1
else|:
name|AR_MCAST_FIL0
expr_stmt|;
name|pos
operator|&=
literal|0x1F
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|pos
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|val
operator||=
operator|(
literal|1
operator|<<
name|pos
operator|)
expr_stmt|;
if|if
condition|(
name|high32
condition|)
block|{
name|ahp
operator|->
name|ah_mcast_filter_u32_set
operator||=
operator|(
literal|1
operator|<<
name|pos
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_mcast_filter_l32_set
operator||=
operator|(
literal|1
operator|<<
name|pos
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * DeviceID SWAR - EV91928  *  * During SW WOW, 0x4004[13] is set to allow BT eCPU to access WLAN MAC  * registers. Setting 00x4004[13] will prevent eeprom state machine to  * load customizable PCIE configuration registers, which lead to the PCIE  * device id stay as default 0xABCD. The SWAR to have BT eCPU to write  * to PCIE registers as soon as it detects PCIE reset is deasserted.  */
end_comment

begin_function
name|void
name|ar9300_wowoffload_download_devid_swar
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|addr
init|=
name|AR_WOW_OFFLOAD_WLAN_REGSET_NUM
decl_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x5000
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) pcie_000 = %08x\n"
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_000
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_000
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x5008
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) pcie_008 = %08x\n"
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_008
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_008
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x502c
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) pcie_02c = %08x\n"
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_02c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_02c
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x18c00
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x18212ede
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x18c04
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x008001d8
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x18c08
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x0003580c
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x570c
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) pcie_70c = %08x\n"
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_70c
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_70c
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x5040
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) pcie_040 = %08x\n"
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_040
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_pcie_040
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
comment|/*     A_SOC_REG_WRITE(0x45000, 0x0034168c);     A_SOC_REG_WRITE(0x45008, 0x02800001);     A_SOC_REG_WRITE(0x4502c, 0x3117168c);     A_SOC_REG_WRITE(0x58c00, 0x18212ede);     A_SOC_REG_WRITE(0x58c04, 0x000801d8);     A_SOC_REG_WRITE(0x58c08, 0x0003580c);     A_SOC_REG_WRITE(0x4570c, 0x275f3f01);     A_SOC_REG_WRITE(0x45040, 0xffc25001); */
block|}
end_function

begin_comment
comment|/* Retrieve updated information from MAC PCU buffer.  * Embedded CPU would have written the value before exiting WoW  * */
end_comment

begin_function
name|void
name|ar9300_wowoffload_retrieve_data
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int32_t
name|param
parameter_list|)
block|{
name|u_int32_t
name|rc_lower
decl_stmt|,
name|rc_upper
decl_stmt|;
if|if
condition|(
name|param
operator|==
name|WOW_PARAM_REPLAY_CNTR
condition|)
block|{
name|rc_lower
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_TXBUF
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rc_upper
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_TXBUF
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
name|buf
operator|=
name|rc_lower
operator|+
operator|(
name|rc_upper
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param
operator|==
name|WOW_PARAM_KEY_TSC
condition|)
block|{
name|rc_lower
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_TXBUF
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|rc_upper
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_TXBUF
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
name|buf
operator|=
name|rc_lower
operator|+
operator|(
name|rc_upper
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|param
operator|==
name|WOW_PARAM_TX_SEQNUM
condition|)
block|{
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|buf
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_TXBUF
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Download GTK rekey related information to the embedded CPU */
end_comment

begin_function
name|u_int32_t
name|ar9300_wowoffload_download_rekey_data
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
modifier|*
name|data
parameter_list|,
name|u_int32_t
name|bytes
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mbox_status
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|)
decl_stmt|;
name|u_int32_t
name|gtk_data_start
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) %s, bytes=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|bytes
operator|>
operator|(
name|AR_WOW_OFFLOAD_GTK_DATA_WORDS_JUPITER
operator|*
literal|4
operator|)
operator|)
condition|)
block|{
name|bytes
operator|=
name|AR_WOW_OFFLOAD_GTK_DATA_WORDS_JUPITER
operator|*
literal|4
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) bytes truncated to %d\n"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/* Check if mailbox is busy */
if|if
condition|(
name|mbox_status
operator|!=
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: Mailbox register busy! Reg = 0x%x"
argument_list|,
name|__func__
argument_list|,
name|mbox_status
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Clear status */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WLAN_WOW_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WLAN_WOW_STATUS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|gtk_data_start
operator|=
name|AR_WOW_OFFLOAD_GTK_DATA_START_JUPITER
expr_stmt|;
block|}
else|else
block|{
name|gtk_data_start
operator|=
name|AR_WOW_OFFLOAD_GTK_DATA_START
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|gtk_data_start
operator|+
name|i
operator|*
literal|4
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ar9300_wowoffload_download_acer_magic
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|valid
parameter_list|,
name|u_int8_t
modifier|*
name|datap
parameter_list|,
name|u_int32_t
name|bytes
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|p32
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|datap
decl_stmt|;
name|u_int32_t
name|l
init|=
literal|0
decl_stmt|,
name|u
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
name|l
operator|=
operator|*
name|p32
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|u
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|p32
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_ACER_MAGIC_START
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_ACER_MAGIC_START
operator|+
literal|4
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: Aer Magic: %02x-%02x-%02x-%02x-%02x-%02x\n"
argument_list|,
name|__func__
argument_list|,
name|datap
index|[
literal|0
index|]
argument_list|,
name|datap
index|[
literal|1
index|]
argument_list|,
name|datap
index|[
literal|2
index|]
argument_list|,
name|datap
index|[
literal|3
index|]
argument_list|,
name|datap
index|[
literal|4
index|]
argument_list|,
name|datap
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_wowoffload_download_acer_swka
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|id
parameter_list|,
name|HAL_BOOL
name|valid
parameter_list|,
name|u_int32_t
name|period
parameter_list|,
name|u_int32_t
name|size
parameter_list|,
name|u_int32_t
modifier|*
name|datap
parameter_list|)
block|{
name|u_int32_t
name|ka_period
index|[
literal|2
index|]
init|=
block|{
name|AR_WOW_OFFLOAD_ACER_KA0_PERIOD_MS
block|,
name|AR_WOW_OFFLOAD_ACER_KA1_PERIOD_MS
block|}
decl_stmt|;
name|u_int32_t
name|ka_size
index|[
literal|2
index|]
init|=
block|{
name|AR_WOW_OFFLOAD_ACER_KA0_SIZE
block|,
name|AR_WOW_OFFLOAD_ACER_KA1_SIZE
block|}
decl_stmt|;
name|u_int32_t
name|ka_data
index|[
literal|2
index|]
init|=
block|{
name|AR_WOW_OFFLOAD_ACER_KA0_DATA
block|,
name|AR_WOW_OFFLOAD_ACER_KA1_DATA
block|}
decl_stmt|;
name|u_int32_t
name|n_data
init|=
name|AR_WOW_OFFLOAD_ACER_KA0_DATA_WORDS
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|id
operator|>=
literal|2
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|valid
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ka_period
index|[
name|id
index|]
argument_list|,
name|period
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ka_size
index|[
name|id
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ka_period
index|[
name|id
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ka_size
index|[
name|id
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: id=%d, period=%d ms, size=%d bytes\n"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|,
name|period
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
operator|(
name|n_data
operator|*
literal|4
operator|)
condition|)
block|{
name|n_data
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_data
operator|*
literal|4
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ka_data
index|[
name|id
index|]
operator|+
name|i
argument_list|,
operator|*
name|datap
argument_list|)
expr_stmt|;
comment|/*HALDEBUG(ah, HAL_DEBUG_UNMASKABLE, "(WOW) %08x\n", *datap);*/
name|datap
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar9300_wowoffload_download_arp_info
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|id
parameter_list|,
name|u_int32_t
modifier|*
name|data
parameter_list|)
block|{
name|u_int32_t
name|addr
decl_stmt|;
name|struct
name|hal_wow_offload_arp_info
modifier|*
name|p_info
init|=
operator|(
expr|struct
name|hal_wow_offload_arp_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|AR_WOW_OFFLOAD_ARP0_VALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
literal|1
condition|)
block|{
name|addr
operator|=
name|AR_WOW_OFFLOAD_ARP1_VALID
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|p_info
operator|->
name|valid
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|RemoteIPv4Address
operator|.
name|u32
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|HostIPv4Address
operator|.
name|u32
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|MacAddress
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|MacAddress
operator|.
name|u32
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|WOW_WRITE_NS_IPV6_ADDRESS
parameter_list|(
name|_ah
parameter_list|,
name|_buf_addr
parameter_list|,
name|_p_ipv6_addr
parameter_list|)
define|\
value|{                                                           \         u_int32_t   offset = (_buf_addr);                       \         u_int32_t  *p_ipv6_addr = (u_int32_t *) (_p_ipv6_addr); \         int i;                                                  \         for (i = 0; i< 4; i++) {                               \             OS_REG_WRITE((_ah), offset, *p_ipv6_addr);          \             offset += 4;                                        \             p_ipv6_addr ++;                                     \         }                                                       \     }
end_define

begin_function
name|void
name|ar9300_wowoffload_download_ns_info
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|id
parameter_list|,
name|u_int32_t
modifier|*
name|data
parameter_list|)
block|{
name|u_int32_t
name|addr
decl_stmt|;
name|struct
name|hal_wow_offload_ns_info
modifier|*
name|p_info
init|=
operator|(
expr|struct
name|hal_wow_offload_ns_info
operator|*
operator|)
name|data
decl_stmt|;
name|u_int8_t
name|mc_addr
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|AR_WOW_OFFLOAD_NS0_VALID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
literal|1
condition|)
block|{
name|addr
operator|=
name|AR_WOW_OFFLOAD_NS1_VALID
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|p_info
operator|->
name|valid
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|WOW_WRITE_NS_IPV6_ADDRESS
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
operator|&
name|p_info
operator|->
name|RemoteIPv6Address
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
operator|*
literal|4
expr_stmt|;
name|WOW_WRITE_NS_IPV6_ADDRESS
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
operator|&
name|p_info
operator|->
name|SolicitedNodeIPv6Address
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
operator|*
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|MacAddress
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
name|p_info
operator|->
name|MacAddress
operator|.
name|u32
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|WOW_WRITE_NS_IPV6_ADDRESS
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
operator|&
name|p_info
operator|->
name|TargetIPv6Addresses
index|[
literal|0
index|]
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4
operator|*
literal|4
expr_stmt|;
name|WOW_WRITE_NS_IPV6_ADDRESS
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
operator|&
name|p_info
operator|->
name|TargetIPv6Addresses
index|[
literal|1
index|]
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mc_addr
index|[
literal|0
index|]
operator|=
literal|0x33
expr_stmt|;
name|mc_addr
index|[
literal|1
index|]
operator|=
literal|0x33
expr_stmt|;
name|mc_addr
index|[
literal|2
index|]
operator|=
literal|0xFF
expr_stmt|;
name|mc_addr
index|[
literal|3
index|]
operator|=
name|p_info
operator|->
name|SolicitedNodeIPv6Address
operator|.
name|u8
index|[
literal|13
index|]
expr_stmt|;
name|mc_addr
index|[
literal|4
index|]
operator|=
name|p_info
operator|->
name|SolicitedNodeIPv6Address
operator|.
name|u8
index|[
literal|14
index|]
expr_stmt|;
name|mc_addr
index|[
literal|5
index|]
operator|=
name|p_info
operator|->
name|SolicitedNodeIPv6Address
operator|.
name|u8
index|[
literal|15
index|]
expr_stmt|;
name|ar9300_wowoffload_add_mcast_filter
argument_list|(
name|ah
argument_list|,
name|mc_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|addr
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Download transmit parameters for GTK response frame during WoW  * offload */
end_comment

begin_function
name|u_int32_t
name|ar9300_wow_offload_download_hal_params
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|tpc
init|=
literal|0x3f
decl_stmt|;
comment|/* Transmit Power Control */
name|u_int32_t
name|tx_tries_series
init|=
literal|7
decl_stmt|;
name|u_int32_t
name|tx_rate_series
decl_stmt|,
name|transmit_rate
decl_stmt|;
name|u_int32_t
name|gtk_txdesc_param_start
decl_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel_flags
operator|&
name|CHANNEL_CCK
condition|)
block|{
name|transmit_rate
operator|=
literal|0x1B
expr_stmt|;
comment|/* CCK_1M */
block|}
else|else
block|{
name|transmit_rate
operator|=
literal|0xB
expr_stmt|;
comment|/* OFDM_6M */
block|}
comment|/* Use single rate for now. Change later as need be */
name|tx_rate_series
operator|=
name|transmit_rate
expr_stmt|;
name|tx_tries_series
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|gtk_txdesc_param_start
operator|=
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM_START_JUPITER
expr_stmt|;
block|}
else|else
block|{
name|gtk_txdesc_param_start
operator|=
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM_START
expr_stmt|;
block|}
define|#
directive|define
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM
parameter_list|(
name|x
parameter_list|)
value|(gtk_txdesc_param_start + ((x) * 4))
comment|/* Do not change the data order unless firmware code on embedded      * CPU is changed correspondingly */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|tx_rate_series
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|tx_tries_series
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM
argument_list|(
literal|2
argument_list|)
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_chainmask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_GTK_TXDESC_PARAM
argument_list|(
literal|3
argument_list|)
argument_list|,
name|tpc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate to the embedded CPU that host is ready to enter WoW mode.  * Embedded CPU will copy relevant information from the MAC PCU buffer  */
end_comment

begin_function
name|u_int32_t
name|ar9300_wow_offload_handshake
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|pattern_enable
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|mbox_status
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|)
decl_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
name|u_int32_t
name|bt_handshake_timeout_us
init|=
name|HAL_WOW_CTRL_WAIT_BT_TO
argument_list|(
name|ah
argument_list|)
operator|*
literal|100000
decl_stmt|;
define|#
directive|define
name|AH_DEFAULT_BT_WAIT_TIMEOUT
value|3000000;
comment|/* 3 sec */
if|if
condition|(
name|bt_handshake_timeout_us
operator|==
literal|0
condition|)
block|{
name|bt_handshake_timeout_us
operator|=
name|AH_DEFAULT_BT_WAIT_TIMEOUT
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) TIMEOUT: %d us\n"
argument_list|,
name|bt_handshake_timeout_us
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
if|if
condition|(
name|mbox_status
operator|&
name|AR_MBOX_WOW_REQ
condition|)
block|{
comment|/* WOW mode request handshake is already in progress.           * Do nothing */
return|return
literal|0
return|;
block|}
comment|/* Clear status */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WLAN_WOW_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WLAN_WOW_STATUS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_USER_PATTERN_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - User pattern\n"
argument_list|)
expr_stmt|;
name|val
operator||=
name|AR_EMB_CPU_WOW_ENABLE_PATTERN_MATCH
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - User pattern\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_MAGIC_PATTERN_EN
operator|)
if|#
directive|if
name|ATH_WOW_OFFLOAD
operator|||
operator|(
name|pattern_enable
operator|&
name|AH_WOW_ACER_MAGIC_EN
operator|)
endif|#
directive|endif
condition|)
block|{
name|val
operator||=
name|AR_EMB_CPU_WOW_ENABLE_MAGIC_PATTERN
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Magic pattern\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Magic pattern\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_LINK_CHANGE
operator|)
if|#
directive|if
name|ATH_WOW_OFFLOAD
operator|||
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_KAFAIL_ENABLE
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|val
operator||=
name|AR_EMB_CPU_WOW_ENABLE_KEEP_ALIVE_FAIL
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Kepp alive fail\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Kepp alive fail\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_BEACON_MISS
condition|)
block|{
name|val
operator||=
name|AR_EMB_CPU_WOW_ENABLE_BEACON_MISS
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Becon Miss\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Becon Miss\n"
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_ENABLE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
name|AR_MBOX_WOW_CONF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
name|AR_MBOX_WOW_REQ
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
name|AR_MBOX_INT_EMB_CPU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
name|AR_MBOX_WOW_CONF
argument_list|,
name|AR_MBOX_WOW_CONF
argument_list|,
name|bt_handshake_timeout_us
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: WoW offload handshake failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
name|AR_MBOX_WOW_CONF
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: WoW offload handshake successful"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_WOW_OFFLOAD */
end_comment

begin_comment
comment|/*  * Notify Power Mgt is enabled in self-generated frames.  * If requested, force chip awake.  *  * Returns A_OK if chip is awake or successfully forced awake.  *  * WARNING WARNING WARNING  * There is a problem with the chip where sometimes it will not wake up.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_power_mode_awake
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|set_chip
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
define|#
directive|define
name|POWER_UP_TIME
value|10000
name|u_int32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set Bits 14 and 17 of AR_WA before powering on the chip. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_wa_reg_val
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* delay to allow the write to take effect. */
if|if
condition|(
name|set_chip
condition|)
block|{
comment|/* Do a Power-On-Reset if MAC is shutdown */
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|)
operator|&
name|AR_RTC_STATUS_SHUTDOWN
operator|)
condition|)
block|{
if|if
condition|(
name|ar9300_set_reset_reg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_POWER_ON
argument_list|)
operator|!=
name|AH_TRUE
condition|)
block|{
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|POWER_UP_TIME
operator|/
literal|50
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|)
operator|&
name|AR_RTC_STATUS_M
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|AR_RTC_STATUS_ON
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: Failed to wakeup in %uus\n"
argument_list|,
name|__func__
argument_list|,
name|POWER_UP_TIME
operator|/
literal|20
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_PWR_SAV
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
undef|#
directive|undef
name|POWER_UP_TIME
block|}
end_function

begin_comment
comment|/*  * Notify Power Mgt is disabled in self-generated frames.  * If requested, force chip to sleep.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_set_power_mode_sleep
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|set_chip
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_PWR_SAV
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_chip
condition|)
block|{
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|)
operator|&
literal|0xFFFFFF00
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GEN_TIMERS2_MODE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_GEN_TIMERS2_MODE
argument_list|)
operator|&
literal|0xFFFFFF00
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_INC
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_INC
argument_list|)
operator|&
literal|0xFFF00000
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the RTC force wake bit to allow the mac to go to sleep */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*              * In Jupiter, after enter sleep mode, hardware will send              * a SYS_SLEEPING message through MCI interface. Add a              * few us delay to make sure the message can reach BT side.              */
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AR_SREV_JUPITER_10
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Shutdown chip. Active low */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
name|AR_RTC_RESET_EN
argument_list|)
expr_stmt|;
comment|/* Settle time */
name|OS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_SET_4004_BIT14
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
block|{
comment|/* Clear Bit 14 of AR_WA after putting chip into Full Sleep mode. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_wa_reg_val
operator|&
operator|~
name|AR_WA_D3_TO_L1_DISABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notify Power Management is enabled in self-generating  * frames. If request, set power mode of chip to  * auto/normal.  Duration in units of 128us (1/8 TU).  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_set_power_mode_network_sleep
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|set_chip
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_PWR_SAV
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_chip
condition|)
block|{
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halAutoSleepSupport
condition|)
block|{
comment|/* Set wake_on_interrupt bit; clear force_wake bit */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * When chip goes into network sleep, it could be waken up by              * MCI_INT interrupt caused by BT's HW messages (LNA_xxx, CONT_xxx)              * which chould be in a very fast rate (~100us). This will cause              * chip to leave and re-enter network sleep mode frequently, which              * in consequence will have WLAN MCI HW to generate lots of              * SYS_WAKING and SYS_SLEEPING messages which will make BT CPU              * to busy to process.              */
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_EN
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_EN
argument_list|)
operator|&
operator|~
name|AR_MCI_INTERRUPT_RX_HW_MSG_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the RTC force wake bit to allow the mac to go to sleep */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*                  * In Jupiter, after enter sleep mode, hardware will send                  * a SYS_SLEEPING message through MCI interface. Add a                  * few us delay to make sure the message can reach BT side.                  */
name|OS_DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_SET_4004_BIT14
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
block|{
comment|/* Clear Bit 14 of AR_WA after putting chip into Sleep mode. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_wa_reg_val
operator|&
operator|~
name|AR_WA_D3_TO_L1_DISABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set power mgt to the requested mode, and conditionally set  * the chip as well  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_power_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_POWER_MODE
name|mode
parameter_list|,
name|int
name|set_chip
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AH_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|AH_PRINT_FILTER
argument_list|)
specifier|static
specifier|const
name|char
modifier|*
name|modes
index|[]
init|=
block|{
literal|"AWAKE"
block|,
literal|"FULL-SLEEP"
block|,
literal|"NETWORK SLEEP"
block|,
literal|"UNDEFINED"
block|}
decl_stmt|;
endif|#
directive|endif
name|int
name|status
init|=
name|AH_TRUE
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: %s -> %s (%s)\n"
argument_list|,
name|__func__
argument_list|,
name|modes
index|[
name|ar9300_get_power_mode
argument_list|(
name|ah
argument_list|)
index|]
argument_list|,
name|modes
index|[
name|mode
index|]
argument_list|,
name|set_chip
condition|?
literal|"set chip "
else|:
literal|""
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIP_POWER
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HAL_PM_AWAKE
case|:
if|if
condition|(
name|set_chip
condition|)
name|ah
operator|->
name|ah_powerMode
operator|=
name|mode
expr_stmt|;
name|status
operator|=
name|ar9300_set_power_mode_awake
argument_list|(
name|ah
argument_list|,
name|set_chip
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|HAL_PM_FULL_SLEEP
case|:
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
if|if
condition|(
name|ar9300_get_power_mode
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_PM_AWAKE
condition|)
block|{
if|if
condition|(
operator|(
name|ar9300_mci_state
argument_list|(
name|ah
argument_list|,
name|HAL_MCI_STATE_ENABLE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|!=
name|MCI_BT_SLEEP
operator|)
operator|&&
operator|!
name|ahp
operator|->
name|ah_mci_halted_bt_gpm
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: HALT BT GPM (full_sleep)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ar9300_mci_send_coex_halt_bt_gpm
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|ahp
operator|->
name|ah_mci_ready
operator|=
name|AH_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ar9300_set_power_mode_sleep
argument_list|(
name|ah
argument_list|,
name|set_chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_chip
condition|)
block|{
name|ahp
operator|->
name|ah_chip_full_sleep
operator|=
name|AH_TRUE
expr_stmt|;
name|ah
operator|->
name|ah_powerMode
operator|=
name|mode
expr_stmt|;
block|}
break|break;
case|case
name|HAL_PM_NETWORK_SLEEP
case|:
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ar9300_set_power_mode_network_sleep
argument_list|(
name|ah
argument_list|,
name|set_chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_chip
condition|)
block|{
name|ah
operator|->
name|ah_powerMode
operator|=
name|mode
expr_stmt|;
block|}
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: unknown power mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIP_POWER_DONE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIP_POWER_DONE
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current sleep mode of the chip  */
end_comment

begin_function
name|HAL_POWER_MODE
name|ar9300_get_power_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|mode
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|)
operator|&
name|AR_RTC_STATUS_M
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|AR_RTC_STATUS_ON
case|:
case|case
name|AR_RTC_STATUS_WAKEUP
case|:
return|return
name|HAL_PM_AWAKE
return|;
break|break;
case|case
name|AR_RTC_STATUS_SLEEP
case|:
return|return
name|HAL_PM_NETWORK_SLEEP
return|;
break|break;
case|case
name|AR_RTC_STATUS_SHUTDOWN
case|:
return|return
name|HAL_PM_FULL_SLEEP
return|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: unknown power mode 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|HAL_PM_UNDEFINED
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set SM power save mode  */
end_comment

begin_function
name|void
name|ar9300_set_sm_power_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_SMPS_MODE
name|mode
parameter_list|)
block|{
name|int
name|regval
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_DYNAMIC_SMPS
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|!=
name|HAL_OK
condition|)
block|{
return|return;
block|}
comment|/* Program low& high power chainmask settings and enable MAC control */
name|regval
operator|=
name|SM
argument_list|(
name|AR_PCU_SMPS_LPWR_CHNMSK_VAL
argument_list|,
name|AR_PCU_SMPS_LPWR_CHNMSK
argument_list|)
operator||
name|SM
argument_list|(
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|AR_PCU_SMPS_HPWR_CHNMSK
argument_list|)
operator||
name|AR_PCU_SMPS_MAC_CHAINMASK
expr_stmt|;
comment|/* Program registers according to required SM power mode.*/
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HAL_SMPS_SW_CTRL_LOW_PWR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_SMPS
argument_list|,
name|regval
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_SMPS_SW_CTRL_HIGH_PWR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_SMPS
argument_list|,
name|regval
operator||
name|AR_PCU_SMPS_SW_CTRL_HPWR
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_SMPS_HW_CTRL
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_SMPS
argument_list|,
name|regval
operator||
name|AR_PCU_SMPS_HW_CTRL_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_SMPS_DEFAULT
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_SMPS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ahp
operator|->
name|ah_sm_power_mode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|ATH_WOW
end_if

begin_if
if|#
directive|if
name|NOT_NEEDED_FOR_OSPREY
end_if

begin_comment
comment|/* not compiled for darwin */
end_comment

begin_comment
comment|/*  * This routine is called to configure the SerDes register for the  * Merlin 2.0 and above chip during WOW sleep.  */
end_comment

begin_function
specifier|static
name|void
name|ar9280_config_ser_des__wow_sleep
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/*      * For WOW sleep, we reprogram the SerDes so that the PLL and CHK REQ      * are both enabled. This uses more power but the Maverick team reported      * that otherwise, WOW sleep is unstable and chip may disappears.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahp
operator|->
name|ah_ini_pcie_serdes_wow
operator|.
name|ia_rows
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|INI_RA
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_pcie_serdes_wow
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INI_RA
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_pcie_serdes_wow
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* if NOT_NEEDED_FOR_OSPREY */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_wow_create_keep_alive_pattern
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|frame_len
init|=
literal|28
decl_stmt|;
name|u_int32_t
name|tpc
init|=
literal|0x3f
decl_stmt|;
name|u_int32_t
name|transmit_rate
decl_stmt|;
name|u_int32_t
name|frame_type
init|=
literal|0x2
decl_stmt|;
comment|/* Frame Type -> Data; */
name|u_int32_t
name|sub_type
init|=
literal|0x4
decl_stmt|;
comment|/* Subtype -> Null Data */
name|u_int32_t
name|to_ds
init|=
literal|1
decl_stmt|;
name|u_int32_t
name|duration_id
init|=
literal|0x3d
decl_stmt|;
name|u_int8_t
modifier|*
name|sta_mac_addr
decl_stmt|,
modifier|*
name|ap_mac_addr
decl_stmt|;
name|u_int8_t
modifier|*
name|addr1
decl_stmt|,
modifier|*
name|addr2
decl_stmt|,
modifier|*
name|addr3
decl_stmt|;
name|u_int32_t
name|ctl
index|[
literal|13
index|]
init|=
block|{
literal|0
block|, }
decl_stmt|;
define|#
directive|define
name|NUM_KA_DATA_WORDS
value|6
name|u_int32_t
name|data_word
index|[
name|NUM_KA_DATA_WORDS
index|]
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|u_int32_t
name|wow_ka_dataword0
decl_stmt|;
name|sta_mac_addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ahp
operator|->
name|ah_macaddr
expr_stmt|;
name|ap_mac_addr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|ahp
operator|->
name|ah_bssid
expr_stmt|;
name|addr2
operator|=
name|sta_mac_addr
expr_stmt|;
name|addr1
operator|=
name|addr3
operator|=
name|ap_mac_addr
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel_flags
operator|&
name|CHANNEL_CCK
condition|)
block|{
name|transmit_rate
operator|=
literal|0x1B
expr_stmt|;
comment|/* CCK_1M */
block|}
else|else
block|{
name|transmit_rate
operator|=
literal|0xB
expr_stmt|;
comment|/* OFDM_6M */
block|}
comment|/* Set the Transmit Buffer. */
name|ctl
index|[
literal|0
index|]
operator|=
operator|(
name|frame_len
operator||
operator|(
name|tpc
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|ctl
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ctl
index|[
literal|2
index|]
operator|=
operator|(
literal|0x7
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* tx_tries0 */
name|ctl
index|[
literal|3
index|]
operator|=
name|transmit_rate
expr_stmt|;
name|ctl
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|ctl
index|[
literal|7
index|]
operator|=
name|ahp
operator|->
name|ah_tx_chainmask
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR_WOW_KA_DESC_WORD2
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|,
name|ctl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|data_word
index|[
literal|0
index|]
operator|=
operator|(
name|frame_type
operator|<<
literal|2
operator|)
operator||
operator|(
name|sub_type
operator|<<
literal|4
operator|)
operator||
operator|(
name|to_ds
operator|<<
literal|8
operator|)
operator||
operator|(
name|duration_id
operator|<<
literal|16
operator|)
expr_stmt|;
name|data_word
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|data_word
index|[
literal|2
index|]
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|1
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr1
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|data_word
index|[
literal|3
index|]
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|5
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|3
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr2
index|[
literal|2
index|]
operator|)
operator|)
expr_stmt|;
name|data_word
index|[
literal|4
index|]
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|data_word
index|[
literal|5
index|]
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|5
index|]
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|addr3
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER_20_OR_LATER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Jupiter 2.0 has an extra descriptor word (Time based          * discard) compared to other chips */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|AR_WOW_KA_DESC_WORD2
operator|+
literal|12
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wow_ka_dataword0
operator|=
name|AR_WOW_TXBUF
argument_list|(
literal|13
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wow_ka_dataword0
operator|=
name|AR_WOW_TXBUF
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_KA_DATA_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|wow_ka_dataword0
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|,
name|data_word
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* TBD: Should querying hal for hardware capability */
end_comment

begin_define
define|#
directive|define
name|MAX_PATTERN_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|MAX_PATTERN_MASK_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|MAX_NUM_USER_PATTERN
value|6
end_define

begin_comment
comment|/* Deducting the disassoc/deauth packets */
end_comment

begin_function
name|void
name|ar9300_wow_apply_pattern
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
modifier|*
name|p_ath_pattern
parameter_list|,
name|u_int8_t
modifier|*
name|p_ath_mask
parameter_list|,
name|int32_t
name|pattern_count
parameter_list|,
name|u_int32_t
name|ath_pattern_len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|reg_pat
index|[]
init|=
block|{
name|AR_WOW_TB_PATTERN0
block|,
name|AR_WOW_TB_PATTERN1
block|,
name|AR_WOW_TB_PATTERN2
block|,
name|AR_WOW_TB_PATTERN3
block|,
name|AR_WOW_TB_PATTERN4
block|,
name|AR_WOW_TB_PATTERN5
block|,
name|AR_WOW_TB_PATTERN6
block|,
name|AR_WOW_TB_PATTERN7
block|}
decl_stmt|;
name|u_int32_t
name|reg_mask
index|[]
init|=
block|{
name|AR_WOW_TB_MASK0
block|,
name|AR_WOW_TB_MASK1
block|,
name|AR_WOW_TB_MASK2
block|,
name|AR_WOW_TB_MASK3
block|,
name|AR_WOW_TB_MASK4
block|,
name|AR_WOW_TB_MASK5
block|,
name|AR_WOW_TB_MASK6
block|,
name|AR_WOW_TB_MASK7
block|}
decl_stmt|;
name|u_int32_t
name|pattern_val
decl_stmt|;
name|u_int32_t
name|mask_val
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|u_int8_t
name|mask_bit
init|=
literal|0x1
decl_stmt|;
name|u_int8_t
name|pattern
decl_stmt|;
comment|/* TBD: should check count by querying the hardware capability */
if|if
condition|(
name|pattern_count
operator|>=
name|MAX_NUM_USER_PATTERN
condition|)
block|{
return|return;
block|}
name|pattern
operator|=
operator|(
name|u_int8_t
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|pattern
operator||
operator|(
name|mask_bit
operator|<<
name|pattern_count
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
comment|/* Set the registers for pattern */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATTERN_SIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|pattern_val
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_pattern
index|[
name|i
operator|+
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_pattern
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_pattern
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_pattern
index|[
name|i
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|reg_pat
index|[
name|pattern_count
index|]
operator|+
name|i
operator|)
argument_list|,
name|pattern_val
argument_list|)
expr_stmt|;
block|}
comment|/* Set the registers for mask */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATTERN_MASK_SIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|mask_val
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_mask
index|[
name|i
operator|+
literal|0
index|]
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_mask
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_mask
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|p_ath_mask
index|[
name|i
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
operator|(
name|reg_mask
index|[
name|pattern_count
index|]
operator|+
name|i
operator|)
argument_list|,
name|mask_val
argument_list|)
expr_stmt|;
block|}
comment|/* XXX */
comment|/* Set the pattern length to be matched */
if|if
condition|(
name|pattern_count
operator|<
literal|4
condition|)
block|{
comment|/* Pattern 0-3 uses AR_WOW_LENGTH1_REG register */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_LENGTH1_REG
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
name|AR_WOW_LENGTH1_MASK
argument_list|(
name|pattern_count
argument_list|)
operator|)
operator|)
operator||
operator|(
operator|(
name|ath_pattern_len
operator|&
name|AR_WOW_LENGTH_MAX
operator|)
operator|<<
name|AR_WOW_LENGTH1_SHIFT
argument_list|(
name|pattern_count
argument_list|)
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_LENGTH1_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pattern 4-7 uses AR_WOW_LENGTH2_REG register */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_LENGTH2_REG
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
operator|(
operator|~
name|AR_WOW_LENGTH2_MASK
argument_list|(
name|pattern_count
argument_list|)
operator|)
operator|)
operator||
operator|(
operator|(
name|ath_pattern_len
operator|&
name|AR_WOW_LENGTH_MAX
operator|)
operator|<<
name|AR_WOW_LENGTH2_SHIFT
argument_list|(
name|pattern_count
argument_list|)
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_LENGTH2_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wow_event_mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pattern_count
operator|+
name|AR_WOW_PATTERN_FOUND_SHIFT
operator|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_set_power_mode_wow_sleep
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|AR_STA_ID1_PWR_SAV
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CR
argument_list|,
name|AR_CR_RXD
argument_list|)
expr_stmt|;
comment|/* Set receive disable bit */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_CR
argument_list|,
name|AR_CR_RXE
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: dma failed to stop in 10ms\n"
literal|"AR_CR=0x%08x\nAR_DIAG_SW=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CR
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|OS_REG_WRITE(ah, AR_RXDP, 0x0);
endif|#
directive|endif
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: TODO How to disable RXDP!!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_wow_enable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|pattern_enable
parameter_list|,
name|u_int32_t
name|timeout_in_seconds
parameter_list|,
name|int
name|clearbssid
parameter_list|,
name|HAL_BOOL
name|offloadEnable
parameter_list|)
block|{
name|uint32_t
name|init_val
decl_stmt|,
name|val
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|ka_delay
init|=
literal|4
decl_stmt|;
comment|/* Delay of 4 millisec between two keep_alive's */
name|uint32_t
name|wow_event_mask
decl_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
name|uint32_t
name|wow_feature_enable
init|=
comment|//AR_WOW_OFFLOAD_ENA_GTK            |
comment|//AR_WOW_OFFLOAD_ENA_ARP_OFFLOAD    |
comment|//AR_WOW_OFFLOAD_ENA_NS_OFFLOAD     |
comment|//AR_WOW_OFFLOAD_ENA_ACER_MAGIC     |
comment|//AR_WOW_OFFLOAD_ENA_STD_MAGIC      |
comment|//AR_WOW_OFFLOAD_ENA_4WAY_WAKE      |
comment|//AR_WOW_OFFLOAD_ENA_SWKA           |
comment|//AR_WOW_OFFLOAD_ENA_BT_SLEEP       |
name|AR_WOW_OFFLOAD_ENA_SW_NULL
decl_stmt|;
endif|#
directive|endif
comment|/*      * ah_wow_event_mask is a mask to the AR_WOW_PATTERN_REG register to      * indicate which WOW events that we have enabled. The WOW Events are      * from the pattern_enable in this function and pattern_count of      * ar9300_wow_apply_pattern()      */
name|wow_event_mask
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wow_event_mask
expr_stmt|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: offload: %d, pattern: %08x, event_mask: %08x\n"
argument_list|,
name|__func__
argument_list|,
name|offloadEnable
argument_list|,
name|pattern_enable
argument_list|,
name|wow_event_mask
argument_list|)
expr_stmt|;
comment|/*      * Untie Power-On-Reset from the PCI-E Reset. When we are in WOW sleep,      * we do not want the Reset from the PCI-E to disturb our hw state.      */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_is_pci_express
operator|==
name|AH_TRUE
condition|)
block|{
name|u_int32_t
name|wa_reg_val
decl_stmt|;
comment|/*          * We need to untie the internal POR (power-on-reset) to the external          * PCI-E reset. We also need to tie the PCI-E Phy reset to the PCI-E          * reset.          */
name|HAL_DEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: Untie POR and PCIE reset\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wa_reg_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|)
expr_stmt|;
name|wa_reg_val
operator|=
name|wa_reg_val
operator|&
operator|~
operator|(
name|AR_WA_UNTIE_RESET_EN
operator|)
expr_stmt|;
name|wa_reg_val
operator|=
name|wa_reg_val
operator||
name|AR_WA_RESET_EN
operator||
name|AR_WA_POR_SHORT
expr_stmt|;
comment|/*          * This bit is to bypass the EEPROM/OTP state machine, (by clearing its          * busy state while PCIE_rst is asserted), to allow BT embedded CPU          * be able to access WLAN registers. Otherwise the eCPU access will be          * stalled as eeprom_sm is held in busy state.          *          * EV91928 is that when this bit is set, after host wakeup and PCIE_rst          * deasserted, PCIE configuration registers will be reset and DeviceID          * SubsystemID etc. registers will be different from values before          * entering sleep. This will cause Windows to detect a device removal.          *          * For HW WOW, this bit should keep as cleared.          */
if|if
condition|(
name|offloadEnable
condition|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: Set AR_WA.13 COLD_RESET_OVERRIDE\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wa_reg_val
operator|=
name|wa_reg_val
operator||
name|AR_WA_COLD_RESET_OVERRIDE
expr_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|wa_reg_val
operator|=
name|wa_reg_val
operator||
name|AR_WA_D3_TO_L1_DISABLE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|wa_reg_val
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set the power states appropriately and enable pme.      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator||=
name|AR_PMCTRL_HOST_PME_EN
operator||
name|AR_PMCTRL_PWR_PM_CTRL_ENA
operator||
name|AR_PMCTRL_AUX_PWR_DET
expr_stmt|;
comment|/*      * Set and clear WOW_PME_CLEAR registers for the chip to generate next      * wow signal.      */
name|val
operator||=
name|AR_PMCTRL_WOW_PME_CLR
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AR_PMCTRL_WOW_PME_CLR
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/*      * Setup for for:      *     - beacon misses      *     - magic pattern      *     - keep alive timeout      *     - pattern matching      */
comment|/*      * Program some default values for keep-alives, beacon misses, etc.      */
name|init_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|AR_WOW_BACK_OFF_SHIFT
argument_list|(
name|AR_WOW_PAT_BACKOFF
argument_list|)
operator||
name|init_val
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|AR_WOW_AIFS_CNT
argument_list|(
name|AR_WOW_CNT_AIFS_CNT
argument_list|)
operator||
name|AR_WOW_SLOT_CNT
argument_list|(
name|AR_WOW_CNT_SLOT_CNT
argument_list|)
operator||
name|AR_WOW_KEEP_ALIVE_CNT
argument_list|(
name|AR_WOW_CNT_KA_CNT
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_COUNT_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_COUNT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_BEACON_MISS
condition|)
block|{
name|val
operator|=
name|AR_WOW_BEACON_TIMO
expr_stmt|;
block|}
else|else
block|{
comment|/* We are not using the beacon miss. Program a large value. */
name|val
operator|=
name|AR_WOW_BEACON_TIMO_MAX
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_BCN_TIMO_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_BCN_TIMO_REG
argument_list|)
expr_stmt|;
comment|/*      * Keep Alive Timo in ms.      */
if|if
condition|(
name|pattern_enable
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|AR_WOW_KEEP_ALIVE_NEVER
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_keep_alive_timeout
operator|*
literal|32
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_TIMO_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_TIMO_REG
argument_list|)
expr_stmt|;
comment|/*      * Keep Alive delay in us.      */
name|val
operator|=
name|ka_delay
operator|*
literal|1000
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_DELAY_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_DELAY_REG
argument_list|)
expr_stmt|;
comment|/*      * Create keep_alive Pattern to respond to beacons.      */
name|ar9300_wow_create_keep_alive_pattern
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * Configure Mac Wow Registers.      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_REG
argument_list|)
expr_stmt|;
comment|/*      * Send keep alive timeouts anyway.      */
name|val
operator|&=
operator|~
name|AR_WOW_KEEP_ALIVE_AUTO_DIS
expr_stmt|;
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_LINK_CHANGE
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_WOW_KEEP_ALIVE_FAIL_DIS
expr_stmt|;
name|wow_event_mask
operator||=
name|AR_WOW_KEEP_ALIVE_FAIL
expr_stmt|;
block|}
else|else
block|{
name|val
operator||=
name|AR_WOW_KEEP_ALIVE_FAIL_DIS
expr_stmt|;
block|}
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
name|offloadEnable
condition|)
block|{
comment|/* Don't enable KA frames yet. BT CPU is not           * yet ready. */
block|}
else|else
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_KEEP_ALIVE_REG
argument_list|)
expr_stmt|;
block|}
comment|/*      * We are relying on a bmiss failure. Ensure we have enough      * threshold to prevent AH_FALSE positives.      */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|AR_RSSI_THR_BM_THR
argument_list|,
name|AR_WOW_BMISSTHRESHOLD
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_BCN_EN_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_BEACON_MISS
condition|)
block|{
name|val
operator||=
name|AR_WOW_BEACON_FAIL_EN
expr_stmt|;
name|wow_event_mask
operator||=
name|AR_WOW_BEACON_FAIL
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|AR_WOW_BEACON_FAIL_EN
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_BCN_EN_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_BCN_EN_REG
argument_list|)
expr_stmt|;
comment|/*      * Enable the magic packet registers.      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_MAGIC_PATTERN_EN
operator|)
if|#
directive|if
name|ATH_WOW_OFFLOAD
operator|||
operator|(
name|pattern_enable
operator|&
name|AH_WOW_ACER_MAGIC_EN
operator|)
endif|#
directive|endif
condition|)
block|{
name|val
operator||=
name|AR_WOW_MAGIC_EN
expr_stmt|;
name|wow_event_mask
operator||=
name|AR_WOW_MAGIC_PAT_FOUND
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|AR_WOW_MAGIC_EN
expr_stmt|;
block|}
name|val
operator||=
name|AR_WOW_MAC_INTR_EN
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_FORCE_BT_SLEEP
argument_list|)
condition|)
block|{
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_BT_SLEEP
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - BT SLEEP\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_BT_SLEEP
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - BT SLEEP\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_SW_NULL_DISABLE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - SW NULL\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_SW_NULL
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - SW NULL\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_SW_NULL
expr_stmt|;
block|}
if|if
condition|(
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_DEVID_SWAR_DISABLE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - DevID SWAR\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_DEVID_SWAR
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - DevID SWAR\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_DEVID_SWAR
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_ACER_KEEP_ALIVE_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Acer SWKA\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_SWKA
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Acer SWKA\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_SWKA
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_ACER_MAGIC_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Standard Magic\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_STD_MAGIC
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Acer Magic\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_ACER_MAGIC
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - Standard Magic\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_STD_MAGIC
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - Acer Magic\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_ACER_MAGIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_4WAY_HANDSHAKE_EN
operator|)
operator|||
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_FORCE_4WAY_HS_WAKE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - 4Way Handshake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_4WAY_WAKE
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - 4Way Handshake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_4WAY_WAKE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_AP_ASSOCIATION_LOST_EN
operator|)
operator|||
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_FORCE_AP_LOSS_WAKE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - AP loss wake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_AP_LOSS_WAKE
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - AP loss wake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_AP_LOSS_WAKE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pattern_enable
operator|&
name|AH_WOW_GTK_HANDSHAKE_ERROR_EN
operator|)
operator|||
name|HAL_WOW_CTRL
argument_list|(
name|ah
argument_list|,
name|HAL_WOW_OFFLOAD_FORCE_GTK_ERR_WAKE
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - GTK error wake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_GTK_ERROR_WAKE
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - GTK error wake\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_GTK_ERROR_WAKE
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_GTK_OFFLOAD_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - GTK offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_GTK
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - GTK offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_GTK
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_ARP_OFFLOAD_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - ARP offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_ARP_OFFLOAD
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - ARP offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_ARP_OFFLOAD
expr_stmt|;
block|}
if|if
condition|(
name|pattern_enable
operator|&
name|AH_WOW_NS_OFFLOAD_EN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) ENA - NS offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator||=
name|AR_WOW_OFFLOAD_ENA_NS_OFFLOAD
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) DIS - NS offload\n"
argument_list|)
expr_stmt|;
name|wow_feature_enable
operator|&=
operator|~
name|AR_WOW_OFFLOAD_ENA_NS_OFFLOAD
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
comment|/* For Kite and later version of the chips      * enable wow pattern match for packets less than      * 256 bytes for all patterns.      */
comment|/* XXX */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_MATCH_LT_256B_REG
argument_list|,
name|AR_WOW_PATTERN_SUPPORTED
argument_list|)
expr_stmt|;
comment|/*      * Set the power states appropriately and enable PME.      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator||=
name|AR_PMCTRL_PWR_STATE_D1D3
operator||
name|AR_PMCTRL_HOST_PME_EN
operator||
name|AR_PMCTRL_PWR_PM_CTRL_ENA
expr_stmt|;
name|val
operator|&=
operator|~
name|AR_PCIE_PM_CTRL_ENA
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Wake on Timer Interrupt. Test mode only. Used in Manufacturing line. */
if|if
condition|(
name|timeout_in_seconds
condition|)
block|{
comment|/* convert Timeout to u_secs */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_NDP_TIMER
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|+
name|timeout_in_seconds
operator|*
literal|1000000
argument_list|)
expr_stmt|;
comment|/* timer_period = 30 seconds always */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NDP_PERIOD
argument_list|,
literal|30
operator|*
literal|1000000
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S5
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S5
argument_list|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|)
operator||
name|AR_IMR_GENTMR
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearbssid
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable Seq# generation when asleep. */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
operator|~
name|AR_STA_ID1_PRESERVE_SEQNUM
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wow_event_mask
operator|=
name|wow_event_mask
expr_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
if|if
condition|(
name|offloadEnable
condition|)
block|{
comment|/* Force MAC awake before entering SW WoW mode */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_COMMAND_JUPITER
argument_list|,
name|wow_feature_enable
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_OFFLOAD_STATUS_JUPITER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wow_feature_enable
operator|&
name|AR_WOW_OFFLOAD_ENA_SW_NULL
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_SW_NULL_PARAMETER
argument_list|,
operator|(
operator|(
literal|1000
operator|)
operator||
operator|(
literal|4
operator|<<
name|AR_WOW_SW_NULL_SHORT_PERIOD_MASK_S
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wow_feature_enable
operator|&
name|AR_WOW_OFFLOAD_ENA_DEVID_SWAR
condition|)
block|{
name|ar9300_wowoffload_download_devid_swar
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|ar9300_wow_offload_download_hal_params
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_wow_offload_handshake
argument_list|(
name|ah
argument_list|,
name|pattern_enable
argument_list|)
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chip_full_sleep
operator|=
name|AH_FALSE
expr_stmt|;
comment|//OS_REG_SET_BIT(ah, AR_SW_WOW_CONTROL, AR_HW_WOW_DISABLE);
block|}
else|else
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
block|{
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halMciSupport
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ar9300_set_power_mode_wow_sleep
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_chip_full_sleep
operator|=
name|AH_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|AH_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
comment|//ar9300_wow_wake_up(struct ath_hal *ah, u_int8_t  *chipPatternBytes)
name|ar9300_wow_wake_up
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|offloadEnabled
parameter_list|)
block|{
name|uint32_t
name|wow_status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|,
name|rval
decl_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_SW_WOW_CONTROL
argument_list|,
name|AR_HW_WOW_DISABLE
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_SW_WOW_CONTROL
argument_list|,
name|AR_SW_WOW_ENABLE
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_WOW_OFFLOAD
comment|/* If WoW was offloaded to embedded CPU, use the global       * shared register to know the wakeup reason */
if|if
condition|(
name|offloadEnabled
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|AR_EMB_CPU_WOW_STATUS_MAGIC_PATTERN
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) SW MAGIC_PATTERN\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_MAGIC_PATTERN_EN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AR_EMB_CPU_WOW_STATUS_PATTERN_MATCH
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) SW USER_PATTERN\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_USER_PATTERN_EN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AR_EMB_CPU_WOW_STATUS_KEEP_ALIVE_FAIL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) SW KEEP_ALIVE_FAIL\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_LINK_CHANGE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AR_EMB_CPU_WOW_STATUS_BEACON_MISS
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) SW BEACON_FAIL\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_BEACON_MISS
expr_stmt|;
block|}
block|}
comment|/* Clear status and mask registers */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_EMB_CPU_WOW_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MBOX_CTRL_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ATH_WOW_OFFLOAD */
block|{
comment|/*          * Read the WOW Status register to know the wakeup reason.          */
name|rval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|AR_WOW_STATUS
argument_list|(
name|rval
argument_list|)
expr_stmt|;
comment|/*          * Mask only the WOW events that we have enabled.          * Sometimes we have spurious WOW events from the AR_WOW_PATTERN_REG          * register. This mask will clean it up.          */
name|val
operator|&=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wow_event_mask
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|AR_WOW_MAGIC_PAT_FOUND
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) HW MAGIC_PATTERN\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_MAGIC_PATTERN_EN
expr_stmt|;
block|}
if|if
condition|(
name|AR_WOW_PATTERN_FOUND
argument_list|(
name|val
argument_list|)
condition|)
block|{
comment|//int  i, offset;
comment|//offset = OS_REG_READ(ah, AR_WOW_RXBUF_START_ADDR);
comment|//// Read matched pattern for wake packet detection indication.
comment|//for( i = 0; i< MAX_PATTERN_SIZE/4; i+=4)
comment|//{
comment|//    // RX FIFO is only 8K wrapping.
comment|//    if(offset>= 8 * 1024 / 4) offset = 0;
comment|//    *(u_int32_t*)(chipPatternBytes + i) = OS_REG_READ( ah,offset );
comment|//    offset++;
comment|//}
name|wow_status
operator||=
name|AH_WOW_USER_PATTERN_EN
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) HW USER_PATTERN\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AR_WOW_KEEP_ALIVE_FAIL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) HW KEEP_ALIVE_FAIL\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_LINK_CHANGE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AR_WOW_BEACON_FAIL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) HW BEACON_FAIL\n"
argument_list|)
expr_stmt|;
name|wow_status
operator||=
name|AH_WOW_BEACON_MISS
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Set and clear WOW_PME_CLEAR registers for the chip to generate next      * wow signal.      * Disable D3 before accessing other registers ?      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the bit value 0x01000000 (7-10)? */
name|val
operator|&=
operator|~
name|AR_PMCTRL_PWR_STATE_D1D3
expr_stmt|;
name|val
operator||=
name|AR_PMCTRL_WOW_PME_CLR
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/*      * Clear all events.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|,
name|AR_WOW_CLEAR_EVENTS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_WOW_PATTERN_REG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE,
comment|//    "%s: Skip PCIE WA programming\n", __func__);
if|#
directive|if
literal|0
comment|/*      * Tie reset register.      * FIXME: Per David Quan not tieing it back might have some repurcussions.      */
comment|/* XXX */
block|OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_WA), OS_REG_READ(ah, AR_WA) |             AR_WA_UNTIE_RESET_EN | AR_WA_POR_SHORT | AR_WA_RESET_EN);
endif|#
directive|endif
comment|/* Restore the Beacon Threshold to init value */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|AR_RSSI_THR_BM_THR
argument_list|,
name|INIT_RSSI_THR
argument_list|)
expr_stmt|;
comment|/*      * Restore the way the PCI-E Reset, Power-On-Reset, external PCIE_POR_SHORT      * pins are tied to its original value. Previously just before WOW sleep,      * we untie the PCI-E Reset to our Chip's Power On Reset so that      * any PCI-E reset from the bus will not reset our chip.      */
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: restore AR_WA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_is_pci_express
operator|==
name|AH_TRUE
condition|)
block|{
name|ar9300_config_pci_power_save
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wow_event_mask
operator|=
literal|0
expr_stmt|;
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"(WOW) wow_status=%08x\n"
argument_list|,
name|wow_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|wow_status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ar9300_wow_set_gpio_reset_low
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|2
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OE_OUT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* val = OS_REG_READ(ah,AR_GPIO_IN_OUT ); */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_WOW */
end_comment

end_unit

