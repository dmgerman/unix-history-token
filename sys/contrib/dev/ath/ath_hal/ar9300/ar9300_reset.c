begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR9300
end_ifdef

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_devid.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_include
include|#
directive|include
file|"ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9300desc.h"
end_include

begin_define
define|#
directive|define
name|FIX_NOISE_FLOOR
value|1
end_define

begin_comment
comment|/* Additional Time delay to wait after activiting the Base band */
end_comment

begin_define
define|#
directive|define
name|BASE_ACTIVATE_DELAY
value|100
end_define

begin_comment
comment|/* usec */
end_comment

begin_define
define|#
directive|define
name|RTC_PLL_SETTLE_DELAY
value|100
end_define

begin_comment
comment|/* usec */
end_comment

begin_define
define|#
directive|define
name|COEF_SCALE_S
value|24
end_define

begin_define
define|#
directive|define
name|HT40_CHANNEL_CENTER_SHIFT
value|10
end_define

begin_comment
comment|/* MHz      */
end_comment

begin_define
define|#
directive|define
name|DELPT
value|32
end_define

begin_function_decl
specifier|extern
name|HAL_BOOL
name|ar9300_reset_tx_queue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int32_t
name|ar9300_num_tx_pending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_MEASUREMENT
value|8
end_define

begin_define
define|#
directive|define
name|MAXIQCAL
value|3
end_define

begin_struct
struct|struct
name|coeff_t
block|{
name|int32_t
name|mag_coeff
index|[
name|AR9300_MAX_CHAINS
index|]
index|[
name|MAX_MEASUREMENT
index|]
index|[
name|MAXIQCAL
index|]
decl_stmt|;
name|int32_t
name|phs_coeff
index|[
name|AR9300_MAX_CHAINS
index|]
index|[
name|MAX_MEASUREMENT
index|]
index|[
name|MAXIQCAL
index|]
decl_stmt|;
name|int32_t
name|iqc_coeff
index|[
literal|2
index|]
decl_stmt|;
name|int
name|last_nmeasurement
decl_stmt|;
name|HAL_BOOL
name|last_cal
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|HAL_BOOL
name|ar9300_tx_iq_cal_hw_run
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9300_tx_iq_cal_post_proc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|int
name|iqcal_idx
parameter_list|,
name|int
name|max_iqcal
parameter_list|,
name|HAL_BOOL
name|is_cal_reusable
parameter_list|,
name|HAL_BOOL
name|apply_last_corr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ar9300_tx_iq_cal_outlier_detection
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|u_int32_t
name|num_chains
parameter_list|,
name|struct
name|coeff_t
modifier|*
name|coeff
parameter_list|,
name|HAL_BOOL
name|is_cal_reusable
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
end_if

begin_function_decl
specifier|static
name|void
name|ar9300_tx_iq_cal_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|ar9300_prog_ini
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar9300_ini_array
modifier|*
name|ini_arr
parameter_list|,
name|int
name|column
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ar9300_set_rf_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_init_cal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|skip_if_none
parameter_list|,
name|HAL_BOOL
name|apply_last_corr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ar9300_init_user_settings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_OFFLOAD
end_ifdef

begin_comment
comment|/*   * For usb offload solution, some USB registers must be tuned   * to gain better stability/performance but these registers  * might be changed while doing wlan reset so do this here   */
end_comment

begin_define
define|#
directive|define
name|WAR_USB_DISABLE_PLL_LOCK_DETECT
parameter_list|(
name|__ah
parameter_list|)
define|\
value|do { \     if (AR_SREV_HORNET(__ah) || AR_SREV_WASP(__ah)) { \         volatile u_int32_t *usb_ctrl_r1 = (u_int32_t *) 0xb8116c84; \         volatile u_int32_t *usb_ctrl_r2 = (u_int32_t *) 0xb8116c88; \         *usb_ctrl_r1 = (*usb_ctrl_r1& 0xffefffff); \         *usb_ctrl_r2 = (*usb_ctrl_r2& 0xfc1fffff) | (1<< 21) | (3<< 22); \     } \ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WAR_USB_DISABLE_PLL_LOCK_DETECT
parameter_list|(
name|__ah
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_attach_hw_platform
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|ah_hwp
operator|=
name|HAL_TRUE_CHIP
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Adjust various register settings based on half/quarter rate clock setting.  * This includes: +USEC, TX/RX latency,   *                + IFS params: slot, eifs, misc etc.  * SIFS stays the same.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_set_ifs_timing
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|tx_lat
decl_stmt|,
name|rx_lat
decl_stmt|,
name|usec
decl_stmt|,
name|slot
decl_stmt|,
name|regval
decl_stmt|,
name|eifs
decl_stmt|;
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
name|AR_USEC_RX_LATENCY
operator||
name|AR_USEC_TX_LATENCY
operator||
name|AR_USEC_USEC
operator|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* half rates */
name|slot
operator|=
name|ar9300_mac_to_clks
argument_list|(
name|ah
argument_list|,
name|AR_SLOT_HALF
argument_list|)
expr_stmt|;
name|eifs
operator|=
name|ar9300_mac_to_clks
argument_list|(
name|ah
argument_list|,
name|AR_EIFS_HALF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* fast clock */
name|rx_lat
operator|=
name|SM
argument_list|(
name|AR_RX_LATENCY_HALF_FAST_CLOCK
argument_list|,
name|AR_USEC_RX_LATENCY
argument_list|)
expr_stmt|;
name|tx_lat
operator|=
name|SM
argument_list|(
name|AR_TX_LATENCY_HALF_FAST_CLOCK
argument_list|,
name|AR_USEC_TX_LATENCY
argument_list|)
expr_stmt|;
name|usec
operator|=
name|SM
argument_list|(
name|AR_USEC_HALF_FAST_CLOCK
argument_list|,
name|AR_USEC_USEC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx_lat
operator|=
name|SM
argument_list|(
name|AR_RX_LATENCY_HALF
argument_list|,
name|AR_USEC_RX_LATENCY
argument_list|)
expr_stmt|;
name|tx_lat
operator|=
name|SM
argument_list|(
name|AR_TX_LATENCY_HALF
argument_list|,
name|AR_USEC_TX_LATENCY
argument_list|)
expr_stmt|;
name|usec
operator|=
name|SM
argument_list|(
name|AR_USEC_HALF
argument_list|,
name|AR_USEC_USEC
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* quarter rate */
name|slot
operator|=
name|ar9300_mac_to_clks
argument_list|(
name|ah
argument_list|,
name|AR_SLOT_QUARTER
argument_list|)
expr_stmt|;
name|eifs
operator|=
name|ar9300_mac_to_clks
argument_list|(
name|ah
argument_list|,
name|AR_EIFS_QUARTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
comment|/* fast clock */
name|rx_lat
operator|=
name|SM
argument_list|(
name|AR_RX_LATENCY_QUARTER_FAST_CLOCK
argument_list|,
name|AR_USEC_RX_LATENCY
argument_list|)
expr_stmt|;
name|tx_lat
operator|=
name|SM
argument_list|(
name|AR_TX_LATENCY_QUARTER_FAST_CLOCK
argument_list|,
name|AR_USEC_TX_LATENCY
argument_list|)
expr_stmt|;
name|usec
operator|=
name|SM
argument_list|(
name|AR_USEC_QUARTER_FAST_CLOCK
argument_list|,
name|AR_USEC_USEC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx_lat
operator|=
name|SM
argument_list|(
name|AR_RX_LATENCY_QUARTER
argument_list|,
name|AR_USEC_RX_LATENCY
argument_list|)
expr_stmt|;
name|tx_lat
operator|=
name|SM
argument_list|(
name|AR_TX_LATENCY_QUARTER
argument_list|,
name|AR_USEC_TX_LATENCY
argument_list|)
expr_stmt|;
name|usec
operator|=
name|SM
argument_list|(
name|AR_USEC_QUARTER
argument_list|,
name|AR_USEC_USEC
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_USEC
argument_list|,
operator|(
name|usec
operator||
name|regval
operator||
name|tx_lat
operator||
name|rx_lat
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_SLOT
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_EIFS
argument_list|,
name|eifs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This inline function configures the chip either  * to encrypt/decrypt management frames or pass thru  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_mfp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|mfpcap
decl_stmt|,
name|mfp_qos
decl_stmt|;
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_MFP
argument_list|,
literal|0
argument_list|,
operator|&
name|mfpcap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfpcap
operator|==
name|HAL_MFP_QOSDATA
condition|)
block|{
comment|/* Treat like legacy hardware. Do not touch the MFP registers. */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s forced to use QOSDATA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* MFP support (Sowl 1.0 or greater) */
if|if
condition|(
name|mfpcap
operator|==
name|HAL_MFP_HW_CRYPTO
condition|)
block|{
comment|/* configure hardware MFP support */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s using HW crypto\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_AES_MUTE_MASK1
argument_list|,
name|AR_AES_MUTE_MASK1_FC_MGMT
argument_list|,
name|AR_AES_MUTE_MASK1_FC_MGMT_MFP
argument_list|)
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC_MODE2
argument_list|,
name|AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE
argument_list|,
name|AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT
argument_list|)
expr_stmt|;
comment|/*         * Mask used to construct AAD for CCMP-AES         * Cisco spec defined bits 0-3 as mask          * IEEE802.11w defined as bit 4.         */
if|if
condition|(
name|ath_hal_get_mfp_qos
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|mfp_qos
operator|=
name|AR_MFP_QOS_MASK_IEEE
expr_stmt|;
block|}
else|else
block|{
name|mfp_qos
operator|=
name|AR_MFP_QOS_MASK_CISCO
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC_MODE2
argument_list|,
name|AR_PCU_MISC_MODE2_MGMT_QOS
argument_list|,
name|mfp_qos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mfpcap
operator|==
name|HAL_MFP_PASSTHRU
condition|)
block|{
comment|/* Disable en/decrypt by hardware */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s using passthru\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC_MODE2
argument_list|,
name|AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT
argument_list|,
name|AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ar9300_get_channel_centers
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|CHAN_CENTERS
modifier|*
name|centers
parameter_list|)
block|{
name|int8_t
name|extoff
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|centers
operator|->
name|ctl_center
operator|=
name|centers
operator|->
name|ext_center
operator|=
name|centers
operator|->
name|synth_center
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
return|return;
block|}
name|HALASSERT
argument_list|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * In 20/40 phy mode, the center frequency is      * "between" the primary and extension channels.      */
if|if
condition|(
name|chan
operator|->
name|channel_flags
operator|&
name|CHANNEL_HT40PLUS
condition|)
block|{
name|centers
operator|->
name|synth_center
operator|=
name|chan
operator|->
name|channel
operator|+
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
name|extoff
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|centers
operator|->
name|synth_center
operator|=
name|chan
operator|->
name|channel
operator|-
name|HT40_CHANNEL_CENTER_SHIFT
expr_stmt|;
name|extoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|centers
operator|->
name|ctl_center
operator|=
name|centers
operator|->
name|synth_center
operator|-
operator|(
name|extoff
operator|*
name|HT40_CHANNEL_CENTER_SHIFT
operator|)
expr_stmt|;
name|centers
operator|->
name|ext_center
operator|=
name|centers
operator|->
name|synth_center
operator|+
operator|(
name|extoff
operator|*
operator|(
operator|(
name|ahp
operator|->
name|ah_ext_prot_spacing
operator|==
name|HAL_HT_EXTPROTSPACING_20
operator|)
condition|?
name|HT40_CHANNEL_CENTER_SHIFT
else|:
literal|15
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the noise-floor values from the HW.  * Specifically, read the minimum clear-channel assessment value for  * each chain, for both the control and extension channels.  * (The received power level during clear-channel periods is the  * noise floor.)  * These noise floor values computed by the HW will be stored in the  * NF history buffer.  * The HW sometimes produces bogus NF values.  To avoid using these  * bogus values, the NF data is (a) range-limited, and (b) filtered.  * However, this data-processing is done when reading the NF values  * out of the history buffer.  The history buffer stores the raw values.  * This allows the NF history buffer to be used to check for interference.  * A single high NF reading might be a bogus HW value, but if the NF  * readings are consistently high, it must be due to interference.  * This is the purpose of storing raw NF values in the history buffer,  * rather than processed values.  By looking at a history of NF values  * that have not been range-limited, we can check if they are consistently  * high (due to interference).  */
end_comment

begin_define
define|#
directive|define
name|AH_NF_SIGN_EXTEND
parameter_list|(
name|nf
parameter_list|)
define|\
value|((nf)& 0x100) ?               \         0 - (((nf) ^ 0x1ff) + 1) : \         (nf)
end_define

begin_function
name|void
name|ar9300_upload_noise_floor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|is_2g
parameter_list|,
name|int16_t
name|nfarray
index|[
name|NUM_NF_READINGS
index|]
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|chain
decl_stmt|;
name|u_int32_t
name|regs
index|[
name|NUM_NF_READINGS
index|]
init|=
block|{
comment|/* control channel */
name|AR_PHY_CCA_0
block|,
comment|/* chain 0 */
name|AR_PHY_CCA_1
block|,
comment|/* chain 1 */
name|AR_PHY_CCA_2
block|,
comment|/* chain 2 */
comment|/* extension channel */
name|AR_PHY_EXT_CCA
block|,
comment|/* chain 0 */
name|AR_PHY_EXT_CCA_1
block|,
comment|/* chain 1 */
name|AR_PHY_EXT_CCA_2
block|,
comment|/* chain 2 */
block|}
decl_stmt|;
name|u_int8_t
name|chainmask
decl_stmt|;
comment|/*      * Within a given channel (ctl vs. ext), the CH0, CH1, and CH2      * masks and shifts are the same, though they differ for the      * control vs. extension channels.      */
name|u_int32_t
name|masks
index|[
literal|2
index|]
init|=
block|{
name|AR_PHY_MINCCA_PWR
block|,
comment|/* control channel */
name|AR_PHY_EXT_MINCCA_PWR
block|,
comment|/* extention channel */
block|}
decl_stmt|;
name|u_int8_t
name|shifts
index|[
literal|2
index|]
init|=
block|{
name|AR_PHY_MINCCA_PWR_S
block|,
comment|/* control channel */
name|AR_PHY_EXT_MINCCA_PWR_S
block|,
comment|/* extention channel */
block|}
decl_stmt|;
comment|/*      * Force NF calibration for all chains.      */
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|chainmask
operator|=
literal|0x01
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|chainmask
operator|=
literal|0x03
expr_stmt|;
block|}
else|else
block|{
name|chainmask
operator|=
literal|0x07
expr_stmt|;
block|}
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
literal|2
comment|/*ctl,ext*/
condition|;
name|chan
operator|++
control|)
block|{
for|for
control|(
name|chain
operator|=
literal|0
init|;
name|chain
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|chain
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|chainmask
operator|>>
name|chain
operator|)
operator|&
literal|0x1
operator|)
condition|)
block|{
continue|continue;
block|}
name|i
operator|=
name|chan
operator|*
name|AR9300_MAX_CHAINS
operator|+
name|chain
expr_stmt|;
name|nf
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|)
operator|&
name|masks
index|[
name|chan
index|]
operator|)
operator|>>
name|shifts
index|[
name|chan
index|]
expr_stmt|;
name|nfarray
index|[
name|i
index|]
operator|=
name|AH_NF_SIGN_EXTEND
argument_list|(
name|nf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ar9300_get_min_cca_pwr -  * Used by the scan function for a quick read of the noise floor.  * This is used to detect presence of CW interference such as video bridge.  * The noise floor is assumed to have been already started during reset  * called during channel change. The function checks if the noise floor  * reading is done. In case it has been done, it reads the noise floor value.  * If the noise floor calibration has not been finished, it assumes this is  * due to presence of CW interference an returns a high value for noise floor,  * derived from the CW interference threshold + margin fudge factor.   */
end_comment

begin_define
define|#
directive|define
name|BAD_SCAN_NF_MARGIN
value|(30)
end_define

begin_function
name|int16_t
name|ar9300_get_min_cca_pwr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int16_t
name|nf
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
operator|)
operator|==
literal|0
condition|)
block|{
name|nf
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCA_0
argument_list|)
argument_list|,
name|AR9280_PHY_MINCCA_PWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|&
literal|0x100
condition|)
block|{
name|nf
operator|=
literal|0
operator|-
operator|(
operator|(
name|nf
operator|^
literal|0x1ff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NF calibration is not done, assume CW interference */
name|nf
operator|=
name|ahpriv
operator|->
name|nfp
operator|->
name|nominal
operator|+
name|ahpriv
operator|->
name|nf_cw_int_delta
operator|+
name|BAD_SCAN_NF_MARGIN
expr_stmt|;
block|}
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*   * Noise Floor values for all chains.   * Most recently updated values from the NF history buffer are used.  */
end_comment

begin_function
name|void
name|ar9300_chain_noise_floor
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
modifier|*
name|nf_buf
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|int
name|is_scan
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nf_hist_len
decl_stmt|,
name|recent_nf_index
init|=
literal|0
decl_stmt|;
name|HAL_NFCAL_HIST_FULL
modifier|*
name|h
decl_stmt|;
name|u_int8_t
name|rx_chainmask
init|=
name|ahp
operator|->
name|ah_rx_chainmask
operator||
operator|(
name|ahp
operator|->
name|ah_rx_chainmask
operator|<<
literal|3
operator|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HALASSERT
argument_list|(
name|ichan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_NF_PER_CHAN
comment|/* Fill 0 if valid internal channel is not found */
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|OS_MEMZERO
argument_list|(
name|nf_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|nf_buf
index|[
literal|0
index|]
argument_list|)
operator|*
name|NUM_NF_READINGS
argument_list|)
expr_stmt|;
return|return;
block|}
name|h
operator|=
operator|&
name|ichan
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_FULL
expr_stmt|;
else|#
directive|else
comment|/*      * If a scan is not in progress, then the most recent value goes      * into ahpriv->nf_cal_hist.  If a scan is in progress, then      * the most recent value goes into ichan->nf_cal_hist.      * Thus, return the value from ahpriv->nf_cal_hist if there's      * no scan, and if the specified channel is the current channel.      * Otherwise, return the noise floor from ichan->nf_cal_hist.      */
if|if
condition|(
operator|(
operator|!
name|is_scan
operator|)
operator|&&
name|chan
operator|->
name|channel
operator|==
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel
condition|)
block|{
name|h
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_FULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill 0 if valid internal channel is not found */
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|OS_MEMZERO
argument_list|(
name|nf_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|nf_buf
index|[
literal|0
index|]
argument_list|)
operator|*
name|NUM_NF_READINGS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*         * It is okay to treat a HAL_NFCAL_HIST_SMALL struct as if it were a         * HAL_NFCAL_HIST_FULL struct, as long as only the index 0 of the         * nf_cal_buffer is used (nf_cal_buffer[0][0:NUM_NF_READINGS-1])         */
name|h
operator|=
operator|(
name|HAL_NFCAL_HIST_FULL
operator|*
operator|)
operator|&
name|ichan
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_SMALL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Get most recently updated values from nf cal history buffer */
name|recent_nf_index
operator|=
operator|(
name|h
operator|->
name|base
operator|.
name|curr_index
operator|)
condition|?
name|h
operator|->
name|base
operator|.
name|curr_index
operator|-
literal|1
else|:
name|nf_hist_len
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Fill 0 for unsupported chains */
if|if
condition|(
operator|!
operator|(
name|rx_chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
name|nf_buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|nf_buf
index|[
name|i
index|]
operator|=
name|h
operator|->
name|nf_cal_buffer
index|[
name|recent_nf_index
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pick up the medium one in the noise floor buffer and update the  * corresponding range for valid noise floor values  */
end_comment

begin_function
specifier|static
name|int16_t
name|ar9300_get_nf_hist_mid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_NFCAL_HIST_FULL
modifier|*
name|h
parameter_list|,
name|int
name|reading
parameter_list|,
name|int
name|hist_len
parameter_list|)
block|{
name|int16_t
name|nfval
decl_stmt|;
name|int16_t
name|sort
index|[
name|HAL_NF_CAL_HIST_LEN_FULL
index|]
decl_stmt|;
comment|/* upper bound for hist_len */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hist_len
condition|;
name|i
operator|++
control|)
block|{
name|sort
index|[
name|i
index|]
operator|=
name|h
operator|->
name|nf_cal_buffer
index|[
name|i
index|]
index|[
name|reading
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"nf_cal_buffer[%d][%d] = %d\n"
argument_list|,
name|i
argument_list|,
name|reading
argument_list|,
operator|(
name|int
operator|)
name|sort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hist_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|hist_len
operator|-
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sort
index|[
name|j
index|]
operator|>
name|sort
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
name|nfval
operator|=
name|sort
index|[
name|j
index|]
expr_stmt|;
name|sort
index|[
name|j
index|]
operator|=
name|sort
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sort
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|nfval
expr_stmt|;
block|}
block|}
block|}
name|nfval
operator|=
name|sort
index|[
operator|(
name|hist_len
operator|-
literal|1
operator|)
operator|>>
literal|1
index|]
expr_stmt|;
return|return
name|nfval
return|;
block|}
end_function

begin_function
specifier|static
name|int16_t
name|ar9300_limit_nf_range
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
if|if
condition|(
name|nf
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nfp
operator|->
name|min
condition|)
block|{
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nfp
operator|->
name|nominal
return|;
block|}
elseif|else
if|if
condition|(
name|nf
operator|>
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nfp
operator|->
name|max
condition|)
block|{
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nfp
operator|->
name|max
return|;
block|}
return|return
name|nf
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ATH_NF_PER_CHAN
end_ifndef

begin_function
specifier|inline
specifier|static
name|void
name|ar9300_reset_nf_hist_buff
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
block|{
name|HAL_CHAN_NFCAL_HIST
modifier|*
name|h
init|=
operator|&
name|ichan
operator|->
name|nf_cal_hist
decl_stmt|;
name|HAL_NFCAL_HIST_FULL
modifier|*
name|home
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*       * Copy the value for the channel in question into the home-channel      * NF history buffer.  The channel NF is probably a value filled in by      * a prior background channel scan, but if no scan has been done then      * it is the nominal noise floor filled in by ath_hal_init_NF_buffer      * for this chip and the channel's band.      * Replicate this channel NF into all entries of the home-channel NF      * history buffer.      * If the channel NF was filled in by a channel scan, it has not had      * bounds limits applied to it yet - do so now.  It is important to      * apply bounds limits to the priv_nf value that gets loaded into the      * WLAN chip's min_cca_pwr register field.  It is also necessary to      * apply bounds limits to the nf_cal_buffer[] elements.  Since we are      * replicating a single NF reading into all nf_cal_buffer elements,      * if the single reading were above the CW_INT threshold, the CW_INT      * check in ar9300_get_nf would immediately conclude that CW interference      * is present, even though we're not supposed to set CW_INT unless      * NF values are _consistently_ above the CW_INT threshold.      * Applying the bounds limits to the nf_cal_buffer contents fixes this      * problem.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
comment|/*          * No need to set curr_index, since it already has a value in          * the range [0..HAL_NF_CAL_HIST_LEN_FULL), and all nf_cal_buffer          * values will be the same.          */
name|nf
operator|=
name|ar9300_limit_nf_range
argument_list|(
name|ah
argument_list|,
name|h
operator|->
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|HAL_NF_CAL_HIST_LEN_FULL
condition|;
name|j
operator|++
control|)
block|{
name|home
operator|->
name|nf_cal_buffer
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|nf
expr_stmt|;
block|}
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
operator|.
name|base
operator|.
name|priv_nf
index|[
name|i
index|]
operator|=
name|nf
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Update the noise floor buffer as a ring buffer  */
end_comment

begin_function
specifier|static
name|int16_t
name|ar9300_update_nf_hist_buff
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_NFCAL_HIST_FULL
modifier|*
name|h
parameter_list|,
name|int16_t
modifier|*
name|nfarray
parameter_list|,
name|int
name|hist_len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nr
decl_stmt|;
name|int16_t
name|nf_no_lim_chain0
decl_stmt|;
name|nf_no_lim_chain0
operator|=
name|ar9300_get_nf_hist_mid
argument_list|(
name|ah
argument_list|,
name|h
argument_list|,
literal|0
argument_list|,
name|hist_len
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"%s[%d] BEFORE\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|HAL_NF_CAL_HIST_LEN_FULL
condition|;
name|nr
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"nf_cal_buffer[%d][%d] = %d\n"
argument_list|,
name|nr
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|h
operator|->
name|nf_cal_buffer
index|[
name|nr
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|->
name|nf_cal_buffer
index|[
name|h
operator|->
name|base
operator|.
name|curr_index
index|]
index|[
name|i
index|]
operator|=
name|nfarray
index|[
name|i
index|]
expr_stmt|;
name|h
operator|->
name|base
operator|.
name|priv_nf
index|[
name|i
index|]
operator|=
name|ar9300_limit_nf_range
argument_list|(
name|ah
argument_list|,
name|ar9300_get_nf_hist_mid
argument_list|(
name|ah
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|hist_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"%s[%d] AFTER\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|HAL_NF_CAL_HIST_LEN_FULL
condition|;
name|nr
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"nf_cal_buffer[%d][%d] = %d\n"
argument_list|,
name|nr
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|h
operator|->
name|nf_cal_buffer
index|[
name|nr
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|h
operator|->
name|base
operator|.
name|curr_index
operator|>=
name|hist_len
condition|)
block|{
name|h
operator|->
name|base
operator|.
name|curr_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|nf_no_lim_chain0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|HAL_BOOL
name|get_noise_floor_thresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|int16_t
modifier|*
name|nft
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|chan
operator|->
name|channel_flags
operator|&
name|CHANNEL_ALL_NOTURBO
condition|)
block|{
case|case
name|CHANNEL_A
case|:
case|case
name|CHANNEL_A_HT20
case|:
case|case
name|CHANNEL_A_HT40PLUS
case|:
case|case
name|CHANNEL_A_HT40MINUS
case|:
operator|*
name|nft
operator|=
operator|(
name|int8_t
operator|)
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_NFTHRESH_5
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHANNEL_B
case|:
case|case
name|CHANNEL_G
case|:
case|case
name|CHANNEL_G_HT20
case|:
case|case
name|CHANNEL_G_HT40PLUS
case|:
case|case
name|CHANNEL_G_HT40MINUS
case|:
operator|*
name|nft
operator|=
operator|(
name|int8_t
operator|)
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_NFTHRESH_2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read the NF and check it against the noise floor threshhold  */
end_comment

begin_define
define|#
directive|define
name|IS
parameter_list|(
name|_c
parameter_list|,
name|_f
parameter_list|)
value|(((_c)->channel_flags& _f) || 0)
end_define

begin_function
specifier|static
name|int
name|ar9300_store_new_nf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|int
name|is_scan
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|nf_hist_len
decl_stmt|;
name|int16_t
name|nf_no_lim
decl_stmt|;
name|int16_t
name|nfarray
index|[
name|NUM_NF_READINGS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|HAL_NFCAL_HIST_FULL
modifier|*
name|h
decl_stmt|;
name|int
name|is_2g
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
condition|)
block|{
name|u_int32_t
name|tsf32
decl_stmt|,
name|nf_cal_dur_tsf
decl_stmt|;
comment|/*          * The reason the NF calibration did not complete may just be that          * not enough time has passed since the NF calibration was started,          * because under certain conditions (when first moving to a new          * channel) the NF calibration may be checked very repeatedly.          * Or, there may be CW interference keeping the NF calibration          * from completing.  Check the delta time between when the NF          * calibration was started and now to see whether the NF calibration          * should have already completed (but hasn't, probably due to CW          * interference), or hasn't had enough time to finish yet.          */
comment|/*          * AH_NF_CAL_DUR_MAX_TSF - A conservative maximum time that the          *     HW should need to finish a NF calibration.  If the HW          *     does not complete a NF calibration within this time period,          *     there must be a problem - probably CW interference.          * AH_NF_CAL_PERIOD_MAX_TSF - A conservative maximum time between          *     check of the HW's NF calibration being finished.          *     If the difference between the current TSF and the TSF          *     recorded when the NF calibration started is larger than this          *     value, the TSF must have been reset.          *     In general, we expect the TSF to only be reset during          *     regular operation for STAs, not for APs.  However, an          *     AP's TSF could be reset when joining an IBSS.          *     There's an outside chance that this could result in the          *     CW_INT flag being erroneously set, if the TSF adjustment          *     is smaller than AH_NF_CAL_PERIOD_MAX_TSF but larger than          *     AH_NF_CAL_DUR_TSF.  However, even if this does happen,          *     it shouldn't matter, as the IBSS case shouldn't be          *     concerned about CW_INT.          */
comment|/* AH_NF_CAL_DUR_TSF - 90 sec in usec units */
define|#
directive|define
name|AH_NF_CAL_DUR_TSF
value|(90 * 1000 * 1000)
comment|/* AH_NF_CAL_PERIOD_MAX_TSF - 180 sec in usec units */
define|#
directive|define
name|AH_NF_CAL_PERIOD_MAX_TSF
value|(180 * 1000 * 1000)
comment|/* wraparound handled by using unsigned values */
name|tsf32
operator|=
name|ar9300_get_tsf32
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|nf_cal_dur_tsf
operator|=
name|tsf32
operator|-
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_tsf32
expr_stmt|;
if|if
condition|(
name|nf_cal_dur_tsf
operator|>
name|AH_NF_CAL_PERIOD_MAX_TSF
condition|)
block|{
comment|/*              * The TSF must have gotten reset during the NF cal -              * just reset the NF TSF timestamp, so the next time              * this function is called, the timestamp comparison              * will be valid.              */
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_tsf32
operator|=
name|tsf32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nf_cal_dur_tsf
operator|>
name|AH_NF_CAL_DUR_TSF
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: NF did not complete in calibration window\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* the NF incompletion is probably due to CW interference */
name|chan
operator|->
name|channel_flags
operator||=
name|CHANNEL_CW_INT
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* HW's NF measurement not finished */
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"%s[%d] chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
name|is_2g
operator|=
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_2GHZ
argument_list|)
expr_stmt|;
name|ar9300_upload_noise_floor
argument_list|(
name|ah
argument_list|,
name|is_2g
argument_list|,
name|nfarray
argument_list|)
expr_stmt|;
comment|/* Update the NF buffer for each chain masked by chainmask */
ifdef|#
directive|ifdef
name|ATH_NF_PER_CHAN
name|h
operator|=
operator|&
name|chan
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_FULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|is_scan
condition|)
block|{
comment|/*          * This channel's NF cal info is just a HAL_NFCAL_HIST_SMALL struct          * rather than a HAL_NFCAL_HIST_FULL struct.          * As long as we only use the first history element of nf_cal_buffer          * (nf_cal_buffer[0][0:NUM_NF_READINGS-1]), we can use          * HAL_NFCAL_HIST_SMALL and HAL_NFCAL_HIST_FULL interchangeably.          */
name|h
operator|=
operator|(
name|HAL_NFCAL_HIST_FULL
operator|*
operator|)
operator|&
name|chan
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_SMALL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_FULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * nf_no_lim = median value from NF history buffer without bounds limits,      * priv_nf = median value from NF history buffer with bounds limits.      */
name|nf_no_lim
operator|=
name|ar9300_update_nf_hist_buff
argument_list|(
name|ah
argument_list|,
name|h
argument_list|,
name|nfarray
argument_list|,
name|nf_hist_len
argument_list|)
expr_stmt|;
name|chan
operator|->
name|raw_noise_floor
operator|=
name|h
operator|->
name|base
operator|.
name|priv_nf
index|[
literal|0
index|]
expr_stmt|;
comment|/* check if there is interference */
name|chan
operator|->
name|channel_flags
operator|&=
operator|(
operator|~
name|CHANNEL_CW_INT
operator|)
expr_stmt|;
comment|/*      * Use AR9300_EMULATION to check for emulation purpose as PCIE Device ID      * 0xABCD is recognized as valid Osprey as WAR in some EVs.      */
if|if
condition|(
name|nf_no_lim
operator|>
name|ahpriv
operator|->
name|nfp
operator|->
name|nominal
operator|+
name|ahpriv
operator|->
name|nf_cw_int_delta
condition|)
block|{
comment|/*          * Since this CW interference check is being applied to the          * median element of the NF history buffer, this indicates that          * the CW interference is persistent.  A single high NF reading          * will not show up in the median, and thus will not cause the          * CW_INT flag to be set.          */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_NF_CAL
argument_list|,
literal|"%s: NF Cal: CW interferer detected through NF: %d\n"
argument_list|,
name|__func__
argument_list|,
name|nf_no_lim
argument_list|)
expr_stmt|;
name|chan
operator|->
name|channel_flags
operator||=
name|CHANNEL_CW_INT
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* HW's NF measurement finished */
block|}
end_function

begin_undef
undef|#
directive|undef
name|IS
end_undef

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_get_delta_slope_values
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|coef_scaled
parameter_list|,
name|u_int32_t
modifier|*
name|coef_mantissa
parameter_list|,
name|u_int32_t
modifier|*
name|coef_exponent
parameter_list|)
block|{
name|u_int32_t
name|coef_exp
decl_stmt|,
name|coef_man
decl_stmt|;
comment|/*      * ALGO -> coef_exp = 14-floor(log2(coef));      * floor(log2(x)) is the highest set bit position      */
for|for
control|(
name|coef_exp
operator|=
literal|31
init|;
name|coef_exp
operator|>
literal|0
condition|;
name|coef_exp
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|coef_scaled
operator|>>
name|coef_exp
operator|)
operator|&
literal|0x1
condition|)
block|{
break|break;
block|}
block|}
comment|/* A coef_exp of 0 is a legal bit position but an unexpected coef_exp */
name|HALASSERT
argument_list|(
name|coef_exp
argument_list|)
expr_stmt|;
name|coef_exp
operator|=
literal|14
operator|-
operator|(
name|coef_exp
operator|-
name|COEF_SCALE_S
operator|)
expr_stmt|;
comment|/*      * ALGO -> coef_man = floor(coef* 2^coef_exp+0.5);      * The coefficient is already shifted up for scaling      */
name|coef_man
operator|=
name|coef_scaled
operator|+
operator|(
literal|1
operator|<<
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|coef_mantissa
operator|=
name|coef_man
operator|>>
operator|(
name|COEF_SCALE_S
operator|-
name|coef_exp
operator|)
expr_stmt|;
operator|*
name|coef_exponent
operator|=
name|coef_exp
operator|-
literal|16
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_ANALOG_START
value|319
end_define

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/*  * Delta slope coefficient computation.  * Required for OFDM operation.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_set_delta_slope
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|coef_scaled
decl_stmt|,
name|ds_coef_exp
decl_stmt|,
name|ds_coef_man
decl_stmt|;
name|u_int32_t
name|fclk
init|=
name|COEFF
decl_stmt|;
comment|/* clock * 2.5 */
name|u_int32_t
name|clock_mhz_scaled
init|=
literal|0x1000000
operator|*
name|fclk
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
comment|/*      * half and quarter rate can divide the scaled clock by 2 or 4      * scale for selected channel bandwidth      */
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|clock_mhz_scaled
operator|=
name|clock_mhz_scaled
operator|>>
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|clock_mhz_scaled
operator|=
name|clock_mhz_scaled
operator|>>
literal|2
expr_stmt|;
block|}
comment|/*      * ALGO -> coef = 1e8/fcarrier*fclock/40;      * scaled coef to provide precision for this floating calculation      */
name|ar9300_get_channel_centers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|coef_scaled
operator|=
name|clock_mhz_scaled
operator|/
name|centers
operator|.
name|synth_center
expr_stmt|;
name|ar9300_get_delta_slope_values
argument_list|(
name|ah
argument_list|,
name|coef_scaled
argument_list|,
operator|&
name|ds_coef_man
argument_list|,
operator|&
name|ds_coef_exp
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_MAN
argument_list|,
name|ds_coef_man
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
name|AR_PHY_TIMING3_DSC_EXP
argument_list|,
name|ds_coef_exp
argument_list|)
expr_stmt|;
comment|/*      * For Short GI,      * scaled coeff is 9/10 that of normal coeff      */
name|coef_scaled
operator|=
operator|(
literal|9
operator|*
name|coef_scaled
operator|)
operator|/
literal|10
expr_stmt|;
name|ar9300_get_delta_slope_values
argument_list|(
name|ah
argument_list|,
name|coef_scaled
argument_list|,
operator|&
name|ds_coef_man
argument_list|,
operator|&
name|ds_coef_exp
argument_list|)
expr_stmt|;
comment|/* for short gi */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SGI_DELTA
argument_list|,
name|AR_PHY_SGI_DSC_MAN
argument_list|,
name|ds_coef_man
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SGI_DELTA
argument_list|,
name|AR_PHY_SGI_DSC_EXP
argument_list|,
name|ds_coef_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IS
parameter_list|(
name|_c
parameter_list|,
name|_f
parameter_list|)
value|(((_c)->channel_flags& _f) || 0)
end_define

begin_function
specifier|static
specifier|inline
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ar9300_check_chan
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
operator|(
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_2GHZ
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_5GHZ
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel %u/0x%x; not marked as 2GHz or 5GHz\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
if|if
condition|(
operator|(
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_OFDM
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_CCK
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_HT20
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_HT40PLUS
argument_list|)
operator|^
name|IS
argument_list|(
name|chan
argument_list|,
name|CHANNEL_HT40MINUS
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel %u/0x%x; not marked as "
literal|"OFDM or CCK or HT20 or HT40PLUS or HT40MINUS\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
return|return
operator|(
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IS
end_undef

begin_function
specifier|static
name|void
name|ar9300_set_11n_regs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_HT_MACMODE
name|macmode
parameter_list|)
block|{
name|u_int32_t
name|phymode
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|enable_dac_fifo
decl_stmt|;
comment|/* XXX */
name|enable_dac_fifo
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|)
operator|&
name|AR_PHY_GC_ENABLE_DAC_FIFO
expr_stmt|;
comment|/* Enable 11n HT, 20 MHz */
name|phymode
operator|=
name|AR_PHY_GC_HT_EN
operator||
name|AR_PHY_GC_SINGLE_HT_LTF1
operator||
name|AR_PHY_GC_SHORT_GI_40
operator||
name|enable_dac_fifo
expr_stmt|;
comment|/* Configure baseband for dynamic 20/40 operation */
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|phymode
operator||=
name|AR_PHY_GC_DYN2040_EN
expr_stmt|;
comment|/* Configure control (primary) channel at +-10MHz */
if|if
condition|(
name|chan
operator|->
name|channel_flags
operator|&
name|CHANNEL_HT40PLUS
condition|)
block|{
name|phymode
operator||=
name|AR_PHY_GC_DYN2040_PRI_CH
expr_stmt|;
block|}
comment|/* Configure 20/25 spacing */
if|if
condition|(
name|ahp
operator|->
name|ah_ext_prot_spacing
operator|==
name|HAL_HT_EXTPROTSPACING_25
condition|)
block|{
name|phymode
operator||=
name|AR_PHY_GC_DYN2040_EXT_CH
expr_stmt|;
block|}
block|}
comment|/* make sure we preserve INI settings */
name|phymode
operator||=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|)
expr_stmt|;
comment|/* EV 62881/64991 - turn off Green Field detection for Maverick STA beta */
name|phymode
operator|&=
operator|~
name|AR_PHY_GC_GF_DETECT_EN
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|,
name|phymode
argument_list|)
expr_stmt|;
comment|/* Set IFS timing for half/quarter rates */
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|u_int32_t
name|modeselect
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|modeselect
operator||=
name|AR_PHY_MS_HALF_RATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|modeselect
operator||=
name|AR_PHY_MS_QUARTER_RATE
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|modeselect
argument_list|)
expr_stmt|;
name|ar9300_set_ifs_timing
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FRAME_CTL
argument_list|,
name|AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
block|}
comment|/* Configure MAC for 20/40 operation */
name|ar9300_set_11n_mac2040
argument_list|(
name|ah
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
comment|/* global transmit timeout (25 TUs default)*/
comment|/* XXX - put this elsewhere??? */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GTXTO
argument_list|,
literal|25
operator|<<
name|AR_GTXTO_TIMEOUT_LIMIT_S
argument_list|)
expr_stmt|;
comment|/* carrier sense timeout */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CST
argument_list|,
literal|0xF
operator|<<
name|AR_CST_TIMEOUT_LIMIT_S
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Spur mitigation for MRC CCK  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_spur_mitigate_mrc_cck
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* spur_freq_for_osprey - hardcoded by Systems team for now. */
name|u_int32_t
name|spur_freq_for_osprey
index|[
literal|4
index|]
init|=
block|{
literal|2420
block|,
literal|2440
block|,
literal|2464
block|,
literal|2480
block|}
decl_stmt|;
name|u_int32_t
name|spur_freq_for_jupiter
index|[
literal|2
index|]
init|=
block|{
literal|2440
block|,
literal|2464
block|}
decl_stmt|;
name|int
name|cur_bb_spur
decl_stmt|,
name|negative
init|=
literal|0
decl_stmt|,
name|cck_spur_freq
decl_stmt|;
name|u_int8_t
modifier|*
name|spur_fbin_ptr
init|=
name|NULL
decl_stmt|;
name|int
name|synth_freq
decl_stmt|;
name|int
name|range
init|=
literal|10
decl_stmt|;
name|int
name|max_spurcounts
init|=
name|OSPREY_EEPROM_MODAL_SPURS
decl_stmt|;
comment|/*      * Need to verify range +/- 10 MHz in control channel, otherwise spur      * is out-of-band and can be ignored.      */
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|spur_fbin_ptr
operator|=
name|ar9300_eeprom_get_spur_chans_ptr
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spur_fbin_ptr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* No spur in the mode */
block|}
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|range
operator|=
literal|19
expr_stmt|;
if|if
condition|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|,
name|AR_PHY_GC_DYN2040_PRI_CH
argument_list|)
operator|==
literal|0x0
condition|)
block|{
name|synth_freq
operator|=
name|chan
operator|->
name|channel
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|synth_freq
operator|=
name|chan
operator|->
name|channel
operator|-
literal|10
expr_stmt|;
block|}
block|}
else|else
block|{
name|range
operator|=
literal|10
expr_stmt|;
name|synth_freq
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|range
operator|=
literal|5
expr_stmt|;
name|max_spurcounts
operator|=
literal|2
expr_stmt|;
comment|/* Hardcoded by Jupiter Systems team for now. */
name|synth_freq
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
block|}
else|else
block|{
name|range
operator|=
literal|10
expr_stmt|;
name|max_spurcounts
operator|=
literal|4
expr_stmt|;
comment|/* Hardcoded by Osprey Systems team for now. */
name|synth_freq
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_spurcounts
condition|;
name|i
operator|++
control|)
block|{
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|cur_bb_spur
operator|=
name|FBIN2FREQ
argument_list|(
name|spur_fbin_ptr
index|[
name|i
index|]
argument_list|,
name|HAL_FREQ_BAND_2GHZ
argument_list|)
operator|-
name|synth_freq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|cur_bb_spur
operator|=
name|spur_freq_for_jupiter
index|[
name|i
index|]
operator|-
name|synth_freq
expr_stmt|;
block|}
else|else
block|{
name|cur_bb_spur
operator|=
name|spur_freq_for_osprey
index|[
name|i
index|]
operator|-
name|synth_freq
expr_stmt|;
block|}
if|if
condition|(
name|cur_bb_spur
operator|<
literal|0
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|cur_bb_spur
operator|=
operator|-
name|cur_bb_spur
expr_stmt|;
block|}
if|if
condition|(
name|cur_bb_spur
operator|<
name|range
condition|)
block|{
name|cck_spur_freq
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|cur_bb_spur
operator|<<
literal|19
operator|)
operator|/
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
operator|==
literal|1
condition|)
block|{
name|cck_spur_freq
operator|=
operator|-
name|cck_spur_freq
expr_stmt|;
block|}
name|cck_spur_freq
operator|=
name|cck_spur_freq
operator|&
literal|0xfffff
expr_stmt|;
comment|/*OS_REG_WRITE_field(ah, BB_agc_control.ycok_max, 0x7);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_YCOK_MAX
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE_field(ah, BB_cck_spur_mit.spur_rssi_thr, 0x7f);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE(ah, BB_cck_spur_mit.spur_filter_type, 0x2);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_SPUR_FILTER_TYPE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE(ah, BB_cck_spur_mit.use_cck_spur_mit, 0x1);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE(ah, BB_cck_spur_mit.cck_spur_freq, cck_spur_freq);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ
argument_list|,
name|cck_spur_freq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*OS_REG_WRITE(ah, BB_agc_control.ycok_max, 0x5);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_YCOK_MAX
argument_list|,
literal|0x5
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE(ah, BB_cck_spur_mit.use_cck_spur_mit, 0x0);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/*OS_REG_WRITE(ah, BB_cck_spur_mit.cck_spur_freq, 0x0);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_SPUR_MIT
argument_list|,
name|AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Spur mitigation for OFDM */
end_comment

begin_function
specifier|static
name|void
name|ar9300_spur_mitigate_ofdm
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|synth_freq
decl_stmt|;
name|int
name|range
init|=
literal|10
decl_stmt|;
name|int
name|freq_offset
init|=
literal|0
decl_stmt|;
name|int
name|spur_freq_sd
init|=
literal|0
decl_stmt|;
name|int
name|spur_subchannel_sd
init|=
literal|0
decl_stmt|;
name|int
name|spur_delta_phase
init|=
literal|0
decl_stmt|;
name|int
name|mask_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|u_int8_t
modifier|*
name|spur_chans_ptr
decl_stmt|;
if|if
condition|(
name|IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|spur_chans_ptr
operator|=
name|ar9300_eeprom_get_spur_chans_ptr
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|spur_chans_ptr
operator|=
name|ar9300_eeprom_get_spur_chans_ptr
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|range
operator|=
literal|19
expr_stmt|;
if|if
condition|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|,
name|AR_PHY_GC_DYN2040_PRI_CH
argument_list|)
operator|==
literal|0x0
condition|)
block|{
name|synth_freq
operator|=
name|chan
operator|->
name|channel
operator|-
literal|10
expr_stmt|;
block|}
else|else
block|{
name|synth_freq
operator|=
name|chan
operator|->
name|channel
operator|+
literal|10
expr_stmt|;
block|}
block|}
else|else
block|{
name|range
operator|=
literal|10
expr_stmt|;
name|synth_freq
operator|=
name|chan
operator|->
name|channel
expr_stmt|;
block|}
comment|/* Clean all spur register fields */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_SPUR_FILTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_SPUR_FREQ_SD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_SPUR_RSSI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_ENABLE_MASK_PPM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_PILOT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_CHAN_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_MASK_A
argument_list|,
name|AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_MASK_A
argument_list|,
name|AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_MASK_RATE_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|spur_chans_ptr
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|5
condition|)
block|{
name|freq_offset
operator|=
name|FBIN2FREQ
argument_list|(
name|spur_chans_ptr
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
operator|-
name|synth_freq
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|freq_offset
argument_list|)
operator|<
name|range
condition|)
block|{
comment|/*             printf(                 "Spur Mitigation for OFDM: Synth Frequency = %d, "                 "Spur Frequency = %d\n",                 synth_freq, FBIN2FREQ(spur_chans_ptr[i], mode));              */
if|if
condition|(
name|IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|freq_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|,
name|AR_PHY_GC_DYN2040_PRI_CH
argument_list|)
operator|==
literal|0x0
condition|)
block|{
name|spur_subchannel_sd
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|spur_subchannel_sd
operator|=
literal|0
expr_stmt|;
block|}
name|spur_freq_sd
operator|=
operator|(
operator|(
name|freq_offset
operator|+
literal|10
operator|)
operator|<<
literal|9
operator|)
operator|/
literal|11
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_GEN_CTRL
argument_list|,
name|AR_PHY_GC_DYN2040_PRI_CH
argument_list|)
operator|==
literal|0x0
condition|)
block|{
name|spur_subchannel_sd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|spur_subchannel_sd
operator|=
literal|1
expr_stmt|;
block|}
name|spur_freq_sd
operator|=
operator|(
operator|(
name|freq_offset
operator|-
literal|10
operator|)
operator|<<
literal|9
operator|)
operator|/
literal|11
expr_stmt|;
block|}
name|spur_delta_phase
operator|=
operator|(
name|freq_offset
operator|<<
literal|17
operator|)
operator|/
literal|5
expr_stmt|;
block|}
else|else
block|{
name|spur_subchannel_sd
operator|=
literal|0
expr_stmt|;
name|spur_freq_sd
operator|=
operator|(
name|freq_offset
operator|<<
literal|9
operator|)
operator|/
literal|11
expr_stmt|;
name|spur_delta_phase
operator|=
operator|(
name|freq_offset
operator|<<
literal|18
operator|)
operator|/
literal|5
expr_stmt|;
block|}
name|spur_freq_sd
operator|=
name|spur_freq_sd
operator|&
literal|0x3ff
expr_stmt|;
name|spur_delta_phase
operator|=
name|spur_delta_phase
operator|&
literal|0xfffff
expr_stmt|;
comment|/*             printf(                 "spur_subchannel_sd = %d, spur_freq_sd = 0x%x, "                 "spur_delta_phase = 0x%x\n", spur_subchannel_sd,                 spur_freq_sd, spur_delta_phase);              */
comment|/* OFDM Spur mitigation */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_SPUR_FILTER
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_SPUR_FREQ_SD
argument_list|,
name|spur_freq_sd
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_SPUR_DELTA_PHASE
argument_list|,
name|spur_delta_phase
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD
argument_list|,
name|spur_subchannel_sd
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING11
argument_list|,
name|AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_SPUR_RSSI
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_SPUR_RSSI_THRESH
argument_list|,
literal|34
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*              * Do not subtract spur power from noise floor for wasp.              * This causes the maximum client test (on Veriwave) to fail              * when run on spur channel (2464 MHz).              * Refer to ev#82746 and ev#82744.              */
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|AR_PHY_MODE_DYNAMIC
argument_list|)
operator|==
literal|0x1
operator|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mask_index
operator|=
operator|(
name|freq_offset
operator|<<
literal|4
operator|)
operator|/
literal|5
expr_stmt|;
if|if
condition|(
name|mask_index
operator|<
literal|0
condition|)
block|{
name|mask_index
operator|=
name|mask_index
operator|-
literal|1
expr_stmt|;
block|}
name|mask_index
operator|=
name|mask_index
operator|&
literal|0x7f
expr_stmt|;
comment|/*printf("Bin 0x%x\n", mask_index);*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_ENABLE_MASK_PPM
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_PILOT_MASK
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_ENABLE_CHAN_MASK
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A
argument_list|,
name|mask_index
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_MASK_A
argument_list|,
name|AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A
argument_list|,
name|mask_index
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A
argument_list|,
name|mask_index
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK
argument_list|,
name|AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK
argument_list|,
name|AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_MASK_A
argument_list|,
name|AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SPUR_REG
argument_list|,
name|AR_PHY_SPUR_REG_MASK_RATE_CNTL
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/*             printf("BB_timing_control_4 = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_TIMING4));             printf("BB_timing_control_11 = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_TIMING11));             printf("BB_ext_chan_scorr_thr = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_SFCORR_EXT));             printf("BB_spur_mask_controls = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_SPUR_REG));             printf("BB_pilot_spur_mask = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_PILOT_SPUR_MASK));             printf("BB_chan_spur_mask = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_CHAN_SPUR_MASK));             printf("BB_vit_spur_mask_A = 0x%x\n",                 OS_REG_READ(ah, AR_PHY_SPUR_MASK_A));              */
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert to baseband spur frequency given input channel frequency   * and compute register settings below.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_spur_mitigate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|ar9300_spur_mitigate_ofdm
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ar9300_spur_mitigate_mrc_cck
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************  * ar9300_channel_change  * Assumes caller wants to change channel, and not reset.  */
end_comment

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_channel_change
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|HAL_HT_MACMODE
name|macmode
parameter_list|)
block|{
name|u_int32_t
name|synth_delay
decl_stmt|,
name|qnum
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* TX must be stopped by now */
for|for
control|(
name|qnum
operator|=
literal|0
init|;
name|qnum
operator|<
name|AR_NUM_QCU
condition|;
name|qnum
operator|++
control|)
block|{
if|if
condition|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: Transmit frames pending on queue %d\n"
argument_list|,
name|__func__
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
block|}
comment|/*      * Kill last Baseband Rx Frame - Request analog bus grant      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_REQ
argument_list|,
name|AR_PHY_RFBUS_REQ_EN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_GRANT
argument_list|,
name|AR_PHY_RFBUS_GRANT_EN
argument_list|,
name|AR_PHY_RFBUS_GRANT_EN
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_PHY_IO
argument_list|,
literal|"%s: Could not kill baseband RX\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Setup 11n MAC/Phy mode registers */
name|ar9300_set_11n_regs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
comment|/*      * Change the synth      */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rf_hal
operator|.
name|set_channel
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: failed to set channel\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*       * Some registers get reinitialized during ATH_INI_POST INI programming.       */
name|ar9300_init_user_settings
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * Setup the transmit power values.      *      * After the public to private hal channel mapping, ichan contains the      * valid regulatory power value.      * ath_hal_getctl and ath_hal_getantennaallowed look up ichan from chan.      */
if|if
condition|(
name|ar9300_eeprom_set_transmit_power
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_eeprom
argument_list|,
name|ichan
argument_list|,
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_getantennaallowed
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_get_twice_max_regpower
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ichan
argument_list|,
name|chan
argument_list|)
argument_list|,
name|AH_MIN
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_power_limit
argument_list|)
argument_list|)
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*      * Release the RFBus Grant.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RFBUS_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Write spur immunity and delta slope for OFDM enabled modes (A, G, Turbo)      */
if|if
condition|(
name|IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar9300_set_delta_slope
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set to Ini default */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING3
argument_list|,
literal|0x9c0a9f6b
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SGI_DELTA
argument_list|,
literal|0x00046384
argument_list|)
expr_stmt|;
block|}
name|ar9300_spur_mitigate
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/*      * Wait for the frequency synth to settle (synth goes on via PHY_ACTIVE_EN).      * Read the phy active delay register. Value is in 100ns increments.      */
name|synth_delay
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synth_delay
operator|=
operator|(
literal|4
operator|*
name|synth_delay
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synth_delay
operator|/=
literal|10
expr_stmt|;
block|}
name|OS_DELAY
argument_list|(
name|synth_delay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
comment|/*      * Do calibration.      */
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|void
name|ar9300_set_operating_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|AR_STA_ID1_STA_AP
operator||
name|AR_STA_ID1_ADHOC
operator|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|HAL_M_HOSTAP
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_STA_AP
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_AP_ADHOC_INDICATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_IBSS
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_ADHOC
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_AP_ADHOC_INDICATION
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_M_STA
case|:
case|case
name|HAL_M_MONITOR
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|val
operator||
name|AR_STA_ID1_KSRCH_MODE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* XXX need the logic for Osprey */
end_comment

begin_function
specifier|inline
name|void
name|ar9300_init_pll
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|pll
decl_stmt|;
name|u_int8_t
name|clk_25mhz
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|clk_25mhz
decl_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|clk_25mhz
condition|)
block|{
comment|/* Hornet uses PLL_CONTROL_2. Xtal is 25MHz for Hornet.              * REFDIV set to 0x1.              * $xtal_freq = 25;              * $PLL2_div = (704/$xtal_freq); # 176 * 4 = 704.              * MAC and BB run at 176 MHz.              * $PLL2_divint = int($PLL2_div);              * $PLL2_divfrac = $PLL2_div - $PLL2_divint;              * $PLL2_divfrac = int($PLL2_divfrac * 0x4000); # 2^14              * $PLL2_Val = ($PLL2_divint& 0x3f)<< 19 | (0x1)<< 14 |              *     $PLL2_divfrac& 0x3fff;              * Therefore, $PLL2_Val = 0xe04a3d              */
define|#
directive|define
name|DPLL2_KD_VAL
value|0x1D
define|#
directive|define
name|DPLL2_KI_VAL
value|0x06
define|#
directive|define
name|DPLL3_PHASE_SHIFT_VAL
value|0x1
comment|/* Rewrite DDR PLL2 and PLL3 */
comment|/* program DDR PLL ki and kd value, ki=0x6, kd=0x1d */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_DDR_DPLL2
argument_list|,
literal|0x18e82f01
argument_list|)
expr_stmt|;
comment|/* program DDR PLL phase_shift to 0x1 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_DDR_DPLL3
argument_list|,
name|AR_PHY_BB_DPLL3_PHASE_SHIFT
argument_list|,
name|DPLL3_PHASE_SHIFT_VAL
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x1142c
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* program refdiv, nint, frac to RTC register */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL2
argument_list|,
literal|0xe04a3d
argument_list|)
expr_stmt|;
comment|/* program BB PLL ki and kd value, ki=0x6, kd=0x1d */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KD
argument_list|,
name|DPLL2_KD_VAL
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KI
argument_list|,
name|DPLL2_KI_VAL
argument_list|)
expr_stmt|;
comment|/* program BB PLL phase_shift to 0x1 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL3
argument_list|,
name|AR_PHY_BB_DPLL3_PHASE_SHIFT
argument_list|,
name|DPLL3_PHASE_SHIFT_VAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 40MHz */
undef|#
directive|undef
name|DPLL2_KD_VAL
undef|#
directive|undef
name|DPLL2_KI_VAL
define|#
directive|define
name|DPLL2_KD_VAL
value|0x3D
define|#
directive|define
name|DPLL2_KI_VAL
value|0x06
comment|/* Rewrite DDR PLL2 and PLL3 */
comment|/* program DDR PLL ki and kd value, ki=0x6, kd=0x3d */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_DDR_DPLL2
argument_list|,
literal|0x19e82f01
argument_list|)
expr_stmt|;
comment|/* program DDR PLL phase_shift to 0x1 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_DDR_DPLL3
argument_list|,
name|AR_PHY_BB_DPLL3_PHASE_SHIFT
argument_list|,
name|DPLL3_PHASE_SHIFT_VAL
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x1142c
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* program refdiv, nint, frac to RTC register */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL2
argument_list|,
literal|0x886666
argument_list|)
expr_stmt|;
comment|/* program BB PLL ki and kd value, ki=0x6, kd=0x3d */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KD
argument_list|,
name|DPLL2_KD_VAL
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KI
argument_list|,
name|DPLL2_KI_VAL
argument_list|)
expr_stmt|;
comment|/* program BB PLL phase_shift to 0x1 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL3
argument_list|,
name|AR_PHY_BB_DPLL3_PHASE_SHIFT
argument_list|,
name|DPLL3_PHASE_SHIFT_VAL
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x142c
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_PLL_PWD
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* program BB PLL ki and kd value, ki=0x4, kd=0x40 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KD
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_KI
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL1
argument_list|,
name|AR_PHY_BB_DPLL1_REFDIV
argument_list|,
literal|0x5
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL1
argument_list|,
name|AR_PHY_BB_DPLL1_NINI
argument_list|,
literal|0x58
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL1
argument_list|,
name|AR_PHY_BB_DPLL1_NFRAC
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_OUTDIV
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_LOCAL_PLL
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_EN_NEGTRIG
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* program BB PLL phase_shift to 0x6 */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL3
argument_list|,
name|AR_PHY_BB_DPLL3_PHASE_SHIFT
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_BB_DPLL2
argument_list|,
name|AR_PHY_BB_DPLL2_PLL_PWD
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x142c
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
define|#
directive|define
name|SRIF_PLL
value|1
name|u_int32_t
name|regdata
decl_stmt|,
name|pll2_divint
decl_stmt|,
name|pll2_divfrac
decl_stmt|;
ifndef|#
directive|ifndef
name|SRIF_PLL
name|u_int32_t
name|pll2_clkmode
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SRIF_PLL
name|u_int32_t
name|refdiv
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|clk_25mhz
condition|)
block|{
ifndef|#
directive|ifndef
name|SRIF_PLL
name|pll2_divint
operator|=
literal|0x1c
expr_stmt|;
name|pll2_divfrac
operator|=
literal|0xa3d7
expr_stmt|;
else|#
directive|else
name|pll2_divint
operator|=
literal|0x54
expr_stmt|;
name|pll2_divfrac
operator|=
literal|0x1eb85
expr_stmt|;
name|refdiv
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|SRIF_PLL
name|pll2_divint
operator|=
literal|0x11
expr_stmt|;
name|pll2_divfrac
operator|=
literal|0x26666
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|pll2_divint
operator|=
literal|88
expr_stmt|;
name|pll2_divfrac
operator|=
literal|0
expr_stmt|;
name|refdiv
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|pll2_divint
operator|=
literal|0x11
expr_stmt|;
name|pll2_divfrac
operator|=
literal|0x26666
expr_stmt|;
name|refdiv
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|SRIF_PLL
name|pll2_clkmode
operator|=
literal|0x3d
expr_stmt|;
endif|#
directive|endif
comment|/* PLL programming through SRIF Local Mode */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x1142c
argument_list|)
expr_stmt|;
comment|/* Bypass mode */
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
do|do
block|{
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|)
expr_stmt|;
name|regdata
operator|=
name|regdata
operator||
operator|(
literal|0x1
operator|<<
literal|16
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
comment|/* PWD_PLL set to 1 */
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* override int, frac, refdiv */
ifndef|#
directive|ifndef
name|SRIF_PLL
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CONTROL
argument_list|,
operator|(
operator|(
literal|1
operator|<<
literal|27
operator|)
operator||
operator|(
name|pll2_divint
operator|<<
literal|18
operator|)
operator||
name|pll2_divfrac
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_CONTROL
argument_list|,
operator|(
operator|(
name|refdiv
operator|<<
literal|27
operator|)
operator||
operator|(
name|pll2_divint
operator|<<
literal|18
operator|)
operator||
name|pll2_divfrac
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SRIF_PLL
name|regdata
operator|=
operator|(
name|regdata
operator|&
literal|0x80071fff
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|30
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator||
operator|(
literal|0x6
operator|<<
literal|26
operator|)
operator||
operator|(
name|pll2_clkmode
operator|<<
literal|19
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|regdata
operator|=
operator|(
name|regdata
operator|&
literal|0x80071fff
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|30
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator||
operator|(
literal|0x4
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0x18
operator|<<
literal|19
operator|)
expr_stmt|;
block|}
else|else
block|{
name|regdata
operator|=
operator|(
name|regdata
operator|&
literal|0x80071fff
operator|)
operator||
operator|(
literal|0x3
operator|<<
literal|30
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator||
operator|(
literal|0x4
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0x60
operator|<<
literal|19
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Ki, Kd, Local PLL, Outdiv */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|)
expr_stmt|;
name|regdata
operator|=
operator|(
name|regdata
operator|&
literal|0xfffeffff
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_MODE
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
comment|/* PWD_PLL set to 0 */
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* clear do measure */
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|)
expr_stmt|;
name|regdata
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* set do measure */
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|)
expr_stmt|;
name|regdata
operator||=
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
comment|/* wait for measure done */
do|do
block|{
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL4
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|regdata
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* clear do measure */
name|regdata
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|)
expr_stmt|;
name|regdata
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|,
name|regdata
argument_list|)
expr_stmt|;
comment|/* get measure sqsum dvc */
name|regdata
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_PLL_BB_DPLL3
argument_list|)
operator|&
literal|0x007FFFF8
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|regdata
operator|>=
literal|0x40000
condition|)
do|;
comment|/* Remove from Bypass mode */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
literal|0x142c
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pll
operator|=
name|SM
argument_list|(
literal|0x5
argument_list|,
name|AR_RTC_PLL_REFDIV
argument_list|)
expr_stmt|;
comment|/* Supposedly not needed on Osprey */
if|#
directive|if
literal|0
block|if (chan&& IS_CHAN_HALF_RATE(chan)) {             pll |= SM(0x1, AR_RTC_PLL_CLKSEL);         } else if (chan&& IS_CHAN_QUARTER_RATE(chan)) {             pll |= SM(0x2, AR_RTC_PLL_CLKSEL);         }
endif|#
directive|endif
if|if
condition|(
name|chan
operator|&&
name|IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|pll
operator||=
name|SM
argument_list|(
literal|0x28
argument_list|,
name|AR_RTC_PLL_DIV
argument_list|)
expr_stmt|;
comment|/*               * When doing fast clock, set PLL to 0x142c              */
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|pll
operator|=
literal|0x142c
expr_stmt|;
block|}
block|}
else|else
block|{
name|pll
operator||=
name|SM
argument_list|(
literal|0x2c
argument_list|,
name|AR_RTC_PLL_DIV
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_PLL_CONTROL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
block|}
comment|/* TODO:      * For multi-band owl, switch between bands by reiniting the PLL.      */
name|OS_DELAY
argument_list|(
name|RTC_PLL_SETTLE_DELAY
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_SLEEP_CLK
argument_list|,
name|AR_RTC_FORCE_DERIVED_CLK
operator||
name|AR_RTC_PCIE_RST_PWDN_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|clk_25mhz
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_DERIVED_RTC_CLK
argument_list|,
operator|(
literal|0x17c
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 32KHz sleep clk */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_MODE
argument_list|,
literal|0x0010f3d7
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_INC
argument_list|,
literal|0x0001e7ae
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_DERIVED_RTC_CLK
argument_list|,
operator|(
literal|0x261
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 32KHz sleep clk */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_MODE
argument_list|,
literal|0x0010f400
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP32_INC
argument_list|,
literal|0x0001e800
argument_list|)
expr_stmt|;
block|}
name|OS_DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_set_reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|u_int32_t
name|rst_flags
decl_stmt|;
name|u_int32_t
name|tmp_reg
decl_stmt|;
name|HALASSERT
argument_list|(
name|type
operator|==
name|HAL_RESET_WARM
operator|||
name|type
operator|==
name|HAL_RESET_COLD
argument_list|)
expr_stmt|;
comment|/*      * RTC Force wake should be done before resetting the MAC.      * MDK/ART does it that way.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wa_reg_val
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* delay to allow AR_WA reg write to kick in */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
operator||
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
comment|/* Reset AHB */
comment|/* Bug26871 */
name|tmp_reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp_reg
operator|&
operator|(
name|AR9340_INTR_SYNC_LOCAL_TIMEOUT
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|,
name|AR_RC_HOSTIF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tmp_reg
operator|&
operator|(
name|AR9300_INTR_SYNC_LOCAL_TIMEOUT
operator||
name|AR9300_INTR_SYNC_RADM_CPL_TIMEOUT
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|,
name|AR_RC_HOSTIF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NO AR_RC_AHB in Osprey */
comment|/*OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_RC), AR_RC_AHB);*/
block|}
block|}
name|rst_flags
operator|=
name|AR_RTC_RC_MAC_WARM
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|HAL_RESET_COLD
condition|)
block|{
name|rst_flags
operator||=
name|AR_RTC_RC_MAC_COLD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AH_SUPPORT_HORNET
comment|/* Hornet WAR: trigger SoC to reset WMAC if ...      * (1) doing cold reset. Ref: EV 69254       * (2) beacon pending. Ref: EV 70983      */
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_total_queues
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|||
name|type
operator|==
name|HAL_RESET_COLD
operator|)
condition|)
block|{
name|u_int32_t
name|time_out
decl_stmt|;
define|#
directive|define
name|AR_SOC_RST_RESET
value|0xB806001C
define|#
directive|define
name|AR_SOC_BOOT_STRAP
value|0xB80600AC
define|#
directive|define
name|AR_SOC_WLAN_RST
value|0x00000800
comment|/* WLAN reset */
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val);
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Hornet SoC reset WMAC.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|AR_SOC_RST_RESET
argument_list|,
name|REG_READ
argument_list|(
name|AR_SOC_RST_RESET
argument_list|)
operator||
name|AR_SOC_WLAN_RST
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|AR_SOC_RST_RESET
argument_list|,
name|REG_READ
argument_list|(
name|AR_SOC_RST_RESET
argument_list|)
operator|&
operator|(
operator|~
name|AR_SOC_WLAN_RST
operator|)
argument_list|)
expr_stmt|;
name|time_out
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tmp_reg
operator|=
name|REG_READ
argument_list|(
name|AR_SOC_BOOT_STRAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_reg
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|time_out
operator|>
literal|20
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|time_out
operator|++
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
undef|#
directive|undef
name|AR_SOC_WLAN_RST
undef|#
directive|undef
name|AR_SOC_RST_RESET
undef|#
directive|undef
name|AR_SOC_BOOT_STRAP
block|}
endif|#
directive|endif
comment|/* AH_SUPPORT_HORNET */
ifdef|#
directive|ifdef
name|AH_SUPPORT_SCORPION
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
define|#
directive|define
name|DDR_CTL_CONFIG_ADDRESS
value|0xb8000000
define|#
directive|define
name|DDR_CTL_CONFIG_OFFSET
value|0x0108
define|#
directive|define
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB
value|29
define|#
directive|define
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB
value|21
define|#
directive|define
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK
value|0x3fe00000
define|#
directive|define
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET
parameter_list|(
name|x
parameter_list|)
value|(((x)& DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)>> DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)
define|#
directive|define
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET
parameter_list|(
name|x
parameter_list|)
value|(((x)<< DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)& DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)
define|#
directive|define
name|MAC_DMA_CFG_ADDRESS
value|0xb8100000
define|#
directive|define
name|MAC_DMA_CFG_OFFSET
value|0x0014
define|#
directive|define
name|MAC_DMA_CFG_HALT_REQ_MSB
value|11
define|#
directive|define
name|MAC_DMA_CFG_HALT_REQ_LSB
value|11
define|#
directive|define
name|MAC_DMA_CFG_HALT_REQ_MASK
value|0x00000800
define|#
directive|define
name|MAC_DMA_CFG_HALT_REQ_GET
parameter_list|(
name|x
parameter_list|)
value|(((x)& MAC_DMA_CFG_HALT_REQ_MASK)>> MAC_DMA_CFG_HALT_REQ_LSB)
define|#
directive|define
name|MAC_DMA_CFG_HALT_REQ_SET
parameter_list|(
name|x
parameter_list|)
value|(((x)<< MAC_DMA_CFG_HALT_REQ_LSB)& MAC_DMA_CFG_HALT_REQ_MASK)
define|#
directive|define
name|MAC_DMA_CFG_HALT_ACK_MSB
value|12
define|#
directive|define
name|MAC_DMA_CFG_HALT_ACK_LSB
value|12
define|#
directive|define
name|MAC_DMA_CFG_HALT_ACK_MASK
value|0x00001000
define|#
directive|define
name|MAC_DMA_CFG_HALT_ACK_GET
parameter_list|(
name|x
parameter_list|)
value|(((x)& MAC_DMA_CFG_HALT_ACK_MASK)>> MAC_DMA_CFG_HALT_ACK_LSB)
define|#
directive|define
name|MAC_DMA_CFG_HALT_ACK_SET
parameter_list|(
name|x
parameter_list|)
value|(((x)<< MAC_DMA_CFG_HALT_ACK_LSB)& MAC_DMA_CFG_HALT_ACK_MASK)
define|#
directive|define
name|RST_RESET
value|0xB806001c
define|#
directive|define
name|RTC_RESET
value|(1<<27)
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val);
define|#
directive|define
name|DDR_REG_READ
parameter_list|(
name|_ah
parameter_list|,
name|_reg
parameter_list|)
define|\
value|*((volatile u_int32_t *)( DDR_CTL_CONFIG_ADDRESS + (_reg)))
define|#
directive|define
name|DDR_REG_WRITE
parameter_list|(
name|_ah
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|*((volatile u_int32_t *)(DDR_CTL_CONFIG_ADDRESS + (_reg))) = (_val)
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|MAC_DMA_CFG_OFFSET
argument_list|,
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|MAC_DMA_CFG_OFFSET
argument_list|)
operator|&
operator|~
name|MAC_DMA_CFG_HALT_REQ_MASK
operator|)
operator||
name|MAC_DMA_CFG_HALT_REQ_SET
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|u_int32_t
name|data
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|MAC_DMA_CFG_HALT_ACK_GET
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|MAC_DMA_CFG_OFFSET
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|10
condition|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"Halt ACK timeout\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|DDR_REG_READ
argument_list|(
name|ah
argument_list|,
name|DDR_CTL_CONFIG_OFFSET
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"check DDR Activity - HIGH\n"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET
argument_list|(
name|data
argument_list|)
condition|)
block|{
comment|//      AVE_DEBUG(0,"DDR Activity - HIGH\n");
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"DDR Activity - HIGH\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|data
operator|=
name|DDR_REG_READ
argument_list|(
name|ah
argument_list|,
name|DDR_CTL_CONFIG_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|10
condition|)
block|{
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"DDR Activity timeout\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|{
comment|//Force RTC reset
name|REG_WRITE
argument_list|(
name|RST_RESET
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|RST_RESET
argument_list|)
operator||
name|RTC_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|RST_RESET
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|RST_RESET
argument_list|)
operator|&
operator|~
name|RTC_RESET
operator|)
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"%s: Scorpion SoC RTC reset done.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
block|}
endif|#
directive|endif
comment|/* AH_SUPPORT_SCORPION */
comment|/*      * Set Mac(BB,Phy) Warm Reset      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
name|rst_flags
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* XXX 50 usec */
comment|/*      * Clear resets and force wakeup      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|,
name|AR_RTC_RC_M
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: RTC stuck in MAC reset\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: AR_RTC_RC = 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RC
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Clear AHB reset */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar9300_attach_hw_platform
argument_list|(
name|ah
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_set_reset_power_on
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
comment|/* Force wake */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wa_reg_val
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* delay to allow AR_WA reg write to kick in */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
operator||
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
comment|/*      * RTC reset and clear. Some delay in between is needed       * to give the chip time to settle.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Poll till RTC is ON      */
define|#
directive|define
name|AH_RTC_POLL_TIMEOUT
value|AH_WAIT_TIMEOUT
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|,
name|AR_RTC_STATUS_M
argument_list|,
name|AR_RTC_STATUS_ON
argument_list|,
name|AH_RTC_POLL_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: RTC not waking up for %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*      * Read Revisions from Chip right after RTC is on for the first time.      * This helps us detect the chip type early and initialize it accordingly.      */
name|ar9300_read_revisions
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * Warm reset if we aren't really powering on,      * just restarting the driver.      */
return|return
name|ar9300_set_reset
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_WARM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the given reset bit mask into the reset register  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_reset_reg
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|type
parameter_list|)
block|{
name|HAL_BOOL
name|ret
init|=
name|AH_FALSE
decl_stmt|;
comment|/*      * Set force wake      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_WA
argument_list|)
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_wa_reg_val
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* delay to allow AR_WA reg write to kick in */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_FORCE_WAKE
argument_list|,
name|AR_RTC_FORCE_WAKE_EN
operator||
name|AR_RTC_FORCE_WAKE_ON_INT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_RESET_POWER_ON
case|:
name|ret
operator|=
name|ar9300_set_reset_power_on
argument_list|(
name|ah
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_RESET_WARM
case|:
case|case
name|HAL_RESET_COLD
case|:
name|ret
operator|=
name|ar9300_set_reset
argument_list|(
name|ah
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_KEEP_AWAKE
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Places the PHY and Radio chips into reset.  A full reset  * must be called to leave this state.  The PCI/MAC/PCU are  * not placed into reset as we must receive interrupt to  * re-enable the hardware.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_phy_disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar9300_set_reset_reg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_WARM
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|ATH_SUPPORT_LED
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val);
define|#
directive|define
name|ATH_GPIO_OE
value|0xB8040000
define|#
directive|define
name|ATH_GPIO_OUT
value|0xB8040008
comment|/* GPIO Ouput Value reg.*/
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator||
operator|(
literal|0x1
operator|<<
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator||
operator|(
literal|0x1
operator|<<
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off JMPST led */
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OUT
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OUT
argument_list|)
operator||
operator|(
literal|0x1
operator|<<
literal|15
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
endif|#
directive|endif
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_OUTPUT_MUX1
argument_list|)
argument_list|,
literal|0x0
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
block|}
name|ar9300_init_pll
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Places all of hardware into reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_disable
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ar9300_set_power_mode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ar9300_set_reset_reg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_COLD
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|ar9300_init_pll
argument_list|(
name|ah
argument_list|,
name|AH_NULL
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: Only write the PLL if we're changing to or from CCK mode  *  * WARNING: The order of the PLL and mode registers must be correct.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_set_rf_mode
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|rf_mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|AH_NULL
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_hwp
condition|)
block|{
case|case
name|HAL_TRUE_CHIP
case|:
name|rf_mode
operator||=
operator|(
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|)
condition|?
name|AR_PHY_MODE_DYNAMIC
else|:
name|AR_PHY_MODE_OFDM
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  Phy mode bits for 5GHz channels requiring Fast Clock */
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|rf_mode
operator||=
operator|(
name|AR_PHY_MODE_DYNAMIC
operator||
name|AR_PHY_MODE_DYN_CCK_DISABLE
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|,
name|rf_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Places the hardware into reset and then pulls it out of reset  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_chip_reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_CHIPRESET
argument_list|,
name|chan
condition|?
name|chan
operator|->
name|channel
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Warm reset is optimistic.      */
if|if
condition|(
operator|!
name|ar9300_set_reset_reg
argument_list|(
name|ah
argument_list|,
name|HAL_RESET_WARM
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
comment|/* Bring out of sleep mode (AGAIN) */
if|if
condition|(
operator|!
name|ar9300_set_power_mode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|ahp
operator|->
name|ah_chip_full_sleep
operator|=
name|AH_FALSE
expr_stmt|;
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ar9300_internal_regulator_apply
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
name|ar9300_init_pll
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/*      * Perform warm reset before the mode/PLL/turbo registers      * are changed in order to deactivate the radio.  Mode changes      * with an active radio can result in corrupted shifts to the      * radio device.      */
name|ar9300_set_rf_mode
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* ar9300_setup_calibration  * Setup HW to collect samples used for current cal  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|ar9300_setup_calibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|curr_cal
parameter_list|)
block|{
comment|/* Select calibration to run */
switch|switch
condition|(
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
condition|)
block|{
case|case
name|IQ_MISMATCH_CAL
case|:
comment|/* Start calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_IQCAL_LOG_COUNT_MAX
argument_list|,
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_count_max
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CALMODE
argument_list|,
name|AR_PHY_CALMODE_IQ
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: starting IQ Mismatch Calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Kick-off cal */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_DO_CAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEMP_COMP_CAL
case|:
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_LOCAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HORNET_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM_JUPITER
argument_list|,
name|AR_PHY_65NM_CH0_THERM_LOCAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM_JUPITER
argument_list|,
name|AR_PHY_65NM_CH0_THERM_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_LOCAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_THERM
argument_list|,
name|AR_PHY_65NM_CH0_THERM_START
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: starting Temperature Compensation Calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s called with incorrect calibration type.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ar9300_reset_calibration  * Initialize shared data structures and prepare a cal to be run.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|ar9300_reset_calibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|curr_cal
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Setup HW for new calibration */
name|ar9300_setup_calibration
argument_list|(
name|ah
argument_list|,
name|curr_cal
argument_list|)
expr_stmt|;
comment|/* Change SW state to RUNNING for this calibration */
name|curr_cal
operator|->
name|cal_state
operator|=
name|CAL_RUNNING
expr_stmt|;
comment|/* Reset data structures shared between different calibrations */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
name|ahp
operator|->
name|ah_meas0
operator|.
name|sign
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_meas1
operator|.
name|sign
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_meas2
operator|.
name|sign
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_meas3
operator|.
name|sign
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_cal_samples
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XXX_UNUSED_FUNCTION
end_ifdef

begin_comment
comment|/*  * Find out which of the RX chains are enabled  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ar9300_get_rx_chain_mask
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|ret_val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_CHAINMASK
argument_list|)
decl_stmt|;
comment|/* The bits [2:0] indicate the rx chain mask and are to be      * interpreted as follows:      * 00x => Only chain 0 is enabled      * 01x => Chain 1 and 0 enabled      * 1xx => Chain 2,1 and 0 enabled      */
return|return
operator|(
name|ret_val
operator|&
literal|0x7
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ar9300_get_nf_hist_base
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|chan
parameter_list|,
name|int
name|is_scan
parameter_list|,
name|int16_t
name|nf
index|[]
parameter_list|)
block|{
name|HAL_NFCAL_BASE
modifier|*
name|h_base
decl_stmt|;
ifdef|#
directive|ifdef
name|ATH_NF_PER_CHAN
name|h_base
operator|=
operator|&
name|chan
operator|->
name|nf_cal_hist
operator|.
name|base
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|is_scan
condition|)
block|{
comment|/*          * The channel we are currently on is not the home channel,          * so we shouldn't use the home channel NF buffer's values on          * this channel.  Instead, use the NF single value already          * read for this channel.  (Or, if we haven't read the NF for          * this channel yet, the SW default for this chip/band will          * be used.)          */
name|h_base
operator|=
operator|&
name|chan
operator|->
name|nf_cal_hist
operator|.
name|base
expr_stmt|;
block|}
else|else
block|{
comment|/* use the home channel NF info */
name|h_base
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
operator|.
name|base
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_MEMCPY
argument_list|(
name|nf
argument_list|,
name|h_base
operator|->
name|priv_nf
argument_list|,
sizeof|sizeof
argument_list|(
name|h_base
operator|->
name|priv_nf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_load_nf
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int16_t
name|nf
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
comment|/* XXX where are EXT regs defined */
specifier|const
name|u_int32_t
name|ar9300_cca_regs
index|[]
init|=
block|{
name|AR_PHY_CCA_0
block|,
name|AR_PHY_CCA_1
block|,
name|AR_PHY_CCA_2
block|,
name|AR_PHY_EXT_CCA
block|,
name|AR_PHY_EXT_CCA_1
block|,
name|AR_PHY_EXT_CCA_2
block|,     }
decl_stmt|;
name|u_int8_t
name|chainmask
decl_stmt|;
comment|/*      * Force NF calibration for all chains, otherwise Vista station      * would conduct a bad performance      */
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|chainmask
operator|=
literal|0x9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|chainmask
operator|=
literal|0x1b
expr_stmt|;
block|}
else|else
block|{
name|chainmask
operator|=
literal|0x3F
expr_stmt|;
block|}
comment|/*      * Write filtered NF values into max_cca_pwr register parameter      * so we can load below.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|ar9300_cca_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|nf
index|[
name|i
index|]
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar9300_cca_regs
index|[
name|i
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Load software filtered NF value into baseband internal min_cca_pwr      * variable.      */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
comment|/* Wait for load to complete, should be fast, a few 10s of us. */
comment|/* Changed the max delay 250us back to 10000us, since 250us often      * results in NF load timeout and causes deaf condition      * during stress testing 12/12/2009      */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10000
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|10000
condition|)
block|{
comment|/*          * We timed out waiting for the noisefloor to load, probably          * due to an in-progress rx.  Simply return here and allow          * the load plenty of time to complete before the next           * calibration interval.  We need to avoid trying to load -50          * (which happens below) while the previous load is still in          * progress as this can cause rx deafness (see EV 66368,62830).          * Instead by returning here, the baseband nf cal will           * just be capped by our present noisefloor until the next          * calibration timer.          */
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: *** TIMEOUT while waiting for nf to load: "
literal|"AR_PHY_AGC_CONTROL=0x%x ***\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*      * Restore max_cca_power register parameter again so that we're not capped      * by the median we just loaded.  This will be initial (and max) value      * of next noise floor calibration the baseband does.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|ar9300_cca_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFFFFFE00
expr_stmt|;
name|val
operator||=
operator|(
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|-
literal|50
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|ar9300_cca_regs
index|[
name|i
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* ar9300_per_calibration  * Generic calibration routine.  * Recalibrate the lower PHY chips to account for temperature/environment  * changes.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|ar9300_per_calibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|u_int8_t
name|rxchainmask
parameter_list|,
name|HAL_CAL_LIST
modifier|*
name|curr_cal
parameter_list|,
name|HAL_BOOL
modifier|*
name|is_cal_done
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Cal is assumed not done until explicitly set below */
operator|*
name|is_cal_done
operator|=
name|AH_FALSE
expr_stmt|;
comment|/* Calibration in progress. */
if|if
condition|(
name|curr_cal
operator|->
name|cal_state
operator|==
name|CAL_RUNNING
condition|)
block|{
comment|/* Check to see if it has finished. */
if|if
condition|(
operator|!
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|)
operator|&
name|AR_PHY_TIMING4_DO_CAL
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|num_chains
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rxchainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|num_chains
operator|++
expr_stmt|;
block|}
block|}
comment|/*              * Accumulate cal measures for active chains              */
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_collect
argument_list|(
name|ah
argument_list|,
name|num_chains
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_cal_samples
operator|++
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_cal_samples
operator|>=
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_num_samples
condition|)
block|{
comment|/*                  * Process accumulated data                  */
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_post_proc
argument_list|(
name|ah
argument_list|,
name|num_chains
argument_list|)
expr_stmt|;
comment|/* Calibration has finished. */
name|ichan
operator|->
name|cal_valid
operator||=
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
expr_stmt|;
name|curr_cal
operator|->
name|cal_state
operator|=
name|CAL_DONE
expr_stmt|;
operator|*
name|is_cal_done
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Set-up collection of another sub-sample until we                  * get desired number                  */
name|ar9300_setup_calibration
argument_list|(
name|ah
argument_list|,
name|curr_cal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ichan
operator|->
name|cal_valid
operator|&
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
operator|)
condition|)
block|{
comment|/* If current cal is marked invalid in channel, kick it off */
name|ar9300_reset_calibration
argument_list|(
name|ah
argument_list|,
name|curr_cal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_start_nf_cal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_ENABLE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NO_UPDATE_NF
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_tsf32
operator|=
name|ar9300_get_tsf32
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ar9300_calibration  * Wrapper for a more generic Calibration routine. Primarily to abstract to  * upper layers whether there is 1 or more calibrations to be run.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_calibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|u_int8_t
name|rxchainmask
parameter_list|,
name|HAL_BOOL
name|do_nf_cal
parameter_list|,
name|HAL_BOOL
modifier|*
name|is_cal_done
parameter_list|,
name|int
name|is_scan
parameter_list|,
name|u_int32_t
modifier|*
name|sched_cals
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|curr_cal
init|=
name|ahp
operator|->
name|ah_cal_list_curr
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int16_t
name|nf_buf
index|[
name|NUM_NF_READINGS
index|]
decl_stmt|;
operator|*
name|is_cal_done
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* XXX: For initial wasp bringup - disable periodic calibration */
comment|/* Invalid channel check */
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Entering, Doing NF Cal = %d\n"
argument_list|,
name|__func__
argument_list|,
name|do_nf_cal
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Chain 0 Rx IQ Cal Correction 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Chain 1 Rx IQ Cal Correction 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|!
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Chain 2 Rx IQ Cal Correction 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_PERCAL
argument_list|,
name|chan
operator|->
name|channel
argument_list|)
expr_stmt|;
comment|/* For given calibration:      * 1. Call generic cal routine      * 2. When this cal is done (is_cal_done) if we have more cals waiting      *    (eg after reset), mask this to upper layers by not propagating      *    is_cal_done if it is set to TRUE.      *    Instead, change is_cal_done to FALSE and setup the waiting cal(s)      *    to be run.      */
if|if
condition|(
name|curr_cal
operator|&&
operator|(
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
operator|&
operator|*
name|sched_cals
operator|)
operator|&&
operator|(
name|curr_cal
operator|->
name|cal_state
operator|==
name|CAL_RUNNING
operator|||
name|curr_cal
operator|->
name|cal_state
operator|==
name|CAL_WAITING
operator|)
condition|)
block|{
name|ar9300_per_calibration
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|rxchainmask
argument_list|,
name|curr_cal
argument_list|,
name|is_cal_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_cal_done
operator|==
name|AH_TRUE
condition|)
block|{
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|curr_cal
operator|=
name|curr_cal
operator|->
name|cal_next
expr_stmt|;
if|if
condition|(
name|curr_cal
operator|&&
name|curr_cal
operator|->
name|cal_state
operator|==
name|CAL_WAITING
condition|)
block|{
operator|*
name|is_cal_done
operator|=
name|AH_FALSE
expr_stmt|;
name|ar9300_reset_calibration
argument_list|(
name|ah
argument_list|,
name|curr_cal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sched_cals
operator|&=
operator|~
name|IQ_MISMATCH_CAL
expr_stmt|;
block|}
block|}
block|}
comment|/* Do NF cal only at longer intervals */
if|if
condition|(
name|do_nf_cal
condition|)
block|{
name|int
name|nf_done
decl_stmt|;
comment|/* Get the value from the previous NF cal and update history buffer */
name|nf_done
operator|=
name|ar9300_store_new_nf
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|is_scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|->
name|channel_flags
operator|&
name|CHANNEL_CW_INT
condition|)
block|{
name|chan
operator|->
name|channel_flags
operator||=
name|CHANNEL_CW_INT
expr_stmt|;
block|}
name|ichan
operator|->
name|channel_flags
operator|&=
operator|(
operator|~
name|CHANNEL_CW_INT
operator|)
expr_stmt|;
if|if
condition|(
name|nf_done
condition|)
block|{
comment|/*              * Load the NF from history buffer of the current channel.              * NF is slow time-variant, so it is OK to use a historical value.              */
name|ar9300_get_nf_hist_base
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|,
name|is_scan
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
name|ar9300_load_nf
argument_list|(
name|ah
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
comment|/* start NF calibration, without updating BB NF register*/
name|ar9300_start_nf_cal
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* ar9300_iq_cal_collect  * Collect data from HW to later perform IQ Mismatch Calibration  */
end_comment

begin_function
name|void
name|ar9300_iq_cal_collect
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
name|num_chains
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Accumulate IQ cal measures for active chains      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chains
condition|;
name|i
operator|++
control|)
block|{
name|ahp
operator|->
name|ah_total_power_meas_i
index|[
name|i
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_MEAS_0
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_total_power_meas_q
index|[
name|i
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_MEAS_1
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_total_iq_corr_meas
index|[
name|i
index|]
operator|=
operator|(
name|int32_t
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_MEAS_2
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%d: Chn %d "
literal|"Reg Offset(0x%04x)pmi=0x%08x; "
literal|"Reg Offset(0x%04x)pmq=0x%08x; "
literal|"Reg Offset (0x%04x)iqcm=0x%08x;\n"
argument_list|,
name|ahp
operator|->
name|ah_cal_samples
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
operator|)
name|AR_PHY_CAL_MEAS_0
argument_list|(
name|i
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_total_power_meas_i
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|AR_PHY_CAL_MEAS_1
argument_list|(
name|i
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_total_power_meas_q
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|AR_PHY_CAL_MEAS_2
argument_list|(
name|i
argument_list|)
argument_list|,
name|ahp
operator|->
name|ah_total_iq_corr_meas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ar9300_iq_calibration  * Use HW data to perform IQ Mismatch Calibration  */
end_comment

begin_function
name|void
name|ar9300_iq_calibration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
name|num_chains
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|power_meas_q
decl_stmt|,
name|power_meas_i
decl_stmt|,
name|iq_corr_meas
decl_stmt|;
name|u_int32_t
name|q_coff_denom
decl_stmt|,
name|i_coff_denom
decl_stmt|;
name|int32_t
name|q_coff
decl_stmt|,
name|i_coff
decl_stmt|;
name|int
name|iq_corr_neg
decl_stmt|,
name|i
decl_stmt|;
specifier|static
specifier|const
name|u_int32_t
name|offset_array
index|[
literal|3
index|]
init|=
block|{
name|AR_PHY_RX_IQCAL_CORR_B0
block|,
name|AR_PHY_RX_IQCAL_CORR_B1
block|,
name|AR_PHY_RX_IQCAL_CORR_B2
block|,     }
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chains
condition|;
name|i
operator|++
control|)
block|{
name|power_meas_i
operator|=
name|ahp
operator|->
name|ah_total_power_meas_i
index|[
name|i
index|]
expr_stmt|;
name|power_meas_q
operator|=
name|ahp
operator|->
name|ah_total_power_meas_q
index|[
name|i
index|]
expr_stmt|;
name|iq_corr_meas
operator|=
name|ahp
operator|->
name|ah_total_iq_corr_meas
index|[
name|i
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Starting IQ Cal and Correction for Chain %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Orignal: Chn %diq_corr_meas = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|ahp
operator|->
name|ah_total_iq_corr_meas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iq_corr_neg
operator|=
literal|0
expr_stmt|;
comment|/* iq_corr_meas is always negative. */
if|if
condition|(
name|iq_corr_meas
operator|>
literal|0x80000000
condition|)
block|{
name|iq_corr_meas
operator|=
operator|(
literal|0xffffffff
operator|-
name|iq_corr_meas
operator|)
operator|+
literal|1
expr_stmt|;
name|iq_corr_neg
operator|=
literal|1
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Chn %d pwr_meas_i = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|power_meas_i
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Chn %d pwr_meas_q = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|power_meas_q
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"iq_corr_neg is 0x%08x\n"
argument_list|,
name|iq_corr_neg
argument_list|)
expr_stmt|;
name|i_coff_denom
operator|=
operator|(
name|power_meas_i
operator|/
literal|2
operator|+
name|power_meas_q
operator|/
literal|2
operator|)
operator|/
literal|256
expr_stmt|;
name|q_coff_denom
operator|=
name|power_meas_q
operator|/
literal|64
expr_stmt|;
comment|/* Protect against divide-by-0 */
if|if
condition|(
operator|(
name|i_coff_denom
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|q_coff_denom
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* IQ corr_meas is already negated if iqcorr_neg == 1 */
name|i_coff
operator|=
name|iq_corr_meas
operator|/
name|i_coff_denom
expr_stmt|;
name|q_coff
operator|=
name|power_meas_i
operator|/
name|q_coff_denom
operator|-
literal|64
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Chn %d i_coff = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|i_coff
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Chn %d q_coff = 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|q_coff
argument_list|)
expr_stmt|;
comment|/* Force bounds on i_coff */
if|if
condition|(
name|i_coff
operator|>=
literal|63
condition|)
block|{
name|i_coff
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_coff
operator|<=
operator|-
literal|63
condition|)
block|{
name|i_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
comment|/* Negate i_coff if iq_corr_neg == 0 */
if|if
condition|(
name|iq_corr_neg
operator|==
literal|0x0
condition|)
block|{
name|i_coff
operator|=
operator|-
name|i_coff
expr_stmt|;
block|}
comment|/* Force bounds on q_coff */
if|if
condition|(
name|q_coff
operator|>=
literal|63
condition|)
block|{
name|q_coff
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_coff
operator|<=
operator|-
literal|63
condition|)
block|{
name|q_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
name|i_coff
operator|=
name|i_coff
operator|&
literal|0x7f
expr_stmt|;
name|q_coff
operator|=
name|q_coff
operator|&
literal|0x7f
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Chn %d : i_coff = 0x%x  q_coff = 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i_coff
argument_list|,
name|q_coff
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Register offset (0x%04x) before update = 0x%x\n"
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF
argument_list|,
name|i_coff
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF
argument_list|,
name|q_coff
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Register offset (0x%04x) QI COFF (bitfields 0x%08x) "
literal|"after update = 0x%x\n"
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"Register offset (0x%04x) QQ COFF (bitfields 0x%08x) "
literal|"after update = 0x%x\n"
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|offset_array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"IQ Cal and Correction done for Chain %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"IQ Cal and Correction (offset 0x%04x) enabled "
literal|"(bit position 0x%08x). New Value 0x%08x\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|)
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a limit on the overall output power.  Used for dynamic  * transmit power control and the like.  *  * NB: limit is in units of 0.5 dbM.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_tx_power_limit
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|limit
parameter_list|,
name|u_int16_t
name|extra_txpow
parameter_list|,
name|u_int16_t
name|tpc_in_db
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ahpriv
operator|->
name|ah_curchan
decl_stmt|;
name|HAL_CHANNEL
modifier|*
name|chan
init|=
operator|(
name|HAL_CHANNEL
operator|*
operator|)
name|ichan
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|chan
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|ahpriv
operator|->
name|ah_power_limit
operator|=
name|AH_MIN
argument_list|(
name|limit
argument_list|,
name|MAX_RATE_POWER
argument_list|)
expr_stmt|;
name|ahpriv
operator|->
name|ah_extra_txpow
operator|=
name|extra_txpow
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|ar9300_eeprom_set_transmit_power
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_eeprom
argument_list|,
name|ichan
argument_list|,
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_getantennaallowed
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_get_twice_max_regpower
argument_list|(
name|ahpriv
argument_list|,
name|ichan
argument_list|,
name|chan
argument_list|)
argument_list|,
name|AH_MIN
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|ahpriv
operator|->
name|ah_power_limit
argument_list|)
argument_list|)
operator|!=
name|HAL_OK
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Exported call to check for a recent gain reading and return  * the current state of the thermal calibration gain engine.  */
end_comment

begin_function
name|HAL_RFGAIN
name|ar9300_get_rfgain
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|HAL_RFGAIN_INACTIVE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HAL_GREEN_AP_RX_MASK
value|0x1
end_define

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_chain_masks
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|rx_chainmask
parameter_list|,
name|int
name|tx_chainmask
parameter_list|)
block|{
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|green_ap_ps_on
condition|)
block|{
name|rx_chainmask
operator|=
name|HAL_GREEN_AP_RX_MASK
expr_stmt|;
block|}
if|if
condition|(
name|rx_chainmask
operator|==
literal|0x5
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ANALOG_SWAP
argument_list|,
name|AR_PHY_SWAP_ALT_CHAIN
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_CHAINMASK
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_CHAINMASK
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
comment|/*      * Adaptive Power Management:      * Some 3 stream chips exceed the PCIe power requirements.      * This workaround will reduce power consumption by using 2 tx chains      * for 1 and 2 stream rates (5 GHz only).      *      * Set the self gen mask to 2 tx chains when APM is enabled.      *      */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_enable_apm
operator|&&
operator|(
name|tx_chainmask
operator|==
literal|0x7
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SELFGEN_MASK
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SELFGEN_MASK
argument_list|,
name|tx_chainmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx_chainmask
operator|==
literal|0x5
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ANALOG_SWAP
argument_list|,
name|AR_PHY_SWAP_ALT_CHAIN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Override INI values with chip specific configuration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_override_ini
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
comment|/*      * Set the RX_ABORT and RX_DIS and clear it only after      * RXE is set for MAC. This prevents frames with      * corrupted descriptor status.      */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
operator|(
name|AR_DIAG_RX_DIS
operator||
name|AR_DIAG_RX_ABORT
operator|)
argument_list|)
expr_stmt|;
comment|/*      * For Merlin and above, there is a new feature that allows Multicast      * search based on both MAC Address and Key ID.      * By default, this feature is enabled.      * But since the driver is not using this feature, we switch it off;      * otherwise multicast search based on MAC addr only will fail.      */
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC_MODE2
argument_list|)
operator|&
operator|(
operator|~
name|AR_ADHOC_MCAST_KEYID_ENABLE
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC_MODE2
argument_list|,
name|val
operator||
name|AR_BUG_58603_FIX_ENABLE
operator||
name|AR_AGG_WEP_ENABLE
argument_list|)
expr_stmt|;
comment|/* Osprey revision specific configuration */
comment|/* Osprey 2.0+ - if SW RAC support is disabled, must also disable      * the Osprey 2.0 hardware RAC fix.      */
if|if
condition|(
name|p_cap
operator|->
name|hal_isr_rac_support
operator|==
name|AH_FALSE
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_MISSING_TX_INTR_FIX_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/* try to enable old pal if it is needed for h/w green tx */
name|ar9300_hwgreentx_set_pal_spare
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_prog_ini
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ar9300_ini_array
modifier|*
name|ini_arr
parameter_list|,
name|int
name|column
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reg_writes
init|=
literal|0
decl_stmt|;
comment|/* New INI format: Array may be undefined (pre, core, post arrays) */
if|if
condition|(
name|ini_arr
operator|->
name|ia_array
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/*      * New INI format: Pre, core, and post arrays for a given subsystem may be      * modal (> 2 columns) or non-modal (2 columns).      * Determine if the array is non-modal and force the column to 1.      */
if|if
condition|(
name|column
operator|>=
name|ini_arr
operator|->
name|ia_columns
condition|)
block|{
name|column
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ini_arr
operator|->
name|ia_rows
condition|;
name|i
operator|++
control|)
block|{
name|u_int32_t
name|reg
init|=
name|INI_RA
argument_list|(
name|ini_arr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int32_t
name|val
init|=
name|INI_RA
argument_list|(
name|ini_arr
argument_list|,
name|i
argument_list|,
name|column
argument_list|)
decl_stmt|;
comment|/*         ** Determine if this is a shift register value          ** (reg>= 0x16000&& reg< 0x17000 for Osprey) ,          ** and insert the configured delay if so.          ** -this delay is not required for Osprey (EV#71410)         */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|WAR_6773
argument_list|(
name|reg_writes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HAL_STATUS
name|ar9300_process_ini
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|HAL_HT_MACMODE
name|macmode
parameter_list|)
block|{
name|int
name|reg_writes
init|=
literal|0
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int
name|modes_index
decl_stmt|,
name|modes_txgaintable_index
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Setup the indices for the next set of register array writes */
comment|/* TODO:      * If the channel marker is indicative of the current mode rather      * than capability, we do not need to check the phy mode below.      */
switch|switch
condition|(
name|chan
operator|->
name|channel_flags
operator|&
name|CHANNEL_ALL
condition|)
block|{
case|case
name|CHANNEL_A
case|:
case|case
name|CHANNEL_A_HT20
case|:
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|channel
operator|<=
literal|5350
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|>
literal|5350
operator|)
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|<=
literal|5600
operator|)
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>
literal|5600
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|5
expr_stmt|;
block|}
block|}
name|modes_index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CHANNEL_A_HT40PLUS
case|:
case|case
name|CHANNEL_A_HT40MINUS
case|:
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|chan
operator|->
name|channel
operator|<=
literal|5350
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|chan
operator|->
name|channel
operator|>
literal|5350
operator|)
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|<=
literal|5600
operator|)
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chan
operator|->
name|channel
operator|>
literal|5600
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|6
expr_stmt|;
block|}
block|}
name|modes_index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CHANNEL_PUREG
case|:
case|case
name|CHANNEL_G_HT20
case|:
case|case
name|CHANNEL_B
case|:
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|8
expr_stmt|;
block|}
name|modes_index
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|CHANNEL_G_HT40PLUS
case|:
case|case
name|CHANNEL_G_HT40MINUS
case|:
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|modes_txgaintable_index
operator|=
literal|7
expr_stmt|;
block|}
name|modes_index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|CHANNEL_108G
case|:
name|modes_index
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|HALASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|HAL_EINVAL
return|;
block|}
if|#
directive|if
literal|0
comment|/* Set correct Baseband to analog shift setting to access analog chips. */
block|OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);
endif|#
directive|endif
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"ar9300_process_ini: "
literal|"Skipping OS-REG-WRITE(ah, AR-PHY(0), 0x00000007)\n"
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"ar9300_process_ini: no ADDac programming\n"
argument_list|)
expr_stmt|;
comment|/*      * Osprey 2.0+ - new INI format.      * Each subsystem has a pre, core, and post array.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_INI_NUM_SPLIT
condition|;
name|i
operator|++
control|)
block|{
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_soc
index|[
name|i
index|]
argument_list|,
name|modes_index
argument_list|)
expr_stmt|;
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_mac
index|[
name|i
index|]
argument_list|,
name|modes_index
argument_list|)
expr_stmt|;
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_bb
index|[
name|i
index|]
argument_list|,
name|modes_index
argument_list|)
expr_stmt|;
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_radio
index|[
name|i
index|]
argument_list|,
name|modes_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|ATH_INI_POST
operator|)
operator|&&
operator|(
name|AR_SREV_JUPITER_20
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_radio_post_sys2ant
argument_list|,
name|modes_index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|AR_SREV_SOC
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
comment|/* Doubler issue : Some board doesn't work well with MCS15. Turn off doubler after freq locking is complete*/
comment|//ath_hal_printf(ah, "%s[%d] ==== before reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Set synthon, synthover */
comment|//ath_hal_printf(ah, "%s[%d] ==== after reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX2
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Set synthon, synthover */
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX2
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Set synthon, synthover */
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|//ath_hal_printf(ah, "%s[%d] ==== before reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|)
expr_stmt|;
comment|/* clr synthon */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|)
expr_stmt|;
comment|/* clr synthon */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|)
expr_stmt|;
comment|/* clr synthon */
comment|//ath_hal_printf(ah, "%s[%d] ==== after reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//ath_hal_printf(ah, "%s[%d] ==== before reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set synthon */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set synthon */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX2
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set synthon */
comment|//ath_hal_printf(ah, "%s[%d] ==== after reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|//ath_hal_printf(ah, "%s[%d] ==== before reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_SYNTH12, OS_REG_READ(ah, AR_PHY_65NM_CH0_SYNTH12));
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_SYNTH12
argument_list|,
name|AR_PHY_65NM_CH0_SYNTH12_VREFMUL3
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
comment|//OS_REG_CLR_BIT(ah, AR_PHY_65NM_CH0_SYNTH12, 1<< 16); /* clr charge pump */
comment|//ath_hal_printf(ah, "%s[%d] ==== After  reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_SYNTH12, OS_REG_READ(ah, AR_PHY_65NM_CH0_SYNTH12));
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_RXTX2
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|)
expr_stmt|;
comment|/*Clr synthon, synthover */
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH1_RXTX2
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|)
expr_stmt|;
comment|/*Clr synthon, synthover */
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH2_RXTX2
argument_list|,
literal|0
argument_list|,
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S
operator||
literal|1
operator|<<
name|AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S
argument_list|)
expr_stmt|;
comment|/*Clr synthon, synthover */
comment|//ath_hal_printf(ah, "%s[%d] ==== after reg[0x%08x] = 0x%08x\n", __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));
block|}
comment|/* Write rxgain Array Parameters */
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_rxgain
argument_list|,
literal|1
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"ar9300_process_ini: Rx Gain programming\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Write rxgain bounds Array */
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_rxgain_bounds
argument_list|,
name|modes_index
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"ar9300_process_ini: Rx Gain table bounds programming\n"
argument_list|)
expr_stmt|;
block|}
comment|/* UB124 xLNA settings */
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
name|ar9300_rx_gain_index_get
argument_list|(
name|ah
argument_list|)
operator|==
literal|2
condition|)
block|{
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val);
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
name|u_int32_t
name|val
decl_stmt|;
comment|/* B8040000:  bit[0]=0, bit[3]=0; */
name|val
operator|=
name|REG_READ
argument_list|(
literal|0xB8040000
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xfffffff6
expr_stmt|;
name|REG_WRITE
argument_list|(
literal|0xB8040000
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* B804002c:  bit[31:24]=0x2e; bit[7:0]=0x2f; */
name|val
operator|=
name|REG_READ
argument_list|(
literal|0xB804002c
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0x00ffff00
expr_stmt|;
name|val
operator||=
literal|0x2e00002f
expr_stmt|;
name|REG_WRITE
argument_list|(
literal|0xB804002c
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* B804006c:  bit[1]=1; */
name|val
operator|=
name|REG_READ
argument_list|(
literal|0xB804006c
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x2
expr_stmt|;
name|REG_WRITE
argument_list|(
literal|0xB804006c
argument_list|,
name|val
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
block|}
comment|/* Write txgain Array Parameters */
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_txgain
argument_list|,
name|modes_txgaintable_index
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_txgain
argument_list|,
name|modes_index
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"ar9300_process_ini: Tx Gain programming\n"
argument_list|)
expr_stmt|;
comment|/* For 5GHz channels requiring Fast Clock, apply different modal values */
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Fast clock enabled, use special ini values\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_additional
argument_list|,
name|modes_index
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: use xtal ini for AH9300(ah)->clk_25mhz: %d\n"
argument_list|,
name|__func__
argument_list|,
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|clk_25mhz
argument_list|)
expr_stmt|;
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_additional
argument_list|,
literal|1
comment|/*modes_index*/
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|clk_25mhz
operator|==
literal|0
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Apply 40MHz ini settings\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ini_modes_additional_40mhz
argument_list|,
literal|1
comment|/*modesIndex*/
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|2484
operator|==
name|chan
operator|->
name|channel
condition|)
block|{
name|ar9300_prog_ini
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_ini_japan2484
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (AR_SREV_JUPITER_20(ah) || AR_SREV_APHRODITE(ah)) {         ar9300_prog_ini(ah,&ahp->ah_ini_BTCOEX_MAX_TXPWR, 1);     }
endif|#
directive|endif
comment|/* Override INI with chip specific configuration */
name|ar9300_override_ini
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* Setup 11n MAC/Phy mode registers */
name|ar9300_set_11n_regs
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
comment|/*      * Moved ar9300_init_chain_masks() here to ensure the swap bit is set before      * the pdadc table is written.  Swap must occur before any radio dependent      * replicated register access.  The pdadc curve addressing in particular      * depends on the consistent setting of the swap bit.      */
name|ar9300_init_chain_masks
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|ahp
operator|->
name|ah_tx_chainmask
argument_list|)
expr_stmt|;
comment|/*      * Setup the transmit power values.      *      * After the public to private hal channel mapping, ichan contains the      * valid regulatory power value.      * ath_hal_getctl and ath_hal_getantennaallowed look up ichan from chan.      */
name|status
operator|=
name|ar9300_eeprom_set_transmit_power
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_eeprom
argument_list|,
name|ichan
argument_list|,
name|ath_hal_getctl
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_getantennaallowed
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
argument_list|,
name|ath_hal_get_twice_max_regpower
argument_list|(
name|ahpriv
argument_list|,
name|ichan
argument_list|,
name|chan
argument_list|)
argument_list|,
name|AH_MIN
argument_list|(
name|MAX_RATE_POWER
argument_list|,
name|ahpriv
operator|->
name|ah_power_limit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|HAL_OK
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_POWER_MGMT
argument_list|,
literal|"%s: error init'ing transmit power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|HAL_EIO
return|;
block|}
return|return
name|HAL_OK
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/* ar9300_is_cal_supp  * Determine if calibration is supported by device and channel flags  */
end_comment

begin_function
specifier|inline
specifier|static
name|HAL_BOOL
name|ar9300_is_cal_supp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_CAL_TYPES
name|cal_type
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_BOOL
name|retval
init|=
name|AH_FALSE
decl_stmt|;
switch|switch
condition|(
name|cal_type
operator|&
name|ahp
operator|->
name|ah_supp_cals
condition|)
block|{
case|case
name|IQ_MISMATCH_CAL
case|:
comment|/* Run IQ Mismatch for non-CCK only */
if|if
condition|(
operator|!
name|IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|retval
operator|=
name|AH_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|TEMP_COMP_CAL
case|:
name|retval
operator|=
name|AH_TRUE
expr_stmt|;
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ar9285_pa_cal  * PA Calibration for Kite 1.1 and later versions of Kite.  * - from system's team.  */
end_comment

begin_comment
unit|static inline void ar9285_pa_cal(struct ath_hal *ah) {     u_int32_t reg_val;     int i, lo_gn, offs_6_1, offs_0;     u_int8_t reflo;     u_int32_t phy_test2_reg_val, phy_adc_ctl_reg_val;     u_int32_t an_top2_reg_val, phy_tst_dac_reg_val;
comment|/* Kite 1.1 WAR for Bug 35666       * Increase the LDO value to 1.28V before accessing analog Reg */
end_comment

begin_comment
unit|if (AR_SREV_KITE_11(ah)) {         OS_REG_WRITE(ah, AR9285_AN_TOP4, (AR9285_AN_TOP4_DEFAULT | 0x14) );     }     an_top2_reg_val = OS_REG_READ(ah, AR9285_AN_TOP2);
comment|/* set pdv2i pdrxtxbb */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RXTXBB1);     reg_val |= ((0x1<< 5) | (0x1<< 7));     OS_REG_WRITE(ah, AR9285_AN_RXTXBB1, reg_val);
comment|/* clear pwddb */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G7);     reg_val&= 0xfffffffd;     OS_REG_WRITE(ah, AR9285_AN_RF2G7, reg_val);
comment|/* clear enpacal */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);     reg_val&= 0xfffff7ff;     OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);
comment|/* set offcal */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G2);     reg_val |= (0x1<< 12);     OS_REG_WRITE(ah, AR9285_AN_RF2G2, reg_val);
comment|/* set pdpadrv1=pdpadrv2=pdpaout=1 */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);     reg_val |= (0x7<< 23);     OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);
comment|/* Read back reflo, increase it by 1 and write it. */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reflo = ((reg_val>> 26)& 0x7);          if (reflo< 0x7) {         reflo++;     }     reg_val = ((reg_val& 0xe3ffffff) | (reflo<< 26));     OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);      reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reflo = ((reg_val>> 26)& 0x7);
comment|/* use TX single carrier to transmit      * dac const      * reg. 15      */
end_comment

begin_comment
unit|phy_tst_dac_reg_val = OS_REG_READ(ah, AR_PHY_TSTDAC_CONST);     OS_REG_WRITE(ah, AR_PHY_TSTDAC_CONST, ((0x7ff<< 11) | 0x7ff));      reg_val = OS_REG_READ(ah, AR_PHY_TSTDAC_CONST);
comment|/* source is dac const      * reg. 2      */
end_comment

begin_comment
unit|phy_test2_reg_val = OS_REG_READ(ah, AR_PHY_TEST2);     OS_REG_WRITE(ah, AR_PHY_TEST2, ((0x1<< 7) | (0x1<< 1)));     reg_val = OS_REG_READ(ah, AR_PHY_TEST2);
comment|/* set dac on      * reg. 11      */
end_comment

begin_comment
unit|phy_adc_ctl_reg_val = OS_REG_READ(ah, AR_PHY_ADC_CTL);     OS_REG_WRITE(ah, AR_PHY_ADC_CTL, 0x80008000);     reg_val = OS_REG_READ(ah, AR_PHY_ADC_CTL);      OS_REG_WRITE(ah, AR9285_AN_TOP2, (0x1<< 27) | (0x1<< 17) | (0x1<< 16) |               (0x1<< 14) | (0x1<< 12) | (0x1<< 11) |               (0x1<< 7) | (0x1<< 5));      OS_DELAY(10);
comment|/* 10 usec */
end_comment

begin_comment
comment|/* clear off[6:0] */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);     reg_val&= 0xfc0fffff;     OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);     reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reg_val&= 0xfdffffff;     OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);      offs_6_1 = 0;     for (i = 6; i> 0; i--) {
comment|/* sef off[$k]==1 */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);         reg_val&= 0xfc0fffff;         reg_val = reg_val | (0x1<< (19 + i)) | ((offs_6_1)<< 20);         OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);         lo_gn = (OS_REG_READ(ah, AR9285_AN_RF2G9))& 0x1;         offs_6_1 = offs_6_1 | (lo_gn<< (i - 1));     }      reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);     reg_val&= 0xfc0fffff;     reg_val = reg_val | ((offs_6_1 - 1)<< 20);     OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);
comment|/* set off_0=1; */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reg_val&= 0xfdffffff;     reg_val = reg_val | (0x1<< 25);     OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);      lo_gn = OS_REG_READ(ah, AR9285_AN_RF2G9)& 0x1;     offs_0 = lo_gn;      reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reg_val&= 0xfdffffff;     reg_val = reg_val | (offs_0<< 25);     OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);
comment|/* clear pdv2i */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RXTXBB1);     reg_val&= 0xffffff5f;     OS_REG_WRITE(ah, AR9285_AN_RXTXBB1, reg_val);
comment|/* set enpacal */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);     reg_val |= (0x1<< 11);     OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);
comment|/* clear offcal */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G2);     reg_val&= 0xffffefff;     OS_REG_WRITE(ah, AR9285_AN_RF2G2, reg_val);
comment|/* set pdpadrv1=pdpadrv2=pdpaout=0 */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);     reg_val&= 0xfc7fffff;     OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);
comment|/* Read back reflo, decrease it by 1 and write it. */
end_comment

begin_comment
unit|reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reflo = (reg_val>> 26)& 0x7;     if (reflo) {         reflo--;     }     reg_val = ((reg_val& 0xe3ffffff) | (reflo<< 26));     OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);     reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);     reflo = (reg_val>> 26)& 0x7;
comment|/* write back registers */
end_comment

begin_comment
unit|OS_REG_WRITE(ah, AR_PHY_TSTDAC_CONST, phy_tst_dac_reg_val);     OS_REG_WRITE(ah, AR_PHY_TEST2, phy_test2_reg_val);     OS_REG_WRITE(ah, AR_PHY_ADC_CTL, phy_adc_ctl_reg_val);     OS_REG_WRITE(ah, AR9285_AN_TOP2, an_top2_reg_val);
comment|/* Kite 1.1 WAR for Bug 35666       * Decrease the LDO value back to 1.20V */
end_comment

begin_endif
unit|if (AR_SREV_KITE_11(ah)) {         OS_REG_WRITE(ah, AR9285_AN_TOP4, AR9285_AN_TOP4_DEFAULT);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ar9300_run_init_cals  * Runs non-periodic calibrations  */
end_comment

begin_function
specifier|inline
specifier|static
name|HAL_BOOL
name|ar9300_run_init_cals
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|init_cal_count
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
name|ichan
decl_stmt|;
comment|/* bogus */
name|HAL_BOOL
name|is_cal_done
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|curr_cal
decl_stmt|;
name|int
name|i
decl_stmt|;
name|curr_cal
operator|=
name|ahp
operator|->
name|ah_cal_list_curr
expr_stmt|;
if|if
condition|(
name|curr_cal
operator|==
name|AH_NULL
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|ichan
operator|.
name|cal_valid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|init_cal_count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Reset this Cal */
name|ar9300_reset_calibration
argument_list|(
name|ah
argument_list|,
name|curr_cal
argument_list|)
expr_stmt|;
comment|/* Poll for offset calibration complete */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING4
argument_list|,
name|AR_PHY_TIMING4_DO_CAL
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Cal %d failed to complete in 100ms.\n"
argument_list|,
name|__func__
argument_list|,
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
argument_list|)
expr_stmt|;
comment|/* Re-initialize list pointers for periodic cals */
name|ahp
operator|->
name|ah_cal_list
operator|=
name|ahp
operator|->
name|ah_cal_list_last
operator|=
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|AH_NULL
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Run this cal */
name|ar9300_per_calibration
argument_list|(
name|ah
argument_list|,
operator|&
name|ichan
argument_list|,
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|curr_cal
argument_list|,
operator|&
name|is_cal_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cal_done
operator|==
name|AH_FALSE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Not able to run Init Cal %d.\n"
argument_list|,
name|__func__
argument_list|,
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curr_cal
operator|->
name|cal_next
condition|)
block|{
name|curr_cal
operator|=
name|curr_cal
operator|->
name|cal_next
expr_stmt|;
block|}
block|}
comment|/* Re-initialize list pointers for periodic cals */
name|ahp
operator|->
name|ah_cal_list
operator|=
name|ahp
operator|->
name|ah_cal_list_last
operator|=
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|AH_NULL
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void ar9300_tx_carrier_leak_war(struct ath_hal *ah) {     unsigned long tx_gain_table_max;     unsigned long reg_bb_cl_map_0_b0 = 0xffffffff;     unsigned long reg_bb_cl_map_1_b0 = 0xffffffff;     unsigned long reg_bb_cl_map_2_b0 = 0xffffffff;     unsigned long reg_bb_cl_map_3_b0 = 0xffffffff;     unsigned long tx_gain, cal_run = 0;     unsigned long cal_gain[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];     unsigned long cal_gain_index[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];     unsigned long new_gain[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];     int i, j;      OS_MEMSET(new_gain, 0, sizeof(new_gain));
comment|/*printf("     Running TxCarrierLeakWAR\n");*/
end_comment

begin_comment
comment|/* process tx gain table, we use cl_map_hw_gen=0. */
end_comment

begin_comment
unit|OS_REG_RMW_FIELD(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_MAP_HW_GEN, 0);
comment|//the table we used is txbb_gc[2:0], 1dB[2:1].
end_comment

begin_comment
unit|tx_gain_table_max = OS_REG_READ_FIELD(ah,         AR_PHY_TPC_7, AR_PHY_TPC_7_TX_GAIN_TABLE_MAX);      for (i = 0; i<= tx_gain_table_max; i++) {         tx_gain = OS_REG_READ(ah, AR_PHY_TXGAIN_TAB(1) + i * 4);         cal_gain[i] = (((tx_gain>> 5)& 0x7)<< 2) |             (((tx_gain>> 1)& 0x3)<< 0);         if (i == 0) {             cal_gain_index[i] = cal_run;             new_gain[i] = 1;             cal_run++;         } else {             new_gain[i] = 1;             for (j = 0; j< i; j++) {
comment|/*                 printf("i=%d, j=%d cal_gain[$i]=0x%04x\n", i, j, cal_gain[i]);                  */
end_comment

begin_comment
unit|if (new_gain[i]) {                     if ((cal_gain[i] != cal_gain[j])) {                         new_gain[i] = 1;                     } else {
comment|/* if old gain found, use old cal_run value. */
end_comment

begin_comment
unit|new_gain[i] = 0;                         cal_gain_index[i] = cal_gain_index[j];                     }                 }             }
comment|/* if new gain found, increase cal_run */
end_comment

begin_comment
unit|if (new_gain[i] == 1) {                 cal_gain_index[i] = cal_run;                 cal_run++;             }         }          reg_bb_cl_map_0_b0 = (reg_bb_cl_map_0_b0& ~(0x1<< i)) |             ((cal_gain_index[i]>> 0& 0x1)<< i);         reg_bb_cl_map_1_b0 = (reg_bb_cl_map_1_b0& ~(0x1<< i)) |             ((cal_gain_index[i]>> 1& 0x1)<< i);         reg_bb_cl_map_2_b0 = (reg_bb_cl_map_2_b0& ~(0x1<< i)) |             ((cal_gain_index[i]>> 2& 0x1)<< i);         reg_bb_cl_map_3_b0 = (reg_bb_cl_map_3_b0& ~(0x1<< i)) |             ((cal_gain_index[i]>> 3& 0x1)<< i);
comment|/*         printf("i=%2d, cal_gain[$i]= 0x%04x, cal_run= %d, "             "cal_gain_index[i]=%d, new_gain[i] = %d\n",             i, cal_gain[i], cal_run, cal_gain_index[i], new_gain[i]);          */
end_comment

begin_endif
unit|}     OS_REG_WRITE(ah, AR_PHY_CL_MAP_0_B0, reg_bb_cl_map_0_b0);     OS_REG_WRITE(ah, AR_PHY_CL_MAP_1_B0, reg_bb_cl_map_1_b0);     OS_REG_WRITE(ah, AR_PHY_CL_MAP_2_B0, reg_bb_cl_map_2_b0);     OS_REG_WRITE(ah, AR_PHY_CL_MAP_3_B0, reg_bb_cl_map_3_b0);     if (AR_SREV_WASP(ah)) {         OS_REG_WRITE(ah, AR_PHY_CL_MAP_0_B1, reg_bb_cl_map_0_b0);         OS_REG_WRITE(ah, AR_PHY_CL_MAP_1_B1, reg_bb_cl_map_1_b0);         OS_REG_WRITE(ah, AR_PHY_CL_MAP_2_B1, reg_bb_cl_map_2_b0);         OS_REG_WRITE(ah, AR_PHY_CL_MAP_3_B1, reg_bb_cl_map_3_b0);     } }
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_invalidate_saved_cals
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
block|{
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_cal_reuse
operator|&
name|ATH_CAL_REUSE_REDO_IN_FULL_RESET
condition|)
block|{
name|ichan
operator|->
name|one_time_txiqcal_done
operator|=
name|AH_FALSE
expr_stmt|;
name|ichan
operator|->
name|one_time_txclcal_done
operator|=
name|AH_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_restore_rtt_cals
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
block|{
name|HAL_BOOL
name|restore_status
init|=
name|AH_FALSE
decl_stmt|;
return|return
name|restore_status
return|;
block|}
end_function

begin_comment
comment|/* ar9300_init_cal  * Initialize Calibration infrastructure  */
end_comment

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_init_cal_internal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|HAL_BOOL
name|enable_rtt
parameter_list|,
name|HAL_BOOL
name|do_rtt_cal
parameter_list|,
name|HAL_BOOL
name|skip_if_none
parameter_list|,
name|HAL_BOOL
name|apply_last_iqcorr
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_BOOL
name|txiqcal_success_flag
init|=
name|AH_FALSE
decl_stmt|;
name|HAL_BOOL
name|cal_done
init|=
name|AH_FALSE
decl_stmt|;
name|int
name|iqcal_idx
init|=
literal|0
decl_stmt|;
name|HAL_BOOL
name|do_sep_iq_cal
init|=
name|AH_FALSE
decl_stmt|;
name|HAL_BOOL
name|do_agc_cal
init|=
name|do_rtt_cal
decl_stmt|;
name|HAL_BOOL
name|is_cal_reusable
init|=
name|AH_TRUE
decl_stmt|;
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
name|HAL_BOOL
name|cal_reuse_enable
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_cal_reuse
operator|&
name|ATH_CAL_REUSE_ENABLE
decl_stmt|;
name|HAL_BOOL
name|clc_success
init|=
name|AH_FALSE
decl_stmt|;
name|int32_t
name|ch_idx
decl_stmt|,
name|j
decl_stmt|,
name|cl_tab_reg
decl_stmt|;
name|u_int32_t
name|BB_cl_tab_entry
init|=
name|MAX_BB_CL_TABLE_ENTRY
decl_stmt|;
name|u_int32_t
name|BB_cl_tab_b
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
name|AR_PHY_CL_TAB_0
block|,
name|AR_PHY_CL_TAB_1
block|,
name|AR_PHY_CL_TAB_2
block|}
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Hornet: 1 x 1 */
name|ahp
operator|->
name|ah_rx_cal_chainmask
operator|=
literal|0x1
expr_stmt|;
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|=
literal|0x1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Wasp/Jupiter: 2 x 2 */
name|ahp
operator|->
name|ah_rx_cal_chainmask
operator|=
literal|0x3
expr_stmt|;
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|=
literal|0x3
expr_stmt|;
block|}
else|else
block|{
comment|/*          * Osprey needs to be configured for the correct chain mode          * before running AGC/TxIQ cals.          */
if|if
condition|(
name|ahp
operator|->
name|ah_enterprise_mode
operator|&
name|AR_ENT_OTP_CHAIN2_DISABLE
condition|)
block|{
comment|/* chain 2 disabled - 2 chain mode */
name|ahp
operator|->
name|ah_rx_cal_chainmask
operator|=
literal|0x3
expr_stmt|;
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|=
literal|0x3
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_rx_cal_chainmask
operator|=
literal|0x7
expr_stmt|;
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|=
literal|0x7
expr_stmt|;
block|}
block|}
name|ar9300_init_chain_masks
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_rx_cal_chainmask
argument_list|,
name|ahp
operator|->
name|ah_tx_cal_chainmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|tx_cl_cal_enable
condition|)
block|{
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
comment|/* disable Carrie Leak or set do_agc_cal accordingly */
if|if
condition|(
name|cal_reuse_enable
operator|&&
name|ichan
operator|->
name|one_time_txclcal_done
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CL_CAL_CTL
argument_list|,
name|AR_PHY_CL_CAL_ENABLE
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ATH_SUPPORT_CAL_REUSE */
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CL_CAL_CTL
argument_list|,
name|AR_PHY_CL_CAL_ENABLE
argument_list|)
expr_stmt|;
name|do_agc_cal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
comment|/* Do Tx IQ Calibration here for osprey hornet and wasp */
comment|/* XXX: For initial wasp bringup - check and enable this */
comment|/* EV 74233: Tx IQ fails to complete for half/quarter rates */
if|if
condition|(
operator|!
operator|(
name|IS_CHAN_HALF_RATE
argument_list|(
name|ichan
argument_list|)
operator|||
name|IS_CHAN_QUARTER_RATE
argument_list|(
name|ichan
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|tx_iq_cal_enable
condition|)
block|{
comment|/* this should be eventually moved to INI file */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_1
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_1_IQCORR_I_Q_COFF_DELPT
argument_list|,
name|DELPT
argument_list|)
expr_stmt|;
comment|/*              * For poseidon and later chips,              * Tx IQ cal HW run will be a part of AGC calibration              */
if|if
condition|(
name|ahp
operator|->
name|tx_iq_cal_during_agc_cal
condition|)
block|{
comment|/*                  * txiqcal_success_flag always set to 1 to run                  *     ar9300_tx_iq_cal_post_proc                  * if following AGC cal passes                 */
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
operator|!
name|cal_reuse_enable
operator|||
operator|!
name|ichan
operator|->
name|one_time_txiqcal_done
condition|)
block|{
name|txiqcal_success_flag
operator|=
name|AH_TRUE
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|)
operator||
name|AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|)
operator|&
operator|(
operator|~
name|AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|apply_last_iqcorr
operator|==
name|AH_TRUE
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL
argument_list|)
expr_stmt|;
name|txiqcal_success_flag
operator|=
name|AH_FALSE
expr_stmt|;
block|}
else|else
block|{
name|txiqcal_success_flag
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|txiqcal_success_flag
operator|=
name|AH_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|txiqcal_success_flag
condition|)
block|{
name|do_agc_cal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
operator|!
name|cal_reuse_enable
operator|||
operator|!
name|ichan
operator|->
name|one_time_txiqcal_done
condition|)
endif|#
directive|endif
block|{
name|do_sep_iq_cal
operator|=
name|AH_TRUE
expr_stmt|;
name|do_agc_cal
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
name|IS_CHAN_2GHZ
argument_list|(
name|ichan
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|==
name|MCI_BT_AWAKE
operator|)
operator|&&
name|do_agc_cal
operator|&&
operator|!
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_mci_config
operator|&
name|ATH_MCI_CONFIG_DISABLE_MCI_CAL
operator|)
condition|)
block|{
name|u_int32_t
name|payload
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Send CAL_REQ only when BT is AWAKE. */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Send WLAN_CAL_REQ 0x%X\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_mci_wlan_cal_seq
argument_list|)
expr_stmt|;
name|MCI_GPM_SET_CAL_TYPE
argument_list|(
name|payload
argument_list|,
name|MCI_GPM_WLAN_CAL_REQ
argument_list|)
expr_stmt|;
name|payload
index|[
name|MCI_GPM_WLAN_CAL_W_SEQUENCE
index|]
operator|=
name|ahp
operator|->
name|ah_mci_wlan_cal_seq
operator|++
expr_stmt|;
name|ar9300_mci_send_message
argument_list|(
name|ah
argument_list|,
name|MCI_GPM
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
literal|16
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* Wait BT_CAL_GRANT for 50ms */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Wait for BT_CAL_GRANT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar9300_mci_wait_for_gpm
argument_list|(
name|ah
argument_list|,
name|MCI_GPM_BT_CAL_GRANT
argument_list|,
literal|0
argument_list|,
literal|50000
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Got BT_CAL_GRANT.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is_cal_reusable
operator|=
name|AH_FALSE
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: BT is not responding.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_SUPPORT_MCI */
if|if
condition|(
name|do_sep_iq_cal
condition|)
block|{
comment|/* enable Tx IQ Calibration HW for osprey/hornet/wasp */
name|txiqcal_success_flag
operator|=
name|ar9300_tx_iq_cal_hw_run
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_DIS
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah)) {         ar9300_tx_carrier_leak_war(ah);     }
endif|#
directive|endif
comment|/*      * Calibrate the AGC      *      * Tx IQ cal is a part of AGC cal for Jupiter/Poseidon, etc.      * please enable the bit of txiqcal_control_0[31] in INI file      * for Jupiter/Poseidon/etc.      */
if|if
condition|(
operator|!
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_agc_cal
operator|||
operator|!
name|skip_if_none
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
argument_list|)
expr_stmt|;
comment|/* Poll for offset calibration complete */
name|cal_done
operator|=
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cal_done
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_FCS_RTT
argument_list|,
literal|"(FCS) CAL NOT DONE!!! - %d\n"
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cal_done
operator|=
name|AH_TRUE
expr_stmt|;
block|}
comment|/*              * Tx IQ cal post-processing in SW              * This part of code should be common to all chips,              * no chip specific code for Jupiter/Posdeion except for register names.              */
if|if
condition|(
name|txiqcal_success_flag
condition|)
block|{
name|ar9300_tx_iq_cal_post_proc
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|is_cal_reusable
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|txiqcal_success_flag
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: offset calibration failed to complete in 1ms; "
literal|"noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|apply_last_iqcorr
operator|==
name|AH_TRUE
condition|)
block|{
name|ar9300_tx_iq_cal_post_proc
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|is_cal_reusable
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|iqcal_idx
operator|=
literal|0
init|;
name|iqcal_idx
operator|<
name|MAXIQCAL
condition|;
name|iqcal_idx
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_CAL
argument_list|)
expr_stmt|;
comment|/* Poll for offset calibration complete */
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|AR_PHY_AGC_CONTROL_CAL
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: offset calibration failed to complete in 1ms; "
literal|"noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*                  * Tx IQ cal post-processing in SW                  * This part of code should be common to all chips,                  * no chip specific code for Jupiter/Posdeion except for register names.                  */
name|ar9300_tx_iq_cal_post_proc
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|iqcal_idx
operator|+
literal|1
argument_list|,
name|MAXIQCAL
argument_list|,
name|is_cal_reusable
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
name|IS_CHAN_2GHZ
argument_list|(
name|ichan
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|==
name|MCI_BT_AWAKE
operator|)
operator|&&
name|do_agc_cal
operator|&&
operator|!
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_mci_config
operator|&
name|ATH_MCI_CONFIG_DISABLE_MCI_CAL
operator|)
condition|)
block|{
name|u_int32_t
name|payload
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Send WLAN_CAL_DONE 0x%X\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_mci_wlan_cal_done
argument_list|)
expr_stmt|;
name|MCI_GPM_SET_CAL_TYPE
argument_list|(
name|payload
argument_list|,
name|MCI_GPM_WLAN_CAL_DONE
argument_list|)
expr_stmt|;
name|payload
index|[
name|MCI_GPM_WLAN_CAL_W_SEQUENCE
index|]
operator|=
name|ahp
operator|->
name|ah_mci_wlan_cal_done
operator|++
expr_stmt|;
name|ar9300_mci_send_message
argument_list|(
name|ah
argument_list|,
name|MCI_GPM
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
literal|16
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_SUPPORT_MCI */
if|if
condition|(
operator|!
name|cal_done
operator|&&
operator|!
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: offset calibration failed to complete in 1ms; "
literal|"noisy environment?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|#
directive|if
literal|0
comment|/* Beacon stuck fix, refer to EV 120056 */
block|if(IS_CHAN_2GHZ(chan)&& AR_SREV_SCORPION(ah))         OS_REG_WRITE(ah, AR_PHY_TIMING5, OS_REG_READ(ah,AR_PHY_TIMING5)& ~AR_PHY_TIMING5_CYCPWR_THR1_ENABLE);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Do PA Calibration */
block|if (AR_SREV_KITE(ah)&& AR_SREV_KITE_11_OR_LATER(ah)) {         ar9285_pa_cal(ah);     }
endif|#
directive|endif
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
name|ichan
operator|->
name|one_time_txiqcal_done
condition|)
block|{
name|ar9300_tx_iq_cal_apply
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_FCS_RTT
argument_list|,
literal|"(FCS) TXIQCAL applied - %d\n"
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_SUPPORT_CAL_REUSE */
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
name|cal_reuse_enable
operator|&&
name|ahp
operator|->
name|tx_cl_cal_enable
condition|)
block|{
name|clc_success
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_CLC_SUCCESS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ichan
operator|->
name|one_time_txclcal_done
condition|)
block|{
comment|/* reapply CL cal results */
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ch_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|&
operator|(
literal|1
operator|<<
name|ch_idx
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cl_tab_reg
operator|=
name|BB_cl_tab_b
index|[
name|ch_idx
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BB_cl_tab_entry
condition|;
name|j
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|cl_tab_reg
argument_list|,
name|ichan
operator|->
name|tx_clcal
index|[
name|ch_idx
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|cl_tab_reg
operator|+=
literal|4
expr_stmt|;
empty_stmt|;
block|}
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_FCS_RTT
argument_list|,
literal|"(FCS) TX CL CAL applied - %d\n"
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_cal_reusable
operator|&&
name|clc_success
condition|)
block|{
comment|/* save CL cal results */
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ch_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|&
operator|(
literal|1
operator|<<
name|ch_idx
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cl_tab_reg
operator|=
name|BB_cl_tab_b
index|[
name|ch_idx
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BB_cl_tab_entry
condition|;
name|j
operator|++
control|)
block|{
name|ichan
operator|->
name|tx_clcal
index|[
name|ch_idx
index|]
index|[
name|j
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|cl_tab_reg
argument_list|)
expr_stmt|;
name|cl_tab_reg
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|ichan
operator|->
name|one_time_txclcal_done
operator|=
name|AH_TRUE
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_FCS_RTT
argument_list|,
literal|"(FCS) TX CL CAL saved - %d\n"
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_SUPPORT_CAL_REUSE */
comment|/* Revert chainmasks to their original values before NF cal */
name|ar9300_init_chain_masks
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_rx_chainmask
argument_list|,
name|ahp
operator|->
name|ah_tx_chainmask
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|FIX_NOISE_FLOOR
comment|/*      * Do NF calibration after DC offset and other CALs.      * Per system engineers, noise floor value can sometimes be 20 dB      * higher than normal value if DC offset and noise floor cal are      * triggered at the same time.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator||
name|AR_PHY_AGC_CONTROL_NF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize list pointers */
name|ahp
operator|->
name|ah_cal_list
operator|=
name|ahp
operator|->
name|ah_cal_list_last
operator|=
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|AH_NULL
expr_stmt|;
comment|/*      * Enable IQ, ADC Gain, ADC DC Offset Cals      */
comment|/* Setup all non-periodic, init time only calibrations */
comment|/* XXX: Init DC Offset not working yet */
ifdef|#
directive|ifdef
name|not_yet
if|if
condition|(
name|AH_TRUE
operator|==
name|ar9300_is_cal_supp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ADC_DC_INIT_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|ahp
operator|->
name|ah_adc_dc_cal_init_data
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|ahp
argument_list|,
operator|&
name|ahp
operator|->
name|ah_adc_dc_cal_init_data
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize current pointer to first element in list */
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|ahp
operator|->
name|ah_cal_list
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_cal_list_curr
condition|)
block|{
if|if
condition|(
name|ar9300_run_init_cals
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
operator|==
name|AH_FALSE
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* end - Init time calibrations */
comment|/* If Cals are supported, add them to list via INIT/INSERT_CAL */
if|if
condition|(
name|AH_TRUE
operator|==
name|ar9300_is_cal_supp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|IQ_MISMATCH_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|ahp
operator|->
name|ah_iq_cal_data
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|ahp
argument_list|,
operator|&
name|ahp
operator|->
name|ah_iq_cal_data
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: enabling IQ Calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_TRUE
operator|==
name|ar9300_is_cal_supp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|TEMP_COMP_CAL
argument_list|)
condition|)
block|{
name|INIT_CAL
argument_list|(
operator|&
name|ahp
operator|->
name|ah_temp_comp_cal_data
argument_list|)
expr_stmt|;
name|INSERT_CAL
argument_list|(
name|ahp
argument_list|,
operator|&
name|ahp
operator|->
name|ah_temp_comp_cal_data
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: enabling Temperature Compensation Calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize current pointer to first element in list */
name|ahp
operator|->
name|ah_cal_list_curr
operator|=
name|ahp
operator|->
name|ah_cal_list
expr_stmt|;
comment|/* Reset state within current cal */
if|if
condition|(
name|ahp
operator|->
name|ah_cal_list_curr
condition|)
block|{
name|ar9300_reset_calibration
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_cal_list_curr
argument_list|)
expr_stmt|;
block|}
comment|/* Mark all calibrations on this channel as being invalid */
name|ichan
operator|->
name|cal_valid
operator|=
literal|0
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HAL_BOOL
name|ar9300_init_cal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
name|skip_if_none
parameter_list|,
name|HAL_BOOL
name|apply_last_iqcorr
parameter_list|)
block|{
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_BOOL
name|do_rtt_cal
init|=
name|AH_TRUE
decl_stmt|;
name|HAL_BOOL
name|enable_rtt
init|=
name|AH_FALSE
decl_stmt|;
name|HALASSERT
argument_list|(
name|ichan
argument_list|)
expr_stmt|;
return|return
name|ar9300_init_cal_internal
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ichan
argument_list|,
name|enable_rtt
argument_list|,
name|do_rtt_cal
argument_list|,
name|skip_if_none
argument_list|,
name|apply_last_iqcorr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ar9300_reset_cal_valid  * Entry point for upper layers to restart current cal.  * Reset the calibration valid bit in channel.  */
end_comment

begin_function
name|void
name|ar9300_reset_cal_valid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_BOOL
modifier|*
name|is_cal_done
parameter_list|,
name|u_int32_t
name|cal_type
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|HAL_CAL_LIST
modifier|*
name|curr_cal
init|=
name|ahp
operator|->
name|ah_cal_list_curr
decl_stmt|;
operator|*
name|is_cal_done
operator|=
name|AH_TRUE
expr_stmt|;
if|if
condition|(
name|curr_cal
operator|==
name|AH_NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|cal_type
operator|&
name|IQ_MISMATCH_CAL
operator|)
condition|)
block|{
operator|*
name|is_cal_done
operator|=
name|AH_FALSE
expr_stmt|;
return|return;
block|}
comment|/* Expected that this calibration has run before, post-reset.      * Current state should be done      */
if|if
condition|(
name|curr_cal
operator|->
name|cal_state
operator|!=
name|CAL_DONE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Calibration state incorrect, %d\n"
argument_list|,
name|__func__
argument_list|,
name|curr_cal
operator|->
name|cal_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Verify Cal is supported on this channel */
if|if
condition|(
name|ar9300_is_cal_supp
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
argument_list|)
operator|==
name|AH_FALSE
condition|)
block|{
return|return;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Resetting Cal %d state for channel %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
comment|/* Disable cal validity in channel */
name|ichan
operator|->
name|cal_valid
operator|&=
operator|~
name|curr_cal
operator|->
name|cal_data
operator|->
name|cal_type
expr_stmt|;
name|curr_cal
operator|->
name|cal_state
operator|=
name|CAL_WAITING
expr_stmt|;
comment|/* Indicate to upper layers that we need polling */
operator|*
name|is_cal_done
operator|=
name|AH_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_set_dma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|regval
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/*      * set AHB_MODE not to do cacheline prefetches      */
block|regval = OS_REG_READ(ah, AR_AHB_MODE);     OS_REG_WRITE(ah, AR_AHB_MODE, regval | AR_AHB_PREFETCH_RD_EN);
endif|#
directive|endif
comment|/*      * let mac dma reads be in 128 byte chunks      */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|)
operator|&
operator|~
name|AR_TXCFG_DMASZ_MASK
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
name|regval
operator||
name|AR_TXCFG_DMASZ_128B
argument_list|)
expr_stmt|;
comment|/*      * Restore TX Trigger Level to its pre-reset value.      * The initial value depends on whether aggregation is enabled, and is      * adjusted whenever underruns are detected.      */
comment|/*     OS_REG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, AH_PRIVATE(ah)->ah_tx_trig_level);      */
comment|/*       * Osprey 1.0 bug (EV 61936). Don't change trigger level from .ini default.      * Osprey 2.0 - hardware recommends using the default INI settings.      */
if|#
directive|if
literal|0
block|OS_REG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, 0x3f);
endif|#
directive|endif
comment|/*      * let mac dma writes be in 128 byte chunks      */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|)
operator|&
operator|~
name|AR_RXCFG_DMASZ_MASK
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXCFG
argument_list|,
name|regval
operator||
name|AR_RXCFG_DMASZ_128B
argument_list|)
expr_stmt|;
comment|/*      * Setup receive FIFO threshold to hold off TX activities      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RXFIFO_CFG
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
comment|/*      * reduce the number of usable entries in PCU TXBUF to avoid      * wrap around bugs. (bug 20428)      */
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
operator|(
name|ah
operator|)
argument_list|)
operator|->
name|ah_macRev
operator|>
name|AR_SREV_REVISION_WASP_12
operator|)
condition|)
block|{
comment|/* Wasp 1.3 fix for EV#85395 requires usable entries           * to be set to 0x500           */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_TXBUF_CTRL
argument_list|,
literal|0x500
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_TXBUF_CTRL
argument_list|,
name|AR_PCU_TXBUF_CTRL_USABLE_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Enable HPQ for UAPSD      */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|==
name|HAL_M_HOSTAP
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HP_Q_CONTROL
argument_list|,
name|AR_HPQ_ENABLE
operator||
name|AR_HPQ_UAPSD
operator||
name|AR_HPQ_UAPSD_TRIGGER_EN
argument_list|)
expr_stmt|;
block|}
comment|/*      * set the transmit status ring      */
name|ar9300_reset_tx_status_ring
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * set rxbp threshold.  Must be non-zero for RX_EOL to occur.      * For Osprey 2.0+, keep the original thresholds      * otherwise performance is lost due to excessive RX EOL interrupts.      */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RXBP_THRESH
argument_list|,
name|AR_RXBP_THRESH_HP
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RXBP_THRESH
argument_list|,
name|AR_RXBP_THRESH_LP
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/*      * set receive buffer size.      */
if|if
condition|(
name|ahp
operator|->
name|rx_buf_size
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DATABUF
argument_list|,
name|ahp
operator|->
name|rx_buf_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_bb
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|synth_delay
decl_stmt|;
comment|/*      * Wait for the frequency synth to settle (synth goes on      * via AR_PHY_ACTIVE_EN).  Read the phy active delay register.      * Value is in 100ns increments.      */
name|synth_delay
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_DELAY
argument_list|)
operator|&
name|AR_PHY_RX_DELAY_DELAY
expr_stmt|;
if|if
condition|(
name|IS_CHAN_CCK
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|synth_delay
operator|=
operator|(
literal|4
operator|*
name|synth_delay
operator|)
operator|/
literal|22
expr_stmt|;
block|}
else|else
block|{
name|synth_delay
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Activate the PHY (includes baseband activate + synthesizer on) */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ACTIVE
argument_list|,
name|AR_PHY_ACTIVE_EN
argument_list|)
expr_stmt|;
comment|/*      * There is an issue if the AP starts the calibration before      * the base band timeout completes.  This could result in the      * rx_clear AH_FALSE triggering.  As a workaround we add delay an      * extra BASE_ACTIVATE_DELAY usecs to ensure this condition      * does not happen.      */
name|OS_DELAY
argument_list|(
name|synth_delay
operator|+
name|BASE_ACTIVATE_DELAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_interrupt_masks
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|msi_cfg
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|sync_en_def
init|=
name|AR9300_INTR_SYNC_DEFAULT
decl_stmt|;
comment|/*      * Setup interrupt handling.  Note that ar9300_reset_tx_queue      * manipulates the secondary IMR's as queues are enabled      * and disabled.  This is done with RMW ops to insure the      * settings we make here are preserved.      */
name|ahp
operator|->
name|ah_mask_reg
operator|=
name|AR_IMR_TXERR
operator||
name|AR_IMR_TXURN
operator||
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXORN
operator||
name|AR_IMR_BCNMISC
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_rx
condition|)
block|{
comment|/* enable interrupt mitigation for rx */
name|ahp
operator|->
name|ah_mask_reg
operator||=
name|AR_IMR_RXINTM
operator||
name|AR_IMR_RXMINTR
operator||
name|AR_IMR_RXOK_HP
expr_stmt|;
name|msi_cfg
operator||=
name|AR_INTCFG_MSI_RXINTM
operator||
name|AR_INTCFG_MSI_RXMINTR
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_mask_reg
operator||=
name|AR_IMR_RXOK_LP
operator||
name|AR_IMR_RXOK_HP
expr_stmt|;
name|msi_cfg
operator||=
name|AR_INTCFG_MSI_RXOK
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_tx
condition|)
block|{
comment|/* enable interrupt mitigation for tx */
name|ahp
operator|->
name|ah_mask_reg
operator||=
name|AR_IMR_TXINTM
operator||
name|AR_IMR_TXMINTR
expr_stmt|;
name|msi_cfg
operator||=
name|AR_INTCFG_MSI_TXINTM
operator||
name|AR_INTCFG_MSI_TXMINTR
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_mask_reg
operator||=
name|AR_IMR_TXOK
expr_stmt|;
name|msi_cfg
operator||=
name|AR_INTCFG_MSI_TXOK
expr_stmt|;
block|}
if|if
condition|(
name|opmode
operator|==
name|HAL_M_HOSTAP
condition|)
block|{
name|ahp
operator|->
name|ah_mask_reg
operator||=
name|AR_IMR_MIB
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|ahp
operator|->
name|ah_mask_reg
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
operator||
name|AR_IMR_S2_GTT
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_mask2Reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_enable_msi
condition|)
block|{
comment|/* Cache MSI register value */
name|ahp
operator|->
name|ah_msi_reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_MSI
argument_list|)
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_msi_reg
operator||=
name|AR_PCIE_MSI_HW_DBI_WR_EN
expr_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|ah_msi_reg
operator|&=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_msi_reg
operator|&=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR
expr_stmt|;
block|}
comment|/* Program MSI configuration */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_INTCFG
argument_list|,
name|msi_cfg
argument_list|)
expr_stmt|;
block|}
comment|/*      * debug - enable to see all synchronous interrupts status      */
comment|/* Clear any pending sync cause interrupts */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Allow host interface sync interrupt sources to set cause bit */
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9300_INTR_SYNC_DEF_NO_HOST1_PERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9340_INTR_SYNC_DEFAULT
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|,
name|sync_en_def
argument_list|)
expr_stmt|;
comment|/* _Disable_ host interface sync interrupt when cause bits set */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_MASK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_MASK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_SYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_SYNC_MASK
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_qos
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIC_QOS_CONTROL
argument_list|,
literal|0x100aa
argument_list|)
expr_stmt|;
comment|/* XXX magic */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIC_QOS_SELECT
argument_list|,
literal|0x3210
argument_list|)
expr_stmt|;
comment|/* XXX magic */
comment|/* Turn on NOACK Support for QoS packets */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QOS_NO_ACK
argument_list|,
name|SM
argument_list|(
literal|2
argument_list|,
name|AR_QOS_NO_ACK_TWO_BIT
argument_list|)
operator||
name|SM
argument_list|(
literal|5
argument_list|,
name|AR_QOS_NO_ACK_BIT_OFF
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_QOS_NO_ACK_BYTE_OFF
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * initialize TXOP for all TIDs      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_X
argument_list|,
name|AR_TXOP_X_VAL
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_0_3
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_4_7
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_8_11
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXOP_12_15
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ar9300_init_user_settings
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* Restore user-specified settings */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"--AP %s ahp->ah_misc_mode 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_misc_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_misc_mode
operator|!=
literal|0
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|)
operator||
name|ahp
operator|->
name|ah_misc_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_get_plcp_hdr
condition|)
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|,
name|AR_PCU_SEL_EVM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_slot_time
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|ar9300_set_slot_time
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_slot_time
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_ack_timeout
operator|!=
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|ar9300_set_ack_timeout
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_ack_timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
operator|!=
literal|0
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_diagreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_beacon_rssi_threshold
operator|!=
literal|0
condition|)
block|{
name|ar9300_set_hw_beacon_rssi_threshold
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_beacon_rssi_threshold
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ATH_SUPPORT_DFS
if|if
condition|(
name|ahp
operator|->
name|ah_cac_quiet_enabled
condition|)
block|{
name|ar9300_cac_tx_quiet
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_SUPPORT_DFS */
block|}
end_function

begin_function
name|int
name|ar9300_get_spur_info
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
modifier|*
name|enable
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int16_t
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ap
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|freq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|enable
operator|=
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_mode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|AR_EEPROM_MODAL_SPURS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
name|AR_NO_SPUR
condition|)
block|{
name|freq
index|[
name|j
operator|++
index|]
operator|=
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"1. get spur %d\n"
argument_list|,
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|AR_NO_SPUR
condition|)
block|{
name|freq
index|[
name|j
operator|++
index|]
operator|=
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"2. get spur %d\n"
argument_list|,
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATH_HAL_2GHZ_FREQ_MIN
value|20000
end_define

begin_define
define|#
directive|define
name|ATH_HAL_2GHZ_FREQ_MAX
value|29999
end_define

begin_define
define|#
directive|define
name|ATH_HAL_5GHZ_FREQ_MIN
value|50000
end_define

begin_define
define|#
directive|define
name|ATH_HAL_5GHZ_FREQ_MAX
value|59999
end_define

begin_function
name|int
name|ar9300_set_spur_info
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int16_t
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ap
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_mode
operator|=
name|enable
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_mode
operator|==
name|SPUR_ENABLE_IOCTL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_EEPROM_MODAL_SPURS
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|AR_NO_SPUR
expr_stmt|;
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|AR_NO_SPUR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
index|[
name|i
index|]
operator|>
name|ATH_HAL_2GHZ_FREQ_MIN
operator|&&
name|freq
index|[
name|i
index|]
operator|<
name|ATH_HAL_2GHZ_FREQ_MAX
condition|)
block|{
comment|/* 2GHz Spur */
if|if
condition|(
name|j
operator|<
name|AR_EEPROM_MODAL_SPURS
condition|)
block|{
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|j
operator|++
index|]
index|[
literal|1
index|]
operator|=
name|freq
index|[
name|i
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"1 set spur %d\n"
argument_list|,
name|freq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|freq
index|[
name|i
index|]
operator|>
name|ATH_HAL_5GHZ_FREQ_MIN
operator|&&
name|freq
index|[
name|i
index|]
operator|<
name|ATH_HAL_5GHZ_FREQ_MAX
condition|)
block|{
comment|/* 5Ghz Spur */
if|if
condition|(
name|k
operator|<
name|AR_EEPROM_MODAL_SPURS
condition|)
block|{
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_spur_chans
index|[
name|k
operator|++
index|]
index|[
literal|0
index|]
operator|=
name|freq
index|[
name|i
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"2 set spur %d\n"
argument_list|,
name|freq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ar9300_check_op_mode
parameter_list|(
name|_opmode
parameter_list|)
define|\
value|((_opmode == HAL_M_STA) || (_opmode == HAL_M_IBSS) ||\      (_opmode == HAL_M_HOSTAP) || (_opmode == HAL_M_MONITOR))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ATH_NF_PER_CHAN
end_ifndef

begin_comment
comment|/* * To fixed first reset noise floor value not correct issue * For ART need it to fixed low rate sens too low issue	 */
end_comment

begin_function
specifier|static
name|int
name|First_NFCal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|int
name|is_scan
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|HAL_NFCAL_HIST_FULL
modifier|*
name|nfh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int16_t
name|nfarray
index|[
name|NUM_NF_READINGS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|is_2g
init|=
literal|0
decl_stmt|;
name|int
name|nf_hist_len
decl_stmt|;
name|int
name|stats
init|=
literal|0
decl_stmt|;
name|int16_t
name|nf_buf
index|[
name|NUM_NF_READINGS
index|]
decl_stmt|;
define|#
directive|define
name|IS
parameter_list|(
name|_c
parameter_list|,
name|_f
parameter_list|)
value|(((_c)->channel_flags& _f) || 0)
if|if
condition|(
operator|(
operator|!
name|is_scan
operator|)
operator|&&
name|chan
operator|->
name|channel
operator|==
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel
condition|)
block|{
name|nfh
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
expr_stmt|;
block|}
else|else
block|{
name|nfh
operator|=
operator|(
name|HAL_NFCAL_HIST_FULL
operator|*
operator|)
operator|&
name|ichan
operator|->
name|nf_cal_hist
expr_stmt|;
block|}
name|ar9300_start_nf_cal
argument_list|(
name|ah
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10000
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_AGC_CONTROL
argument_list|)
operator|&
name|AR_PHY_AGC_CONTROL_NF
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
literal|10000
condition|)
block|{
name|is_2g
operator|=
name|IS
argument_list|(
name|ichan
argument_list|,
name|CHANNEL_2GHZ
argument_list|)
expr_stmt|;
name|ar9300_upload_noise_floor
argument_list|(
name|ah
argument_list|,
name|is_2g
argument_list|,
name|nfarray
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_scan
condition|)
block|{
comment|/* 			 * This channel's NF cal info is just a HAL_NFCAL_HIST_SMALL struct 			 * rather than a HAL_NFCAL_HIST_FULL struct. 			 * As long as we only use the first history element of nf_cal_buffer 			 * (nf_cal_buffer[0][0:NUM_NF_READINGS-1]), we can use 			 * HAL_NFCAL_HIST_SMALL and HAL_NFCAL_HIST_FULL interchangeably. 			 */
name|nfh
operator|=
operator|(
name|HAL_NFCAL_HIST_FULL
operator|*
operator|)
operator|&
name|ichan
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_SMALL
expr_stmt|;
block|}
else|else
block|{
name|nfh
operator|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
expr_stmt|;
name|nf_hist_len
operator|=
name|HAL_NF_CAL_HIST_LEN_FULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|HAL_NF_CAL_HIST_LEN_FULL
condition|;
name|k
operator|++
control|)
block|{
name|nfh
operator|->
name|nf_cal_buffer
index|[
name|k
index|]
index|[
name|i
index|]
operator|=
name|nfarray
index|[
name|i
index|]
expr_stmt|;
block|}
name|nfh
operator|->
name|base
operator|.
name|priv_nf
index|[
name|i
index|]
operator|=
name|ar9300_limit_nf_range
argument_list|(
name|ah
argument_list|,
name|ar9300_get_nf_hist_mid
argument_list|(
name|ah
argument_list|,
name|nfh
argument_list|,
name|i
argument_list|,
name|nf_hist_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//ar9300StoreNewNf(ah, ichan, is_scan);
comment|/* 		 * See if the NF value from the old channel should be 		 * retained when switching to a new channel. 		 * TBD: this may need to be changed, as it wipes out the 		 * purpose of saving NF values for each channel. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NF_READINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|nfh
operator|->
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<
name|AR_PHY_CCA_MAX_GOOD_VAL_OSPREY_2GHZ
condition|)
block|{
name|ichan
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|nfh
operator|->
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<
name|AR_PHY_CCA_NOM_VAL_PEACOCK_5GHZ
condition|)
block|{
name|ichan
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nfh
operator|->
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|<
name|AR_PHY_CCA_NOM_VAL_OSPREY_5GHZ
condition|)
block|{
name|ichan
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|nf_cal_hist
operator|.
name|nf_cal_buffer
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Copy the channel's NF buffer, which may have been modified 		 * just above here, to the full NF history buffer. 		 */
name|ar9300_reset_nf_hist_buff
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|ar9300_get_nf_hist_base
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|,
name|is_scan
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
name|ar9300_load_nf
argument_list|(
name|ah
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
name|stats
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|=
literal|1
expr_stmt|;
block|}
undef|#
directive|undef
name|IS
return|return
name|stats
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Places the device in and out of reset and then places sane  * values in the registers based on EEPROM config, initialization  * vectors (as determined by the mode), and station configuration  *  * b_channel_change is used to preserve DMA/PCU registers across  * a HW Reset during channel change.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_OPMODE
name|opmode
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|,
name|HAL_HT_MACMODE
name|macmode
parameter_list|,
name|u_int8_t
name|txchainmask
parameter_list|,
name|u_int8_t
name|rxchainmask
parameter_list|,
name|HAL_HT_EXTPROTSPACING
name|extprotspacing
parameter_list|,
name|HAL_BOOL
name|b_channel_change
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|,
name|int
name|is_scan
parameter_list|)
block|{
define|#
directive|define
name|FAIL
parameter_list|(
name|_code
parameter_list|)
value|do { ecode = _code; goto bad; } while (0)
name|u_int32_t
name|save_led_state
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ap
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|curchan
init|=
name|ap
operator|->
name|ah_curchan
decl_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
name|HAL_BOOL
name|save_full_sleep
init|=
name|ahp
operator|->
name|ah_chip_full_sleep
decl_stmt|;
endif|#
directive|endif
name|u_int32_t
name|save_def_antenna
decl_stmt|;
name|u_int32_t
name|mac_sta_id1
decl_stmt|;
name|HAL_STATUS
name|ecode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rx_chainmask
decl_stmt|;
name|int
name|nf_hist_buff_reset
init|=
literal|0
decl_stmt|;
name|int16_t
name|nf_buf
index|[
name|NUM_NF_READINGS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ATH_FORCE_PPM
name|u_int32_t
name|save_force_val
decl_stmt|,
name|tmp_reg
decl_stmt|;
endif|#
directive|endif
name|HAL_BOOL
name|stopped
decl_stmt|,
name|cal_ret
decl_stmt|;
name|HAL_BOOL
name|apply_last_iqcorr
init|=
name|AH_FALSE
decl_stmt|;
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
operator|==
name|AR_IER_ENABLE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"** Reset called with WLAN "
literal|"interrupt enabled %08x **\n"
argument_list|,
name|ar9300_get_interrupts
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set the status to "ok" by default to cover the cases      * where we return AH_FALSE without going to "bad"      */
name|HALASSERT
argument_list|(
name|status
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_OK
expr_stmt|;
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_sta_update_tx_pwr_enable
operator|)
condition|)
block|{
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|green_tx_status
operator|=
name|HAL_RSSI_TX_POWER_NONE
expr_stmt|;
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
operator|(
name|AR_SREV_JUPITER_20
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
operator|)
condition|)
block|{
name|ar9300_mci_2g5g_changed
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ahp
operator|->
name|ah_ext_prot_spacing
operator|=
name|extprotspacing
expr_stmt|;
name|ahp
operator|->
name|ah_tx_chainmask
operator|=
name|txchainmask
operator|&
name|ap
operator|->
name|ah_caps
operator|.
name|hal_tx_chain_mask
expr_stmt|;
name|ahp
operator|->
name|ah_rx_chainmask
operator|=
name|rxchainmask
operator|&
name|ap
operator|->
name|ah_caps
operator|.
name|hal_rx_chain_mask
expr_stmt|;
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|=
name|ap
operator|->
name|ah_caps
operator|.
name|hal_tx_chain_mask
expr_stmt|;
name|ahp
operator|->
name|ah_rx_cal_chainmask
operator|=
name|ap
operator|->
name|ah_caps
operator|.
name|hal_rx_chain_mask
expr_stmt|;
name|HALASSERT
argument_list|(
name|ar9300_check_op_mode
argument_list|(
name|opmode
argument_list|)
argument_list|)
expr_stmt|;
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET
argument_list|,
name|b_channel_change
argument_list|)
expr_stmt|;
comment|/*      * Map public channel to private.      */
name|ichan
operator|=
name|ar9300_check_chan
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EINVAL
argument_list|)
expr_stmt|;
block|}
name|ichan
operator|->
name|paprd_table_write_done
operator|=
literal|0
expr_stmt|;
comment|/* Clear PAPRD table write flag */
name|chan
operator|->
name|paprd_table_write_done
operator|=
literal|0
expr_stmt|;
comment|/* Clear PAPRD table write flag */
if|if
condition|(
name|ar9300_get_power_mode
argument_list|(
name|ah
argument_list|)
operator|!=
name|HAL_PM_FULL_SLEEP
condition|)
block|{
comment|/* Need to stop RX DMA before reset otherwise chip might hang */
name|stopped
operator|=
name|ar9300_set_rx_abort
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
comment|/* abort and disable PCU */
name|ar9300_set_rx_filter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stopped
operator|&=
name|ar9300_stop_dma_receive
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop and disable RX DMA */
if|if
condition|(
operator|!
name|stopped
condition|)
block|{
comment|/*              * During the transition from full sleep to reset,              * recv DMA regs are not available to be read              */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s[%d]: ar9300_stop_dma_receive failed\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|b_channel_change
operator|=
name|AH_FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s[%d]: Chip is already in full sleep\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|==
name|MCI_BT_CAL_START
operator|)
condition|)
block|{
name|u_int32_t
name|payload
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Stop rx for BT cal.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_mci_bt_state
operator|=
name|MCI_BT_CAL
expr_stmt|;
comment|/*          * MCIFIX: disable mci interrupt here. This is to avoid SW_MSG_DONE or          * RX_MSG bits to trigger MCI_INT and lead to mci_intr reentry.          */
name|ar9300_mci_disable_interrupt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Send WLAN_CAL_GRANT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|MCI_GPM_SET_CAL_TYPE
argument_list|(
name|payload
argument_list|,
name|MCI_GPM_WLAN_CAL_GRANT
argument_list|)
expr_stmt|;
name|ar9300_mci_send_message
argument_list|(
name|ah
argument_list|,
name|MCI_GPM
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|,
literal|16
argument_list|,
name|AH_TRUE
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
comment|/* Wait BT calibration to be completed for 25ms */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: BT is calibrating.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar9300_mci_wait_for_gpm
argument_list|(
name|ah
argument_list|,
name|MCI_GPM_BT_CAL_DONE
argument_list|,
literal|0
argument_list|,
literal|25000
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Got BT_CAL_DONE.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: ### BT cal takes too long. Force bt_state to be bt_awake.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_mci_bt_state
operator|=
name|MCI_BT_AWAKE
expr_stmt|;
comment|/* MCIFIX: enable mci interrupt here */
name|ar9300_mci_enable_interrupt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
endif|#
directive|endif
comment|/* Bring out of sleep mode */
if|if
condition|(
operator|!
name|ar9300_set_power_mode
argument_list|(
name|ah
argument_list|,
name|HAL_PM_AWAKE
argument_list|,
name|AH_TRUE
argument_list|)
condition|)
block|{
operator|*
name|status
operator|=
name|HAL_INV_PMODE
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* Check the Rx mitigation config again, it might have changed      * during attach in ath_vap_attach.      */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_intr_mitigation_rx
operator|!=
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_intr_mitigation_rx
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_intr_mitigation_rx
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/* Get the value from the previous NF cal and update history buffer */
if|if
condition|(
name|curchan
operator|&&
operator|(
name|ahp
operator|->
name|ah_chip_full_sleep
operator|!=
name|AH_TRUE
operator|)
condition|)
block|{
name|ar9300_store_new_nf
argument_list|(
name|ah
argument_list|,
name|curchan
argument_list|,
name|is_scan
argument_list|)
expr_stmt|;
block|}
comment|/*      * Account for the effect of being in either the 2 GHz or 5 GHz band      * on the nominal, max allowable, and min allowable noise floor values.      */
name|ap
operator|->
name|nfp
operator|=
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|?
operator|&
name|ap
operator|->
name|nf_2GHz
else|:
operator|&
name|ap
operator|->
name|nf_5GHz
expr_stmt|;
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|&&
name|curchan
operator|&&
operator|(
name|chan
operator|->
name|channel
operator|==
name|curchan
operator|->
name|channel
operator|)
operator|&&
operator|(
operator|(
name|chan
operator|->
name|channel_flags
operator|&
operator|(
name|CHANNEL_ALL
operator||
name|CHANNEL_HALF
operator||
name|CHANNEL_QUARTER
operator|)
operator|)
operator|==
operator|(
name|curchan
operator|->
name|channel_flags
operator|&
operator|(
name|CHANNEL_ALL
operator||
name|CHANNEL_HALF
operator||
name|CHANNEL_QUARTER
operator|)
operator|)
operator|)
condition|)
block|{
name|apply_last_iqcorr
operator|=
name|AH_TRUE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ATH_NF_PER_CHAN
comment|/*      * If there's only one full-size home-channel NF history buffer      * rather than a full-size NF history buffer per channel, decide      * whether to (re)initialize the home-channel NF buffer.      * If this is just a channel change for a scan, or if the channel      * is not being changed, don't mess up the home channel NF history      * buffer with NF values from this scanned channel.  If we're      * changing the home channel to a new channel, reset the home-channel      * NF history buffer with the most accurate NF known for the new channel.      */
if|if
condition|(
operator|!
name|is_scan
operator|&&
operator|(
operator|!
name|ap
operator|->
name|ah_curchan
operator|||
name|ap
operator|->
name|ah_curchan
operator|->
name|channel
operator|!=
name|chan
operator|->
name|channel
operator|||
name|ap
operator|->
name|ah_curchan
operator|->
name|channel_flags
operator|!=
name|chan
operator|->
name|channel_flags
operator|)
condition|)
block|{
name|nf_hist_buff_reset
operator|=
literal|1
expr_stmt|;
name|ar9300_reset_nf_hist_buff
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Fast channel change (Change synthesizer based on channel freq      * without resetting chip)      * Don't do it when      *   - Flag is not set      *   - Chip is just coming out of full sleep      *   - Channel to be set is same as current channel      *   - Channel flags are different, like when moving from 2GHz to 5GHz      *     channels      *   - Merlin: Switching in/out of fast clock enabled channels      *             (not currently coded, since fast clock is enabled      *             across the 5GHz band      *             and we already do a full reset when switching in/out      *             of 5GHz channels)      */
if|if
condition|(
name|b_channel_change
operator|&&
operator|(
name|ahp
operator|->
name|ah_chip_full_sleep
operator|!=
name|AH_TRUE
operator|)
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|!=
name|AH_NULL
operator|)
operator|&&
operator|(
operator|(
name|chan
operator|->
name|channel
operator|!=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel
operator|)
operator|&&
operator|(
operator|(
operator|(
name|CHANNEL_ALL
operator||
name|CHANNEL_HALF
operator||
name|CHANNEL_QUARTER
operator|)
operator|&
name|chan
operator|->
name|channel_flags
operator|)
operator|==
operator|(
operator|(
name|CHANNEL_ALL
operator||
name|CHANNEL_HALF
operator||
name|CHANNEL_QUARTER
operator|)
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|channel_flags
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ar9300_channel_change
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ichan
argument_list|,
name|macmode
argument_list|)
condition|)
block|{
name|chan
operator|->
name|channel_flags
operator|=
name|ichan
operator|->
name|channel_flags
expr_stmt|;
name|chan
operator|->
name|priv_flags
operator|=
name|ichan
operator|->
name|priv_flags
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|ah_channel_time
operator|=
literal|0
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|->
name|ah_tsf_last
operator|=
name|ar9300_get_tsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*              * Load the NF from history buffer of the current channel.              * NF is slow time-variant, so it is OK to use a historical value.              */
name|ar9300_get_nf_hist_base
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|,
name|is_scan
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
name|ar9300_load_nf
argument_list|(
name|ah
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
comment|/* start NF calibration, without updating BB NF register*/
name|ar9300_start_nf_cal
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*              * If channel_change completed and DMA was stopped              * successfully - skip the rest of reset              */
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_dma_stuck
operator|!=
name|AH_TRUE
condition|)
block|{
name|WAR_USB_DISABLE_PLL_LOCK_DETECT
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
name|ahp
operator|->
name|ah_mci_ready
condition|)
block|{
name|ar9300_mci_2g5g_switch
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|AH_TRUE
return|;
block|}
block|}
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
condition|)
block|{
name|ar9300_mci_disable_interrupt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_mci_ready
operator|&&
operator|!
name|save_full_sleep
condition|)
block|{
name|ar9300_mci_mute_bt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BTCOEX_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_mci_bt_state
operator|=
name|MCI_BT_SLEEP
expr_stmt|;
name|ahp
operator|->
name|ah_mci_ready
operator|=
name|AH_FALSE
expr_stmt|;
block|}
endif|#
directive|endif
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_dma_stuck
operator|=
name|AH_FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_FORCE_PPM
comment|/* Preserve force ppm state */
name|save_force_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING2
argument_list|)
operator|&
operator|(
name|AR_PHY_TIMING2_USE_FORCE
operator||
name|AR_PHY_TIMING2_FORCE_VAL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Preserve the antenna on a channel change      */
name|save_def_antenna
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|ahp
operator|->
name|ah_smartantenna_enable
condition|)
block|{
if|if
condition|(
name|save_def_antenna
operator|==
literal|0
condition|)
block|{
name|save_def_antenna
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Save hardware flag before chip reset clears the register */
name|mac_sta_id1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator|&
name|AR_STA_ID1_BASE_RATE_11B
expr_stmt|;
comment|/* Save led state from pci config register */
name|save_led_state
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CFG_LED
argument_list|)
operator|&
operator|(
name|AR_CFG_LED_ASSOC_CTL
operator||
name|AR_CFG_LED_MODE_SEL
operator||
name|AR_CFG_LED_BLINK_THRESH_SEL
operator||
name|AR_CFG_LED_BLINK_SLOW
operator|)
expr_stmt|;
comment|/* Mark PHY inactive prior to reset, to be undone in ar9300_init_bb () */
name|ar9300_mark_phy_inactive
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar9300_chip_reset
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: chip reset failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Disable JTAG */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_GPIO_INPUT_EN_VAL
argument_list|)
argument_list|,
name|AR_GPIO_JTAG_DISABLE
argument_list|)
expr_stmt|;
comment|/*      * Note that ar9300_init_chain_masks() is called from within      * ar9300_process_ini() to ensure the swap bit is set before      * the pdadc table is written.      */
name|ecode
operator|=
name|ar9300_process_ini
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|ichan
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|HAL_OK
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|ahp
operator|->
name|ah_immunity_on
operator|=
name|AH_FALSE
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|tx_iq_cal_enable
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|ahp
operator|->
name|tx_cl_cal_enable
operator|=
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CL_CAL_CTL
argument_list|)
operator|&
name|AR_PHY_CL_CAL_ENABLE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* For devices with full HW RIFS Rx support (Sowl/Howl/Merlin, etc),      * restore register settings from prior to reset.      */
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|!=
name|AH_NULL
operator|)
operator|&&
operator|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_LDPCWAR
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
operator|)
condition|)
block|{
comment|/* Re-program RIFS Rx policy after reset */
name|ar9300_set_rifs_delay
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_rifs_enabled
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
condition|)
block|{
name|ar9300_mci_reset
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
argument_list|,
name|save_full_sleep
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize Management Frame Protection */
name|ar9300_init_mfp
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|0
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M1_THRESH_LOW
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|1
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2_THRESH_LOW
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|2
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M1_THRESH
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|3
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2_THRESH
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|4
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2COUNT_THR
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_immunity_vals
index|[
literal|5
index|]
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW
argument_list|)
expr_stmt|;
comment|/* Write delta slope for OFDM enabled modes (A, G, Turbo) */
if|if
condition|(
name|IS_CHAN_OFDM
argument_list|(
name|chan
argument_list|)
operator|||
name|IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar9300_set_delta_slope
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
block|}
name|ar9300_spur_mitigate
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar9300_eeprom_set_board_values
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_EEPROM
argument_list|,
literal|"%s: error setting board options\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ATH_HAL_WAR_REG16284_APH128
comment|/* temp work around, will be removed. */
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
literal|0x16284
argument_list|,
literal|0x1553e000
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_macaddr
operator|+
literal|4
argument_list|)
operator||
name|mac_sta_id1
operator||
name|AR_STA_ID1_RTS_USE_DEF
operator||
operator|(
name|ap
operator|->
name|ah_config
operator|.
name|ath_hal_6mb_ack
condition|?
name|AR_STA_ID1_ACKCTS_6MB
else|:
literal|0
operator|)
operator||
name|ahp
operator|->
name|ah_sta_id1_defaults
argument_list|)
expr_stmt|;
name|ar9300_set_operating_mode
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Set Venice BSSID mask according to current state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKL
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid_mask
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSSMSKU
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid_mask
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore previous antenna */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DEF_ANTENNA
argument_list|,
name|save_def_antenna
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_FORCE_PPM
comment|/* Restore force ppm state */
name|tmp_reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING2
argument_list|)
operator|&
operator|~
operator|(
name|AR_PHY_TIMING2_USE_FORCE
operator||
name|AR_PHY_TIMING2_FORCE_VAL
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING2
argument_list|,
name|tmp_reg
operator||
name|save_force_val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* then our BSSID and assocID */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID0
argument_list|,
name|LE_READ_4
argument_list|(
name|ahp
operator|->
name|ah_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_BSS_ID1
argument_list|,
name|LE_READ_2
argument_list|(
name|ahp
operator|->
name|ah_bssid
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|ahp
operator|->
name|ah_assoc_id
operator|&
literal|0x3fff
operator|)
operator|<<
name|AR_BSS_ID1_AID_S
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* cleared on write */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|AR_RSSI_THR_BM_THR
argument_list|,
name|INIT_RSSI_THR
argument_list|)
expr_stmt|;
comment|/* HW beacon processing */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RSSI_THR
argument_list|,
name|AR_RSSI_BCN_WEIGHT
argument_list|,
name|INIT_RSSI_BEACON_WEIGHT
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HWBCNPROC1
argument_list|,
name|AR_HWBCNPROC1_CRC_ENABLE
operator||
name|AR_HWBCNPROC1_EXCLUDE_TIM_ELM
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_beacon_filter_interval
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_HWBCNPROC2
argument_list|,
name|AR_HWBCNPROC2_FILTER_INTERVAL
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_config
operator|.
name|ath_hal_beacon_filter_interval
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HWBCNPROC2
argument_list|,
name|AR_HWBCNPROC2_FILTER_INTERVAL_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set Channel now modifies bank 6 parameters for FOWL workaround      * to force rf_pwd_icsyndiv bias current as function of synth      * frequency.Thus must be called after ar9300_process_ini() to ensure      * analog register cache is valid.      */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_rf_hal
operator|.
name|set_channel
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
condition|)
block|{
name|FAIL
argument_list|(
name|HAL_EIO
argument_list|)
expr_stmt|;
block|}
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_LINE
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Set 1:1 QCU to DCU mapping for all queues */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR_NUM_DCU
condition|;
name|i
operator|++
control|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DQCUMASK
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_intr_txqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_total_queues
condition|;
name|i
operator|++
control|)
block|{
name|ar9300_reset_tx_queue
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ar9300_init_interrupt_masks
argument_list|(
name|ah
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
comment|/* Reset ier reference count to disabled */
name|OS_ATOMIC_SET
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ier_ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_isrfkillenabled
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ar9300_enable_rf_kill
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
comment|/* must be called AFTER ini is processed */
name|ar9300_ani_init_defaults
argument_list|(
name|ah
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
name|ar9300_init_qos
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_init_user_settings
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|=
name|opmode
expr_stmt|;
comment|/* record operating mode */
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * disable seq number generation in hw      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_STA_ID1
argument_list|)
operator||
name|AR_STA_ID1_PRESERVE_SEQNUM
argument_list|)
expr_stmt|;
name|ar9300_set_dma
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/*      * program OBS bus to see MAC interrupts      */
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
operator|!
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_OBS
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_OBS
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enabling AR_GTTM_IGNORE_IDLE in GTTM register so that        GTT timer will not increment if the channel idle indicates         the air is busy or NAV is still counting down */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_GTTM
argument_list|,
name|AR_GTTM_IGNORE_IDLE
argument_list|)
expr_stmt|;
comment|/*      * GTT debug mode setting      */
comment|/*     OS_REG_WRITE(ah, 0x64, 0x00320000);     OS_REG_WRITE(ah, 0x68, 7);     OS_REG_WRITE(ah, 0x4080, 0xC);      */
comment|/*      * Disable general interrupt mitigation by setting MIRT = 0x0      * Rx and tx interrupt mitigation are conditionally enabled below.      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIRT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_rx
condition|)
block|{
comment|/*          * Enable Interrupt Mitigation for Rx.          * If no build-specific limits for the rx interrupt mitigation          * timer have been specified, use conservative defaults.          */
ifndef|#
directive|ifndef
name|AH_RIMT_VAL_LAST
define|#
directive|define
name|AH_RIMT_LAST_MICROSEC
value|500
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AH_RIMT_VAL_FIRST
define|#
directive|define
name|AH_RIMT_FIRST_MICROSEC
value|2000
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HOST_OFFLOAD
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_LAST
argument_list|,
name|AH_RIMT_LAST_MICROSEC
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_FIRST
argument_list|,
name|AH_RIMT_FIRST_MICROSEC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* lower mitigation level to reduce latency for offload arch. */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_LAST
argument_list|,
operator|(
name|AH_RIMT_LAST_MICROSEC
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_FIRST
argument_list|,
operator|(
name|AH_RIMT_FIRST_MICROSEC
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_tx
condition|)
block|{
comment|/*          * Enable Interrupt Mitigation for Tx.          * If no build-specific limits for the tx interrupt mitigation          * timer have been specified, use the values preferred for          * the carrier group's products.          */
ifndef|#
directive|ifndef
name|AH_TIMT_LAST
define|#
directive|define
name|AH_TIMT_LAST_MICROSEC
value|300
endif|#
directive|endif
ifndef|#
directive|ifndef
name|AH_TIMT_FIRST
define|#
directive|define
name|AH_TIMT_FIRST_MICROSEC
value|750
endif|#
directive|endif
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|,
name|AR_TIMT_LAST
argument_list|,
name|AH_TIMT_LAST_MICROSEC
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|,
name|AR_TIMT_FIRST
argument_list|,
name|AH_TIMT_FIRST_MICROSEC
argument_list|)
expr_stmt|;
block|}
name|rx_chainmask
operator|=
name|ahp
operator|->
name|ah_rx_chainmask
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_CHAINMASK
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CAL_CHAINMASK
argument_list|,
name|rx_chainmask
argument_list|)
expr_stmt|;
name|ar9300_init_bb
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* BB Step 7: Calibration */
name|ar9300_invalidate_saved_cals
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|cal_ret
operator|=
name|ar9300_init_cal
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|AH_FALSE
argument_list|,
name|apply_last_iqcorr
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
name|ahp
operator|->
name|ah_mci_ready
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|==
name|MCI_BT_SLEEP
operator|)
condition|)
block|{
if|if
condition|(
name|ar9300_mci_check_int
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET
argument_list|)
operator|||
name|ar9300_mci_check_int
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE
argument_list|)
condition|)
block|{
comment|/*                   * BT is sleeping. Check if BT wakes up duing WLAN                   * calibration. If BT wakes up during WLAN calibration, need                  * to go through all message exchanges again and recal.                  */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) ### %s: BT wakes up during WLAN calibration.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_RAW
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET
operator||
name|AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) send REMOTE_RESET\n"
argument_list|)
expr_stmt|;
name|ar9300_mci_remote_reset
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|ar9300_mci_send_sys_waking
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
name|OS_DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|ar9300_mci_send_lna_transfer
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_mci_bt_state
operator|=
name|MCI_BT_AWAKE
expr_stmt|;
comment|/* Redo calibration */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) %s: Re-calibrate.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ar9300_invalidate_saved_cals
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|cal_ret
operator|=
name|ar9300_init_cal
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
name|AH_FALSE
argument_list|,
name|ar9300_init_cal
argument_list|)
expr_stmt|;
block|}
block|}
name|ar9300_mci_enable_interrupt
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|cal_ret
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Init Cal Failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|HAL_ESELFTEST
argument_list|)
expr_stmt|;
block|}
name|ar9300_init_txbf
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * WAR for owl 1.0 - restore chain mask for 2-chain cfgs after cal      */
block|rx_chainmask = ahp->ah_rx_chainmask;     if ((rx_chainmask == 0x5) || (rx_chainmask == 0x3)) {         OS_REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx_chainmask);         OS_REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx_chainmask);     }
endif|#
directive|endif
comment|/* Restore previous led state */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_CFG_LED
argument_list|,
name|save_led_state
operator||
name|AR_CFG_SCLK_32KHZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_BT_COEX
if|if
condition|(
name|ahp
operator|->
name|ah_bt_coex_config_type
operator|!=
name|HAL_BT_COEX_CFG_NONE
condition|)
block|{
name|ar9300_init_bt_coex
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_mci_support
operator|&&
name|ahp
operator|->
name|ah_mci_ready
condition|)
block|{
comment|/* Check BT state again to make sure it's not changed. */
name|ar9300_mci_sync_bt_state
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_mci_2g5g_switch
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_mci_bt_state
operator|==
name|MCI_BT_AWAKE
operator|)
operator|&&
operator|(
name|ahp
operator|->
name|ah_mci_query_bt
operator|==
name|AH_TRUE
operator|)
condition|)
block|{
name|ahp
operator|->
name|ah_mci_need_flush_btinfo
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Start TSF2 for generic timer 8-15. */
name|ar9300_start_tsf2
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* MIMO Power save setting */
if|if
condition|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_DYNAMIC_SMPS
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|ar9300_set_sm_power_mode
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_sm_power_mode
argument_list|)
expr_stmt|;
block|}
comment|/*      * For big endian systems turn on swapping for descriptors      */
if|#
directive|if
name|AH_BYTE_ORDER
operator|==
name|AH_BIG_ENDIAN
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_CFG
argument_list|,
name|AR_CFG_SWTB
operator||
name|AR_CFG_SWRB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar9300_init_cfg_reg
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW
argument_list|(
name|ah
argument_list|,
name|AR_CFG_LED
argument_list|,
name|AR_CFG_LED_ASSOC_CTL
argument_list|,
name|AR_CFG_LED_ASSOC_CTL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ART_BUILD
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|ATH_SUPPORT_LED
argument_list|)
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val);
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
define|#
directive|define
name|ATH_GPIO_OUT_FUNCTION3
value|0xB8040038
define|#
directive|define
name|ATH_GPIO_OE
value|0xB8040000
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0xff
operator|<<
literal|8
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x33
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable 2G WLAN LED. During ath_open, reset function is called even before channel is set.              So 2GHz is taken as default and it also blinks. Hence              to avoid both from blinking, disable 2G led while in 5G mode */
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0xff
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x33
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0x1
operator|<<
literal|12
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0xff
operator|<<
literal|8
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x2F
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CHAN_5GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|,
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OUT_FUNCTION3
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0xff
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x2F
operator|)
argument_list|)
expr_stmt|;
name|REG_WRITE
argument_list|(
name|ATH_GPIO_OE
argument_list|,
operator|(
operator|(
name|REG_READ
argument_list|(
name|ATH_GPIO_OE
argument_list|)
operator|&
operator|(
operator|~
operator|(
literal|0x1
operator|<<
literal|12
operator|)
operator|)
operator|)
operator||
operator|(
literal|0x1
operator|<<
literal|13
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
endif|#
directive|endif
name|chan
operator|->
name|channel_flags
operator|=
name|ichan
operator|->
name|channel_flags
expr_stmt|;
name|chan
operator|->
name|priv_flags
operator|=
name|ichan
operator|->
name|priv_flags
expr_stmt|;
if|#
directive|if
name|FIX_NOISE_FLOOR
name|ar9300_get_nf_hist_base
argument_list|(
name|ah
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
argument_list|,
name|is_scan
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
name|ar9300_load_nf
argument_list|(
name|ah
argument_list|,
name|nf_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf_hist_buff_reset
operator|==
literal|1
condition|)
block|{
name|nf_hist_buff_reset
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|ATH_NF_PER_CHAN
if|if
condition|(
name|First_NFCal
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|is_scan
argument_list|,
name|chan
argument_list|)
condition|)
block|{         }
endif|#
directive|endif
comment|/* ATH_NF_PER_CHAN */
block|}
else|else
block|{
name|ar9300_start_nf_cal
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR9300
comment|/* BB Panic Watchdog */
if|if
condition|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_BB_PANIC_WATCHDOG
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|ar9300_config_bb_panic_watchdog
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* While receiving unsupported rate frame receive state machine      * gets into a state 0xb and if phy_restart happens when rx      * state machine is in 0xb state, BB would go hang, if we      * see 0xb state after first bb panic, make sure that we      * disable the phy_restart.      *       * There may be multiple panics, make sure that we always do      * this if we see this panic at least once. This is required      * because reset seems to be writing from INI file.      */
if|if
condition|(
operator|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_PHYRESTART_CLR_WAR
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
operator|)
operator|&&
operator|(
operator|(
operator|(
name|MS
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_bb_panic_last_status
operator|)
argument_list|,
name|AR_PHY_BB_WD_RX_OFDM_SM
argument_list|)
operator|)
operator|==
literal|0xb
operator|)
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyrestart_disabled
operator|)
condition|)
block|{
name|ar9300_disable_phy_restart
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_radar1
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_1
argument_list|)
argument_list|,
name|AR_PHY_RADAR_1_CF_BIN_THRESH
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_dc_offset
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING2
argument_list|)
argument_list|,
name|AR_PHY_TIMING2_DC_OFFSET
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_disable_cck
operator|=
name|MS
argument_list|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MODE
argument_list|)
argument_list|,
name|AR_PHY_MODE_DISABLE_CCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ah_enable_keysearch_always
condition|)
block|{
name|ar9300_enable_keysearch_always
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ATH_LOW_POWER_ENABLE
define|#
directive|define
name|REG_WRITE
parameter_list|(
name|_reg
parameter_list|,
name|_val
parameter_list|)
value|*((volatile u_int32_t *)(_reg)) = (_val)
define|#
directive|define
name|REG_READ
parameter_list|(
name|_reg
parameter_list|)
value|*((volatile u_int32_t *)(_reg))
if|if
condition|(
name|AR_SREV_OSPREY
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|REG_WRITE
argument_list|(
literal|0xb4000080
argument_list|,
name|REG_READ
argument_list|(
literal|0xb4000080
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_RTC_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_PM_CTRL
argument_list|)
argument_list|,
name|AR_PCIE_PM_CTRL_ENA
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_SPARE
argument_list|)
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|REG_READ
undef|#
directive|undef
name|REG_WRITE
endif|#
directive|endif
comment|/* ATH_LOW_POWER_ENABLE */
name|WAR_USB_DISABLE_PLL_LOCK_DETECT
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* H/W Green TX */
name|ar9300_control_signals_for_green_tx_mode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* Smart Antenna, only for 5GHz on Scropion */
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|)
argument_list|)
operator|&&
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|ah_smartantenna_enable
operator|=
literal|0
expr_stmt|;
block|}
name|ar9300_set_smart_antenna
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_smartantenna_enable
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
name|bad
label|:
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_RESET_DONE
argument_list|,
name|ecode
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
name|ecode
expr_stmt|;
return|return
name|AH_FALSE
return|;
undef|#
directive|undef
name|FAIL
block|}
end_function

begin_function
name|void
name|ar9300_green_ap_ps_on_off
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|on_off
parameter_list|)
block|{
comment|/* Set/reset the ps flag */
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|green_ap_ps_on
operator|=
operator|!
operator|!
name|on_off
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function returns 1, where it is possible to do  * single-chain power save.  */
end_comment

begin_function
name|u_int16_t
name|ar9300_is_single_ant_power_save_possible
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/* To avoid compilation warnings. Functions not used when EMULATION. */
end_comment

begin_comment
comment|/*  * ar9300_find_mag_approx()  */
end_comment

begin_function
specifier|static
name|int32_t
name|ar9300_find_mag_approx
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|in_re
parameter_list|,
name|int32_t
name|in_im
parameter_list|)
block|{
name|int32_t
name|abs_i
init|=
name|abs
argument_list|(
name|in_re
argument_list|)
decl_stmt|;
name|int32_t
name|abs_q
init|=
name|abs
argument_list|(
name|in_im
argument_list|)
decl_stmt|;
name|int32_t
name|max_abs
decl_stmt|,
name|min_abs
decl_stmt|;
if|if
condition|(
name|abs_i
operator|>
name|abs_q
condition|)
block|{
name|max_abs
operator|=
name|abs_i
expr_stmt|;
name|min_abs
operator|=
name|abs_q
expr_stmt|;
block|}
else|else
block|{
name|max_abs
operator|=
name|abs_q
expr_stmt|;
name|min_abs
operator|=
name|abs_i
expr_stmt|;
block|}
return|return
operator|(
name|max_abs
operator|-
operator|(
name|max_abs
operator|/
literal|32
operator|)
operator|+
operator|(
name|min_abs
operator|/
literal|8
operator|)
operator|+
operator|(
name|min_abs
operator|/
literal|4
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * ar9300_solve_iq_cal()         * solve 4x4 linear equation used in loopback iq cal.  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_solve_iq_cal
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|sin_2phi_1
parameter_list|,
name|int32_t
name|cos_2phi_1
parameter_list|,
name|int32_t
name|sin_2phi_2
parameter_list|,
name|int32_t
name|cos_2phi_2
parameter_list|,
name|int32_t
name|mag_a0_d0
parameter_list|,
name|int32_t
name|phs_a0_d0
parameter_list|,
name|int32_t
name|mag_a1_d0
parameter_list|,
name|int32_t
name|phs_a1_d0
parameter_list|,
name|int32_t
name|solved_eq
index|[]
parameter_list|)
block|{
name|int32_t
name|f1
init|=
name|cos_2phi_1
operator|-
name|cos_2phi_2
decl_stmt|;
name|int32_t
name|f3
init|=
name|sin_2phi_1
operator|-
name|sin_2phi_2
decl_stmt|;
name|int32_t
name|f2
decl_stmt|;
name|int32_t
name|mag_tx
decl_stmt|,
name|phs_tx
decl_stmt|,
name|mag_rx
decl_stmt|,
name|phs_rx
decl_stmt|;
specifier|const
name|int32_t
name|result_shift
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
name|f2
operator|=
operator|(
operator|(
operator|(
name|int64_t
operator|)
name|f1
operator|*
operator|(
name|int64_t
operator|)
name|f1
operator|)
operator|/
name|result_shift
operator|)
operator|+
operator|(
operator|(
operator|(
name|int64_t
operator|)
name|f3
operator|*
operator|(
name|int64_t
operator|)
name|f3
operator|)
operator|/
name|result_shift
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|f2
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Divide by 0(%d).\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* magnitude mismatch, tx */
name|mag_tx
operator|=
name|f1
operator|*
operator|(
name|mag_a0_d0
operator|-
name|mag_a1_d0
operator|)
operator|+
name|f3
operator|*
operator|(
name|phs_a0_d0
operator|-
name|phs_a1_d0
operator|)
expr_stmt|;
comment|/* phase mismatch, tx */
name|phs_tx
operator|=
name|f3
operator|*
operator|(
operator|-
name|mag_a0_d0
operator|+
name|mag_a1_d0
operator|)
operator|+
name|f1
operator|*
operator|(
name|phs_a0_d0
operator|-
name|phs_a1_d0
operator|)
expr_stmt|;
name|mag_tx
operator|=
operator|(
name|mag_tx
operator|/
name|f2
operator|)
expr_stmt|;
name|phs_tx
operator|=
operator|(
name|phs_tx
operator|/
name|f2
operator|)
expr_stmt|;
comment|/* magnitude mismatch, rx */
name|mag_rx
operator|=
name|mag_a0_d0
operator|-
operator|(
name|cos_2phi_1
operator|*
name|mag_tx
operator|+
name|sin_2phi_1
operator|*
name|phs_tx
operator|)
operator|/
name|result_shift
expr_stmt|;
comment|/* phase mismatch, rx */
name|phs_rx
operator|=
name|phs_a0_d0
operator|+
operator|(
name|sin_2phi_1
operator|*
name|mag_tx
operator|-
name|cos_2phi_1
operator|*
name|phs_tx
operator|)
operator|/
name|result_shift
expr_stmt|;
name|solved_eq
index|[
literal|0
index|]
operator|=
name|mag_tx
expr_stmt|;
name|solved_eq
index|[
literal|1
index|]
operator|=
name|phs_tx
expr_stmt|;
name|solved_eq
index|[
literal|2
index|]
operator|=
name|mag_rx
expr_stmt|;
name|solved_eq
index|[
literal|3
index|]
operator|=
name|phs_rx
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * ar9300_calc_iq_corr()  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_calc_iq_corr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int32_t
name|chain_idx
parameter_list|,
specifier|const
name|int32_t
name|iq_res
index|[]
parameter_list|,
name|int32_t
name|iqc_coeff
index|[]
parameter_list|)
block|{
name|int32_t
name|i2_m_q2_a0_d0
decl_stmt|,
name|i2_p_q2_a0_d0
decl_stmt|,
name|iq_corr_a0_d0
decl_stmt|;
name|int32_t
name|i2_m_q2_a0_d1
decl_stmt|,
name|i2_p_q2_a0_d1
decl_stmt|,
name|iq_corr_a0_d1
decl_stmt|;
name|int32_t
name|i2_m_q2_a1_d0
decl_stmt|,
name|i2_p_q2_a1_d0
decl_stmt|,
name|iq_corr_a1_d0
decl_stmt|;
name|int32_t
name|i2_m_q2_a1_d1
decl_stmt|,
name|i2_p_q2_a1_d1
decl_stmt|,
name|iq_corr_a1_d1
decl_stmt|;
name|int32_t
name|mag_a0_d0
decl_stmt|,
name|mag_a1_d0
decl_stmt|,
name|mag_a0_d1
decl_stmt|,
name|mag_a1_d1
decl_stmt|;
name|int32_t
name|phs_a0_d0
decl_stmt|,
name|phs_a1_d0
decl_stmt|,
name|phs_a0_d1
decl_stmt|,
name|phs_a1_d1
decl_stmt|;
name|int32_t
name|sin_2phi_1
decl_stmt|,
name|cos_2phi_1
decl_stmt|,
name|sin_2phi_2
decl_stmt|,
name|cos_2phi_2
decl_stmt|;
name|int32_t
name|mag_tx
decl_stmt|,
name|phs_tx
decl_stmt|,
name|mag_rx
decl_stmt|,
name|phs_rx
decl_stmt|;
name|int32_t
name|solved_eq
index|[
literal|4
index|]
decl_stmt|,
name|mag_corr_tx
decl_stmt|,
name|phs_corr_tx
decl_stmt|,
name|mag_corr_rx
decl_stmt|,
name|phs_corr_rx
decl_stmt|;
name|int32_t
name|q_q_coff
decl_stmt|,
name|q_i_coff
decl_stmt|;
specifier|const
name|int32_t
name|res_scale
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
specifier|const
name|int32_t
name|delpt_shift
init|=
literal|1
operator|<<
literal|8
decl_stmt|;
name|int32_t
name|mag1
decl_stmt|,
name|mag2
decl_stmt|;
name|i2_m_q2_a0_d0
operator|=
name|iq_res
index|[
literal|0
index|]
operator|&
literal|0xfff
expr_stmt|;
name|i2_p_q2_a0_d0
operator|=
operator|(
name|iq_res
index|[
literal|0
index|]
operator|>>
literal|12
operator|)
operator|&
literal|0xfff
expr_stmt|;
name|iq_corr_a0_d0
operator|=
operator|(
operator|(
name|iq_res
index|[
literal|0
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|iq_res
index|[
literal|1
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|i2_m_q2_a0_d0
operator|>
literal|0x800
condition|)
block|{
name|i2_m_q2_a0_d0
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|i2_m_q2_a0_d0
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iq_corr_a0_d0
operator|>
literal|0x800
condition|)
block|{
name|iq_corr_a0_d0
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|iq_corr_a0_d0
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|i2_m_q2_a0_d1
operator|=
operator|(
name|iq_res
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xfff
expr_stmt|;
name|i2_p_q2_a0_d1
operator|=
operator|(
name|iq_res
index|[
literal|2
index|]
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|iq_corr_a0_d1
operator|=
operator|(
name|iq_res
index|[
literal|2
index|]
operator|>>
literal|12
operator|)
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|i2_m_q2_a0_d1
operator|>
literal|0x800
condition|)
block|{
name|i2_m_q2_a0_d1
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|i2_m_q2_a0_d1
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iq_corr_a0_d1
operator|>
literal|0x800
condition|)
block|{
name|iq_corr_a0_d1
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|iq_corr_a0_d1
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|i2_m_q2_a1_d0
operator|=
operator|(
operator|(
name|iq_res
index|[
literal|2
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|iq_res
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|i2_p_q2_a1_d0
operator|=
operator|(
name|iq_res
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xfff
expr_stmt|;
name|iq_corr_a1_d0
operator|=
name|iq_res
index|[
literal|4
index|]
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|i2_m_q2_a1_d0
operator|>
literal|0x800
condition|)
block|{
name|i2_m_q2_a1_d0
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|i2_m_q2_a1_d0
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iq_corr_a1_d0
operator|>
literal|0x800
condition|)
block|{
name|iq_corr_a1_d0
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|iq_corr_a1_d0
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|i2_m_q2_a1_d1
operator|=
operator|(
name|iq_res
index|[
literal|4
index|]
operator|>>
literal|12
operator|)
operator|&
literal|0xfff
expr_stmt|;
name|i2_p_q2_a1_d1
operator|=
operator|(
operator|(
name|iq_res
index|[
literal|4
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|iq_res
index|[
literal|5
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|iq_corr_a1_d1
operator|=
operator|(
name|iq_res
index|[
literal|5
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|i2_m_q2_a1_d1
operator|>
literal|0x800
condition|)
block|{
name|i2_m_q2_a1_d1
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|i2_m_q2_a1_d1
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|iq_corr_a1_d1
operator|>
literal|0x800
condition|)
block|{
name|iq_corr_a1_d1
operator|=
operator|-
operator|(
operator|(
literal|0xfff
operator|-
name|iq_corr_a1_d1
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i2_p_q2_a0_d0
operator|==
literal|0
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d1
operator|==
literal|0
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d0
operator|==
literal|0
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d1
operator|==
literal|0
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Divide by 0(%d):\na0_d0=%d\na0_d1=%d\na2_d0=%d\na1_d1=%d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|i2_p_q2_a0_d0
argument_list|,
name|i2_p_q2_a0_d1
argument_list|,
name|i2_p_q2_a1_d0
argument_list|,
name|i2_p_q2_a1_d1
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
operator|(
name|i2_p_q2_a0_d0
operator|<=
literal|1024
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d0
operator|>
literal|2047
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d0
operator|<
literal|0
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d1
operator|<
literal|0
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d0
operator|<=
name|i2_m_q2_a0_d0
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d0
operator|<=
name|iq_corr_a0_d0
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d1
operator|<=
name|i2_m_q2_a0_d1
operator|)
operator|||
operator|(
name|i2_p_q2_a0_d1
operator|<=
name|iq_corr_a0_d1
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d0
operator|<=
name|i2_m_q2_a1_d0
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d0
operator|<=
name|iq_corr_a1_d0
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d1
operator|<=
name|i2_m_q2_a1_d1
operator|)
operator|||
operator|(
name|i2_p_q2_a1_d1
operator|<=
name|iq_corr_a1_d1
operator|)
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
name|mag_a0_d0
operator|=
operator|(
name|i2_m_q2_a0_d0
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a0_d0
expr_stmt|;
name|phs_a0_d0
operator|=
operator|(
name|iq_corr_a0_d0
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a0_d0
expr_stmt|;
name|mag_a0_d1
operator|=
operator|(
name|i2_m_q2_a0_d1
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a0_d1
expr_stmt|;
name|phs_a0_d1
operator|=
operator|(
name|iq_corr_a0_d1
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a0_d1
expr_stmt|;
name|mag_a1_d0
operator|=
operator|(
name|i2_m_q2_a1_d0
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a1_d0
expr_stmt|;
name|phs_a1_d0
operator|=
operator|(
name|iq_corr_a1_d0
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a1_d0
expr_stmt|;
name|mag_a1_d1
operator|=
operator|(
name|i2_m_q2_a1_d1
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a1_d1
expr_stmt|;
name|phs_a1_d1
operator|=
operator|(
name|iq_corr_a1_d1
operator|*
name|res_scale
operator|)
operator|/
name|i2_p_q2_a1_d1
expr_stmt|;
comment|/* without analog phase shift */
name|sin_2phi_1
operator|=
operator|(
operator|(
operator|(
name|mag_a0_d0
operator|-
name|mag_a0_d1
operator|)
operator|*
name|delpt_shift
operator|)
operator|/
name|DELPT
operator|)
expr_stmt|;
comment|/* without analog phase shift */
name|cos_2phi_1
operator|=
operator|(
operator|(
operator|(
name|phs_a0_d1
operator|-
name|phs_a0_d0
operator|)
operator|*
name|delpt_shift
operator|)
operator|/
name|DELPT
operator|)
expr_stmt|;
comment|/* with  analog phase shift */
name|sin_2phi_2
operator|=
operator|(
operator|(
operator|(
name|mag_a1_d0
operator|-
name|mag_a1_d1
operator|)
operator|*
name|delpt_shift
operator|)
operator|/
name|DELPT
operator|)
expr_stmt|;
comment|/* with analog phase shift */
name|cos_2phi_2
operator|=
operator|(
operator|(
operator|(
name|phs_a1_d1
operator|-
name|phs_a1_d0
operator|)
operator|*
name|delpt_shift
operator|)
operator|/
name|DELPT
operator|)
expr_stmt|;
comment|/* force sin^2 + cos^2 = 1; */
comment|/* find magnitude by approximation */
name|mag1
operator|=
name|ar9300_find_mag_approx
argument_list|(
name|ah
argument_list|,
name|cos_2phi_1
argument_list|,
name|sin_2phi_1
argument_list|)
expr_stmt|;
name|mag2
operator|=
name|ar9300_find_mag_approx
argument_list|(
name|ah
argument_list|,
name|cos_2phi_2
argument_list|,
name|sin_2phi_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mag1
operator|==
literal|0
operator|)
operator|||
operator|(
name|mag2
operator|==
literal|0
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Divide by 0(%d): mag1=%d, mag2=%d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mag1
argument_list|,
name|mag2
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* normalization sin and cos by mag */
name|sin_2phi_1
operator|=
operator|(
name|sin_2phi_1
operator|*
name|res_scale
operator|/
name|mag1
operator|)
expr_stmt|;
name|cos_2phi_1
operator|=
operator|(
name|cos_2phi_1
operator|*
name|res_scale
operator|/
name|mag1
operator|)
expr_stmt|;
name|sin_2phi_2
operator|=
operator|(
name|sin_2phi_2
operator|*
name|res_scale
operator|/
name|mag2
operator|)
expr_stmt|;
name|cos_2phi_2
operator|=
operator|(
name|cos_2phi_2
operator|*
name|res_scale
operator|/
name|mag2
operator|)
expr_stmt|;
comment|/* calculate IQ mismatch */
if|if
condition|(
name|AH_FALSE
operator|==
name|ar9300_solve_iq_cal
argument_list|(
name|ah
argument_list|,
name|sin_2phi_1
argument_list|,
name|cos_2phi_1
argument_list|,
name|sin_2phi_2
argument_list|,
name|cos_2phi_2
argument_list|,
name|mag_a0_d0
argument_list|,
name|phs_a0_d0
argument_list|,
name|mag_a1_d0
argument_list|,
name|phs_a1_d0
argument_list|,
name|solved_eq
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Call to ar9300_solve_iq_cal failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|mag_tx
operator|=
name|solved_eq
index|[
literal|0
index|]
expr_stmt|;
name|phs_tx
operator|=
name|solved_eq
index|[
literal|1
index|]
expr_stmt|;
name|mag_rx
operator|=
name|solved_eq
index|[
literal|2
index|]
expr_stmt|;
name|phs_rx
operator|=
name|solved_eq
index|[
literal|3
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: chain %d: mag mismatch=%d phase mismatch=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chain_idx
argument_list|,
name|mag_tx
operator|/
name|res_scale
argument_list|,
name|phs_tx
operator|/
name|res_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|res_scale
operator|==
name|mag_tx
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Divide by 0(%d): mag_tx=%d, res_scale=%d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mag_tx
argument_list|,
name|res_scale
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* calculate and quantize Tx IQ correction factor */
name|mag_corr_tx
operator|=
operator|(
name|mag_tx
operator|*
name|res_scale
operator|)
operator|/
operator|(
name|res_scale
operator|-
name|mag_tx
operator|)
expr_stmt|;
name|phs_corr_tx
operator|=
operator|-
name|phs_tx
expr_stmt|;
name|q_q_coff
operator|=
operator|(
name|mag_corr_tx
operator|*
literal|128
operator|/
name|res_scale
operator|)
expr_stmt|;
name|q_i_coff
operator|=
operator|(
name|phs_corr_tx
operator|*
literal|256
operator|/
name|res_scale
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: tx chain %d: mag corr=%d  phase corr=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chain_idx
argument_list|,
name|q_q_coff
argument_list|,
name|q_i_coff
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_i_coff
operator|<
operator|-
literal|63
condition|)
block|{
name|q_i_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_i_coff
operator|>
literal|63
condition|)
block|{
name|q_i_coff
operator|=
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_q_coff
operator|<
operator|-
literal|63
condition|)
block|{
name|q_q_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_q_coff
operator|>
literal|63
condition|)
block|{
name|q_q_coff
operator|=
literal|63
expr_stmt|;
block|}
name|iqc_coeff
index|[
literal|0
index|]
operator|=
operator|(
name|q_q_coff
operator|*
literal|128
operator|)
operator|+
operator|(
literal|0x7f
operator|&
name|q_i_coff
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: tx chain %d: iq corr coeff=%x\n"
argument_list|,
name|__func__
argument_list|,
name|chain_idx
argument_list|,
name|iqc_coeff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
name|mag_rx
operator|==
name|res_scale
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Divide by 0(%d): mag_rx=%d, res_scale=%d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mag_rx
argument_list|,
name|res_scale
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/* calculate and quantize Rx IQ correction factors */
name|mag_corr_rx
operator|=
operator|(
operator|-
name|mag_rx
operator|*
name|res_scale
operator|)
operator|/
operator|(
name|res_scale
operator|+
name|mag_rx
operator|)
expr_stmt|;
name|phs_corr_rx
operator|=
operator|-
name|phs_rx
expr_stmt|;
name|q_q_coff
operator|=
operator|(
name|mag_corr_rx
operator|*
literal|128
operator|/
name|res_scale
operator|)
expr_stmt|;
name|q_i_coff
operator|=
operator|(
name|phs_corr_rx
operator|*
literal|256
operator|/
name|res_scale
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rx chain %d: mag corr=%d  phase corr=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chain_idx
argument_list|,
name|q_q_coff
argument_list|,
name|q_i_coff
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_i_coff
operator|<
operator|-
literal|63
condition|)
block|{
name|q_i_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_i_coff
operator|>
literal|63
condition|)
block|{
name|q_i_coff
operator|=
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_q_coff
operator|<
operator|-
literal|63
condition|)
block|{
name|q_q_coff
operator|=
operator|-
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|q_q_coff
operator|>
literal|63
condition|)
block|{
name|q_q_coff
operator|=
literal|63
expr_stmt|;
block|}
name|iqc_coeff
index|[
literal|1
index|]
operator|=
operator|(
name|q_q_coff
operator|*
literal|128
operator|)
operator|+
operator|(
literal|0x7f
operator|&
name|q_i_coff
operator|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rx chain %d: iq corr coeff=%x\n"
argument_list|,
name|__func__
argument_list|,
name|chain_idx
argument_list|,
name|iqc_coeff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_MAG_DELTA
value|11
end_define

begin_comment
comment|//maximum magnitude mismatch delta across gains
end_comment

begin_define
define|#
directive|define
name|MAX_PHS_DELTA
value|10
end_define

begin_comment
comment|//maximum phase mismatch delta across gains
end_comment

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : (-(x)))
end_define

begin_decl_stmt
name|u_int32_t
name|tx_corr_coeff
index|[
name|MAX_MEASUREMENT
index|]
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|,     }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ar9300_tx_iq_cal_outlier_detection
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|u_int32_t
name|num_chains
parameter_list|,
name|struct
name|coeff_t
modifier|*
name|coeff
parameter_list|,
name|HAL_BOOL
name|is_cal_reusable
parameter_list|)
block|{
name|int
name|nmeasurement
decl_stmt|,
name|ch_idx
decl_stmt|,
name|im
decl_stmt|;
name|int32_t
name|magnitude
decl_stmt|,
name|phase
decl_stmt|;
name|int32_t
name|magnitude_max
decl_stmt|,
name|phase_max
decl_stmt|;
name|int32_t
name|magnitude_min
decl_stmt|,
name|phase_min
decl_stmt|;
name|int32_t
name|magnitude_max_idx
decl_stmt|,
name|phase_max_idx
decl_stmt|;
name|int32_t
name|magnitude_min_idx
decl_stmt|,
name|phase_min_idx
decl_stmt|;
name|int32_t
name|magnitude_avg
decl_stmt|,
name|phase_avg
decl_stmt|;
name|int32_t
name|outlier_mag_idx
init|=
literal|0
decl_stmt|;
name|int32_t
name|outlier_phs_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALASSERT
argument_list|(
name|num_chains
operator|==
literal|0x1
argument_list|)
expr_stmt|;
name|tx_corr_coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|6
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|7
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON
expr_stmt|;
block|}
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|num_chains
condition|;
name|ch_idx
operator|++
control|)
block|{
name|nmeasurement
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_STATUS_B0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_CALIBRATED_GAINS_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmeasurement
operator|>
name|MAX_MEASUREMENT
condition|)
block|{
name|nmeasurement
operator|=
name|MAX_MEASUREMENT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*              * reset max/min variable to min/max values so that              * we always start with 1st calibrated gain value              */
name|magnitude_max
operator|=
operator|-
literal|64
expr_stmt|;
name|phase_max
operator|=
operator|-
literal|64
expr_stmt|;
name|magnitude_min
operator|=
literal|63
expr_stmt|;
name|phase_min
operator|=
literal|63
expr_stmt|;
name|magnitude_avg
operator|=
literal|0
expr_stmt|;
name|phase_avg
operator|=
literal|0
expr_stmt|;
name|magnitude_max_idx
operator|=
literal|0
expr_stmt|;
name|magnitude_min_idx
operator|=
literal|0
expr_stmt|;
name|phase_max_idx
operator|=
literal|0
expr_stmt|;
name|phase_min_idx
operator|=
literal|0
expr_stmt|;
comment|/* detect outlier only if nmeasurement> 1 */
if|if
condition|(
name|nmeasurement
operator|>
literal|1
condition|)
block|{
comment|/* printf("----------- start outlier detection -----------\n"); */
comment|/*                  * find max/min and phase/mag mismatch across all calibrated gains                  */
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
name|magnitude
operator|=
name|coeff
operator|->
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
name|phase
operator|=
name|coeff
operator|->
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
name|magnitude_avg
operator|=
name|magnitude_avg
operator|+
name|magnitude
expr_stmt|;
name|phase_avg
operator|=
name|phase_avg
operator|+
name|phase
expr_stmt|;
if|if
condition|(
name|magnitude
operator|>
name|magnitude_max
condition|)
block|{
name|magnitude_max
operator|=
name|magnitude
expr_stmt|;
name|magnitude_max_idx
operator|=
name|im
expr_stmt|;
block|}
if|if
condition|(
name|magnitude
operator|<
name|magnitude_min
condition|)
block|{
name|magnitude_min
operator|=
name|magnitude
expr_stmt|;
name|magnitude_min_idx
operator|=
name|im
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|>
name|phase_max
condition|)
block|{
name|phase_max
operator|=
name|phase
expr_stmt|;
name|phase_max_idx
operator|=
name|im
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|<
name|phase_min
condition|)
block|{
name|phase_min
operator|=
name|phase
expr_stmt|;
name|phase_min_idx
operator|=
name|im
expr_stmt|;
block|}
block|}
comment|/* find average (exclude max abs value) */
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
name|magnitude
operator|=
name|coeff
operator|->
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
name|phase
operator|=
name|coeff
operator|->
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|magnitude
argument_list|)
operator|<
name|ABS
argument_list|(
name|magnitude_max
argument_list|)
operator|)
operator|||
operator|(
name|ABS
argument_list|(
name|magnitude
argument_list|)
operator|<
name|ABS
argument_list|(
name|magnitude_min
argument_list|)
operator|)
condition|)
block|{
name|magnitude_avg
operator|=
name|magnitude_avg
operator|+
name|magnitude
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ABS
argument_list|(
name|phase
argument_list|)
operator|<
name|ABS
argument_list|(
name|phase_max
argument_list|)
operator|)
operator|||
operator|(
name|ABS
argument_list|(
name|phase
argument_list|)
operator|<
name|ABS
argument_list|(
name|phase_min
argument_list|)
operator|)
condition|)
block|{
name|phase_avg
operator|=
name|phase_avg
operator|+
name|phase
expr_stmt|;
block|}
block|}
name|magnitude_avg
operator|=
name|magnitude_avg
operator|/
operator|(
name|nmeasurement
operator|-
literal|1
operator|)
expr_stmt|;
name|phase_avg
operator|=
name|phase_avg
operator|/
operator|(
name|nmeasurement
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* detect magnitude outlier */
if|if
condition|(
name|ABS
argument_list|(
name|magnitude_max
operator|-
name|magnitude_min
argument_list|)
operator|>
name|MAX_MAG_DELTA
condition|)
block|{
if|if
condition|(
name|ABS
argument_list|(
name|magnitude_max
operator|-
name|magnitude_avg
argument_list|)
operator|>
name|ABS
argument_list|(
name|magnitude_min
operator|-
name|magnitude_avg
argument_list|)
condition|)
block|{
comment|/* max is outlier, force to avg */
name|outlier_mag_idx
operator|=
name|magnitude_max_idx
expr_stmt|;
block|}
else|else
block|{
comment|/* min is outlier, force to avg */
name|outlier_mag_idx
operator|=
name|magnitude_min_idx
expr_stmt|;
block|}
name|coeff
operator|->
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|outlier_mag_idx
index|]
index|[
literal|0
index|]
operator|=
name|magnitude_avg
expr_stmt|;
name|coeff
operator|->
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|outlier_mag_idx
index|]
index|[
literal|0
index|]
operator|=
name|phase_avg
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"[ch%d][outlier mag gain%d]:: "
literal|"mag_avg = %d (/128), phase_avg = %d (/256)\n"
argument_list|,
name|ch_idx
argument_list|,
name|outlier_mag_idx
argument_list|,
name|magnitude_avg
argument_list|,
name|phase_avg
argument_list|)
expr_stmt|;
block|}
comment|/* detect phase outlier */
if|if
condition|(
name|ABS
argument_list|(
name|phase_max
operator|-
name|phase_min
argument_list|)
operator|>
name|MAX_PHS_DELTA
condition|)
block|{
if|if
condition|(
name|ABS
argument_list|(
name|phase_max
operator|-
name|phase_avg
argument_list|)
operator|>
name|ABS
argument_list|(
name|phase_min
operator|-
name|phase_avg
argument_list|)
condition|)
block|{
comment|/* max is outlier, force to avg */
name|outlier_phs_idx
operator|=
name|phase_max_idx
expr_stmt|;
block|}
else|else
block|{
comment|/* min is outlier, force to avg */
name|outlier_phs_idx
operator|=
name|phase_min_idx
expr_stmt|;
block|}
name|coeff
operator|->
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|outlier_phs_idx
index|]
index|[
literal|0
index|]
operator|=
name|magnitude_avg
expr_stmt|;
name|coeff
operator|->
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|outlier_phs_idx
index|]
index|[
literal|0
index|]
operator|=
name|phase_avg
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"[ch%d][outlier phs gain%d]:: "
literal|"mag_avg = %d (/128), phase_avg = %d (/256)\n"
argument_list|,
name|ch_idx
argument_list|,
name|outlier_phs_idx
argument_list|,
name|magnitude_avg
argument_list|,
name|phase_avg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*printf("------------ after outlier detection -------------\n");*/
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
name|magnitude
operator|=
name|coeff
operator|->
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
name|phase
operator|=
name|coeff
operator|->
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|printf("[ch%d][gain%d]:: mag = %d (/128), phase = %d (/256)\n",                 ch_idx, im, magnitude, phase);
endif|#
directive|endif
name|coeff
operator|->
name|iqc_coeff
index|[
literal|0
index|]
operator|=
operator|(
name|phase
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|magnitude
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|im
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE
argument_list|,
name|coeff
operator|->
name|iqc_coeff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE
argument_list|,
name|coeff
operator|->
name|iqc_coeff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
name|ichan
operator|->
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
operator|=
name|coeff
operator|->
name|iqc_coeff
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
name|ichan
operator|->
name|num_measures
index|[
name|ch_idx
index|]
operator|=
name|nmeasurement
expr_stmt|;
endif|#
directive|endif
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
if|if
condition|(
name|is_cal_reusable
condition|)
block|{
name|ichan
operator|->
name|one_time_txiqcal_done
operator|=
name|AH_TRUE
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_FCS_RTT
argument_list|,
literal|"(FCS) TXIQCAL saved - %d\n"
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|ATH_SUPPORT_CAL_REUSE
end_if

begin_function
specifier|static
name|void
name|ar9300_tx_iq_cal_apply
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|nmeasurement
decl_stmt|,
name|ch_idx
decl_stmt|,
name|im
decl_stmt|;
name|u_int32_t
name|tx_corr_coeff
index|[
name|MAX_MEASUREMENT
index|]
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|,     }
decl_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|HALASSERT
argument_list|(
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|==
literal|0x1
argument_list|)
expr_stmt|;
name|tx_corr_coeff
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|5
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|6
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON
expr_stmt|;
name|tx_corr_coeff
index|[
literal|7
index|]
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON
expr_stmt|;
block|}
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ch_idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahp
operator|->
name|ah_tx_cal_chainmask
operator|&
operator|(
literal|1
operator|<<
name|ch_idx
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|nmeasurement
operator|=
name|ichan
operator|->
name|num_measures
index|[
name|ch_idx
index|]
expr_stmt|;
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|im
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE
argument_list|,
name|ichan
operator|->
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE
argument_list|,
name|ichan
operator|->
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0
argument_list|,
name|AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ar9300_tx_iq_cal_hw_run is only needed for osprey/wasp/hornet  * It is not needed for jupiter/poseidon.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_tx_iq_cal_hw_run
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|is_tx_gain_forced
decl_stmt|;
name|is_tx_gain_forced
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_FORCED_GAIN
argument_list|,
name|AR_PHY_TXGAIN_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tx_gain_forced
condition|)
block|{
comment|/*printf("Tx gain can not be forced during tx I/Q cal!\n");*/
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_FORCED_GAIN
argument_list|,
name|AR_PHY_TXGAIN_FORCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* enable tx IQ cal */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_START
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_START_DO_CAL
argument_list|,
name|AR_PHY_TX_IQCAL_START_DO_CAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_wait
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_START
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_TX_IQCAL_START_DO_CAL
argument_list|,
literal|0
argument_list|,
name|AH_WAIT_TIMEOUT
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Tx IQ Cal is never completed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_tx_iq_cal_post_proc
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
parameter_list|,
name|int
name|iqcal_idx
parameter_list|,
name|int
name|max_iqcal
parameter_list|,
name|HAL_BOOL
name|is_cal_reusable
parameter_list|,
name|HAL_BOOL
name|apply_last_corr
parameter_list|)
block|{
name|int
name|nmeasurement
init|=
literal|0
decl_stmt|,
name|im
decl_stmt|,
name|ix
decl_stmt|,
name|iy
decl_stmt|,
name|temp
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|txiqcal_status
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
name|AR_PHY_TX_IQCAL_STATUS_B0
argument_list|(
name|ah
argument_list|)
block|,
name|AR_PHY_TX_IQCAL_STATUS_B1
block|,
name|AR_PHY_TX_IQCAL_STATUS_B2
block|,     }
decl_stmt|;
specifier|const
name|u_int32_t
name|chan_info_tab
index|[]
init|=
block|{
name|AR_PHY_CHAN_INFO_TAB_0
block|,
name|AR_PHY_CHAN_INFO_TAB_1
block|,
name|AR_PHY_CHAN_INFO_TAB_2
block|,     }
decl_stmt|;
name|int32_t
name|iq_res
index|[
literal|6
index|]
decl_stmt|;
name|int32_t
name|ch_idx
decl_stmt|,
name|j
decl_stmt|;
name|u_int32_t
name|num_chains
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|coeff_t
name|coeff
decl_stmt|;
name|txiqcal_status
index|[
literal|0
index|]
operator|=
name|AR_PHY_TX_IQCAL_STATUS_B0
argument_list|(
name|ah
argument_list|)
expr_stmt|;
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|AR9300_MAX_CHAINS
condition|;
name|ch_idx
operator|++
control|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_tx_chainmask
operator|&
operator|(
literal|1
operator|<<
name|ch_idx
operator|)
condition|)
block|{
name|num_chains
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apply_last_corr
condition|)
block|{
if|if
condition|(
name|coeff
operator|.
name|last_cal
operator|==
name|AH_TRUE
condition|)
block|{
name|int32_t
name|magnitude
decl_stmt|,
name|phase
decl_stmt|;
name|int
name|ch_idx
decl_stmt|,
name|im
decl_stmt|;
name|u_int32_t
name|tx_corr_coeff
index|[
name|MAX_MEASUREMENT
index|]
index|[
name|AR9300_MAX_CHAINS
index|]
init|=
block|{
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_23_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_45_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|,
block|{
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B0
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B1
block|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_67_B2
block|}
block|, 		    }
decl_stmt|;
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|num_chains
condition|;
name|ch_idx
operator|++
control|)
block|{
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|coeff
operator|.
name|last_nmeasurement
condition|;
name|im
operator|++
control|)
block|{
name|magnitude
operator|=
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
name|phase
operator|=
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|printf("[ch%d][gain%d]:: mag = %d (/128), phase = %d (/256)\n", 						    ch_idx, im, magnitude, phase);
endif|#
directive|endif
name|coeff
operator|.
name|iqc_coeff
index|[
literal|0
index|]
operator|=
operator|(
name|phase
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|magnitude
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|im
operator|%
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE
argument_list|,
name|coeff
operator|.
name|iqc_coeff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|tx_corr_coeff
index|[
name|im
index|]
index|[
name|ch_idx
index|]
argument_list|,
name|AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE
argument_list|,
name|coeff
operator|.
name|iqc_coeff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3
argument_list|,
name|AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|num_chains
condition|;
name|ch_idx
operator|++
control|)
block|{
name|nmeasurement
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TX_IQCAL_STATUS_B0
argument_list|(
name|ah
argument_list|)
argument_list|,
name|AR_PHY_CALIBRATED_GAINS_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmeasurement
operator|>
name|MAX_MEASUREMENT
condition|)
block|{
name|nmeasurement
operator|=
name|MAX_MEASUREMENT
expr_stmt|;
block|}
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Doing Tx IQ Cal for chain %d.\n"
argument_list|,
name|__func__
argument_list|,
name|ch_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|txiqcal_status
index|[
name|ch_idx
index|]
argument_list|)
operator|&
name|AR_PHY_TX_IQCAL_STATUS_FAILED
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Tx IQ Cal failed for chain %d.\n"
argument_list|,
name|__func__
argument_list|,
name|ch_idx
argument_list|)
expr_stmt|;
goto|goto
name|TX_IQ_CAL_FAILED_
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|u_int32_t
name|idx
init|=
literal|2
operator|*
name|j
decl_stmt|;
comment|/* 3 registers for each calibration result */
name|u_int32_t
name|offset
init|=
literal|4
operator|*
operator|(
literal|3
operator|*
name|im
operator|+
name|j
operator|)
decl_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_INFO_MEMORY
argument_list|,
name|AR_PHY_CHAN_INFO_TAB_S2_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 32 bits */
name|iq_res
index|[
name|idx
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|chan_info_tab
index|[
name|ch_idx
index|]
operator|+
name|offset
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CHAN_INFO_MEMORY
argument_list|,
name|AR_PHY_CHAN_INFO_TAB_S2_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 16 bits */
name|iq_res
index|[
name|idx
operator|+
literal|1
index|]
operator|=
literal|0xffff
operator|&
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|chan_info_tab
index|[
name|ch_idx
index|]
operator|+
name|offset
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: IQ RES[%d]=0x%x IQ_RES[%d]=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|iq_res
index|[
name|idx
index|]
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|iq_res
index|[
name|idx
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AH_FALSE
operator|==
name|ar9300_calc_iq_corr
argument_list|(
name|ah
argument_list|,
name|ch_idx
argument_list|,
name|iq_res
argument_list|,
name|coeff
operator|.
name|iqc_coeff
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"%s: Failed in calculation of IQ correction.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|TX_IQ_CAL_FAILED_
goto|;
block|}
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|=
name|coeff
operator|.
name|iqc_coeff
index|[
literal|0
index|]
operator|&
literal|0x7f
expr_stmt|;
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|=
operator|(
name|coeff
operator|.
name|iqc_coeff
index|[
literal|0
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|>
literal|63
condition|)
block|{
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|-=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|>
literal|63
condition|)
block|{
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iqcal_idx
operator|-
literal|1
index|]
operator|-=
literal|128
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|ath_hal_printf(ah, "IQCAL::[ch%d][gain%d]:: mag = %d phase = %d \n",                 ch_idx, im, coeff.mag_coeff[ch_idx][im][iqcal_idx-1],                 coeff.phs_coeff[ch_idx][im][iqcal_idx-1]);
endif|#
directive|endif
block|}
block|}
comment|//last iteration; calculate mag and phs
if|if
condition|(
name|iqcal_idx
operator|==
name|max_iqcal
condition|)
block|{
if|if
condition|(
name|max_iqcal
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|ch_idx
operator|=
literal|0
init|;
name|ch_idx
operator|<
name|num_chains
condition|;
name|ch_idx
operator|++
control|)
block|{
for|for
control|(
name|im
operator|=
literal|0
init|;
name|im
operator|<
name|nmeasurement
condition|;
name|im
operator|++
control|)
block|{
comment|//sort mag and phs
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|max_iqcal
operator|-
literal|1
condition|;
name|ix
operator|++
control|)
block|{
for|for
control|(
name|iy
operator|=
name|ix
operator|+
literal|1
init|;
name|iy
operator|<=
name|max_iqcal
operator|-
literal|1
condition|;
name|iy
operator|++
control|)
block|{
if|if
condition|(
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
operator|<
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
condition|)
block|{
comment|//swap
name|temp
operator|=
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
expr_stmt|;
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
operator|=
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
expr_stmt|;
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
operator|<
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
condition|)
block|{
comment|//swap
name|temp
operator|=
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
expr_stmt|;
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|ix
index|]
operator|=
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
expr_stmt|;
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|iy
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|//select median; 3rd entry in the sorted array
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
operator|=
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|max_iqcal
operator|/
literal|2
index|]
expr_stmt|;
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
operator|=
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
name|max_iqcal
operator|/
literal|2
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"IQCAL: Median [ch%d][gain%d]:: mag = %d phase = %d \n"
argument_list|,
name|ch_idx
argument_list|,
name|im
argument_list|,
name|coeff
operator|.
name|mag_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
argument_list|,
name|coeff
operator|.
name|phs_coeff
index|[
name|ch_idx
index|]
index|[
name|im
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ar9300_tx_iq_cal_outlier_detection
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|,
name|num_chains
argument_list|,
operator|&
name|coeff
argument_list|,
name|is_cal_reusable
argument_list|)
expr_stmt|;
block|}
name|coeff
operator|.
name|last_nmeasurement
operator|=
name|nmeasurement
expr_stmt|;
name|coeff
operator|.
name|last_cal
operator|=
name|AH_TRUE
expr_stmt|;
return|return;
name|TX_IQ_CAL_FAILED_
label|:
comment|/* no need to print this, it is AGC failure not chip stuck */
comment|/*ath_hal_printf(ah, "Tx IQ Cal failed(%d)\n", line);*/
name|coeff
operator|.
name|last_cal
operator|=
name|AH_FALSE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ar9300_disable_phy_restart  *  * In some BBpanics, we can disable the phyrestart  * disable_phy_restart  *      != 0, disable the phy restart in h/w  *      == 0, enable the phy restart in h/w  */
end_comment

begin_function
name|void
name|ar9300_disable_phy_restart
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|disable_phy_restart
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RESTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|disable_phy_restart
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RESTART_ENA
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyrestart_disabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator||=
name|AR_PHY_RESTART_ENA
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_phyrestart_disabled
operator|=
literal|0
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RESTART
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RESTART
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_interference_is_present
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/* This function is called after a stuck beacon, if EACS is enabled.      * If CW interference is severe, then HW goes into a loop of continuous      * stuck beacons and resets. On reset the NF cal history is cleared.      * So the median value of the history cannot be used -      * hence check if any value (Chain 0/Primary Channel)      * is outside the bounds.      */
name|HAL_NFCAL_HIST_FULL
modifier|*
name|h
init|=
name|AH_HOME_CHAN_NFCAL_HIST
argument_list|(
name|ah
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NF_CAL_HIST_LEN_FULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|nf_cal_buffer
index|[
name|i
index|]
index|[
literal|0
index|]
operator|>
name|ahpriv
operator|->
name|nfp
operator|->
name|nominal
operator|+
name|ahpriv
operator|->
name|nf_cw_int_delta
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ATH_SUPPORT_CRDC
end_if

begin_function
name|void
name|ar9300_crdc_rx_notify
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ath_rx_status
modifier|*
name|rxs
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|rssi_index
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_enable
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rxs
operator|->
name|rs_isaggr
operator|&&
name|rxs
operator|->
name|rs_moreaggr
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|rxs
operator|->
name|rs_rssi_ctl0
operator|>=
name|HAL_RSSI_BAD
operator|)
operator|||
operator|(
name|rxs
operator|->
name|rs_rssi_ctl1
operator|>=
name|HAL_RSSI_BAD
operator|)
condition|)
block|{
return|return;
block|}
name|rssi_index
operator|=
name|ah
operator|->
name|ah_crdc_rssi_ptr
operator|%
name|HAL_MAX_CRDC_RSSI_SAMPLE
expr_stmt|;
name|ah
operator|->
name|ah_crdc_rssi_sample
index|[
literal|0
index|]
index|[
name|rssi_index
index|]
operator|=
name|rxs
operator|->
name|rs_rssi_ctl0
expr_stmt|;
name|ah
operator|->
name|ah_crdc_rssi_sample
index|[
literal|1
index|]
index|[
name|rssi_index
index|]
operator|=
name|rxs
operator|->
name|rs_rssi_ctl1
expr_stmt|;
name|ah
operator|->
name|ah_crdc_rssi_ptr
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ar9300_crdc_avg_rssi
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|chain
parameter_list|)
block|{
name|int
name|crdc_rssi_sum
init|=
literal|0
decl_stmt|;
name|int
name|crdc_rssi_ptr
init|=
name|ah
operator|->
name|ah_crdc_rssi_ptr
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|crdc_window
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_window
decl_stmt|;
if|if
condition|(
name|crdc_window
operator|>
name|HAL_MAX_CRDC_RSSI_SAMPLE
condition|)
block|{
name|crdc_window
operator|=
name|HAL_MAX_CRDC_RSSI_SAMPLE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|crdc_window
condition|;
name|i
operator|++
control|)
block|{
name|crdc_rssi_sum
operator|+=
name|ah
operator|->
name|ah_crdc_rssi_sample
index|[
name|chain
index|]
index|[
operator|(
name|crdc_rssi_ptr
operator|-
name|i
operator|)
operator|%
name|HAL_MAX_CRDC_RSSI_SAMPLE
index|]
expr_stmt|;
block|}
return|return
name|crdc_rssi_sum
operator|/
name|crdc_window
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_crdc_activate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|rssi_diff
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|orig_val
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|crdc_numerator
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_numerator
decl_stmt|;
name|int
name|crdc_denominator
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_denominator
decl_stmt|;
name|int
name|c
init|=
operator|(
name|rssi_diff
operator|*
name|crdc_numerator
operator|)
operator|/
name|crdc_denominator
decl_stmt|;
name|val
operator|=
name|orig_val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MULTICHAIN_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xffffff00
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|val
operator||=
literal|0x1
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|c
operator|<<
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MULTICHAIN_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"diff: %02d comp: %02d reg: %08x %08x\n"
argument_list|,
name|rssi_diff
argument_list|,
name|c
argument_list|,
name|orig_val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_chain_rssi_diff_compensation
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|crdc_window
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_window
decl_stmt|;
name|int
name|crdc_rssi_ptr
init|=
name|ah
operator|->
name|ah_crdc_rssi_ptr
decl_stmt|;
name|int
name|crdc_rssi_thresh
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_rssithresh
decl_stmt|;
name|int
name|crdc_diff_thresh
init|=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_diffthresh
decl_stmt|;
name|int
name|avg_rssi
index|[
literal|2
index|]
decl_stmt|,
name|avg_rssi_diff
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_crdc_enable
operator|)
condition|)
block|{
if|if
condition|(
name|ah
operator|->
name|ah_crdc_rssi_ptr
condition|)
block|{
name|ar9300_crdc_activate
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_crdc_rssi_ptr
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|crdc_window
operator|>
name|HAL_MAX_CRDC_RSSI_SAMPLE
condition|)
block|{
name|crdc_window
operator|=
name|HAL_MAX_CRDC_RSSI_SAMPLE
expr_stmt|;
block|}
if|if
condition|(
name|crdc_rssi_ptr
operator|<
name|crdc_window
condition|)
block|{
return|return;
block|}
name|avg_rssi
index|[
literal|0
index|]
operator|=
name|ar9300_crdc_avg_rssi
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|avg_rssi
index|[
literal|1
index|]
operator|=
name|ar9300_crdc_avg_rssi
argument_list|(
name|ah
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|avg_rssi_diff
operator|=
name|avg_rssi
index|[
literal|1
index|]
operator|-
name|avg_rssi
index|[
literal|0
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CALIBRATE
argument_list|,
literal|"crdc: avg: %02d %02d "
argument_list|,
name|avg_rssi
index|[
literal|0
index|]
argument_list|,
name|avg_rssi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|avg_rssi
index|[
literal|0
index|]
operator|<
name|crdc_rssi_thresh
operator|)
operator|&&
operator|(
name|avg_rssi
index|[
literal|1
index|]
operator|<
name|crdc_rssi_thresh
operator|)
condition|)
block|{
name|ar9300_crdc_activate
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ABS
argument_list|(
name|avg_rssi_diff
argument_list|)
operator|>=
name|crdc_diff_thresh
condition|)
block|{
name|ar9300_crdc_activate
argument_list|(
name|ah
argument_list|,
name|avg_rssi_diff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar9300_crdc_activate
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ATH_ANT_DIV_COMB
end_if

begin_function
name|HAL_BOOL
name|ar9300_ant_ctrl_set_lna_div_use_bt_ant
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|enable
parameter_list|,
name|HAL_CHANNEL
modifier|*
name|chan
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|u_int32_t
name|regval
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahpriv
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|pcap
init|=
operator|&
name|ahpriv
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|// Make sure this scheme is only used for WB225(Astra)
name|ahp
operator|->
name|ah_lna_div_use_bt_ant_enable
operator|=
name|enable
expr_stmt|;
name|ichan
operator|=
name|ar9300_check_chan
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichan
operator|==
name|AH_NULL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_CHANNEL
argument_list|,
literal|"%s: invalid channel %u/0x%x; no mapping\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|channel
argument_list|,
name|chan
operator|->
name|channel_flags
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|enable
operator|==
name|TRUE
condition|)
block|{
name|pcap
operator|->
name|hal_ant_div_comb_support
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|pcap
operator|->
name|hal_ant_div_comb_support
operator|=
name|pcap
operator|->
name|hal_ant_div_comb_support_org
expr_stmt|;
block|}
define|#
directive|define
name|AR_SWITCH_TABLE_COM2_ALL
value|(0xffffff)
define|#
directive|define
name|AR_SWITCH_TABLE_COM2_ALL_S
value|(0)
name|value
operator|=
name|ar9300_ant_ctrl_common2_get
argument_list|(
name|ah
argument_list|,
name|IS_CHAN_2GHZ
argument_list|(
name|ichan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|==
name|TRUE
condition|)
block|{
name|value
operator|&=
operator|~
name|AR_SWITCH_TABLE_COM2_ALL
expr_stmt|;
name|value
operator||=
name|ahpriv
operator|->
name|ah_config
operator|.
name|ath_hal_ant_ctrl_comm2g_switch_enable
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SWITCH_COM_2
argument_list|,
name|AR_SWITCH_TABLE_COM2_ALL
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|ar9300_eeprom_get
argument_list|(
name|ahp
argument_list|,
name|EEP_ANTDIV_control
argument_list|)
expr_stmt|;
comment|/* main_lnaconf, alt_lnaconf, main_tb, alt_tb */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|ANT_DIV_CONTROL_ALL
operator|)
expr_stmt|;
comment|/* clear bit 25~30 */
name|regval
operator||=
operator|(
name|value
operator|&
literal|0x3f
operator|)
operator|<<
name|ANT_DIV_CONTROL_ALL_S
expr_stmt|;
comment|/* enable_lnadiv */
name|regval
operator|&=
operator|(
operator|~
name|MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__MASK
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__SHIFT
expr_stmt|;
if|if
condition|(
name|enable
operator|==
name|TRUE
condition|)
block|{
name|regval
operator||=
name|ANT_DIV_ENABLE
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* enable fast_div */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|(
operator|~
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
operator|(
name|value
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
operator|<<
name|BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__SHIFT
expr_stmt|;
if|if
condition|(
name|enable
operator|==
name|TRUE
condition|)
block|{
name|regval
operator||=
name|FAST_DIV_ENABLE
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_CCK_DETECT
argument_list|,
name|regval
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON_11_OR_LATER
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcap
operator|->
name|hal_ant_div_comb_support
condition|)
block|{
comment|/* If support DivComb, set MAIN to LNA1 and ALT to LNA2 at the first beginning */
name|regval
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|)
expr_stmt|;
comment|/* clear bit 25~30 main_lnaconf, alt_lnaconf, main_tb, alt_tb */
name|regval
operator|&=
operator|(
operator|~
operator|(
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK
operator||
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK
operator|)
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA1
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT
operator|)
expr_stmt|;
name|regval
operator||=
operator|(
name|HAL_ANT_DIV_COMB_LNA2
operator|<<
name|MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MC_GAIN_CTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
else|else
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_ANT_DIV_COMB */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AH_SUPPORT_AR9300 */
end_comment

end_unit

