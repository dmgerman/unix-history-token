begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_comment
comment|/*  * Note: The key cache hardware requires that each double-word  * pair be written in even/odd order (since the destination is  * a 64-bit register).  Don't reorder the writes in this code  * w/o considering this!  */
end_comment

begin_define
define|#
directive|define
name|KEY_XOR
value|0xaa
end_define

begin_define
define|#
directive|define
name|IS_MIC_ENABLED
parameter_list|(
name|ah
parameter_list|)
define|\
value|(AH9300(ah)->ah_sta_id1_defaults& AR_STA_ID1_CRPT_MIC_ENABLE)
end_define

begin_comment
comment|/*  * This isn't the keytable type; this is actually something separate  * for the TX descriptor.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|keyType
index|[]
init|=
block|{
literal|1
block|,
comment|/* HAL_CIPHER_WEP */
literal|0
block|,
comment|/* HAL_CIPHER_AES_OCB */
literal|2
block|,
comment|/* HAL_CIPHER_AES_CCM */
literal|0
block|,
comment|/* HAL_CIPHER_CKIP */
literal|3
block|,
comment|/* HAL_CIPHER_TKIP */
literal|0
comment|/* HAL_CIPHER_CLR */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the size of the hardware key cache.  */
end_comment

begin_function
name|u_int32_t
name|ar9300_get_key_cache_size
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halKeyCacheSize
return|;
block|}
end_function

begin_comment
comment|/*  * Return AH_TRUE if the specific key cache entry is valid.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_is_key_cache_entry_valid
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halKeyCacheSize
condition|)
block|{
name|u_int32_t
name|val
init|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC1
argument_list|(
name|entry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|AR_KEYTABLE_VALID
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the specified key cache entry and any associated MIC entry.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_reset_key_cache_entry
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|entry
parameter_list|)
block|{
name|u_int32_t
name|key_type
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|>=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halKeyCacheSize
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u out of range\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|ahp
operator|->
name|ah_keytype
index|[
name|entry
index|]
operator|=
name|keyType
index|[
name|HAL_CIPHER_CLR
index|]
expr_stmt|;
name|key_type
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX why not clear key type/valid bit first? */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|,
name|AR_KEYTABLE_TYPE_CLR
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC0
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC1
argument_list|(
name|entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_TKIP
operator|&&
name|IS_MIC_ENABLED
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|u_int16_t
name|micentry
init|=
name|entry
operator|+
literal|64
decl_stmt|;
comment|/* MIC goes at slot+64 */
name|HALASSERT
argument_list|(
name|micentry
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halKeyCacheSize
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NB: key type and MAC are known to be ok */
block|}
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|==
name|AH_NULL
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_BB_RIFS_HANG
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
if|if
condition|(
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_TKIP
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_40
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_104
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_128
condition|)
block|{
comment|/* SW WAR for Bug 31602 */
if|if
condition|(
operator|--
name|ahp
operator|->
name|ah_rifs_sec_cnt
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: Count = %d, enabling RIFS\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_rifs_sec_cnt
argument_list|)
expr_stmt|;
name|ar9300_set_rifs_delay
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the mac part of the specified key cache entry (and any  * associated MIC entry) and mark them valid.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_key_cache_entry_mac
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|entry
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|mac
parameter_list|)
block|{
name|u_int32_t
name|mac_hi
decl_stmt|,
name|mac_lo
decl_stmt|;
name|u_int32_t
name|unicast_addr
init|=
name|AR_KEYTABLE_VALID
decl_stmt|;
if|if
condition|(
name|entry
operator|>=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halKeyCacheSize
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u out of range\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*      * Set MAC address -- shifted right by 1.  mac_lo is      * the 4 MSBs, and mac_hi is the 2 LSBs.      */
if|if
condition|(
name|mac
operator|!=
name|AH_NULL
condition|)
block|{
comment|/*          *  If upper layers have requested mcast MACaddr lookup, then          *  signify this to the hw by setting the (poorly named) valid_bit          *  to 0.  Yes, really 0. The hardware specs, pcu_registers.txt, is          *  has incorrectly named valid_bit. It should be called "Unicast".          *  When the Key Cache entry is to decrypt Unicast frames, this bit          *  should be '1'; for multicast and broadcast frames, this bit is '0'.          */
if|if
condition|(
name|mac
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
block|{
name|unicast_addr
operator|=
literal|0
expr_stmt|;
comment|/* Not an unicast address */
block|}
name|mac_hi
operator|=
operator|(
name|mac
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|mac
index|[
literal|4
index|]
expr_stmt|;
name|mac_lo
operator|=
operator|(
name|mac
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mac
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mac
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|mac
index|[
literal|0
index|]
expr_stmt|;
name|mac_lo
operator|>>=
literal|1
expr_stmt|;
comment|/* Note that the bit 0 is shifted out. This bit is used to                       * indicate that this is a multicast key cache. */
name|mac_lo
operator||=
operator|(
name|mac_hi
operator|&
literal|1
operator|)
operator|<<
literal|31
expr_stmt|;
comment|/* carry */
name|mac_hi
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mac_lo
operator|=
name|mac_hi
operator|=
literal|0
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC0
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mac_lo
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC1
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mac_hi
operator||
name|unicast_addr
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the contents of the specified key cache entry  * and any associated MIC entry.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_key_cache_entry
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|entry
parameter_list|,
specifier|const
name|HAL_KEYVAL
modifier|*
name|k
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|mac
parameter_list|,
name|int
name|xor_key
parameter_list|)
block|{
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|u_int32_t
name|key0
decl_stmt|,
name|key1
decl_stmt|,
name|key2
decl_stmt|,
name|key3
decl_stmt|,
name|key4
decl_stmt|;
name|u_int32_t
name|key_type
decl_stmt|;
name|u_int32_t
name|xor_mask
init|=
name|xor_key
condition|?
operator|(
name|KEY_XOR
operator|<<
literal|24
operator||
name|KEY_XOR
operator|<<
literal|16
operator||
name|KEY_XOR
operator|<<
literal|8
operator||
name|KEY_XOR
operator|)
else|:
literal|0
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|pwrmgt
decl_stmt|,
name|pwrmgt_mic
decl_stmt|,
name|uapsd_cfg
decl_stmt|,
name|psta
init|=
literal|0
decl_stmt|;
name|int
name|is_proxysta_key
init|=
name|k
operator|->
name|kv_type
operator|&
name|HAL_KEY_PROXY_STA_MASK
decl_stmt|;
if|if
condition|(
name|entry
operator|>=
name|p_cap
operator|->
name|halKeyCacheSize
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u out of range\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s[%d] mac %s proxy %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mac
condition|?
name|ath_hal_ether_sprintf
argument_list|(
name|mac
argument_list|)
else|:
literal|"null"
argument_list|,
name|is_proxysta_key
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|k
operator|->
name|kv_type
operator|&
name|AH_KEYTYPE_MASK
condition|)
block|{
case|case
name|HAL_CIPHER_AES_OCB
case|:
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_AES
expr_stmt|;
break|break;
case|case
name|HAL_CIPHER_AES_CCM
case|:
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halCipherAesCcmSupport
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: AES-CCM not supported by "
literal|"mac rev 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_CCM
expr_stmt|;
break|break;
case|case
name|HAL_CIPHER_TKIP
case|:
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_TKIP
expr_stmt|;
if|if
condition|(
name|IS_MIC_ENABLED
argument_list|(
name|ah
argument_list|)
operator|&&
name|entry
operator|+
literal|64
operator|>=
name|p_cap
operator|->
name|halKeyCacheSize
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u inappropriate for TKIP\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
break|break;
case|case
name|HAL_CIPHER_WEP
case|:
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<
literal|40
operator|/
name|NBBY
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: WEP key length %u too small\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|kv_len
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|40
operator|/
name|NBBY
condition|)
block|{
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|104
operator|/
name|NBBY
condition|)
block|{
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_104
expr_stmt|;
block|}
else|else
block|{
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_128
expr_stmt|;
block|}
break|break;
case|case
name|HAL_CIPHER_CLR
case|:
name|key_type
operator|=
name|AR_KEYTABLE_TYPE_CLR
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: cipher %u not supported\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|kv_type
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|key0
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|0
argument_list|)
operator|^
name|xor_mask
expr_stmt|;
name|key1
operator|=
operator|(
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|4
argument_list|)
operator|^
name|xor_mask
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|key2
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|6
argument_list|)
operator|^
name|xor_mask
expr_stmt|;
name|key3
operator|=
operator|(
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|10
argument_list|)
operator|^
name|xor_mask
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|key4
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|12
argument_list|)
operator|^
name|xor_mask
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|104
operator|/
name|NBBY
condition|)
block|{
name|key4
operator|&=
literal|0xff
expr_stmt|;
block|}
comment|/* Extract the UAPSD AC bits and shift it appropriately */
name|uapsd_cfg
operator|=
name|k
operator|->
name|kv_apsd
expr_stmt|;
name|uapsd_cfg
operator|=
operator|(
name|u_int32_t
operator|)
name|SM
argument_list|(
name|uapsd_cfg
argument_list|,
name|AR_KEYTABLE_UAPSD
argument_list|)
expr_stmt|;
comment|/* Need to preserve the power management bit used by MAC */
name|pwrmgt
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&
name|AR_KEYTABLE_PWRMGT
expr_stmt|;
if|if
condition|(
name|is_proxysta_key
condition|)
block|{
name|u_int8_t
name|bcast_mac
index|[
literal|6
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|mac
operator|||
name|OS_MEMCMP
argument_list|(
name|mac
argument_list|,
name|bcast_mac
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|psta
operator|=
name|AR_KEYTABLE_DIR_ACK_BIT
expr_stmt|;
block|}
block|}
comment|/*      * Note: key cache hardware requires that each double-word      * pair be written in even/odd order (since the destination is      * a 64-bit register).  Don't reorder these writes w/o      * considering this!      */
if|if
condition|(
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_TKIP
operator|&&
name|IS_MIC_ENABLED
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|u_int16_t
name|micentry
init|=
name|entry
operator|+
literal|64
decl_stmt|;
comment|/* MIC goes at slot+64 */
comment|/* Need to preserve the power management bit used by MAC */
name|pwrmgt_mic
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|&
name|AR_KEYTABLE_PWRMGT
expr_stmt|;
comment|/*          * Invalidate the encrypt/decrypt key until the MIC          * key is installed so pending rx frames will fail          * with decrypt errors rather than a MIC error.          */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|~
name|key0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|~
name|key1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key2
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key3
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key4
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key_type
operator||
name|pwrmgt
operator||
name|uapsd_cfg
operator||
name|psta
argument_list|)
expr_stmt|;
name|ar9300_set_key_cache_entry_mac
argument_list|(
name|ah
argument_list|,
name|entry
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/*          * since the AR_MISC_MODE register was written with the contents of          * ah_misc_mode (if any) in ar9300_attach, just check ah_misc_mode and          * save a pci read per key set.          */
if|if
condition|(
name|ahp
operator|->
name|ah_misc_mode
operator|&
name|AR_PCU_MIC_NEW_LOC_ENA
condition|)
block|{
name|u_int32_t
name|mic0
decl_stmt|,
name|mic1
decl_stmt|,
name|mic2
decl_stmt|,
name|mic3
decl_stmt|,
name|mic4
decl_stmt|;
comment|/*              * both RX and TX mic values can be combined into              * one cache slot entry.              * 8*N + 800         31:0    RX Michael key 0              * 8*N + 804         15:0    TX Michael key 0 [31:16]              * 8*N + 808         31:0    RX Michael key 1              * 8*N + 80C         15:0    TX Michael key 0 [15:0]              * 8*N + 810         31:0    TX Michael key 1              * 8*N + 814         15:0    reserved              * 8*N + 818         31:0    reserved              * 8*N + 81C         14:0    reserved              *                   15      key valid == 0              */
comment|/* RX mic */
name|mic0
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|0
argument_list|)
expr_stmt|;
name|mic2
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* TX mic */
name|mic1
operator|=
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|2
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|mic3
operator|=
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|0
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|mic4
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|4
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic2
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic3
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic4
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|AR_KEYTABLE_TYPE_CLR
operator||
name|pwrmgt_mic
operator||
name|uapsd_cfg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|mic0
decl_stmt|,
name|mic2
decl_stmt|;
name|mic0
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|0
argument_list|)
expr_stmt|;
name|mic2
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|4
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|micentry
argument_list|)
argument_list|,
name|mic2
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|micentry
operator||
name|pwrmgt_mic
operator||
name|uapsd_cfg
argument_list|)
argument_list|,
name|AR_KEYTABLE_TYPE_CLR
argument_list|)
expr_stmt|;
block|}
comment|/* NB: MIC key is not marked valid and has no MAC address */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC0
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_MAC1
argument_list|(
name|micentry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* correct intentionally corrupted key */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key2
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key3
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key4
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|,
name|key_type
operator||
name|pwrmgt
operator||
name|uapsd_cfg
operator||
name|psta
argument_list|)
expr_stmt|;
comment|/*         ath_hal_printf(ah, "%s[%d] mac %s proxy %d\n",             __func__, __LINE__, mac ? ath_hal_ether_sprintf(mac) : "null",             is_proxysta_key);          */
name|ar9300_set_key_cache_entry_mac
argument_list|(
name|ah
argument_list|,
name|entry
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
name|ahp
operator|->
name|ah_keytype
index|[
name|entry
index|]
operator|=
name|keyType
index|[
name|k
operator|->
name|kv_type
index|]
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry=%d, k->kv_type=%d,"
literal|"keyType=%d\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|,
name|k
operator|->
name|kv_type
argument_list|,
name|keyType
index|[
name|k
operator|->
name|kv_type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|==
name|AH_NULL
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
if|if
condition|(
name|ar9300_get_capability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_BB_RIFS_HANG
argument_list|,
literal|0
argument_list|,
name|AH_NULL
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
if|if
condition|(
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_TKIP
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_40
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_104
operator|||
name|key_type
operator|==
name|AR_KEYTABLE_TYPE_128
condition|)
block|{
comment|/* SW WAR for Bug 31602 */
name|ahp
operator|->
name|ah_rifs_sec_cnt
operator|++
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: Count = %d, disabling RIFS\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_rifs_sec_cnt
argument_list|)
expr_stmt|;
name|ar9300_set_rifs_delay
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s[%d] mac %s proxy %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|mac
condition|?
name|ath_hal_ether_sprintf
argument_list|(
name|mac
argument_list|)
else|:
literal|"null"
argument_list|,
name|is_proxysta_key
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Enable the Keysearch for every subframe of an aggregate  */
end_comment

begin_function
name|void
name|ar9300_enable_keysearch_always
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|ah
condition|)
block|{
return|return;
block|}
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|val
operator||=
name|AR_PCU_ALWAYS_PERFORM_KEYSEARCH
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|AR_PCU_ALWAYS_PERFORM_KEYSEARCH
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_dump_keycache
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int32_t
modifier|*
name|entry
parameter_list|)
block|{
define|#
directive|define
name|AH_KEY_REG_SIZE
value|8
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AH_KEY_REG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|entry
index|[
name|i
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|n
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|AH_KEY_REG_SIZE
block|}
end_function

begin_if
if|#
directive|if
name|ATH_SUPPORT_KEYPLUMB_WAR
end_if

begin_comment
comment|/*  * Check the contents of the specified key cache entry  * and any associated MIC entry.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_check_key_cache_entry
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int16_t
name|entry
parameter_list|,
specifier|const
name|HAL_KEYVAL
modifier|*
name|k
parameter_list|,
name|int
name|xorKey
parameter_list|)
block|{
specifier|const
name|HAL_CAPABILITIES
modifier|*
name|pCap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|u_int32_t
name|key0
decl_stmt|,
name|key1
decl_stmt|,
name|key2
decl_stmt|,
name|key3
decl_stmt|,
name|key4
decl_stmt|;
name|u_int32_t
name|keyType
decl_stmt|;
name|u_int32_t
name|xorMask
init|=
name|xorKey
condition|?
operator|(
name|KEY_XOR
operator|<<
literal|24
operator||
name|KEY_XOR
operator|<<
literal|16
operator||
name|KEY_XOR
operator|<<
literal|8
operator||
name|KEY_XOR
operator|)
else|:
literal|0
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|>=
name|pCap
operator|->
name|hal_key_cache_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u out of range\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
switch|switch
condition|(
name|k
operator|->
name|kv_type
condition|)
block|{
case|case
name|HAL_CIPHER_AES_OCB
case|:
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_AES
expr_stmt|;
break|break;
case|case
name|HAL_CIPHER_AES_CCM
case|:
if|if
condition|(
operator|!
name|pCap
operator|->
name|hal_cipher_aes_ccm_support
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: AES-CCM not supported by "
literal|"mac rev 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_CCM
expr_stmt|;
break|break;
case|case
name|HAL_CIPHER_TKIP
case|:
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_TKIP
expr_stmt|;
if|if
condition|(
name|IS_MIC_ENABLED
argument_list|(
name|ah
argument_list|)
operator|&&
name|entry
operator|+
literal|64
operator|>=
name|pCap
operator|->
name|hal_key_cache_size
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: entry %u inappropriate for TKIP\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
break|break;
case|case
name|HAL_CIPHER_WEP
case|:
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<
literal|40
operator|/
name|NBBY
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: WEP key length %u too small\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|kv_len
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|40
operator|/
name|NBBY
condition|)
block|{
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|104
operator|/
name|NBBY
condition|)
block|{
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_104
expr_stmt|;
block|}
else|else
block|{
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_128
expr_stmt|;
block|}
break|break;
case|case
name|HAL_CIPHER_CLR
case|:
name|keyType
operator|=
name|AR_KEYTABLE_TYPE_CLR
expr_stmt|;
return|return
name|AH_TRUE
return|;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_KEYCACHE
argument_list|,
literal|"%s: cipher %u not supported\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|kv_type
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
name|key0
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|0
argument_list|)
operator|^
name|xorMask
expr_stmt|;
name|key1
operator|=
operator|(
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|4
argument_list|)
operator|^
name|xorMask
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|key2
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|6
argument_list|)
operator|^
name|xorMask
expr_stmt|;
name|key3
operator|=
operator|(
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|10
argument_list|)
operator|^
name|xorMask
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|key4
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_val
operator|+
literal|12
argument_list|)
operator|^
name|xorMask
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|kv_len
operator|<=
literal|104
operator|/
name|NBBY
condition|)
block|{
name|key4
operator|&=
literal|0xff
expr_stmt|;
block|}
comment|/*      * Note: key cache hardware requires that each double-word      * pair be written in even/odd order (since the destination is      * a 64-bit register).  Don't reorder these writes w/o      * considering this!      */
if|if
condition|(
name|keyType
operator|==
name|AR_KEYTABLE_TYPE_TKIP
operator|&&
name|IS_MIC_ENABLED
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|u_int16_t
name|micentry
init|=
name|entry
operator|+
literal|64
decl_stmt|;
comment|/* MIC goes at slot+64 */
comment|/*          * Invalidate the encrypt/decrypt key until the MIC          * key is installed so pending rx frames will fail          * with decrypt errors rather than a MIC error.          */
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key0
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key1
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key2
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key3
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key4
operator|)
operator|&&
operator|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&
name|AR_KEY_TYPE
operator|)
operator|==
operator|(
name|keyType
operator|&
name|AR_KEY_TYPE
operator|)
operator|)
condition|)
block|{
comment|/*              * since the AR_MISC_MODE register was written with the contents of              * ah_miscMode (if any) in ar9300Attach, just check ah_miscMode and              * save a pci read per key set.              */
if|if
condition|(
name|ahp
operator|->
name|ah_misc_mode
operator|&
name|AR_PCU_MIC_NEW_LOC_ENA
condition|)
block|{
name|u_int32_t
name|mic0
decl_stmt|,
name|mic1
decl_stmt|,
name|mic2
decl_stmt|,
name|mic3
decl_stmt|,
name|mic4
decl_stmt|;
comment|/*                  * both RX and TX mic values can be combined into                  * one cache slot entry.                  * 8*N + 800         31:0    RX Michael key 0                  * 8*N + 804         15:0    TX Michael key 0 [31:16]                  * 8*N + 808         31:0    RX Michael key 1                  * 8*N + 80C         15:0    TX Michael key 0 [15:0]                  * 8*N + 810         31:0    TX Michael key 1                  * 8*N + 814         15:0    reserved                  * 8*N + 818         31:0    reserved                  * 8*N + 81C         14:0    reserved                  *                   15      key valid == 0                  */
comment|/* RX mic */
name|mic0
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|0
argument_list|)
expr_stmt|;
name|mic2
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_mic
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* TX mic */
name|mic1
operator|=
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|2
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|mic3
operator|=
name|LE_READ_2
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|0
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|mic4
operator|=
name|LE_READ_4
argument_list|(
name|k
operator|->
name|kv_txmic
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|==
name|mic0
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|==
name|mic1
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|==
name|mic2
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|==
name|mic3
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|==
name|mic4
operator|)
operator|&&
operator|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|micentry
argument_list|)
argument_list|)
operator|&
name|AR_KEY_TYPE
operator|)
operator|==
operator|(
name|AR_KEYTABLE_TYPE_CLR
operator|&
name|AR_KEY_TYPE
operator|)
operator|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
else|else
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY0
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key0
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY1
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key1
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY2
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key2
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY3
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key3
operator|)
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_KEY4
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|==
name|key4
operator|)
operator|&&
operator|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_KEYTABLE_TYPE
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&
name|AR_KEY_TYPE
operator|)
operator|==
operator|(
name|keyType
operator|&
name|AR_KEY_TYPE
operator|)
operator|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

