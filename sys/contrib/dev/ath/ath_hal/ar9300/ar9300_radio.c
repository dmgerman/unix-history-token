begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_comment
comment|/* chansel table, used by Hornet and Poseidon */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|ar9300_chansel_xtal_25M
index|[]
init|=
block|{
literal|0x101479e
block|,
comment|/* Freq 2412 - (128<< 17) + 83870  */
literal|0x101d027
block|,
comment|/* Freq 2417 - (128<< 17) + 118823 */
literal|0x10258af
block|,
comment|/* Freq 2422 - (129<< 17) + 22703  */
literal|0x102e138
block|,
comment|/* Freq 2427 - (129<< 17) + 57656  */
literal|0x10369c0
block|,
comment|/* Freq 2432 - (129<< 17) + 92608  */
literal|0x103f249
block|,
comment|/* Freq 2437 - (129<< 17) + 127561 */
literal|0x1047ad1
block|,
comment|/* Freq 2442 - (130<< 17) + 31441  */
literal|0x105035a
block|,
comment|/* Freq 2447 - (130<< 17) + 66394  */
literal|0x1058be2
block|,
comment|/* Freq 2452 - (130<< 17) + 101346 */
literal|0x106146b
block|,
comment|/* Freq 2457 - (131<< 17) + 5227   */
literal|0x1069cf3
block|,
comment|/* Freq 2462 - (131<< 17) + 40179  */
literal|0x107257c
block|,
comment|/* Freq 2467 - (131<< 17) + 75132  */
literal|0x107ae04
block|,
comment|/* Freq 2472 - (131<< 17) + 110084 */
literal|0x108f5b2
block|,
comment|/* Freq 2484 - (132<< 17) + 62898  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int32_t
name|ar9300_chansel_xtal_40M
index|[]
init|=
block|{
literal|0xa0ccbe
block|,
comment|/* Freq 2412 - (80<< 17) + 52414  */
literal|0xa12213
block|,
comment|/* Freq 2417 - (80<< 17) + 74259  */
literal|0xa17769
block|,
comment|/* Freq 2422 - (80<< 17) + 96105  */
literal|0xa1ccbe
block|,
comment|/* Freq 2427 - (80<< 17) + 117950 */
literal|0xa22213
block|,
comment|/* Freq 2432 - (81<< 17) + 8723   */
literal|0xa27769
block|,
comment|/* Freq 2437 - (81<< 17) + 30569  */
literal|0xa2ccbe
block|,
comment|/* Freq 2442 - (81<< 17) + 52414  */
literal|0xa32213
block|,
comment|/* Freq 2447 - (81<< 17) + 74259  */
literal|0xa37769
block|,
comment|/* Freq 2452 - (81<< 17) + 96105  */
literal|0xa3ccbe
block|,
comment|/* Freq 2457 - (81<< 17) + 117950 */
literal|0xa42213
block|,
comment|/* Freq 2462 - (82<< 17) + 8723   */
literal|0xa47769
block|,
comment|/* Freq 2467 - (82<< 17) + 30569  */
literal|0xa4ccbe
block|,
comment|/* Freq 2472 - (82<< 17) + 52414  */
literal|0xa5998b
block|,
comment|/* Freq 2484 - (82<< 17) + 104843 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Take the MHz channel value and set the Channel value  *  * ASSUMES: Writes enabled to analog bus  *  * Actual Expression,  *  * For 2GHz channel,  * Channel Frequency = (3/4) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^17)  * (freq_ref = 40MHz)  *  * For 5GHz channel,  * Channel Frequency = (3/2) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^10)  * (freq_ref = 40MHz/(24>>amode_ref_sel))  *  * For 5GHz channels which are 5MHz spaced,  * Channel Frequency = (3/2) * freq_ref * (chansel[8:0] + chanfrac[16:0]/2^17)  * (freq_ref = 40MHz)  */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_set_channel
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|u_int16_t
name|b_mode
decl_stmt|,
name|frac_mode
init|=
literal|0
decl_stmt|,
name|a_mode_ref_sel
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|freq
decl_stmt|,
name|channel_sel
decl_stmt|,
name|reg32
decl_stmt|;
name|u_int8_t
name|clk_25mhz
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|clk_25mhz
decl_stmt|;
name|CHAN_CENTERS
name|centers
decl_stmt|;
name|int
name|load_synth_channel
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
comment|/*      * Put this behind AH_DEBUG_ALQ for now until the Hornet      * channel_sel code below is made to work.      */
ifdef|#
directive|ifdef
name|AH_DEBUG_ALQ
name|OS_MARK
argument_list|(
name|ah
argument_list|,
name|AH_MARK_SETCHANNEL
argument_list|,
name|ichan
operator|->
name|channel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ar9300_get_channel_centers
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|,
operator|&
name|centers
argument_list|)
expr_stmt|;
name|freq
operator|=
name|centers
operator|.
name|synth_center
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|4800
condition|)
block|{
comment|/* 2 GHz, fractional mode */
name|b_mode
operator|=
literal|1
expr_stmt|;
comment|/* 2 GHz */
if|if
condition|(
name|AR_SREV_HORNET
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|u_int32_t ichan =               ieee80211_mhz2ieee(ah, chan->ic_freq, chan->ic_flags);             HALASSERT(ichan> 0&& ichan<= 14);             if (clk_25mhz) {                 channel_sel = ar9300_chansel_xtal_25M[ichan - 1];             } else {                 channel_sel = ar9300_chansel_xtal_40M[ichan - 1];             }
endif|#
directive|endif
name|uint32_t
name|i
decl_stmt|;
name|i
operator|=
name|ath_hal_mhz2ieee_2ghz
argument_list|(
name|ah
argument_list|,
name|ichan
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<=
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_25mhz
condition|)
block|{
name|channel_sel
operator|=
name|ar9300_chansel_xtal_25M
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|channel_sel
operator|=
name|ar9300_chansel_xtal_40M
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|u_int32_t
name|channel_frac
decl_stmt|;
comment|/*               * freq_ref = (40 / (refdiva>> a_mode_ref_sel));              *     (where refdiva = 1 and amoderefsel = 0)              * ndiv = ((chan_mhz * 4) / 3) / freq_ref;              * chansel = int(ndiv),  chanfrac = (ndiv - chansel) * 0x20000              */
name|channel_sel
operator|=
operator|(
name|freq
operator|*
literal|4
operator|)
operator|/
literal|120
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
operator|(
name|freq
operator|*
literal|4
operator|)
operator|%
literal|120
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|120
expr_stmt|;
name|channel_sel
operator|=
operator|(
name|channel_sel
operator|<<
literal|17
operator|)
operator||
operator|(
name|channel_frac
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|u_int32_t
name|channel_frac
decl_stmt|;
if|if
condition|(
name|clk_25mhz
condition|)
block|{
comment|/*                   * freq_ref = (50 / (refdiva>> a_mode_ref_sel));                  *     (where refdiva = 1 and amoderefsel = 0)                  * ndiv = ((chan_mhz * 4) / 3) / freq_ref;                  * chansel = int(ndiv),  chanfrac = (ndiv - chansel) * 0x20000                  */
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Doubler is off for Scorpion */
name|channel_sel
operator|=
operator|(
name|freq
operator|*
literal|4
operator|)
operator|/
literal|75
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
operator|(
name|freq
operator|*
literal|4
operator|)
operator|%
literal|75
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|75
expr_stmt|;
block|}
else|else
block|{
name|channel_sel
operator|=
operator|(
name|freq
operator|*
literal|2
operator|)
operator|/
literal|75
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
operator|(
name|freq
operator|*
literal|2
operator|)
operator|%
literal|75
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|75
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*                   * freq_ref = (50 / (refdiva>> a_mode_ref_sel));                  *     (where refdiva = 1 and amoderefsel = 0)                  * ndiv = ((chan_mhz * 4) / 3) / freq_ref;                  * chansel = int(ndiv),  chanfrac = (ndiv - chansel) * 0x20000                  */
if|if
condition|(
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/* Doubler is off for Scorpion */
name|channel_sel
operator|=
operator|(
name|freq
operator|*
literal|4
operator|)
operator|/
literal|120
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
operator|(
name|freq
operator|*
literal|4
operator|)
operator|%
literal|120
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|120
expr_stmt|;
block|}
else|else
block|{
name|channel_sel
operator|=
operator|(
name|freq
operator|*
literal|2
operator|)
operator|/
literal|120
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
operator|(
name|freq
operator|*
literal|2
operator|)
operator|%
literal|120
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|120
expr_stmt|;
block|}
block|}
name|channel_sel
operator|=
operator|(
name|channel_sel
operator|<<
literal|17
operator|)
operator||
operator|(
name|channel_frac
operator|)
expr_stmt|;
block|}
else|else
block|{
name|channel_sel
operator|=
name|CHANSEL_2G
argument_list|(
name|freq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|b_mode
operator|=
literal|0
expr_stmt|;
comment|/* 5 GHz */
if|if
condition|(
operator|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
operator|)
operator|&&
name|clk_25mhz
condition|)
block|{
name|u_int32_t
name|channel_frac
decl_stmt|;
comment|/*               * freq_ref = (50 / (refdiva>> amoderefsel));              *     (refdiva = 1, amoderefsel = 0)              * ndiv = ((chan_mhz * 2) / 3) / freq_ref;              * chansel = int(ndiv),  chanfrac = (ndiv - chansel) * 0x20000              */
name|channel_sel
operator|=
name|freq
operator|/
literal|75
expr_stmt|;
name|channel_frac
operator|=
operator|(
operator|(
name|freq
operator|%
literal|75
operator|)
operator|*
literal|0x20000
operator|)
operator|/
literal|75
expr_stmt|;
name|channel_sel
operator|=
operator|(
name|channel_sel
operator|<<
literal|17
operator|)
operator||
operator|(
name|channel_frac
operator|)
expr_stmt|;
block|}
else|else
block|{
name|channel_sel
operator|=
name|CHANSEL_5G
argument_list|(
name|freq
argument_list|)
expr_stmt|;
comment|/* Doubler is ON, so, divide channel_sel by 2. */
name|channel_sel
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Enable fractional mode for all channels */
name|frac_mode
operator|=
literal|1
expr_stmt|;
name|a_mode_ref_sel
operator|=
literal|0
expr_stmt|;
name|load_synth_channel
operator|=
literal|0
expr_stmt|;
name|reg32
operator|=
operator|(
name|b_mode
operator|<<
literal|29
operator|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SYNTH_CONTROL
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
comment|/* Enable Long shift Select for Synthesizer */
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_SYNTH4
argument_list|,
name|AR_PHY_SYNTH4_LONG_SHIFT_SELECT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* program synth. setting */
name|reg32
operator|=
operator|(
name|channel_sel
operator|<<
literal|2
operator|)
operator||
operator|(
name|a_mode_ref_sel
operator|<<
literal|28
operator|)
operator||
operator|(
name|frac_mode
operator|<<
literal|30
operator|)
operator||
operator|(
name|load_synth_channel
operator|<<
literal|31
operator|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|reg32
operator|+=
name|CHANSEL_5G_DOT5MHZ
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_SYNTH7
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
comment|/* Toggle Load Synth channel bit */
name|load_synth_channel
operator|=
literal|1
expr_stmt|;
name|reg32
operator||=
name|load_synth_channel
operator|<<
literal|31
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_65NM_CH0_SYNTH7
argument_list|,
name|reg32
argument_list|)
expr_stmt|;
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|=
name|chan
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static HAL_BOOL ar9300_get_chip_power_limits(struct ath_hal *ah, HAL_CHANNEL *chans,                          u_int32_t nchans) {     int i;      for (i = 0; i< nchans; i++) {         chans[i].max_tx_power = AR9300_MAX_RATE_POWER;         chans[i].min_tx_power = AR9300_MAX_RATE_POWER;     }     return AH_TRUE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX FreeBSD */
end_comment

begin_function
specifier|static
name|HAL_BOOL
name|ar9300_get_chip_power_limits
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
comment|/* XXX ? */
name|chan
operator|->
name|ic_minpower
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|ic_maxpower
operator|=
name|AR9300_MAX_RATE_POWER
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
name|HAL_BOOL
name|ar9300_rf_attach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_STATUS
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|ah_rf_hal
operator|.
name|set_channel
operator|=
name|ar9300_set_channel
expr_stmt|;
name|ahp
operator|->
name|ah_rf_hal
operator|.
name|get_chip_power_lim
operator|=
name|ar9300_get_chip_power_limits
expr_stmt|;
operator|*
name|status
operator|=
name|HAL_OK
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

end_unit

