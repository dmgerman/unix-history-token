begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_comment
comment|//#include "ah_pktlog.h"
end_comment

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_function_decl
specifier|extern
name|void
name|ar9300_set_rx_filter
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_int32_t
name|ar9300_get_rx_filter
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HAL_ANI_DEBUG
value|1
end_define

begin_comment
comment|/*  * Anti noise immunity support.  We track phy errors and react  * to excessive errors by adjusting the noise immunity parameters.  */
end_comment

begin_comment
comment|/******************************************************************************  *  * New Ani Algorithm for Station side only  *  *****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_OFDM_TRIG_HIGH
value|1000
end_define

begin_comment
comment|/* units are errors per second */
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_OFDM_TRIG_LOW
value|400
end_define

begin_comment
comment|/* units are errors per second */
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_CCK_TRIG_HIGH
value|600
end_define

begin_comment
comment|/* units are errors per second */
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_CCK_TRIG_LOW
value|300
end_define

begin_comment
comment|/* units are errors per second */
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_USE_OFDM_WEAK_SIG
value|AH_TRUE
end_define

begin_define
define|#
directive|define
name|HAL_ANI_ENABLE_MRC_CCK
value|AH_TRUE
end_define

begin_comment
comment|/* default is enabled */
end_comment

begin_define
define|#
directive|define
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
value|3
end_define

begin_define
define|#
directive|define
name|HAL_ANI_DEF_FIRSTEP_LVL
value|2
end_define

begin_define
define|#
directive|define
name|HAL_ANI_RSSI_THR_HIGH
value|40
end_define

begin_define
define|#
directive|define
name|HAL_ANI_RSSI_THR_LOW
value|7
end_define

begin_define
define|#
directive|define
name|HAL_ANI_PERIOD
value|1000
end_define

begin_define
define|#
directive|define
name|HAL_NOISE_DETECT_PERIOD
value|100
end_define

begin_define
define|#
directive|define
name|HAL_NOISE_RECOVER_PERIOD
value|5000
end_define

begin_define
define|#
directive|define
name|HAL_SIG_FIRSTEP_SETTING_MIN
value|0
end_define

begin_define
define|#
directive|define
name|HAL_SIG_FIRSTEP_SETTING_MAX
value|20
end_define

begin_define
define|#
directive|define
name|HAL_SIG_SPUR_IMM_SETTING_MIN
value|0
end_define

begin_define
define|#
directive|define
name|HAL_SIG_SPUR_IMM_SETTING_MAX
value|22
end_define

begin_define
define|#
directive|define
name|HAL_EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x) % (mul))>= ((mul) / 2)) ? ((x) + ((mul) - 1)) / (mul) : (x) / (mul))
end_define

begin_define
define|#
directive|define
name|BEACON_RSSI
parameter_list|(
name|ahp
parameter_list|)
define|\
value|HAL_EP_RND(ahp->ah_stats.ast_nodestats.ns_avgbrssi, \         HAL_RSSI_EP_MULTIPLIER)
end_define

begin_typedef
typedef|typedef
name|int
name|TABLE
index|[]
typedef|;
end_typedef

begin_comment
comment|/*  *                            level:    0   1   2   3   4   5   6   7   8  * firstep_table:    lvl 0-8, default 2  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|TABLE
name|firstep_table
init|=
block|{
operator|-
literal|4
block|,
operator|-
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cycpwr_thr1_table: lvl 0-7, default 3 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|TABLE
name|cycpwr_thr1_table
init|=
block|{
operator|-
literal|6
block|,
operator|-
literal|4
block|,
operator|-
literal|2
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* values here are relative to the INI */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_HAL_ANI_OFDM_LEVEL_ENTRY
block|{
name|int
name|spur_immunity_level
decl_stmt|;
name|int
name|fir_step_level
decl_stmt|;
name|int
name|ofdm_weak_signal_on
decl_stmt|;
block|}
name|HAL_ANI_OFDM_LEVEL_ENTRY
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|HAL_ANI_OFDM_LEVEL_ENTRY
name|ofdm_level_table
index|[]
init|=
block|{
comment|/*     SI  FS  WS */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* lvl 0 */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* lvl 1 */
block|{
literal|2
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* lvl 2 */
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* lvl 3  (default) */
block|{
literal|4
block|,
literal|3
block|,
literal|1
block|}
block|,
comment|/* lvl 4 */
block|{
literal|5
block|,
literal|4
block|,
literal|1
block|}
block|,
comment|/* lvl 5 */
block|{
literal|6
block|,
literal|5
block|,
literal|1
block|}
block|,
comment|/* lvl 6 */
block|{
literal|7
block|,
literal|6
block|,
literal|1
block|}
block|,
comment|/* lvl 7 */
block|{
literal|7
block|,
literal|7
block|,
literal|1
block|}
block|,
comment|/* lvl 8 */
block|{
literal|7
block|,
literal|8
block|,
literal|0
block|}
comment|/* lvl 9 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAL_ANI_OFDM_NUM_LEVEL
define|\
value|(sizeof(ofdm_level_table) / sizeof(ofdm_level_table[0]))
end_define

begin_define
define|#
directive|define
name|HAL_ANI_OFDM_MAX_LEVEL
value|(HAL_ANI_OFDM_NUM_LEVEL - 1)
end_define

begin_define
define|#
directive|define
name|HAL_ANI_OFDM_DEF_LEVEL
value|3
end_define

begin_comment
comment|/* default level - matches the INI settings */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_HAL_ANI_CCK_LEVEL_ENTRY
block|{
name|int
name|fir_step_level
decl_stmt|;
name|int
name|mrc_cck_on
decl_stmt|;
block|}
name|HAL_ANI_CCK_LEVEL_ENTRY
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|HAL_ANI_CCK_LEVEL_ENTRY
name|cck_level_table
index|[]
init|=
block|{
comment|/*     FS  MRC-CCK */
block|{
literal|0
block|,
literal|1
block|}
block|,
comment|/* lvl 0 */
block|{
literal|1
block|,
literal|1
block|}
block|,
comment|/* lvl 1 */
block|{
literal|2
block|,
literal|1
block|}
block|,
comment|/* lvl 2  (default) */
block|{
literal|3
block|,
literal|1
block|}
block|,
comment|/* lvl 3 */
block|{
literal|4
block|,
literal|0
block|}
block|,
comment|/* lvl 4 */
block|{
literal|5
block|,
literal|0
block|}
block|,
comment|/* lvl 5 */
block|{
literal|6
block|,
literal|0
block|}
block|,
comment|/* lvl 6 */
block|{
literal|7
block|,
literal|0
block|}
block|,
comment|/* lvl 7 (only for high rssi) */
block|{
literal|8
block|,
literal|0
block|}
comment|/* lvl 8 (only for high rssi) */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAL_ANI_CCK_NUM_LEVEL
define|\
value|(sizeof(cck_level_table) / sizeof(cck_level_table[0]))
end_define

begin_define
define|#
directive|define
name|HAL_ANI_CCK_MAX_LEVEL
value|(HAL_ANI_CCK_NUM_LEVEL - 1)
end_define

begin_define
define|#
directive|define
name|HAL_ANI_CCK_MAX_LEVEL_LOW_RSSI
value|(HAL_ANI_CCK_NUM_LEVEL - 3)
end_define

begin_define
define|#
directive|define
name|HAL_ANI_CCK_DEF_LEVEL
value|2
end_define

begin_comment
comment|/* default level - matches the INI settings */
end_comment

begin_comment
comment|/*  * register values to turn OFDM weak signal detection OFF  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m1_thresh_low_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_thresh_low_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m1_thresh_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_thresh_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_count_thr_off
init|=
literal|31
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_count_thr_low_off
init|=
literal|63
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m1_thresh_low_ext_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_thresh_low_ext_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m1_thresh_ext_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|m2_thresh_ext_off
init|=
literal|127
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ar9300_enable_mib_counters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Enable MIB counters\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar9300_update_mib_mac_stats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_OFDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_CCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|,
operator|~
operator|(
name|AR_MIBC_COW
operator||
name|AR_MIBC_FMC
operator||
name|AR_MIBC_CMC
operator||
name|AR_MIBC_MCS
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_OFDM_TIMING
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_2
argument_list|,
name|AR_PHY_ERR_CCK_TIMING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_disable_mib_counters
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_RESET
argument_list|,
literal|"%s: Disabling MIB counters\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIBC
argument_list|,
name|AR_MIBC_FMC
operator||
name|AR_MIBC_CMC
argument_list|)
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar9300_update_mib_mac_stats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_OFDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_CCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine returns the index into the ani_state array that  * corresponds to the channel in *chan.  If no match is found and the  * array is still not fully utilized, a new entry is created for the  * channel.  We assume the attach function has already initialized the  * ah_ani values and only the channel field needs to be set.  */
end_comment

begin_function
specifier|static
name|int
name|ar9300_get_ani_channel_index
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_LENGTH
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX this doesn't distinguish between 20/40 channels */
if|if
condition|(
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|c
operator|.
name|ic_freq
operator|==
name|chan
operator|->
name|ic_freq
condition|)
block|{
return|return
name|i
return|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|c
operator|.
name|ic_freq
operator|==
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|c
operator|.
name|ic_freq
operator|=
name|chan
operator|->
name|ic_freq
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|c
operator|.
name|ic_flags
operator|=
name|chan
operator|->
name|ic_flags
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
comment|/* XXX statistic */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: No more channel states left. Using channel 0\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXX gotta return something valid */
block|}
end_function

begin_comment
comment|/*  * Return the current ANI state of the channel we're on  */
end_comment

begin_function
name|struct
name|ar9300_ani_state
modifier|*
name|ar9300_ani_get_current_state
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curani
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current statistics.  */
end_comment

begin_function
name|struct
name|ar9300_stats
modifier|*
name|ar9300_ani_get_current_stats
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|&
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_stats
return|;
block|}
end_function

begin_comment
comment|/*  * Setup ANI handling.  Sets all thresholds and levels to default level AND  * resets the channel statistics  */
end_comment

begin_function
name|void
name|ar9300_ani_attach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OS_MEMZERO
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|,
sizeof|sizeof
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_LENGTH
argument_list|(
name|ahp
operator|->
name|ah_ani
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|ofdm_trig_high
operator|=
name|HAL_ANI_OFDM_TRIG_HIGH
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|ofdm_trig_low
operator|=
name|HAL_ANI_OFDM_TRIG_LOW
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|cck_trig_high
operator|=
name|HAL_ANI_CCK_TRIG_HIGH
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|cck_trig_low
operator|=
name|HAL_ANI_CCK_TRIG_LOW
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|rssi_thr_high
operator|=
name|HAL_ANI_RSSI_THR_HIGH
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|rssi_thr_low
operator|=
name|HAL_ANI_RSSI_THR_LOW
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|ofdm_noise_immunity_level
operator|=
name|HAL_ANI_OFDM_DEF_LEVEL
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|cck_noise_immunity_level
operator|=
name|HAL_ANI_CCK_DEF_LEVEL
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|ofdm_weak_sig_detect_off
operator|=
operator|!
name|HAL_ANI_USE_OFDM_WEAK_SIG
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|spur_immunity_level
operator|=
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|firstep_level
operator|=
name|HAL_ANI_DEF_FIRSTEP_LVL
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|mrc_cck_off
operator|=
operator|!
name|HAL_ANI_ENABLE_MRC_CCK
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|ofdms_turn
operator|=
name|AH_TRUE
expr_stmt|;
name|ahp
operator|->
name|ah_ani
index|[
name|i
index|]
operator|.
name|must_restore
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/*      * Since we expect some ongoing maintenance on the tables,      * let's sanity check here.      * The default level should not modify INI setting.      */
name|HALASSERT
argument_list|(
name|firstep_table
index|[
name|HAL_ANI_DEF_FIRSTEP_LVL
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|cycpwr_thr1_table
index|[
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ofdm_level_table
index|[
name|HAL_ANI_OFDM_DEF_LEVEL
index|]
operator|.
name|fir_step_level
operator|==
name|HAL_ANI_DEF_FIRSTEP_LVL
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|ofdm_level_table
index|[
name|HAL_ANI_OFDM_DEF_LEVEL
index|]
operator|.
name|spur_immunity_level
operator|==
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|cck_level_table
index|[
name|HAL_ANI_CCK_DEF_LEVEL
index|]
operator|.
name|fir_step_level
operator|==
name|HAL_ANI_DEF_FIRSTEP_LVL
argument_list|)
expr_stmt|;
comment|/* Initialize and enable MIB Counters */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ar9300_enable_mib_counters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ani_period
operator|=
name|HAL_ANI_PERIOD
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_config
operator|.
name|ath_hal_enable_ani
condition|)
block|{
name|ahp
operator|->
name|ah_proc_phy_err
operator||=
name|HAL_PROCESS_ANI
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cleanup any ANI state setup.  */
end_comment

begin_function
name|void
name|ar9300_ani_detach
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Detaching Ani\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ar9300_disable_mib_counters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the ANI register values with default (ini) values.  * This routine is called during a (full) hardware reset after  * all the registers are initialised from the INI.  */
end_comment

begin_function
name|void
name|ar9300_ani_init_defaults
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_HT_MACMODE
name|macmode
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|HALASSERT
argument_list|(
name|chan
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|index
operator|=
name|ar9300_get_ani_channel_index
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ani_state
operator|=
operator|&
name|ahp
operator|->
name|ah_ani
index|[
name|index
index|]
expr_stmt|;
name|ahp
operator|->
name|ah_curani
operator|=
name|ani_state
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ver %d.%d opmode %u chan %d Mhz/0x%x macmode %d\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macVersion
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_macRev
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|macmode
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_M1_THRESH
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_M2_THRESH
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_count_thr
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_M2COUNT_THR
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_low
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_LOW_M1_THRESH_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_low
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_LOW_M2_THRESH_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_count_thr_low
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_ext
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_ext
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_low_ext
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_low_ext
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG
argument_list|,
name|AR_PHY_FIND_SIG_FIRSTEP
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep_low
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG_LOW
argument_list|,
name|AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING5
argument_list|,
name|AR_PHY_TIMING5_CYCPWR_THR1
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1_ext
operator|=
name|OS_REG_READ_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA
argument_list|,
name|AR_PHY_EXT_CYCPWR_THR1
argument_list|)
expr_stmt|;
comment|/* these levels just got reset to defaults by the INI */
name|ani_state
operator|->
name|spur_immunity_level
operator|=
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
expr_stmt|;
name|ani_state
operator|->
name|firstep_level
operator|=
name|HAL_ANI_DEF_FIRSTEP_LVL
expr_stmt|;
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
operator|=
operator|!
name|HAL_ANI_USE_OFDM_WEAK_SIG
expr_stmt|;
name|ani_state
operator|->
name|mrc_cck_off
operator|=
operator|!
name|HAL_ANI_ENABLE_MRC_CCK
expr_stmt|;
name|ani_state
operator|->
name|cycle_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the ANI settings to match an OFDM level.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_ani_set_odfm_noise_immunity_level
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
name|ofdm_noise_immunity_level
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
name|ani_state
operator|->
name|rssi
operator|=
name|BEACON_RSSI
argument_list|(
name|ahp
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"**** %s: ofdmlevel %d=>%d, rssi=%d[lo=%d hi=%d]\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ofdm_noise_immunity_level
argument_list|,
name|ani_state
operator|->
name|rssi
argument_list|,
name|ani_state
operator|->
name|rssi_thr_low
argument_list|,
name|ani_state
operator|->
name|rssi_thr_high
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|=
name|ofdm_noise_immunity_level
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|spur_immunity_level
operator|!=
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|spur_immunity_level
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|spur_immunity_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ani_state
operator|->
name|firstep_level
operator|!=
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|fir_step_level
operator|&&
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|fir_step_level
operator|>=
name|cck_level_table
index|[
name|ani_state
operator|->
name|cck_noise_immunity_level
index|]
operator|.
name|fir_step_level
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|fir_step_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_STA
operator|||
name|ani_state
operator|->
name|rssi
operator|<=
name|ani_state
operator|->
name|rssi_thr_high
operator|)
condition|)
block|{
if|if
condition|(
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
condition|)
block|{
comment|/*              * force on ofdm weak sig detect.              */
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
operator|==
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|ofdm_weak_signal_on
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|ofdm_level_table
index|[
name|ofdm_noise_immunity_level
index|]
operator|.
name|ofdm_weak_signal_on
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the ANI settings to match a CCK level.  */
end_comment

begin_function
specifier|static
name|void
name|ar9300_ani_set_cck_noise_immunity_level
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int8_t
name|cck_noise_immunity_level
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
name|int
name|level
decl_stmt|;
name|ani_state
operator|->
name|rssi
operator|=
name|BEACON_RSSI
argument_list|(
name|ahp
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"**** %s: ccklevel %d=>%d, rssi=%d[lo=%d hi=%d]\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|,
name|cck_noise_immunity_level
argument_list|,
name|ani_state
operator|->
name|rssi
argument_list|,
name|ani_state
operator|->
name|rssi_thr_low
argument_list|,
name|ani_state
operator|->
name|rssi_thr_high
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|==
name|HAL_M_STA
operator|&&
name|ani_state
operator|->
name|rssi
operator|<=
name|ani_state
operator|->
name|rssi_thr_low
operator|&&
name|cck_noise_immunity_level
operator|>
name|HAL_ANI_CCK_MAX_LEVEL_LOW_RSSI
condition|)
block|{
name|cck_noise_immunity_level
operator|=
name|HAL_ANI_CCK_MAX_LEVEL_LOW_RSSI
expr_stmt|;
block|}
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|=
name|cck_noise_immunity_level
expr_stmt|;
name|level
operator|=
name|ani_state
operator|->
name|ofdm_noise_immunity_level
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|firstep_level
operator|!=
name|cck_level_table
index|[
name|cck_noise_immunity_level
index|]
operator|.
name|fir_step_level
operator|&&
name|cck_level_table
index|[
name|cck_noise_immunity_level
index|]
operator|.
name|fir_step_level
operator|>=
name|ofdm_level_table
index|[
name|level
index|]
operator|.
name|fir_step_level
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|cck_level_table
index|[
name|cck_noise_immunity_level
index|]
operator|.
name|fir_step_level
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ani_state
operator|->
name|mrc_cck_off
operator|==
name|cck_level_table
index|[
name|cck_noise_immunity_level
index|]
operator|.
name|mrc_cck_on
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_MRC_CCK
argument_list|,
name|cck_level_table
index|[
name|cck_noise_immunity_level
index|]
operator|.
name|mrc_cck_on
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Control Adaptive Noise Immunity Parameters  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_ani_control
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANI_CMD
name|cmd
parameter_list|,
name|int
name|param
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|int32_t
name|value
decl_stmt|,
name|value2
decl_stmt|;
name|u_int
name|level
init|=
name|param
decl_stmt|;
name|u_int
name|is_on
decl_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
operator|&&
name|cmd
operator|!=
name|HAL_ANI_MODE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: ignoring cmd 0x%02x - no channel\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
switch|switch
condition|(
name|cmd
operator|&
name|ahp
operator|->
name|ah_ani_function
condition|)
block|{
case|case
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
case|:
block|{
name|int
name|m1_thresh_low
decl_stmt|,
name|m2_thresh_low
decl_stmt|;
name|int
name|m1_thresh
decl_stmt|,
name|m2_thresh
decl_stmt|;
name|int
name|m2_count_thr
decl_stmt|,
name|m2_count_thr_low
decl_stmt|;
name|int
name|m1_thresh_low_ext
decl_stmt|,
name|m2_thresh_low_ext
decl_stmt|;
name|int
name|m1_thresh_ext
decl_stmt|,
name|m2_thresh_ext
decl_stmt|;
comment|/*              * is_on == 1 means ofdm weak signal detection is ON              * (default, less noise imm)              * is_on == 0 means ofdm weak signal detection is OFF              * (more noise imm)              */
name|is_on
operator|=
name|param
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|AR_SREV_JUPITER
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_APHRODITE
argument_list|(
name|ah
argument_list|)
condition|)
goto|goto
name|skip_ws_det
goto|;
comment|/*              * make register setting for default (weak sig detect ON)              * come from INI file              */
name|m1_thresh_low
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_low
else|:
name|m1_thresh_low_off
expr_stmt|;
name|m2_thresh_low
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_low
else|:
name|m2_thresh_low_off
expr_stmt|;
name|m1_thresh
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh
else|:
name|m1_thresh_off
expr_stmt|;
name|m2_thresh
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh
else|:
name|m2_thresh_off
expr_stmt|;
name|m2_count_thr
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_count_thr
else|:
name|m2_count_thr_off
expr_stmt|;
name|m2_count_thr_low
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_count_thr_low
else|:
name|m2_count_thr_low_off
expr_stmt|;
name|m1_thresh_low_ext
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_low_ext
else|:
name|m1_thresh_low_ext_off
expr_stmt|;
name|m2_thresh_low_ext
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_low_ext
else|:
name|m2_thresh_low_ext_off
expr_stmt|;
name|m1_thresh_ext
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m1_thresh_ext
else|:
name|m1_thresh_ext_off
expr_stmt|;
name|m2_thresh_ext
operator|=
name|is_on
condition|?
name|ani_state
operator|->
name|ini_def
operator|.
name|m2_thresh_ext
else|:
name|m2_thresh_ext_off
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M1_THRESH_LOW
argument_list|,
name|m1_thresh_low
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2_THRESH_LOW
argument_list|,
name|m2_thresh_low
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M1_THRESH
argument_list|,
name|m1_thresh
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2_THRESH
argument_list|,
name|m2_thresh
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR
argument_list|,
name|AR_PHY_SFCORR_M2COUNT_THR
argument_list|,
name|m2_count_thr
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW
argument_list|,
name|m2_count_thr_low
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH_LOW
argument_list|,
name|m1_thresh_low_ext
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH_LOW
argument_list|,
name|m2_thresh_low_ext
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M1_THRESH
argument_list|,
name|m1_thresh_ext
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_EXT
argument_list|,
name|AR_PHY_SFCORR_EXT_M2_THRESH
argument_list|,
name|m2_thresh_ext
argument_list|)
expr_stmt|;
name|skip_ws_det
label|:
if|if
condition|(
name|is_on
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PHY_SFCORR_LOW
argument_list|,
name|AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_on
operator|!=
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: ofdm weak signal: %s=>%s\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
operator|!
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|is_on
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_on
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmon
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmoff
operator|++
expr_stmt|;
block|}
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
operator|=
operator|!
name|is_on
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HAL_ANI_FIRSTEP_LEVEL
case|:
if|if
condition|(
name|level
operator|>=
name|ARRAY_LENGTH
argument_list|(
name|firstep_table
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: HAL_ANI_FIRSTEP_LEVEL level out of range (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|,
operator|(
name|unsigned
operator|)
name|ARRAY_LENGTH
argument_list|(
name|firstep_table
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*          * make register setting relative to default          * from INI file& cap value          */
name|value
operator|=
name|firstep_table
index|[
name|level
index|]
operator|-
name|firstep_table
index|[
name|HAL_ANI_DEF_FIRSTEP_LVL
index|]
operator|+
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|HAL_SIG_FIRSTEP_SETTING_MIN
condition|)
block|{
name|value
operator|=
name|HAL_SIG_FIRSTEP_SETTING_MIN
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|>
name|HAL_SIG_FIRSTEP_SETTING_MAX
condition|)
block|{
name|value
operator|=
name|HAL_SIG_FIRSTEP_SETTING_MAX
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG
argument_list|,
name|AR_PHY_FIND_SIG_FIRSTEP
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*          * we need to set first step low register too          * make register setting relative to default from INI file& cap value          */
name|value2
operator|=
name|firstep_table
index|[
name|level
index|]
operator|-
name|firstep_table
index|[
name|HAL_ANI_DEF_FIRSTEP_LVL
index|]
operator|+
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep_low
expr_stmt|;
if|if
condition|(
name|value2
operator|<
name|HAL_SIG_FIRSTEP_SETTING_MIN
condition|)
block|{
name|value2
operator|=
name|HAL_SIG_FIRSTEP_SETTING_MIN
expr_stmt|;
block|}
if|if
condition|(
name|value2
operator|>
name|HAL_SIG_FIRSTEP_SETTING_MAX
condition|)
block|{
name|value2
operator|=
name|HAL_SIG_FIRSTEP_SETTING_MAX
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_FIND_SIG_LOW
argument_list|,
name|AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW
argument_list|,
name|value2
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
name|ani_state
operator|->
name|firstep_level
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: level %d=>%d[def:%d] firstep[level]=%d ini=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|ani_state
operator|->
name|firstep_level
argument_list|,
name|level
argument_list|,
name|HAL_ANI_DEF_FIRSTEP_LVL
argument_list|,
name|value
argument_list|,
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: level %d=>%d[def:%d] "
literal|"firstep_low[level]=%d ini=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|ani_state
operator|->
name|firstep_level
argument_list|,
name|level
argument_list|,
name|HAL_ANI_DEF_FIRSTEP_LVL
argument_list|,
name|value2
argument_list|,
name|ani_state
operator|->
name|ini_def
operator|.
name|firstep_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|ani_state
operator|->
name|firstep_level
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_stepup
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|<
name|ani_state
operator|->
name|firstep_level
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_stepdown
operator|++
expr_stmt|;
block|}
name|ani_state
operator|->
name|firstep_level
operator|=
name|level
expr_stmt|;
block|}
break|break;
case|case
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
case|:
if|if
condition|(
name|level
operator|>=
name|ARRAY_LENGTH
argument_list|(
name|cycpwr_thr1_table
argument_list|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: HAL_ANI_SPUR_IMMUNITY_LEVEL level "
literal|"out of range (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|level
argument_list|,
operator|(
name|unsigned
operator|)
name|ARRAY_LENGTH
argument_list|(
name|cycpwr_thr1_table
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
comment|/*          * make register setting relative to default from INI file& cap value          */
name|value
operator|=
name|cycpwr_thr1_table
index|[
name|level
index|]
operator|-
name|cycpwr_thr1_table
index|[
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
index|]
operator|+
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|HAL_SIG_SPUR_IMM_SETTING_MIN
condition|)
block|{
name|value
operator|=
name|HAL_SIG_SPUR_IMM_SETTING_MIN
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|>
name|HAL_SIG_SPUR_IMM_SETTING_MAX
condition|)
block|{
name|value
operator|=
name|HAL_SIG_SPUR_IMM_SETTING_MAX
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING5
argument_list|,
name|AR_PHY_TIMING5_CYCPWR_THR1
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*          * set AR_PHY_EXT_CCA for extension channel          * make register setting relative to default from INI file& cap value          */
name|value2
operator|=
name|cycpwr_thr1_table
index|[
name|level
index|]
operator|-
name|cycpwr_thr1_table
index|[
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
index|]
operator|+
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1_ext
expr_stmt|;
if|if
condition|(
name|value2
operator|<
name|HAL_SIG_SPUR_IMM_SETTING_MIN
condition|)
block|{
name|value2
operator|=
name|HAL_SIG_SPUR_IMM_SETTING_MIN
expr_stmt|;
block|}
if|if
condition|(
name|value2
operator|>
name|HAL_SIG_SPUR_IMM_SETTING_MAX
condition|)
block|{
name|value2
operator|=
name|HAL_SIG_SPUR_IMM_SETTING_MAX
expr_stmt|;
block|}
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_EXT_CCA
argument_list|,
name|AR_PHY_EXT_CYCPWR_THR1
argument_list|,
name|value2
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
name|ani_state
operator|->
name|spur_immunity_level
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: level %d=>%d[def:%d] "
literal|"cycpwr_thr1[level]=%d ini=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|ani_state
operator|->
name|spur_immunity_level
argument_list|,
name|level
argument_list|,
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
argument_list|,
name|value
argument_list|,
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: level %d=>%d[def:%d] "
literal|"cycpwr_thr1_ext[level]=%d ini=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|ani_state
operator|->
name|spur_immunity_level
argument_list|,
name|level
argument_list|,
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
argument_list|,
name|value2
argument_list|,
name|ani_state
operator|->
name|ini_def
operator|.
name|cycpwr_thr1_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|ani_state
operator|->
name|spur_immunity_level
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_spurup
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|level
operator|<
name|ani_state
operator|->
name|spur_immunity_level
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_spurdown
operator|++
expr_stmt|;
block|}
name|ani_state
operator|->
name|spur_immunity_level
operator|=
name|level
expr_stmt|;
block|}
break|break;
case|case
name|HAL_ANI_MRC_CCK
case|:
comment|/*          * is_on == 1 means MRC CCK ON (default, less noise imm)          * is_on == 0 means MRC CCK is OFF (more noise imm)          */
name|is_on
operator|=
name|param
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MRC_CCK_CTRL
argument_list|,
name|AR_PHY_MRC_CCK_ENABLE
argument_list|,
name|is_on
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_PHY_MRC_CCK_CTRL
argument_list|,
name|AR_PHY_MRC_CCK_MUX_REG
argument_list|,
name|is_on
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_on
operator|!=
name|ani_state
operator|->
name|mrc_cck_off
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ** ch %d: MRC CCK: %s=>%s\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
operator|!
name|ani_state
operator|->
name|mrc_cck_off
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|is_on
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_on
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ccklow
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckhigh
operator|++
expr_stmt|;
block|}
name|ani_state
operator|->
name|mrc_cck_off
operator|=
operator|!
name|is_on
expr_stmt|;
block|}
break|break;
case|case
name|HAL_ANI_PRESENT
case|:
break|break;
ifdef|#
directive|ifdef
name|AH_PRIVATE_DIAG
case|case
name|HAL_ANI_MODE
case|:
if|if
condition|(
name|param
operator|==
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_proc_phy_err
operator|&=
operator|~
name|HAL_PROCESS_ANI
expr_stmt|;
comment|/* Turn off HW counters if we have them */
name|ar9300_ani_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|==
name|NULL
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
comment|/* if we're turning off ANI, reset regs back to INI settings */
if|if
condition|(
name|ah
operator|->
name|ah_config
operator|.
name|ath_hal_enable_ani
condition|)
block|{
name|HAL_ANI_CMD
name|savefunc
init|=
name|ahp
operator|->
name|ah_ani_function
decl_stmt|;
comment|/* temporarly allow all functions so we can reset */
name|ahp
operator|->
name|ah_ani_function
operator|=
name|HAL_ANI_ALL
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: disable all ANI functions\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ar9300_ani_set_odfm_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_DEF_LEVEL
argument_list|)
expr_stmt|;
name|ar9300_ani_set_cck_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_CCK_DEF_LEVEL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_ani_function
operator|=
name|savefunc
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* normal/auto mode */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: enabled\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_proc_phy_err
operator||=
name|HAL_PROCESS_ANI
expr_stmt|;
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
operator|==
name|NULL
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
name|ar9300_enable_mib_counters
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_ani_reset
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"5 ANC: ahp->ah_proc_phy_err %x \n"
argument_list|,
name|ahp
operator|->
name|ah_proc_phy_err
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_ANI_PHYERR_RESET
case|:
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmerrs
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckerrs
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* AH_PRIVATE_DIAG */
default|default:
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: invalid cmd 0x%02x (allowed=0x%02x)\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
argument_list|,
name|ahp
operator|->
name|ah_ani_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AH_FALSE
return|;
block|}
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: ANI parameters: SI=%d, ofdm_ws=%s FS=%d MRCcck=%s listen_time=%d "
literal|"CC=%d listen=%d ofdm_errs=%d cck_errs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|spur_immunity_level
argument_list|,
operator|!
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|ani_state
operator|->
name|firstep_level
argument_list|,
operator|!
name|ani_state
operator|->
name|mrc_cck_off
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ani_state
operator|->
name|cycle_count
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ani_state
operator|->
name|ofdm_phy_err_count
argument_list|,
name|ani_state
operator|->
name|cck_phy_err_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|REMOVE_PKT_LOG
comment|/* do pktlog */
block|{
name|struct
name|log_ani
name|log_data
decl_stmt|;
comment|/* Populate the ani log record */
name|log_data
operator|.
name|phy_stats_disable
operator|=
name|DO_ANI
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|log_data
operator|.
name|noise_immun_lvl
operator|=
name|ani_state
operator|->
name|ofdm_noise_immunity_level
expr_stmt|;
name|log_data
operator|.
name|spur_immun_lvl
operator|=
name|ani_state
operator|->
name|spur_immunity_level
expr_stmt|;
name|log_data
operator|.
name|ofdm_weak_det
operator|=
name|ani_state
operator|->
name|ofdm_weak_sig_detect_off
expr_stmt|;
name|log_data
operator|.
name|cck_weak_thr
operator|=
name|ani_state
operator|->
name|cck_noise_immunity_level
expr_stmt|;
name|log_data
operator|.
name|fir_lvl
operator|=
name|ani_state
operator|->
name|firstep_level
expr_stmt|;
name|log_data
operator|.
name|listen_time
operator|=
name|ani_state
operator|->
name|listen_time
expr_stmt|;
name|log_data
operator|.
name|cycle_count
operator|=
name|ani_state
operator|->
name|cycle_count
expr_stmt|;
comment|/* express ofdm_phy_err_count as errors/second */
name|log_data
operator|.
name|ofdm_phy_err_count
operator|=
name|ani_state
operator|->
name|listen_time
condition|?
name|ani_state
operator|->
name|ofdm_phy_err_count
operator|*
literal|1000
operator|/
name|ani_state
operator|->
name|listen_time
else|:
literal|0
expr_stmt|;
comment|/* express cck_phy_err_count as errors/second */
name|log_data
operator|.
name|cck_phy_err_count
operator|=
name|ani_state
operator|->
name|listen_time
condition|?
name|ani_state
operator|->
name|cck_phy_err_count
operator|*
literal|1000
operator|/
name|ani_state
operator|->
name|listen_time
else|:
literal|0
expr_stmt|;
name|log_data
operator|.
name|rssi
operator|=
name|ani_state
operator|->
name|rssi
expr_stmt|;
comment|/* clear interrupt context flag */
name|ath_hal_log_ani
argument_list|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_sc
argument_list|,
operator|&
name|log_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_ani_restart
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return;
block|}
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
name|ani_state
operator|->
name|listen_time
operator|=
literal|0
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_OFDM_TIMING
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_2
argument_list|,
name|AR_PHY_ERR_CCK_TIMING
argument_list|)
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar9300_update_mib_mac_stats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ofdm_phy_err_count
operator|=
literal|0
expr_stmt|;
name|ani_state
operator|->
name|cck_phy_err_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_ani_ofdm_err_trigger
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return;
block|}
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|<
name|HAL_ANI_OFDM_MAX_LEVEL
condition|)
block|{
name|ar9300_ani_set_odfm_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_ani_cck_err_trigger
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return;
block|}
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|<
name|HAL_ANI_CCK_MAX_LEVEL
condition|)
block|{
name|ar9300_ani_set_cck_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Restore the ANI parameters in the HAL and reset the statistics.  * This routine should be called for every hardware reset and for  * every channel change.  */
end_comment

begin_function
name|void
name|ar9300_ani_reset
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_scanning
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|HAL_CHANNEL_INTERNAL
modifier|*
name|ichan
init|=
name|ath_hal_checkchannel
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|HALASSERT
argument_list|(
name|chan
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/*      * we need to re-point to the correct ANI state since the channel      * may have changed due to a fast channel change     */
name|index
operator|=
name|ar9300_get_ani_channel_index
argument_list|(
name|ah
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ani_state
operator|=
operator|&
name|ahp
operator|->
name|ah_ani
index|[
name|index
index|]
expr_stmt|;
name|HALASSERT
argument_list|(
name|ani_state
operator|!=
name|AH_NULL
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_curani
operator|=
name|ani_state
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_reset
operator|++
expr_stmt|;
name|ani_state
operator|->
name|phy_noise_spur
operator|=
literal|0
expr_stmt|;
comment|/* only allow a subset of functions in AP mode */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|==
name|HAL_M_HOSTAP
condition|)
block|{
if|if
condition|(
name|IS_CHAN_2GHZ
argument_list|(
name|ichan
argument_list|)
condition|)
block|{
name|ahp
operator|->
name|ah_ani_function
operator|=
operator|(
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
operator||
name|HAL_ANI_FIRSTEP_LEVEL
operator||
name|HAL_ANI_MRC_CCK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_ani_function
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* always allow mode (on/off) to be controlled */
name|ahp
operator|->
name|ah_ani_function
operator||=
name|HAL_ANI_MODE
expr_stmt|;
if|if
condition|(
name|is_scanning
operator|||
operator|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_STA
operator|&&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_IBSS
operator|)
condition|)
block|{
comment|/*          * If we're scanning or in AP mode, the defaults (ini) should be          * in place.          * For an AP we assume the historical levels for this channel are          * probably outdated so start from defaults instead.          */
if|if
condition|(
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|!=
name|HAL_ANI_OFDM_DEF_LEVEL
operator|||
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|!=
name|HAL_ANI_CCK_DEF_LEVEL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Restore defaults: opmode %u chan %d Mhz/0x%x "
literal|"is_scanning=%d restore=%d ofdm:%d cck:%d\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|is_scanning
argument_list|,
name|ani_state
operator|->
name|must_restore
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|)
expr_stmt|;
comment|/*              * for STA/IBSS, we want to restore the historical values later              * (when we're not scanning)              */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|==
name|HAL_M_STA
operator|||
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|==
name|HAL_M_IBSS
condition|)
block|{
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_SPUR_IMMUNITY_LEVEL
argument_list|,
name|HAL_ANI_DEF_SPUR_IMMUNE_LVL
argument_list|)
expr_stmt|;
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_FIRSTEP_LEVEL
argument_list|,
name|HAL_ANI_DEF_FIRSTEP_LVL
argument_list|)
expr_stmt|;
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION
argument_list|,
name|HAL_ANI_USE_OFDM_WEAK_SIG
argument_list|)
expr_stmt|;
name|ar9300_ani_control
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_MRC_CCK
argument_list|,
name|HAL_ANI_ENABLE_MRC_CCK
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|must_restore
operator|=
name|AH_TRUE
expr_stmt|;
block|}
else|else
block|{
name|ar9300_ani_set_odfm_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_OFDM_DEF_LEVEL
argument_list|)
expr_stmt|;
name|ar9300_ani_set_cck_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|HAL_ANI_CCK_DEF_LEVEL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*          * restore historical levels for this channel          */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Restore history: opmode %u chan %d Mhz/0x%x is_scanning=%d "
literal|"restore=%d ofdm:%d cck:%d\n"
argument_list|,
name|__func__
argument_list|,
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|is_scanning
argument_list|,
name|ani_state
operator|->
name|must_restore
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|)
expr_stmt|;
name|ar9300_ani_set_odfm_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|)
expr_stmt|;
name|ar9300_ani_set_cck_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|must_restore
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/* enable phy counters */
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_1
argument_list|,
name|AR_PHY_ERR_OFDM_TIMING
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_MASK_2
argument_list|,
name|AR_PHY_ERR_CCK_TIMING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a MIB interrupt.  We may potentially be invoked because  * any of the MIB counters overflow/trigger so don't assume we're  * here because a PHY error counter triggered.  */
end_comment

begin_function
name|void
name|ar9300_process_mib_intr
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|phy_cnt1
decl_stmt|,
name|phy_cnt2
decl_stmt|;
if|#
directive|if
literal|0
block|HALDEBUG(ah, HAL_DEBUG_ANI, "%s: Processing Mib Intr\n", __func__);
endif|#
directive|endif
comment|/* Reset these counters regardless */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_OFDM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_FILT_CCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_SLP_MIB_CTRL
argument_list|)
operator|&
name|AR_SLP_MIB_PENDING
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_SLP_MIB_CTRL
argument_list|,
name|AR_SLP_MIB_CLEAR
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the mib counters and save them in the stats */
name|ar9300_update_mib_mac_stats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_nodestats
operator|=
operator|*
name|stats
expr_stmt|;
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
comment|/*          * We must always clear the interrupt cause by resetting          * the phy error regs.          */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* NB: these are not reset-on-read */
name|phy_cnt1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|)
expr_stmt|;
name|phy_cnt2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Errors: OFDM=0x%08x-0x0=%d   CCK=0x%08x-0x0=%d\n"
argument_list|,
name|__func__
argument_list|,
name|phy_cnt1
argument_list|,
name|phy_cnt1
argument_list|,
name|phy_cnt2
argument_list|,
name|phy_cnt2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|phy_cnt1
operator|&
name|AR_MIBCNT_INTRMASK
operator|)
operator|==
name|AR_MIBCNT_INTRMASK
operator|)
operator|||
operator|(
operator|(
name|phy_cnt2
operator|&
name|AR_MIBCNT_INTRMASK
operator|)
operator|==
name|AR_MIBCNT_INTRMASK
operator|)
condition|)
block|{
comment|/* NB: always restart to insure the h/w counters are reset */
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ar9300_ani_lower_immunity
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
init|=
name|ahp
operator|->
name|ah_curani
decl_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|>
literal|0
operator|&&
operator|(
name|ani_state
operator|->
name|ofdms_turn
operator|||
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*          * lower OFDM noise immunity          */
name|ar9300_ani_set_odfm_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*          * only lower either OFDM or CCK errors per turn          * we lower the other one next time          */
return|return;
block|}
if|if
condition|(
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|>
literal|0
condition|)
block|{
comment|/*          * lower CCK noise immunity          */
name|ar9300_ani_set_cck_noise_immunity_level
argument_list|(
name|ah
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* convert HW counter values to ms using mode specifix clock rate */
end_comment

begin_comment
comment|//#define CLOCK_RATE(_ah)  (ath_hal_chan_2_clock_rate_mhz(_ah) * 1000)
end_comment

begin_define
define|#
directive|define
name|CLOCK_RATE
parameter_list|(
name|_ah
parameter_list|)
value|(ath_hal_mac_clks(ah, 1000))
end_define

begin_comment
comment|/*  * Return an approximation of the time spent ``listening'' by  * deducting the cycles spent tx'ing and rx'ing from the total  * cycle count since our last call.  A return value<0 indicates  * an invalid/inconsistent time.  */
end_comment

begin_function
specifier|static
name|int32_t
name|ar9300_ani_get_listen_time
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_ANISTATS
modifier|*
name|ani_stats
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
name|u_int32_t
name|tx_frame_count
decl_stmt|,
name|rx_frame_count
decl_stmt|,
name|cycle_count
decl_stmt|;
name|int32_t
name|listen_time
decl_stmt|;
name|tx_frame_count
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TFCNT
argument_list|)
expr_stmt|;
name|rx_frame_count
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RFCNT
argument_list|)
expr_stmt|;
name|cycle_count
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_CCCNT
argument_list|)
expr_stmt|;
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|cycle_count
operator|==
literal|0
operator|||
name|ani_state
operator|->
name|cycle_count
operator|>
name|cycle_count
condition|)
block|{
comment|/*          * Cycle counter wrap (or initial call); it's not possible          * to accurately calculate a value because the registers          * right shift rather than wrap--so punt and return 0.          */
name|listen_time
operator|=
literal|0
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_lzero
operator|++
expr_stmt|;
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: 1st call: ani_state->cycle_count=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|cycle_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|int32_t
name|ccdelta
init|=
name|cycle_count
operator|-
name|ani_state
operator|->
name|cycle_count
decl_stmt|;
name|int32_t
name|rfdelta
init|=
name|rx_frame_count
operator|-
name|ani_state
operator|->
name|rx_frame_count
decl_stmt|;
name|int32_t
name|tfdelta
init|=
name|tx_frame_count
operator|-
name|ani_state
operator|->
name|tx_frame_count
decl_stmt|;
name|listen_time
operator|=
operator|(
name|ccdelta
operator|-
name|rfdelta
operator|-
name|tfdelta
operator|)
operator|/
name|CLOCK_RATE
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: cyclecount=%d, rfcount=%d, tfcount=%d, listen_time=%d "
literal|"CLOCK_RATE=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ccdelta
argument_list|,
name|rfdelta
argument_list|,
name|tfdelta
argument_list|,
name|listen_time
argument_list|,
name|CLOCK_RATE
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ani_state
operator|->
name|cycle_count
operator|=
name|cycle_count
expr_stmt|;
name|ani_state
operator|->
name|tx_frame_count
operator|=
name|tx_frame_count
expr_stmt|;
name|ani_state
operator|->
name|rx_frame_count
operator|=
name|rx_frame_count
expr_stmt|;
return|return
name|listen_time
return|;
block|}
end_function

begin_comment
comment|/*  * Do periodic processing.  This routine is called from a timer  */
end_comment

begin_function
name|void
name|ar9300_ani_ar_poll
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_NODE_STATS
modifier|*
name|stats
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|HAL_ANISTATS
modifier|*
name|ani_stats
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
name|int32_t
name|listen_time
decl_stmt|;
name|u_int32_t
name|ofdm_phy_err_rate
decl_stmt|,
name|cck_phy_err_rate
decl_stmt|;
name|u_int32_t
name|ofdm_phy_err_cnt
decl_stmt|,
name|cck_phy_err_cnt
decl_stmt|;
name|HAL_BOOL
name|old_phy_noise_spur
decl_stmt|;
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_nodestats
operator|=
operator|*
name|stats
expr_stmt|;
comment|/* XXX optimize? */
if|if
condition|(
name|ani_state
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: can't poll - no ANI not initialized for this channel\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * ar9300_ani_ar_poll is never called while scanning but we may have been      * scanning and now just restarted polling.  In this case we need to      * restore historical values.      */
if|if
condition|(
name|ani_state
operator|->
name|must_restore
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: must restore - calling ar9300_ani_restart\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ar9300_ani_reset
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
name|listen_time
operator|=
name|ar9300_ani_get_listen_time
argument_list|(
name|ah
argument_list|,
name|ani_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen_time
operator|<=
literal|0
condition|)
block|{
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_lneg
operator|++
expr_stmt|;
comment|/* restart ANI period if listen_time is invalid */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: listen_time=%d - calling ar9300_ani_restart\n"
argument_list|,
name|__func__
argument_list|,
name|listen_time
argument_list|)
expr_stmt|;
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX beware of overflow? */
name|ani_state
operator|->
name|listen_time
operator|+=
name|listen_time
expr_stmt|;
comment|/* Clear the mib counters and save them in the stats */
name|ar9300_update_mib_mac_stats
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* NB: these are not reset-on-read */
name|ofdm_phy_err_cnt
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_1
argument_list|)
expr_stmt|;
name|cck_phy_err_cnt
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_ERR_2
argument_list|)
expr_stmt|;
comment|/* NB: only use ast_ani_*errs with AH_PRIVATE_DIAG */
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_ofdmerrs
operator|+=
name|ofdm_phy_err_cnt
operator|-
name|ani_state
operator|->
name|ofdm_phy_err_count
expr_stmt|;
name|ani_state
operator|->
name|ofdm_phy_err_count
operator|=
name|ofdm_phy_err_cnt
expr_stmt|;
name|ahp
operator|->
name|ah_stats
operator|.
name|ast_ani_cckerrs
operator|+=
name|cck_phy_err_cnt
operator|-
name|ani_state
operator|->
name|cck_phy_err_count
expr_stmt|;
name|ani_state
operator|->
name|cck_phy_err_count
operator|=
name|cck_phy_err_cnt
expr_stmt|;
if|#
directive|if
name|HAL_ANI_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: Errors: OFDM=0x%08x-0x0=%d   CCK=0x%08x-0x0=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ofdm_phy_err_cnt
argument_list|,
name|ofdm_phy_err_cnt
argument_list|,
name|cck_phy_err_cnt
argument_list|,
name|cck_phy_err_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * If ani is not enabled, return after we've collected      * statistics      */
if|if
condition|(
operator|!
name|DO_ANI
argument_list|(
name|ah
argument_list|)
condition|)
block|{
return|return;
block|}
name|ofdm_phy_err_rate
operator|=
name|ani_state
operator|->
name|ofdm_phy_err_count
operator|*
literal|1000
operator|/
name|ani_state
operator|->
name|listen_time
expr_stmt|;
name|cck_phy_err_rate
operator|=
name|ani_state
operator|->
name|cck_phy_err_count
operator|*
literal|1000
operator|/
name|ani_state
operator|->
name|listen_time
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: listen_time=%d OFDM:%d errs=%d/s CCK:%d errs=%d/s ofdm_turn=%d\n"
argument_list|,
name|__func__
argument_list|,
name|listen_time
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ofdm_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|,
name|cck_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|ofdms_turn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ani_state
operator|->
name|listen_time
operator|>=
name|HAL_NOISE_DETECT_PERIOD
condition|)
block|{
name|old_phy_noise_spur
operator|=
name|ani_state
operator|->
name|phy_noise_spur
expr_stmt|;
if|if
condition|(
name|ofdm_phy_err_rate
operator|<=
name|ani_state
operator|->
name|ofdm_trig_low
operator|&&
name|cck_phy_err_rate
operator|<=
name|ani_state
operator|->
name|cck_trig_low
condition|)
block|{
if|if
condition|(
name|ani_state
operator|->
name|listen_time
operator|>=
name|HAL_NOISE_RECOVER_PERIOD
condition|)
block|{
name|ani_state
operator|->
name|phy_noise_spur
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ani_state
operator|->
name|phy_noise_spur
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|old_phy_noise_spur
operator|!=
name|ani_state
operator|->
name|phy_noise_spur
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: enviroment change from %d to %d\n"
argument_list|,
name|__func__
argument_list|,
name|old_phy_noise_spur
argument_list|,
name|ani_state
operator|->
name|phy_noise_spur
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ani_state
operator|->
name|listen_time
operator|>
literal|5
operator|*
name|ahp
operator|->
name|ah_ani_period
condition|)
block|{
comment|/*          * Check to see if need to lower immunity if          * 5 ani_periods have passed          */
if|if
condition|(
name|ofdm_phy_err_rate
operator|<=
name|ani_state
operator|->
name|ofdm_trig_low
operator|&&
name|cck_phy_err_rate
operator|<=
name|ani_state
operator|->
name|cck_trig_low
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: 1. listen_time=%d OFDM:%d errs=%d/s(<%d)  "
literal|"CCK:%d errs=%d/s(<%d) -> ar9300_ani_lower_immunity\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ofdm_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|ofdm_trig_low
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|,
name|cck_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|cck_trig_low
argument_list|)
expr_stmt|;
name|ar9300_ani_lower_immunity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ofdms_turn
operator|=
operator|!
name|ani_state
operator|->
name|ofdms_turn
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: 1 listen_time=%d ofdm=%d/s cck=%d/s - "
literal|"calling ar9300_ani_restart\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ofdm_phy_err_rate
argument_list|,
name|cck_phy_err_rate
argument_list|)
expr_stmt|;
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ani_state
operator|->
name|listen_time
operator|>
name|ahp
operator|->
name|ah_ani_period
condition|)
block|{
comment|/* check to see if need to raise immunity */
if|if
condition|(
name|ofdm_phy_err_rate
operator|>
name|ani_state
operator|->
name|ofdm_trig_high
operator|&&
operator|(
name|cck_phy_err_rate
operator|<=
name|ani_state
operator|->
name|cck_trig_high
operator|||
name|ani_state
operator|->
name|ofdms_turn
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: 2 listen_time=%d OFDM:%d errs=%d/s(>%d) -> "
literal|"ar9300_ani_ofdm_err_trigger\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ani_state
operator|->
name|ofdm_noise_immunity_level
argument_list|,
name|ofdm_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|ofdm_trig_high
argument_list|)
expr_stmt|;
name|ar9300_ani_ofdm_err_trigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ofdms_turn
operator|=
name|AH_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cck_phy_err_rate
operator|>
name|ani_state
operator|->
name|cck_trig_high
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_ANI
argument_list|,
literal|"%s: 3 listen_time=%d CCK:%d errs=%d/s(>%d) -> "
literal|"ar9300_ani_cck_err_trigger\n"
argument_list|,
name|__func__
argument_list|,
name|ani_state
operator|->
name|listen_time
argument_list|,
name|ani_state
operator|->
name|cck_noise_immunity_level
argument_list|,
name|cck_phy_err_rate
argument_list|,
name|ani_state
operator|->
name|cck_trig_high
argument_list|)
expr_stmt|;
name|ar9300_ani_cck_err_trigger
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ar9300_ani_restart
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ani_state
operator|->
name|ofdms_turn
operator|=
name|AH_TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The poll function above calculates short noise spurs, caused by non-80211  * devices, based on OFDM/CCK Phy errs.  * If the noise is short enough, we don't want our ratectrl Algo to stop probing  * higher rates, due to bad PER.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_is_ani_noise_spur
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|struct
name|ar9300_ani_state
modifier|*
name|ani_state
decl_stmt|;
name|ani_state
operator|=
name|ahp
operator|->
name|ah_curani
expr_stmt|;
return|return
name|ani_state
operator|->
name|phy_noise_spur
return|;
block|}
end_function

end_unit

