begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_comment
comment|/*  * Default 5413/9300 radar phy parameters  * Values adjusted to fix EV76432/EV76320  */
end_comment

begin_define
define|#
directive|define
name|AR9300_DFS_FIRPWR
value|-28
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_RRSSI
value|0
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_HEIGHT
value|10
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_PRSSI
value|6
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_INBAND
value|8
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_RELPWR
value|8
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_RELSTEP
value|12
end_define

begin_define
define|#
directive|define
name|AR9300_DFS_MAXLEN
value|255
end_define

begin_comment
comment|/*  * This PRSSI value should be used during CAC.  */
end_comment

begin_define
define|#
directive|define
name|AR9300_DFS_PRSSI_CAC
value|10
end_define

begin_comment
comment|/*  *  make sure that value matches value in ar9300_osprey_2p2_mac_core[][2]  *  for register 0x1040 to 0x104c */
end_comment

begin_define
define|#
directive|define
name|AR9300_DEFAULT_DIFS
value|0x002ffc0f
end_define

begin_define
define|#
directive|define
name|AR9300_FCC_RADARS_FCC_OFFSET
value|4
end_define

begin_decl_stmt
name|struct
name|dfs_pulse
name|ar9300_etsi_radars
index|[]
init|=
block|{
comment|/* for short pulses, RSSI threshold should be smaller than  * Kquick-drop. The chip has only one chance to drop the gain which  * will be reported as the estimated RSSI */
comment|/* TYPE staggered pulse */
comment|/* 0.8-2us, 2-3 bursts,300-400 PRF, 10 pulses each */
block|{
literal|30
block|,
literal|2
block|,
literal|300
block|,
literal|400
block|,
literal|2
block|,
literal|30
block|,
literal|3
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|31
block|}
block|,
comment|/* Type 5*/
comment|/* 0.8-2us, 2-3 bursts, 400-1200 PRF, 15 pulses each */
block|{
literal|30
block|,
literal|2
block|,
literal|400
block|,
literal|1200
block|,
literal|2
block|,
literal|30
block|,
literal|7
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* Type 6 */
comment|/* constant PRF based */
comment|/* 0.8-5us, 200  300 PRF, 10 pulses */
block|{
literal|10
block|,
literal|5
block|,
literal|200
block|,
literal|400
block|,
literal|0
block|,
literal|24
block|,
literal|5
block|,
literal|0
block|,
literal|8
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|33
block|}
block|,
comment|/* Type 1 */
block|{
literal|10
block|,
literal|5
block|,
literal|400
block|,
literal|600
block|,
literal|0
block|,
literal|24
block|,
literal|5
block|,
literal|0
block|,
literal|8
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|37
block|}
block|,
comment|/* Type 1 */
block|{
literal|10
block|,
literal|5
block|,
literal|600
block|,
literal|800
block|,
literal|0
block|,
literal|24
block|,
literal|5
block|,
literal|0
block|,
literal|8
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|38
block|}
block|,
comment|/* Type 1 */
block|{
literal|10
block|,
literal|5
block|,
literal|800
block|,
literal|1000
block|,
literal|0
block|,
literal|24
block|,
literal|5
block|,
literal|0
block|,
literal|8
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|39
block|}
block|,
comment|/* Type 1 */
comment|//  {10, 5,   200, 1000, 0, 24,  5,  0,  8, 15, 0,   0, 2, 33},
comment|/* 0.8-15us, 200-1600 PRF, 15 pulses */
block|{
literal|15
block|,
literal|15
block|,
literal|200
block|,
literal|1600
block|,
literal|0
block|,
literal|24
block|,
literal|8
block|,
literal|0
block|,
literal|18
block|,
literal|24
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|34
block|}
block|,
comment|/* Type 2 */
comment|/* 0.8-15us, 2300-4000 PRF, 25 pulses*/
block|{
literal|25
block|,
literal|15
block|,
literal|2300
block|,
literal|4000
block|,
literal|0
block|,
literal|24
block|,
literal|10
block|,
literal|0
block|,
literal|18
block|,
literal|24
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|35
block|}
block|,
comment|/* Type 3 */
comment|/* 20-30us, 2000-4000 PRF, 20 pulses*/
block|{
literal|20
block|,
literal|30
block|,
literal|2000
block|,
literal|4000
block|,
literal|0
block|,
literal|24
block|,
literal|8
block|,
literal|19
block|,
literal|33
block|,
literal|24
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|36
block|}
block|,
comment|/* Type 4 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are for FCC Bin 1-4 pulses */
end_comment

begin_decl_stmt
name|struct
name|dfs_pulse
name|ar9300_fcc_radars
index|[]
init|=
block|{
comment|/* following two filters are specific to Japan/MKK4 */
comment|//  {18,  1,  720,  720, 1,  6,  6,  0,  1, 18,  0, 3, 0, 17}, // 1389 +/- 6 us
comment|//  {18,  4,  250,  250, 1, 10,  5,  1,  6, 18,  0, 3, 0, 18}, // 4000 +/- 6 us
comment|//  {18,  5,  260,  260, 1, 10,  6,  1,  6, 18,  0, 3, 0, 19}, // 3846 +/- 7 us
block|{
literal|18
block|,
literal|1
block|,
literal|720
block|,
literal|720
block|,
literal|0
block|,
literal|6
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|17
block|}
block|,
comment|// 1389 +/- 6 us
block|{
literal|18
block|,
literal|4
block|,
literal|250
block|,
literal|250
block|,
literal|0
block|,
literal|10
block|,
literal|5
block|,
literal|1
block|,
literal|6
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|18
block|}
block|,
comment|// 4000 +/- 6 us
block|{
literal|18
block|,
literal|5
block|,
literal|260
block|,
literal|260
block|,
literal|0
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|6
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|19
block|}
block|,
comment|// 3846 +/- 7 us
comment|//  {18,  5,  260,  260, 1, 10,  6,  1,  6, 18,  0, 3, 1, 20}, // 3846 +/- 7 us
block|{
literal|18
block|,
literal|5
block|,
literal|260
block|,
literal|260
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|6
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|20
block|}
block|,
comment|// 3846 +/- 7 us
comment|/* following filters are common to both FCC and JAPAN */
comment|// FCC TYPE 1
comment|// {18,  1,  325, 1930, 0,  6,  7,  0,  1, 18,  0, 3, 0, 0}, // 518 to 3066
block|{
literal|18
block|,
literal|1
block|,
literal|700
block|,
literal|700
block|,
literal|0
block|,
literal|6
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|18
block|,
literal|1
block|,
literal|350
block|,
literal|350
block|,
literal|0
block|,
literal|6
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|18
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|// FCC TYPE 6
comment|// {9,   1, 3003, 3003, 1,  7,  5,  0,  1, 18,  0, 0, 0, 1}, // 333 +/- 7 us
comment|//{9,   1, 3003, 3003, 1,  7,  5,  0,  1, 18,  0, 0, 0, 1},
block|{
literal|9
block|,
literal|1
block|,
literal|3003
block|,
literal|3003
block|,
literal|0
block|,
literal|7
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|18
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|// FCC TYPE 2
block|{
literal|23
block|,
literal|5
block|,
literal|4347
block|,
literal|6666
block|,
literal|0
block|,
literal|18
block|,
literal|11
block|,
literal|0
block|,
literal|7
block|,
literal|22
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|// FCC TYPE 3
block|{
literal|18
block|,
literal|10
block|,
literal|2000
block|,
literal|5000
block|,
literal|0
block|,
literal|23
block|,
literal|8
block|,
literal|6
block|,
literal|13
block|,
literal|22
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|5
block|}
block|,
comment|// FCC TYPE 4
block|{
literal|16
block|,
literal|15
block|,
literal|2000
block|,
literal|5000
block|,
literal|0
block|,
literal|25
block|,
literal|7
block|,
literal|11
block|,
literal|23
block|,
literal|22
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|11
block|}
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dfs_bin5pulse
name|ar9300_bin5pulses
index|[]
init|=
block|{
block|{
literal|2
block|,
literal|28
block|,
literal|105
block|,
literal|12
block|,
literal|22
block|,
literal|5
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Find the internal HAL channel corresponding to the  * public HAL channel specified in c  */
end_comment

begin_define
unit|static HAL_CHANNEL_INTERNAL * getchannel(struct ath_hal *ah, const struct ieee80211_channel *c) {
define|#
directive|define
name|CHAN_FLAGS
value|(CHANNEL_ALL | CHANNEL_HALF | CHANNEL_QUARTER)
end_define

begin_comment
unit|HAL_CHANNEL_INTERNAL *base, *cc;     int flags = c->channel_flags& CHAN_FLAGS;     int n, lim;
comment|/*      * Check current channel to avoid the lookup.      */
end_comment

begin_comment
unit|cc = AH_PRIVATE(ah)->ah_curchan;     if (cc != AH_NULL&& cc->channel == c->channel&&         (cc->channel_flags& CHAN_FLAGS) == flags) {         return cc;     }
comment|/* binary search based on known sorting order */
end_comment

begin_comment
unit|base = AH_TABLES(ah)->ah_channels;     n = AH_PRIVATE(ah)->ah_nchan;
comment|/* binary search based on known sorting order */
end_comment

begin_undef
unit|for (lim = n; lim != 0; lim>>= 1) {         int d;         cc =&base[lim>> 1];         d = c->channel - cc->channel;         if (d == 0) {             if ((cc->channel_flags& CHAN_FLAGS) == flags) {                 return cc;             }             d = flags - (cc->channel_flags& CHAN_FLAGS);         }         HALDEBUG(ah, HAL_DEBUG_DFS, "%s: channel %u/0x%x d %d\n", __func__,                 cc->channel, cc->channel_flags, d);         if (d> 0) {             base = cc + 1;             lim--;         }     }     HALDEBUG(ah, HAL_DEBUG_DFS, "%s: no match for %u/0x%x\n",             __func__, c->channel, c->channel_flags);     return AH_NULL;
undef|#
directive|undef
name|CHAN_FLAGS
end_undef

begin_comment
unit|}
comment|/*  * Check the internal channel list to see if the desired channel  * is ok to release from the NOL.  If not, then do nothing.  If so,  * mark the channel as clear and reset the internal tsf time  */
end_comment

begin_comment
unit|void ar9300_check_dfs(struct ath_hal *ah, struct ieee80211_channel *chan) {     HAL_CHANNEL_INTERNAL *ichan = AH_NULL;      ichan = getchannel(ah, chan);     if (ichan == AH_NULL) {         return;     }     if (!(ichan->priv_flags& CHANNEL_INTERFERENCE)) {         return;     }      ichan->priv_flags&= ~CHANNEL_INTERFERENCE;     ichan->dfs_tsf = 0; }
comment|/*  * This function marks the channel as having found a dfs event  * It also marks the end time that the dfs event should be cleared  * If the channel is already marked, then tsf end time can only  * be increased  */
end_comment

begin_endif
unit|void ar9300_dfs_found(struct ath_hal *ah, struct ieee80211_channel *chan, u_int64_t nol_time) {     HAL_CHANNEL_INTERNAL *ichan;      ichan = getchannel(ah, chan);     if (ichan == AH_NULL) {         return;     }     if (!(ichan->priv_flags& CHANNEL_INTERFERENCE)) {         ichan->dfs_tsf = ar9300_get_tsf64(ah);     }     ichan->dfs_tsf += nol_time;     ichan->priv_flags |= CHANNEL_INTERFERENCE;     chan->priv_flags |= CHANNEL_INTERFERENCE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Enable radar detection and set the radar parameters per the  * values in pe  */
end_comment

begin_function
name|void
name|ar9300_enable_dfs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_PHYERR_PARAM
modifier|*
name|pe
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|struct
name|ath_hal_private
modifier|*
name|ahp
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|ahp
operator|->
name|ah_curchan
decl_stmt|;
name|struct
name|ath_hal_9300
modifier|*
name|ah9300
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|reg_writes
init|=
literal|0
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|)
expr_stmt|;
name|val
operator||=
name|AR_PHY_RADAR_0_FFT_ENA
operator||
name|AR_PHY_RADAR_0_ENA
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_firpwr
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_FIRPWR
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_firpwr
argument_list|,
name|AR_PHY_RADAR_0_FIRPWR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_rrssi
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_RRSSI
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_rrssi
argument_list|,
name|AR_PHY_RADAR_0_RRSSI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_height
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_HEIGHT
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_height
argument_list|,
name|AR_PHY_RADAR_0_HEIGHT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_prssi
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_PRSSI
expr_stmt|;
if|if
condition|(
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (ah->ah_use_cac_prssi) {                 val |= SM(AR9300_DFS_PRSSI_CAC, AR_PHY_RADAR_0_PRSSI);             } else {
endif|#
directive|endif
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_prssi
argument_list|,
name|AR_PHY_RADAR_0_PRSSI
argument_list|)
expr_stmt|;
comment|//            }
block|}
else|else
block|{
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_prssi
argument_list|,
name|AR_PHY_RADAR_0_PRSSI
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pe
operator|->
name|pe_inband
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_INBAND
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_inband
argument_list|,
name|AR_PHY_RADAR_0_INBAND
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_1
argument_list|)
expr_stmt|;
name|val
operator||=
name|AR_PHY_RADAR_1_MAX_RRSSI
operator||
name|AR_PHY_RADAR_1_BLOCK_CHECK
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_maxlen
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_1_MAXLEN
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_maxlen
argument_list|,
name|AR_PHY_RADAR_1_MAXLEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_relstep
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_1_RELSTEP_THRESH
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_relstep
argument_list|,
name|AR_PHY_RADAR_1_RELSTEP_THRESH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_relpwr
operator|!=
name|HAL_PHYERR_PARAM_NOVAL
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_1_RELPWR_THRESH
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|pe
operator|->
name|pe_relpwr
argument_list|,
name|AR_PHY_RADAR_1_RELPWR_THRESH
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|ah
argument_list|,
name|HAL_CAP_EXT_CHAN_DFS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|HAL_OK
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_EXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* Enable extension channel radar detection */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_EXT
argument_list|,
name|val
operator||
name|AR_PHY_RADAR_EXT_ENA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* HT20 mode, disable extension channel radar detect */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_EXT
argument_list|,
name|val
operator|&
operator|~
name|AR_PHY_RADAR_EXT_ENA
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*         apply DFS postamble array from INI         column 0 is register ID, column 1 is  HT20 value, colum2 is HT40 value     */
if|if
condition|(
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_OSPREY_22
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|REG_WRITE_ARRAY
argument_list|(
operator|&
name|ah9300
operator|->
name|ah_ini_dfs
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|?
literal|2
else|:
literal|1
argument_list|,
name|reg_writes
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ATH_HAL_DFS_CHIRPING_FIX_APH128
name|ath_hal_printf
argument_list|(
name|ah
argument_list|,
literal|"DFS change the timing value\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_TIMING6
argument_list|,
literal|0x3140c00a
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Get the radar parameter values and return them in the pe  * structure  */
end_comment

begin_function
name|void
name|ar9300_get_dfs_thresh
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_PHYERR_PARAM
modifier|*
name|pe
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|,
name|temp
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_0_FIRPWR
argument_list|)
expr_stmt|;
name|temp
operator||=
operator|~
operator|(
name|AR_PHY_RADAR_0_FIRPWR
operator|>>
name|AR_PHY_RADAR_0_FIRPWR_S
operator|)
expr_stmt|;
name|pe
operator|->
name|pe_firpwr
operator|=
name|temp
expr_stmt|;
name|pe
operator|->
name|pe_rrssi
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_0_RRSSI
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_height
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_0_HEIGHT
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_prssi
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_0_PRSSI
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_inband
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_0_INBAND
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_1
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_relpwr
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_1_RELPWR_THRESH
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_enrelpwr
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|AR_PHY_RADAR_1_RELPWR_ENA
operator|)
expr_stmt|;
name|pe
operator|->
name|pe_relstep
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_1_RELSTEP_THRESH
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_en_relstep_check
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|AR_PHY_RADAR_1_RELSTEP_CHECK
operator|)
expr_stmt|;
name|pe
operator|->
name|pe_maxlen
operator|=
name|MS
argument_list|(
name|val
argument_list|,
name|AR_PHY_RADAR_1_MAXLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|HAL_BOOL ar9300_radar_wait(struct ath_hal *ah, struct ieee80211_channel *chan) {     struct ath_hal_private *ahp = AH_PRIVATE(ah);      if (!ahp->ah_curchan) {         return AH_TRUE;     }
comment|/*      * Rely on the upper layers to determine that we have spent      * enough time waiting.      */
end_comment

begin_endif
unit|chan->channel = ahp->ah_curchan->channel;     chan->channel_flags = ahp->ah_curchan->channel_flags;     chan->max_reg_tx_power = ahp->ah_curchan->max_reg_tx_power;      ahp->ah_curchan->priv_flags |= CHANNEL_DFS_CLEAR;     chan->priv_flags  = ahp->ah_curchan->priv_flags;     return AH_FALSE;  }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|dfs_pulse
modifier|*
name|ar9300_get_dfs_radars
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|dfsdomain
parameter_list|,
name|int
modifier|*
name|numradars
parameter_list|,
name|struct
name|dfs_bin5pulse
modifier|*
modifier|*
name|bin5pulses
parameter_list|,
name|int
modifier|*
name|numb5radars
parameter_list|,
name|HAL_PHYERR_PARAM
modifier|*
name|pe
parameter_list|)
block|{
name|struct
name|dfs_pulse
modifier|*
name|dfs_radars
init|=
name|AH_NULL
decl_stmt|;
switch|switch
condition|(
name|dfsdomain
condition|)
block|{
case|case
name|HAL_DFS_FCC_DOMAIN
case|:
name|dfs_radars
operator|=
operator|&
name|ar9300_fcc_radars
index|[
name|AR9300_FCC_RADARS_FCC_OFFSET
index|]
expr_stmt|;
operator|*
name|numradars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_fcc_radars
argument_list|)
operator|-
name|AR9300_FCC_RADARS_FCC_OFFSET
expr_stmt|;
operator|*
name|bin5pulses
operator|=
operator|&
name|ar9300_bin5pulses
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|numb5radars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_bin5pulses
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: DFS_FCC_DOMAIN_9300\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_DFS_ETSI_DOMAIN
case|:
name|dfs_radars
operator|=
operator|&
name|ar9300_etsi_radars
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|numradars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_etsi_radars
argument_list|)
expr_stmt|;
operator|*
name|bin5pulses
operator|=
operator|&
name|ar9300_bin5pulses
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|numb5radars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_bin5pulses
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: DFS_ETSI_DOMAIN_9300\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_DFS_MKK4_DOMAIN
case|:
name|dfs_radars
operator|=
operator|&
name|ar9300_fcc_radars
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|numradars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_fcc_radars
argument_list|)
expr_stmt|;
operator|*
name|bin5pulses
operator|=
operator|&
name|ar9300_bin5pulses
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|numb5radars
operator|=
name|ARRAY_LENGTH
argument_list|(
name|ar9300_bin5pulses
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: DFS_MKK4_DOMAIN_9300\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: no domain\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|AH_NULL
return|;
block|}
comment|/* Set the default phy parameters per chip */
name|pe
operator|->
name|pe_firpwr
operator|=
name|AR9300_DFS_FIRPWR
expr_stmt|;
name|pe
operator|->
name|pe_rrssi
operator|=
name|AR9300_DFS_RRSSI
expr_stmt|;
name|pe
operator|->
name|pe_height
operator|=
name|AR9300_DFS_HEIGHT
expr_stmt|;
name|pe
operator|->
name|pe_prssi
operator|=
name|AR9300_DFS_PRSSI
expr_stmt|;
comment|/*         we have an issue with PRSSI.         For normal operation we use AR9300_DFS_PRSSI, which is set to 6.         Please refer to EV91563, 94164.         However, this causes problem during CAC as no radar is detected         during that period with PRSSI=6. Only PRSSI= 10 seems to fix this.         We use this flag to keep track of change in PRSSI.     */
comment|//    ah->ah_use_cac_prssi = 0;
name|pe
operator|->
name|pe_inband
operator|=
name|AR9300_DFS_INBAND
expr_stmt|;
name|pe
operator|->
name|pe_relpwr
operator|=
name|AR9300_DFS_RELPWR
expr_stmt|;
name|pe
operator|->
name|pe_relstep
operator|=
name|AR9300_DFS_RELSTEP
expr_stmt|;
name|pe
operator|->
name|pe_maxlen
operator|=
name|AR9300_DFS_MAXLEN
expr_stmt|;
return|return
name|dfs_radars
return|;
block|}
end_function

begin_function
name|void
name|ar9300_adjust_difs
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/*          * EV 116936:          * Restore the register values with that of the HAL structure.          * Do not assume and overwrite these values to whatever           * is in ar9300_osprey22.ini.          */
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
name|int
name|q
decl_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fccaifs
operator|=
literal|0
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: restore DIFS \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
literal|4
condition|;
name|q
operator|++
control|)
block|{
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cwmin
argument_list|,
name|AR_D_LCL_IFS_CWMIN
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cwmax
argument_list|,
name|AR_D_LCL_IFS_CWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_aifs
argument_list|,
name|AR_D_LCL_IFS_AIFS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          * These are values from George Lai and are specific to          * FCC domain. They are yet to be determined for other domains.           */
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fccaifs
operator|=
literal|1
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_DFS
argument_list|,
literal|"%s: set DIFS to default\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/*printk("%s:  modify DIFS\n", __func__);*/
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0x05fffc0f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|0x05f0fc0f
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|0x05f03c07
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|0x05f01c03
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u_int32_t
name|ar9300_dfs_config_fft
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|is_enable
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_enable
condition|)
block|{
name|val
operator||=
name|AR_PHY_RADAR_0_FFT_ENA
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_FFT_ENA
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*     function to adjust PRSSI value for CAC problem  */
end_comment

begin_function
name|void
name|ar9300_dfs_cac_war
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
name|start
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
if|if
condition|(
name|AR_SREV_AR9580
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|||
name|AR_SREV_SCORPION
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_PRSSI
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|AR9300_DFS_PRSSI_CAC
argument_list|,
name|AR_PHY_RADAR_0_PRSSI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|AR_PHY_RADAR_0_PRSSI
expr_stmt|;
name|val
operator||=
name|SM
argument_list|(
name|AR9300_DFS_PRSSI
argument_list|,
name|AR_PHY_RADAR_0_PRSSI
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_PHY_RADAR_0
argument_list|,
name|val
operator||
name|AR_PHY_RADAR_0_ENA
argument_list|)
expr_stmt|;
comment|//        ah->ah_use_cac_prssi = start;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct ieee80211_channel * ar9300_get_extension_channel(struct ath_hal *ah) {     struct ath_hal_private  *ahp = AH_PRIVATE(ah);     struct ath_hal_private_tables  *aht = AH_TABLES(ah);     int i = 0;      HAL_CHANNEL_INTERNAL *ichan = AH_NULL;     CHAN_CENTERS centers;      ichan = ahp->ah_curchan;     ar9300_get_channel_centers(ah, ichan,&centers);     if (centers.ctl_center == centers.ext_center) {         return AH_NULL;     }     for (i = 0; i< ahp->ah_nchan; i++) {         ichan =&aht->ah_channels[i];         if (ichan->channel == centers.ext_center) {             return (struct ieee80211_channel*)ichan;         }     }     return AH_NULL; }
endif|#
directive|endif
end_endif

begin_function
name|HAL_BOOL
name|ar9300_is_fast_clock_enabled
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_private
modifier|*
name|ahp
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_5GHZ_FAST_CLOCK_EN
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_curchan
argument_list|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * This should be enabled and linked into the build once  * radar support is enabled.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|HAL_BOOL ar9300_handle_radar_bb_panic(struct ath_hal *ah) {     u_int32_t status;     u_int32_t val;
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_endif
unit|struct ath_hal_9300 *ahp = AH9300(ah);
endif|#
directive|endif
end_endif

begin_comment
unit|status = AH_PRIVATE(ah)->ah_bb_panic_last_status;         if ( status == 0x04000539 ) {
comment|/* recover from this BB panic without reset*/
end_comment

begin_comment
comment|/* set AR9300_DFS_FIRPWR to -1 */
end_comment

begin_comment
unit|val = OS_REG_READ(ah, AR_PHY_RADAR_0);         val&= (~AR_PHY_RADAR_0_FIRPWR);         val |= SM( 0x7f, AR_PHY_RADAR_0_FIRPWR);         OS_REG_WRITE(ah, AR_PHY_RADAR_0, val);         OS_DELAY(1);
comment|/* set AR9300_DFS_FIRPWR to its default value */
end_comment

begin_comment
unit|val = OS_REG_READ(ah, AR_PHY_RADAR_0);         val&= ~AR_PHY_RADAR_0_FIRPWR;         val |= SM( AR9300_DFS_FIRPWR, AR_PHY_RADAR_0_FIRPWR);         OS_REG_WRITE(ah, AR_PHY_RADAR_0, val);         return AH_TRUE;     } else if (status == 0x0400000a) {
comment|/* EV 92527 : reset required if we see this signature */
end_comment

begin_comment
unit|HALDEBUG(ah, HAL_DEBUG_DFS, "%s: BB Panic -- 0x0400000a\n", __func__);         return AH_FALSE;     } else if (status == 0x1300000a) {
comment|/* EV92527: we do not need a reset if we see this signature */
end_comment

begin_comment
unit|HALDEBUG(ah, HAL_DEBUG_DFS, "%s: BB Panic -- 0x1300000a\n", __func__);         return AH_TRUE;     } else if (AR_SREV_WASP(ah)&& (status == 0x04000409)) {         return AH_TRUE;     } else {         if (ar9300_get_capability(ah, HAL_CAP_LDPCWAR, 0, AH_NULL) == HAL_OK&&             (status& 0xff00000f) == 0x04000009&&             status != 0x04000409&&             status != 0x04000b09&&             status != 0x04000e09&&             (status& 0x0000ff00))         {
comment|/* disable RIFS Rx */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AH_DEBUG
end_ifdef

begin_endif
unit|HALDEBUG(ah, HAL_DEBUG_UNMASKABLE, "%s: BB status=0x%08x rifs=%d - disable\n",                      __func__, status, ahp->ah_rifs_enabled);             ar9300_set_rifs_delay(ah, AH_FALSE);         }         return AH_FALSE;     } }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

