begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_comment
comment|/*  * Checks to see if an interrupt is pending on our NIC  *  * Returns: TRUE    if an interrupt is pending  *          FALSE   if not  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_is_interrupt_pending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|u_int32_t
name|sync_en_def
init|=
name|AR9300_INTR_SYNC_DEFAULT
decl_stmt|;
name|u_int32_t
name|host_isr
decl_stmt|;
comment|/*      * Some platforms trigger our ISR before applying power to      * the card, so make sure.      */
name|host_isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|host_isr
operator|&
name|AR_INTR_ASYNC_USED
operator|)
operator|&&
operator|(
name|host_isr
operator|!=
name|AR_INTR_SPURIOUS
operator|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
name|host_isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9300_INTR_SYNC_DEF_NO_HOST1_PERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9340_INTR_SYNC_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|host_isr
operator|&
operator|(
name|sync_en_def
operator||
name|AR_INTR_SYNC_MASK_GPIO
operator|)
operator|)
operator|&&
operator|(
name|host_isr
operator|!=
name|AR_INTR_SPURIOUS
operator|)
condition|)
block|{
return|return
name|AH_TRUE
return|;
block|}
return|return
name|AH_FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Reads the Interrupt Status Register value from the NIC, thus deasserting  * the interrupt line, and returns both the masked and unmasked mapped ISR  * values.  The value returned is mapped to abstract the hw-specific bit  * locations in the Interrupt Status Register.  *  * Returns: A hardware-abstracted bitmap of all non-masked-out  *          interrupts pending, as well as an unmasked value  */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_CST
value|6
end_define

begin_comment
comment|/* Carrier sense timeout */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_GTT
value|6
end_define

begin_comment
comment|/* Global transmit timeout */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_TIM
value|3
end_define

begin_comment
comment|/* TIM */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_CABEND
value|0
end_define

begin_comment
comment|/* CABEND */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_DTIMSYNC
value|7
end_define

begin_comment
comment|/* DTIMSYNC */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_DTIM
value|7
end_define

begin_comment
comment|/* DTIM */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_TSFOOR
value|4
end_define

begin_comment
comment|/* Rx TSF out of range */
end_comment

begin_define
define|#
directive|define
name|MAP_ISR_S2_HAL_BBPANIC
value|6
end_define

begin_comment
comment|/* Panic watchdog IRQ from BB */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_get_pending_interrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
modifier|*
name|masked
parameter_list|,
name|HAL_INT_TYPE
name|type
parameter_list|,
name|u_int8_t
name|msi
parameter_list|,
name|HAL_BOOL
name|nortc
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_BOOL
name|ret_val
init|=
name|AH_TRUE
decl_stmt|;
name|u_int32_t
name|isr
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|mask2
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|sync_cause
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|async_cause
decl_stmt|;
name|u_int32_t
name|msi_pend_addr_mask
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|sync_en_def
init|=
name|AR9300_INTR_SYNC_DEFAULT
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
operator|*
name|masked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|nortc
condition|)
block|{
if|if
condition|(
name|HAL_INT_MSI
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|msi
operator|==
name|HAL_MSIVEC_RXHP
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
name|AR_ISR_HP_RXOK
argument_list|)
expr_stmt|;
operator|*
name|masked
operator|=
name|HAL_INT_RXHP
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|msi
operator|==
name|HAL_MSIVEC_RXLP
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
operator|(
name|AR_ISR_LP_RXOK
operator||
name|AR_ISR_RXMINTR
operator||
name|AR_ISR_RXINTM
operator|)
argument_list|)
expr_stmt|;
operator|*
name|masked
operator|=
name|HAL_INT_RXLP
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|msi
operator|==
name|HAL_MSIVEC_TX
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
name|AR_ISR_TXOK
argument_list|)
expr_stmt|;
operator|*
name|masked
operator|=
name|HAL_INT_TX
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|msi
operator|==
name|HAL_MSIVEC_MISC
condition|)
block|{
comment|/*                  * For the misc MSI event fall through and determine the cause.                  */
block|}
block|}
block|}
comment|/* Make sure mac interrupt is pending in async interrupt cause register */
name|async_cause
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_cause
operator|&
name|AR_INTR_ASYNC_USED
condition|)
block|{
comment|/*          * RTC may not be on since it runs on a slow 32khz clock          * so check its status to be sure          */
if|if
condition|(
operator|!
name|nortc
operator|&&
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RTC_STATUS
argument_list|)
operator|&
name|AR_RTC_STATUS_M
operator|)
operator|==
name|AR_RTC_STATUS_ON
condition|)
block|{
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9300_INTR_SYNC_DEF_NO_HOST1_PERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9340_INTR_SYNC_DEFAULT
expr_stmt|;
block|}
comment|/* Store away the async and sync cause registers */
comment|/* XXX Do this before the filtering done below */
ifdef|#
directive|ifdef
name|AH_INTERRUPT_DEBUGGING
name|ah
operator|->
name|ah_intrstate
index|[
literal|0
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|1
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|2
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|3
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|4
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S3
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|5
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S4
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ah_intrstate
index|[
literal|6
index|]
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S5
argument_list|)
expr_stmt|;
comment|/* XXX double reading? */
name|ah
operator|->
name|ah_syncstate
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sync_cause
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE
argument_list|)
argument_list|)
operator|&
operator|(
name|sync_en_def
operator||
name|AR_INTR_SYNC_MASK_GPIO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isr
operator|&&
operator|!
name|sync_cause
operator|&&
operator|!
name|async_cause
condition|)
block|{
name|ret_val
operator|=
name|AH_FALSE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: isr=0x%x, sync_cause=0x%x, async_cause=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|isr
argument_list|,
name|sync_cause
argument_list|,
name|async_cause
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
condition|)
block|{
if|if
condition|(
name|isr
operator|&
name|AR_ISR_BCNMISC
condition|)
block|{
name|u_int32_t
name|isr2
decl_stmt|;
name|isr2
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2
argument_list|)
expr_stmt|;
comment|/* Translate ISR bits to HAL values */
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_TIM
operator|)
operator|>>
name|MAP_ISR_S2_HAL_TIM
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_DTIM
operator|)
operator|>>
name|MAP_ISR_S2_HAL_DTIM
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_DTIMSYNC
operator|)
operator|>>
name|MAP_ISR_S2_HAL_DTIMSYNC
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_CABEND
operator|)
operator|>>
name|MAP_ISR_S2_HAL_CABEND
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_GTT
operator|)
operator|<<
name|MAP_ISR_S2_HAL_GTT
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_CST
operator|)
operator|<<
name|MAP_ISR_S2_HAL_CST
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_TSFOOR
operator|)
operator|>>
name|MAP_ISR_S2_HAL_TSFOOR
operator|)
expr_stmt|;
name|mask2
operator||=
operator|(
operator|(
name|isr2
operator|&
name|AR_ISR_S2_BBPANIC
operator|)
operator|>>
name|MAP_ISR_S2_HAL_BBPANIC
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
comment|/*                  * EV61133 (missing interrupts due to ISR_RAC):                  * If not using ISR_RAC, clear interrupts by writing to ISR_S2.                  * This avoids a race condition where a new BCNMISC interrupt                  * could come in between reading the ISR and clearing the                  * interrupt via the primary ISR.  We therefore clear the                  * interrupt via the secondary, which avoids this race.                  */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S2
argument_list|,
name|isr2
argument_list|)
expr_stmt|;
name|isr
operator|&=
operator|~
name|AR_ISR_BCNMISC
expr_stmt|;
block|}
block|}
comment|/* Use AR_ISR_RAC only if chip supports it.           * See EV61133 (missing interrupts due to ISR_RAC)           */
if|if
condition|(
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
name|isr
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_RAC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|==
literal|0xffffffff
condition|)
block|{
operator|*
name|masked
operator|=
literal|0
expr_stmt|;
name|ret_val
operator|=
name|AH_FALSE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
operator|*
name|masked
operator|=
name|isr
operator|&
name|HAL_INT_COMMON
expr_stmt|;
comment|/*          * When interrupt mitigation is switched on, we fake a normal RX or TX          * interrupt when we received a mitigated interrupt. This way, the upper          * layer do not need to know about feature.          */
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_rx
condition|)
block|{
comment|/* Only Rx interrupt mitigation. No Tx intr. mitigation. */
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_RXMINTR
operator||
name|AR_ISR_RXINTM
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_RXLP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_tx
condition|)
block|{
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_TXMINTR
operator||
name|AR_ISR_TXINTM
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_TX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_LP_RXOK
operator||
name|AR_ISR_RXERR
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_RXLP
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|AR_ISR_HP_RXOK
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_RXHP
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
operator|(
name|AR_ISR_TXOK
operator||
name|AR_ISR_TXERR
operator||
name|AR_ISR_TXEOL
operator|)
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_TX
expr_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
name|u_int32_t
name|s0
decl_stmt|,
name|s1
decl_stmt|;
comment|/*                  * EV61133 (missing interrupts due to ISR_RAC):                  * If not using ISR_RAC, clear interrupts by writing to                  * ISR_S0/S1.                  * This avoids a race condition where a new interrupt                  * could come in between reading the ISR and clearing the                  * interrupt via the primary ISR.  We therefore clear the                  * interrupt via the secondary, which avoids this race.                  */
name|s0
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S0
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|s1
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S1
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|isr
operator|&=
operator|~
operator|(
name|AR_ISR_TXOK
operator||
name|AR_ISR_TXERR
operator||
name|AR_ISR_TXEOL
operator|)
expr_stmt|;
block|}
block|}
comment|/*          * Do not treat receive overflows as fatal for owl.          */
if|if
condition|(
name|isr
operator|&
name|AR_ISR_RXORN
condition|)
block|{
if|#
directive|if
name|__PKT_SERIOUS_ERRORS__
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: receive FIFO overrun interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* XXX Verify if this is fixed for Osprey */
block|if (!p_cap->halAutoSleepSupport) {             u_int32_t isr5 = OS_REG_READ(ah, AR_ISR_S5_S);             if (isr5& AR_ISR_S5_TIM_TIMER) {                 *masked |= HAL_INT_TIM_TIMER;             }         }
endif|#
directive|endif
if|if
condition|(
name|isr
operator|&
name|AR_ISR_GENTMR
condition|)
block|{
name|u_int32_t
name|s5
decl_stmt|;
if|if
condition|(
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
comment|/* Use secondary shadow registers if using ISR_RAC */
name|s5
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S5_S
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s5
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|AR_ISR_GENTMR
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: GENTIMER, ISR_RAC=0x%x ISR_S2_S=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|isr
argument_list|,
name|s5
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intr_gen_timer_trigger
operator|=
name|MS
argument_list|(
name|s5
argument_list|,
name|AR_ISR_S5_GENTIMER_TRIG
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_intr_gen_timer_thresh
operator|=
name|MS
argument_list|(
name|s5
argument_list|,
name|AR_ISR_S5_GENTIMER_THRESH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_intr_gen_timer_trigger
condition|)
block|{
operator|*
name|masked
operator||=
name|HAL_INT_GENTIMER
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
comment|/*                  * EV61133 (missing interrupts due to ISR_RAC):                  * If not using ISR_RAC, clear interrupts by writing to ISR_S5.                  * This avoids a race condition where a new interrupt                  * could come in between reading the ISR and clearing the                  * interrupt via the primary ISR.  We therefore clear the                  * interrupt via the secondary, which avoids this race.                  */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR_S5
argument_list|,
name|s5
argument_list|)
expr_stmt|;
name|isr
operator|&=
operator|~
name|AR_ISR_GENTMR
expr_stmt|;
block|}
block|}
operator|*
name|masked
operator||=
name|mask2
expr_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halIsrRacSupport
condition|)
block|{
comment|/*              * EV61133 (missing interrupts due to ISR_RAC):              * If not using ISR_RAC, clear the interrupts we've read by              * writing back ones in these locations to the primary ISR              * (except for interrupts that have a secondary isr register -              * see above).              */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
comment|/* Flush prior write */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_ISR
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AH_SUPPORT_AR9300
if|if
condition|(
operator|*
name|masked
operator|&
name|HAL_INT_BBPANIC
condition|)
block|{
name|ar9300_handle_bb_panic
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|async_cause
condition|)
block|{
if|if
condition|(
name|nortc
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE_CLR
argument_list|)
argument_list|,
name|async_cause
argument_list|)
expr_stmt|;
comment|/* Flush prior write */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_CAUSE_CLR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ATH_GPIO_USE_ASYNC_CAUSE
if|if
condition|(
name|async_cause
operator|&
name|AR_INTR_ASYNC_CAUSE_GPIO
condition|)
block|{
name|ahp
operator|->
name|ah_gpio_cause
operator|=
operator|(
name|async_cause
operator|&
name|AR_INTR_ASYNC_CAUSE_GPIO
operator|)
operator|>>
name|AR_INTR_ASYNC_ENABLE_GPIO_S
expr_stmt|;
operator|*
name|masked
operator||=
name|HAL_INT_GPIO
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
operator|(
name|async_cause
operator|&
name|AR_INTR_ASYNC_CAUSE_MCI
operator|)
operator|&&
name|p_cap
operator|->
name|halMciSupport
condition|)
block|{
name|u_int32_t
name|int_raw
decl_stmt|,
name|int_rx_msg
decl_stmt|;
name|int_rx_msg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_RAW
argument_list|)
expr_stmt|;
name|int_raw
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int_raw
operator|==
literal|0xdeadbeef
operator|)
operator|||
operator|(
name|int_rx_msg
operator|==
literal|0xdeadbeef
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_BT_COEX
argument_list|,
literal|"(MCI) Get 0xdeadbeef during MCI int processing"
literal|"new int_raw=0x%08x, new rx_msg_raw=0x%08x, "
literal|"int_raw=0x%08x, rx_msg_raw=0x%08x\n"
argument_list|,
name|int_raw
argument_list|,
name|int_rx_msg
argument_list|,
name|ahp
operator|->
name|ah_mci_int_raw
argument_list|,
name|ahp
operator|->
name|ah_mci_int_rx_msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_mci_int_raw
operator|||
name|ahp
operator|->
name|ah_mci_int_rx_msg
condition|)
block|{
name|ahp
operator|->
name|ah_mci_int_rx_msg
operator||=
name|int_rx_msg
expr_stmt|;
name|ahp
operator|->
name|ah_mci_int_raw
operator||=
name|int_raw
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_mci_int_rx_msg
operator|=
name|int_rx_msg
expr_stmt|;
name|ahp
operator|->
name|ah_mci_int_raw
operator|=
name|int_raw
expr_stmt|;
block|}
operator|*
name|masked
operator||=
name|HAL_INT_MCI
expr_stmt|;
name|ahp
operator|->
name|ah_mci_rx_status
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCI_RX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_rx_msg
operator|&
name|AR_MCI_INTERRUPT_RX_MSG_CONT_INFO
condition|)
block|{
name|ahp
operator|->
name|ah_mci_cont_status
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MCI_CONT_STATUS
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RX_MSG_RAW
argument_list|,
name|int_rx_msg
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MCI_INTERRUPT_RAW
argument_list|,
name|int_raw
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s:AR_INTR_SYNC_MCI\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|sync_cause
condition|)
block|{
name|int
name|host1_fatal
decl_stmt|,
name|host1_perr
decl_stmt|,
name|radm_cpl_timeout
decl_stmt|,
name|local_timeout
decl_stmt|;
name|host1_fatal
operator|=
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|?
name|AR9340_INTR_SYNC_HOST1_FATAL
else|:
name|AR9300_INTR_SYNC_HOST1_FATAL
expr_stmt|;
name|host1_perr
operator|=
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|?
name|AR9340_INTR_SYNC_HOST1_PERR
else|:
name|AR9300_INTR_SYNC_HOST1_PERR
expr_stmt|;
name|radm_cpl_timeout
operator|=
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|?
literal|0x0
else|:
name|AR9300_INTR_SYNC_RADM_CPL_TIMEOUT
expr_stmt|;
name|local_timeout
operator|=
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|?
name|AR9340_INTR_SYNC_LOCAL_TIMEOUT
else|:
name|AR9300_INTR_SYNC_LOCAL_TIMEOUT
expr_stmt|;
if|if
condition|(
name|sync_cause
operator|&
name|host1_fatal
condition|)
block|{
if|#
directive|if
name|__PKT_SERIOUS_ERRORS__
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: received PCI FATAL interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
comment|/* Set FATAL INT flag here;*/
block|}
if|if
condition|(
name|sync_cause
operator|&
name|host1_perr
condition|)
block|{
if|#
directive|if
name|__PKT_SERIOUS_ERRORS__
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s: received PCI PERR interrupt\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sync_cause
operator|&
name|radm_cpl_timeout
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: AR_INTR_SYNC_RADM_CPL_TIMEOUT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|,
name|AR_RC_HOSTIF
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_RC
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|masked
operator||=
name|HAL_INT_FATAL
expr_stmt|;
block|}
if|if
condition|(
name|sync_cause
operator|&
name|local_timeout
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: AR_INTR_SYNC_LOCAL_TIMEOUT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ATH_GPIO_USE_ASYNC_CAUSE
if|if
condition|(
name|sync_cause
operator|&
name|AR_INTR_SYNC_MASK_GPIO
condition|)
block|{
name|ahp
operator|->
name|ah_gpio_cause
operator|=
operator|(
name|sync_cause
operator|&
name|AR_INTR_SYNC_MASK_GPIO
operator|)
operator|>>
name|AR_INTR_SYNC_ENABLE_GPIO_S
expr_stmt|;
operator|*
name|masked
operator||=
name|HAL_INT_GPIO
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: AR_INTR_SYNC_GPIO\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|)
argument_list|,
name|sync_cause
argument_list|)
expr_stmt|;
comment|/* Flush prior write */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_CAUSE_CLR
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|HAL_INT_MSI
operator|==
name|type
condition|)
block|{
comment|/*          * WAR for Bug EV#75887          * In normal case, SW read HOST_INTF_PCIE_MSI (0x40A4) and write          * into ah_msi_reg.  Then use value of ah_msi_reg to set bit#25          * when want to enable HW write the cfg_msi_pending.          * Sometimes, driver get MSI interrupt before read 0x40a4 and          * ah_msi_reg is initialization value (0x0).          * We don't know why "MSI interrupt earlier than driver read" now...          */
if|if
condition|(
operator|!
name|ahp
operator|->
name|ah_msi_reg
condition|)
block|{
name|ahp
operator|->
name|ah_msi_reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_MSI
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|msi_pend_addr_mask
operator|=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64
expr_stmt|;
block|}
else|else
block|{
name|msi_pend_addr_mask
operator|=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_MSI
argument_list|)
argument_list|,
operator|(
operator|(
name|ahp
operator|->
name|ah_msi_reg
operator||
name|AR_PCIE_MSI_ENABLE
operator|)
operator|&
name|msi_pend_addr_mask
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|HAL_INT
name|ar9300_get_interrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_mask_reg
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically enables NIC interrupts.  Interrupts are passed in  * via the enumerated bitmask in ints.  */
end_comment

begin_function
name|HAL_INT
name|ar9300_set_interrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT
name|ints
parameter_list|,
name|HAL_BOOL
name|nortc
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|omask
init|=
name|ahp
operator|->
name|ah_mask_reg
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|,
name|mask2
decl_stmt|,
name|msi_mask
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|msi_pend_addr_mask
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|sync_en_def
init|=
name|AR9300_INTR_SYNC_DEFAULT
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: 0x%x => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|omask
argument_list|,
name|ints
argument_list|)
expr_stmt|;
if|if
condition|(
name|omask
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: disable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_config
operator|.
name|ath_hal_enable_msi
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush write to HW */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nortc
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_DISABLE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
expr_stmt|;
comment|/* flush write to HW */
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush write to HW */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush write to HW */
operator|(
name|void
operator|)
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nortc
condition|)
block|{
comment|/* reference count for global IER */
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GLOBAL
condition|)
block|{
ifdef|#
directive|ifdef
name|AH_DEBUG
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: Request HAL_INT_GLOBAL ENABLED\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (OS_ATOMIC_READ(&ahp->ah_ier_ref_count) == 0) {                 HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,                     "%s: WARNING: ah_ier_ref_count is 0 "                     "and attempting to enable IER\n",                     __func__);             }
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (OS_ATOMIC_READ(&ahp->ah_ier_ref_count)> 0) {                 OS_ATOMIC_DEC(&ahp->ah_ier_ref_count);             }
endif|#
directive|endif
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: Request HAL_INT_GLOBAL DISABLED\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|OS_ATOMIC_INC
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ier_ref_count
argument_list|)
expr_stmt|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: ah_ier_ref_count = %d\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_ier_ref_count
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ints
operator|&
name|HAL_INT_COMMON
expr_stmt|;
name|mask2
operator|=
literal|0
expr_stmt|;
name|msi_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TX
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_tx
condition|)
block|{
name|mask
operator||=
name|AR_IMR_TXMINTR
operator||
name|AR_IMR_TXINTM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
condition|)
block|{
name|mask
operator||=
name|AR_IMR_TXOK
expr_stmt|;
block|}
name|msi_mask
operator||=
name|AR_INTR_PRIO_TX
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
condition|)
block|{
name|mask
operator||=
name|AR_IMR_TXERR
expr_stmt|;
block|}
if|if
condition|(
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
condition|)
block|{
name|mask
operator||=
name|AR_IMR_TXEOL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_RX
condition|)
block|{
name|mask
operator||=
name|AR_IMR_RXERR
operator||
name|AR_IMR_RXOK_HP
expr_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_intr_mitigation_rx
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
name|AR_IMR_RXOK_LP
operator|)
expr_stmt|;
name|mask
operator||=
name|AR_IMR_RXMINTR
operator||
name|AR_IMR_RXINTM
expr_stmt|;
block|}
else|else
block|{
name|mask
operator||=
name|AR_IMR_RXOK_LP
expr_stmt|;
block|}
name|msi_mask
operator||=
name|AR_INTR_PRIO_RXLP
operator||
name|AR_INTR_PRIO_RXHP
expr_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halAutoSleepSupport
condition|)
block|{
name|mask
operator||=
name|AR_IMR_GENTMR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ints
operator|&
operator|(
name|HAL_INT_BMISC
operator|)
condition|)
block|{
name|mask
operator||=
name|AR_IMR_BCNMISC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TIM
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_TIM
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIM
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_DTIM
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_DTIMSYNC
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_DTIMSYNC
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_CABEND
condition|)
block|{
name|mask2
operator||=
operator|(
name|AR_IMR_S2_CABEND
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TSFOOR
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_TSFOOR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ints
operator|&
operator|(
name|HAL_INT_GTT
operator||
name|HAL_INT_CST
operator|)
condition|)
block|{
name|mask
operator||=
name|AR_IMR_BCNMISC
expr_stmt|;
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GTT
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_GTT
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_CST
condition|)
block|{
name|mask2
operator||=
name|AR_IMR_S2_CST
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_BBPANIC
condition|)
block|{
comment|/* EV92527 - MAC secondary interrupt must enable AR_IMR_BCNMISC */
name|mask
operator||=
name|AR_IMR_BCNMISC
expr_stmt|;
name|mask2
operator||=
name|AR_IMR_S2_BBPANIC
expr_stmt|;
block|}
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GENTIMER
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: enabling gen timer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mask
operator||=
name|AR_IMR_GENTMR
expr_stmt|;
block|}
comment|/* Write the new IMR and store off our SW copy. */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: new IMR 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_mask2Reg
operator|&=
operator|~
operator|(
name|AR_IMR_S2_TIM
operator||
name|AR_IMR_S2_DTIM
operator||
name|AR_IMR_S2_DTIMSYNC
operator||
name|AR_IMR_S2_CABEND
operator||
name|AR_IMR_S2_CABTO
operator||
name|AR_IMR_S2_TSFOOR
operator||
name|AR_IMR_S2_GTT
operator||
name|AR_IMR_S2_CST
operator||
name|AR_IMR_S2_BBPANIC
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_mask2Reg
operator||=
name|mask2
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|ahp
operator|->
name|ah_mask2Reg
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_mask_reg
operator|=
name|ints
expr_stmt|;
if|if
condition|(
operator|!
name|p_cap
operator|->
name|halAutoSleepSupport
condition|)
block|{
if|if
condition|(
name|ints
operator|&
name|HAL_INT_TIM_TIMER
condition|)
block|{
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S5
argument_list|,
name|AR_IMR_S5_TIM_TIMER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S5
argument_list|,
name|AR_IMR_S5_TIM_TIMER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Re-enable interrupts if they were enabled before. */
if|#
directive|if
name|HAL_INTR_REFCOUNT_DISABLE
if|if
condition|(
operator|(
name|ints
operator|&
name|HAL_INT_GLOBAL
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|ints
operator|&
name|HAL_INT_GLOBAL
operator|)
operator|&&
operator|(
name|OS_ATOMIC_READ
argument_list|(
operator|&
name|ahp
operator|->
name|ah_ier_ref_count
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
endif|#
directive|endif
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: enable IER\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nortc
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|,
name|AR_IER_ENABLE
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|AR_INTR_MAC_IRQ
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_GPIO_USE_ASYNC_CAUSE
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GPIO
condition|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_gpio_mask
condition|)
block|{
name|mask
operator||=
name|SM
argument_list|(
name|ahp
operator|->
name|ah_gpio_mask
argument_list|,
name|AR_INTR_ASYNC_MASK_GPIO
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|ATH_SUPPORT_MCI
if|if
condition|(
name|ints
operator|&
name|HAL_INT_MCI
condition|)
block|{
name|mask
operator||=
name|AR_INTR_ASYNC_MASK_MCI
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_ENABLE
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_ASYNC_MASK
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_config
operator|.
name|ath_hal_enable_msi
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_ENABLE
argument_list|)
argument_list|,
name|msi_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_PRIO_ASYNC_MASK
argument_list|)
argument_list|,
name|msi_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|msi_pend_addr_mask
operator|=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64
expr_stmt|;
block|}
else|else
block|{
name|msi_pend_addr_mask
operator|=
name|AR_PCIE_MSI_HW_INT_PENDING_ADDR
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_PCIE_MSI
argument_list|)
argument_list|,
operator|(
operator|(
name|ahp
operator|->
name|ah_msi_reg
operator||
name|AR_PCIE_MSI_ENABLE
operator|)
operator|&
name|msi_pend_addr_mask
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*          * debug - enable to see all synchronous interrupts status          * Enable synchronous GPIO interrupts as well, since some async          * GPIO interrupts don't wake the chip up.          */
name|mask
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|ATH_GPIO_USE_ASYNC_CAUSE
if|if
condition|(
name|ints
operator|&
name|HAL_INT_GPIO
condition|)
block|{
name|mask
operator||=
name|SM
argument_list|(
name|ahp
operator|->
name|ah_gpio_mask
argument_list|,
name|AR_INTR_SYNC_MASK_GPIO
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|AR_SREV_POSEIDON
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9300_INTR_SYNC_DEF_NO_HOST1_PERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|sync_en_def
operator|=
name|AR9340_INTR_SYNC_DEFAULT
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_ENABLE
argument_list|)
argument_list|,
operator|(
name|sync_en_def
operator||
name|mask
operator|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_HOSTIF_REG
argument_list|(
name|ah
argument_list|,
name|AR_INTR_SYNC_MASK
argument_list|)
argument_list|,
operator|(
name|sync_en_def
operator||
name|mask
operator|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"AR_IMR 0x%x IER 0x%x\n"
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IER
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|omask
return|;
block|}
name|void
name|ar9300_set_intr_mitigation_timer
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT_MITIGATION
name|reg
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|HAL_INT_THRESHOLD
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_MIRT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_INT_RX_LASTPKT
case|:
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_LAST
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_INT_RX_FIRSTPKT
case|:
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|,
name|AR_RIMT_FIRST
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_INT_TX_LASTPKT
case|:
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|,
name|AR_TIMT_LAST
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_INT_TX_FIRSTPKT
case|:
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|,
name|AR_TIMT_FIRST
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
name|u_int32_t
name|ar9300_get_intr_mitigation_timer
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_INT_MITIGATION
name|reg
parameter_list|)
block|{
name|u_int32_t
name|val
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|AR5416_INT_MITIGATION
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|HAL_INT_THRESHOLD
case|:
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_MIRT
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_INT_RX_LASTPKT
case|:
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|HAL_INT_RX_FIRSTPKT
case|:
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_RIMT
argument_list|)
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|HAL_INT_TX_LASTPKT
case|:
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|HAL_INT_TX_FIRSTPKT
case|:
name|val
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TIMT
argument_list|)
operator|>>
literal|16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
return|return
name|val
return|;
block|}
end_function

end_unit

