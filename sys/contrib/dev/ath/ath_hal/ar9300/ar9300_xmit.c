begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Qualcomm Atheros, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR  * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"ah.h"
end_include

begin_include
include|#
directive|include
file|"ah_desc.h"
end_include

begin_include
include|#
directive|include
file|"ah_internal.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300reg.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300phy.h"
end_include

begin_include
include|#
directive|include
file|"ar9300/ar9300desc.h"
end_include

begin_define
define|#
directive|define
name|TU_TO_USEC
parameter_list|(
name|_tu
parameter_list|)
value|((_tu)<< 10)
end_define

begin_define
define|#
directive|define
name|ONE_EIGHTH_TU_TO_USEC
parameter_list|(
name|_tu8
parameter_list|)
value|((_tu8)<< 7)
end_define

begin_comment
comment|/*  * Update Tx FIFO trigger level.  *  * Set b_inc_trig_level to TRUE to increase the trigger level.  * Set b_inc_trig_level to FALSE to decrease the trigger level.  *  * Returns TRUE if the trigger level was updated  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_update_tx_trig_level
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_BOOL
name|b_inc_trig_level
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|u_int32_t
name|txcfg
decl_stmt|,
name|cur_level
decl_stmt|,
name|new_level
decl_stmt|;
name|HAL_INT
name|omask
decl_stmt|;
if|if
condition|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_trig_level
operator|>=
name|MAX_TX_FIFO_THRESHOLD
operator|&&
name|b_inc_trig_level
condition|)
block|{
return|return
name|AH_FALSE
return|;
block|}
comment|/*      * Disable interrupts while futzing with the fifo level.      */
name|omask
operator|=
name|ar9300_set_interrupts
argument_list|(
name|ah
argument_list|,
name|ahp
operator|->
name|ah_mask_reg
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|txcfg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|)
expr_stmt|;
name|cur_level
operator|=
name|MS
argument_list|(
name|txcfg
argument_list|,
name|AR_FTRIG
argument_list|)
expr_stmt|;
name|new_level
operator|=
name|cur_level
expr_stmt|;
if|if
condition|(
name|b_inc_trig_level
condition|)
block|{
comment|/* increase the trigger level */
if|if
condition|(
name|cur_level
operator|<
name|MAX_TX_FIFO_THRESHOLD
condition|)
block|{
name|new_level
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cur_level
operator|>
name|MIN_TX_FIFO_THRESHOLD
condition|)
block|{
name|new_level
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|new_level
operator|!=
name|cur_level
condition|)
block|{
comment|/* Update the trigger level */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_TXCFG
argument_list|,
operator|(
name|txcfg
operator|&
operator|~
name|AR_FTRIG
operator|)
operator||
name|SM
argument_list|(
name|new_level
argument_list|,
name|AR_FTRIG
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* re-enable chip interrupts */
name|ar9300_set_interrupts
argument_list|(
name|ah
argument_list|,
name|omask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_trig_level
operator|=
name|new_level
expr_stmt|;
return|return
operator|(
name|new_level
operator|!=
name|cur_level
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the value of Tx Trigger Level  */
end_comment

begin_function
name|u_int16_t
name|ar9300_get_tx_trig_level
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
return|return
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_tx_trig_level
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the properties of the tx queue with the parameters  * from q_info.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_tx_queue_props
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|q
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|q_info
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|p_cap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|ath_hal_setTxQProps
argument_list|(
name|ah
argument_list|,
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
argument_list|,
name|q_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the properties for the specified tx queue.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_get_tx_queue_props
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|q
parameter_list|,
name|HAL_TXQ_INFO
modifier|*
name|q_info
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|p_cap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
return|return
name|ath_hal_getTxQProps
argument_list|(
name|ah
argument_list|,
name|q_info
argument_list|,
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
argument_list|)
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|AH_TX_QUEUE_MINUS_OFFSET_BEACON
init|=
literal|1
block|,
name|AH_TX_QUEUE_MINUS_OFFSET_CAB
init|=
literal|2
block|,
name|AH_TX_QUEUE_MINUS_OFFSET_UAPSD
init|=
literal|3
block|,
name|AH_TX_QUEUE_MINUS_OFFSET_PAPRD
init|=
literal|4
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Allocate and initialize a tx DCU/QCU combination.  */
end_comment

begin_function
name|int
name|ar9300_setup_tx_queue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE
name|type
parameter_list|,
specifier|const
name|HAL_TXQ_INFO
modifier|*
name|q_info
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|int
name|q
decl_stmt|;
comment|/* XXX move queue assignment to driver */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HAL_TX_QUEUE_BEACON
case|:
comment|/* highest priority */
name|q
operator|=
name|p_cap
operator|->
name|halTotalQueues
operator|-
name|AH_TX_QUEUE_MINUS_OFFSET_BEACON
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_CAB
case|:
comment|/* next highest priority */
name|q
operator|=
name|p_cap
operator|->
name|halTotalQueues
operator|-
name|AH_TX_QUEUE_MINUS_OFFSET_CAB
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_UAPSD
case|:
name|q
operator|=
name|p_cap
operator|->
name|halTotalQueues
operator|-
name|AH_TX_QUEUE_MINUS_OFFSET_UAPSD
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_PAPRD
case|:
name|q
operator|=
name|p_cap
operator|->
name|halTotalQueues
operator|-
name|AH_TX_QUEUE_MINUS_OFFSET_PAPRD
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_DATA
case|:
comment|/*          * don't infringe on top 4 queues, reserved for:          * beacon, CAB, UAPSD, PAPRD          */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|p_cap
operator|->
name|halTotalQueues
operator|-
name|AH_TX_QUEUE_MINUS_OFFSET_PAPRD
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|==
name|p_cap
operator|->
name|halTotalQueues
operator|-
literal|3
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: no available tx queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: bad tx queue type %u\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: tx queue %u already active\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|OS_MEMZERO
argument_list|(
name|qi
argument_list|,
sizeof|sizeof
argument_list|(
name|HAL_TX_QUEUE_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|->
name|tqi_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|q_info
operator|==
name|AH_NULL
condition|)
block|{
comment|/* by default enable OK+ERR+DESC+URN interrupts */
name|qi
operator|->
name|tqi_qflags
operator|=
name|HAL_TXQ_TXOKINT_ENABLE
operator||
name|HAL_TXQ_TXERRINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
operator||
name|HAL_TXQ_TXURNINT_ENABLE
expr_stmt|;
name|qi
operator|->
name|tqi_aifs
operator|=
name|INIT_AIFS
expr_stmt|;
name|qi
operator|->
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: do at reset */
name|qi
operator|->
name|tqi_cwmax
operator|=
name|INIT_CWMAX
expr_stmt|;
name|qi
operator|->
name|tqi_shretry
operator|=
name|INIT_SH_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_lgretry
operator|=
name|INIT_LG_RETRY
expr_stmt|;
name|qi
operator|->
name|tqi_physCompBuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qi
operator|->
name|tqi_physCompBuf
operator|=
name|q_info
operator|->
name|tqi_compBuf
expr_stmt|;
operator|(
name|void
operator|)
name|ar9300_set_tx_queue_props
argument_list|(
name|ah
argument_list|,
name|q
argument_list|,
name|q_info
argument_list|)
expr_stmt|;
block|}
comment|/* NB: must be followed by ar9300_reset_tx_queue */
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Update the h/w interrupt registers to reflect a tx q's configuration.  */
end_comment

begin_function
specifier|static
name|void
name|set_tx_q_interrupts
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_INTERRUPT
argument_list|,
literal|"%s: tx ok 0x%x err 0x%x eol 0x%x urn 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
argument_list|,
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
argument_list|,
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
argument_list|,
name|ahp
operator|->
name|ah_tx_urn_interrupt_mask
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S0
argument_list|,
name|SM
argument_list|(
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
argument_list|,
name|AR_IMR_S0_QCU_TXOK
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S1
argument_list|,
name|SM
argument_list|(
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
argument_list|,
name|AR_IMR_S1_QCU_TXERR
argument_list|)
operator||
name|SM
argument_list|(
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
argument_list|,
name|AR_IMR_S1_QCU_TXEOL
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_RMW_FIELD
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|,
name|AR_IMR_S2_QCU_TXURN
argument_list|,
name|ahp
operator|->
name|ah_tx_urn_interrupt_mask
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_mask2Reg
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_IMR_S2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a tx DCU/QCU combination.  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_release_tx_queue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|p_cap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: inactive queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: release queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qi
operator|->
name|tqi_type
operator|=
name|HAL_TX_QUEUE_INACTIVE
expr_stmt|;
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|ahp
operator|->
name|ah_tx_urn_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
name|set_tx_q_interrupts
argument_list|(
name|ah
argument_list|,
name|qi
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Set the retry, aifs, cwmin/max, ready_time regs for specified queue  * Assumes:  *  phw_channel has been set to point to the current channel  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_reset_tx_queue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|//    struct ath_hal_private  *ap   = AH_PRIVATE(ah);
name|HAL_CAPABILITIES
modifier|*
name|p_cap
init|=
operator|&
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_curchan
decl_stmt|;
name|HAL_TX_QUEUE_INFO
modifier|*
name|qi
decl_stmt|;
name|u_int32_t
name|cw_min
decl_stmt|,
name|chan_cw_min
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|p_cap
operator|->
name|halTotalQueues
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: invalid queue num %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_FALSE
return|;
block|}
name|qi
operator|=
operator|&
name|ahp
operator|->
name|ah_txq
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_type
operator|==
name|HAL_TX_QUEUE_INACTIVE
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: inactive queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
comment|/* XXX??? */
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: reset queue %u\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_cwmin
operator|==
name|HAL_TXQ_USEDEFAULT
condition|)
block|{
comment|/*          * Select cwmin according to channel type.          * NB: chan can be NULL during attach          */
if|if
condition|(
name|chan
operator|&&
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|chan_cw_min
operator|=
name|INIT_CWMIN_11B
expr_stmt|;
block|}
else|else
block|{
name|chan_cw_min
operator|=
name|INIT_CWMIN
expr_stmt|;
block|}
comment|/* make sure that the CWmin is of the form (2^n - 1) */
for|for
control|(
name|cw_min
operator|=
literal|1
init|;
name|cw_min
operator|<
name|chan_cw_min
condition|;
name|cw_min
operator|=
operator|(
name|cw_min
operator|<<
literal|1
operator|)
operator||
literal|1
control|)
block|{}
block|}
else|else
block|{
name|cw_min
operator|=
name|qi
operator|->
name|tqi_cwmin
expr_stmt|;
block|}
comment|/* set cw_min/Max and AIFS values */
if|if
condition|(
name|q
operator|>
literal|3
operator|||
operator|(
operator|!
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_fccaifs
operator|)
condition|)
comment|/* values should not be overwritten if domain is FCC and manual rate           less than 24Mb is set, this check  is making sure this */
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|cw_min
argument_list|,
name|AR_D_LCL_IFS_CWMIN
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cwmax
argument_list|,
name|AR_D_LCL_IFS_CWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_aifs
argument_list|,
name|AR_D_LCL_IFS_AIFS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set retry limit values */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DRETRY_LIMIT
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|INIT_SSH_RETRY
argument_list|,
name|AR_D_RETRY_LIMIT_STA_SH
argument_list|)
operator||
name|SM
argument_list|(
name|INIT_SLG_RETRY
argument_list|,
name|AR_D_RETRY_LIMIT_STA_LG
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_shretry
argument_list|,
name|AR_D_RETRY_LIMIT_FR_SH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable early termination on the QCU */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|AR_Q_MISC_DCU_EARLY_TERM_REQ
argument_list|)
expr_stmt|;
comment|/* enable DCU to wait for next fragment from QCU  */
if|if
condition|(
name|AR_SREV_WASP
argument_list|(
name|ah
argument_list|)
operator|&&
operator|(
name|AH_PRIVATE
argument_list|(
operator|(
name|ah
operator|)
argument_list|)
operator|->
name|ah_macRev
operator|<=
name|AR_SREV_REVISION_WASP_12
operator|)
condition|)
block|{
comment|/* WAR for EV#85395: Wasp Rx overrun issue - reduces Tx queue backoff           * threshold to 1 to avoid Rx overruns - Fixed in Wasp 1.3 */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|AR_D_MISC_CW_BKOFF_EN
operator||
name|AR_D_MISC_FRAG_WAIT_EN
operator||
literal|0x1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|AR_D_MISC_CW_BKOFF_EN
operator||
name|AR_D_MISC_FRAG_WAIT_EN
operator||
literal|0x2
argument_list|)
expr_stmt|;
block|}
comment|/* multiqueue support */
if|if
condition|(
name|qi
operator|->
name|tqi_cbrPeriod
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QCBRCFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cbrPeriod
argument_list|,
name|AR_Q_CBRCFG_INTERVAL
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_cbrOverflowLimit
argument_list|,
name|AR_Q_CBRCFG_OVF_THRESH
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_Q_MISC_FSP_CBR
operator||
operator|(
name|qi
operator|->
name|tqi_cbrOverflowLimit
condition|?
name|AR_Q_MISC_CBR_EXP_CNTR_LIMIT_EN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_readyTime
operator|&&
operator|(
name|qi
operator|->
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_CAB
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_readyTime
argument_list|,
name|AR_Q_RDYTIMECFG_DURATION
argument_list|)
operator||
name|AR_Q_RDYTIMECFG_EN
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DCHNTIME
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
name|qi
operator|->
name|tqi_burstTime
argument_list|,
name|AR_D_CHNTIME_DUR
argument_list|)
operator||
operator|(
name|qi
operator|->
name|tqi_burstTime
condition|?
name|AR_D_CHNTIME_EN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|tqi_burstTime
operator|&&
operator|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_RDYTIME_EXP_POLICY_ENABLE
operator|)
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_Q_MISC_RDYTIME_EXP_POLICY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_BACKOFF_DISABLE
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_D_MISC_POST_FR_BKOFF_DIS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_FRAG_BURST_BACKOFF_ENABLE
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_D_MISC_FRAG_BKOFF_EN
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|qi
operator|->
name|tqi_type
condition|)
block|{
case|case
name|HAL_TX_QUEUE_BEACON
case|:
comment|/* beacon frames */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_Q_MISC_FSP_DBA_GATED
operator||
name|AR_Q_MISC_BEACON_USE
operator||
name|AR_Q_MISC_CBR_INCR_DIS1
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
operator|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
operator|<<
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_S
operator|)
operator||
name|AR_D_MISC_BEACON_USE
operator||
name|AR_D_MISC_POST_FR_BKOFF_DIS
argument_list|)
expr_stmt|;
comment|/* XXX cwmin and cwmax should be 0 for beacon queue */
if|if
condition|(
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_opmode
operator|!=
name|HAL_M_IBSS
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DLCL_IFS
argument_list|(
name|q
argument_list|)
argument_list|,
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_D_LCL_IFS_CWMIN
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|AR_D_LCL_IFS_CWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|qi
operator|->
name|tqi_aifs
argument_list|,
name|AR_D_LCL_IFS_AIFS
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HAL_TX_QUEUE_CAB
case|:
comment|/* CAB  frames */
comment|/*          * No longer Enable AR_Q_MISC_RDYTIME_EXP_POLICY,          * bug #6079.  There is an issue with the CAB Queue          * not properly refreshing the Tx descriptor if          * the TXE clear setting is used.          */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_Q_MISC_FSP_DBA_GATED
operator||
name|AR_Q_MISC_CBR_INCR_DIS1
operator||
name|AR_Q_MISC_CBR_INCR_DIS0
argument_list|)
expr_stmt|;
name|value
operator|=
name|TU_TO_USEC
argument_list|(
name|qi
operator|->
name|tqi_readyTime
argument_list|)
operator|-
operator|(
name|ah
operator|->
name|ah_config
operator|.
name|ah_sw_beacon_response_time
operator|-
name|ah
operator|->
name|ah_config
operator|.
name|ah_dma_beacon_response_time
operator|)
operator|-
name|ah
operator|->
name|ah_config
operator|.
name|ah_additional_swba_backoff
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|,
name|value
operator||
name|AR_Q_RDYTIMECFG_EN
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
operator|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
operator|<<
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_S
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_PSPOLL
case|:
comment|/*          * We may configure ps_poll QCU to be TIM-gated in the          * future; TIM_GATED bit is not enabled currently because          * of a hardware problem in Oahu that overshoots the TIM          * bitmap in beacon and may find matching associd bit in          * non-TIM elements and send PS-poll PS poll processing          * will be done in software          */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_Q_MISC_CBR_INCR_DIS1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HAL_TX_QUEUE_UAPSD
case|:
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|AR_D_MISC_POST_FR_BKOFF_DIS
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* NB: silence compiler */
break|break;
block|}
ifndef|#
directive|ifndef
name|AH_DISABLE_WME
comment|/*      * Yes, this is a hack and not the right way to do it, but      * it does get the lockout bits and backoff set for the      * high-pri WME queues for testing.  We need to either extend      * the meaning of queue_info->mode, or create something like      * queue_info->dcumode.      */
if|if
condition|(
name|qi
operator|->
name|tqi_intFlags
operator|&
name|HAL_TXQ_USE_LOCKOUT_BKOFF_DIS
condition|)
block|{
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_DMISC
argument_list|(
name|q
argument_list|)
argument_list|)
operator||
name|SM
argument_list|(
name|AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL
argument_list|,
name|AR_D_MISC_ARB_LOCKOUT_CNTRL
argument_list|)
operator||
name|AR_D_MISC_POST_FR_BKOFF_DIS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_DESC_CRCCHK
argument_list|,
name|AR_Q_DESC_CRCCHK_EN
argument_list|)
expr_stmt|;
comment|/*      * Always update the secondary interrupt mask registers - this      * could be a new queue getting enabled in a running system or      * hw getting re-initialized during a reset!      *      * Since we don't differentiate between tx interrupts corresponding      * to individual queues - secondary tx mask regs are always unmasked;      * tx interrupts are enabled/disabled for all queues collectively      * using the primary mask reg      */
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXOKINT_ENABLE
condition|)
block|{
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
operator||=
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_tx_ok_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXERRINT_ENABLE
condition|)
block|{
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
operator||=
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_tx_err_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXEOLINT_ENABLE
condition|)
block|{
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
operator||=
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_tx_eol_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|qi
operator|->
name|tqi_qflags
operator|&
name|HAL_TXQ_TXURNINT_ENABLE
condition|)
block|{
name|ahp
operator|->
name|ah_tx_urn_interrupt_mask
operator||=
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ahp
operator|->
name|ah_tx_urn_interrupt_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|q
operator|)
expr_stmt|;
block|}
name|set_tx_q_interrupts
argument_list|(
name|ah
argument_list|,
name|qi
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get the TXDP for the specified queue  */
end_comment

begin_function
name|u_int32_t
name|ar9300_get_tx_dp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
return|return
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QTXDP
argument_list|(
name|q
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the tx_dp for the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_set_tx_dp
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int32_t
name|txdp
parameter_list|)
block|{
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|txdp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QTXDP
argument_list|(
name|q
argument_list|)
argument_list|,
name|txdp
argument_list|)
expr_stmt|;
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit Enable is read-only now  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_start_tx_dma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
return|return
name|AH_TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of pending frames or 0 if the specified  * queue is stopped.  */
end_comment

begin_function
name|u_int32_t
name|ar9300_num_tx_pending
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|u_int32_t
name|npend
decl_stmt|;
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|halTotalQueues
argument_list|)
expr_stmt|;
name|npend
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QSTS
argument_list|(
name|q
argument_list|)
argument_list|)
operator|&
name|AR_Q_STS_PEND_FR_CNT
expr_stmt|;
if|if
condition|(
name|npend
operator|==
literal|0
condition|)
block|{
comment|/*          * Pending frame count (PFC) can momentarily go to zero          * while TXE remains asserted.  In other words a PFC of          * zero is not sufficient to say that the queue has stopped.          */
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|q
operator|)
condition|)
block|{
name|npend
operator|=
literal|1
expr_stmt|;
comment|/* arbitrarily return 1 */
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|npend
operator|&&
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|==
name|HAL_TX_QUEUE_CAB
operator|)
condition|)
block|{
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_RDYTIMESHDN
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|q
operator|)
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"RTSD on CAB queue\n"
argument_list|)
expr_stmt|;
comment|/* Clear the ready_time shutdown status bits */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_RDYTIMESHDN
argument_list|,
literal|1
operator|<<
name|q
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|HALASSERT
argument_list|(
operator|(
name|npend
operator|==
literal|0
operator|)
operator|||
operator|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
operator|)
argument_list|)
expr_stmt|;
return|return
name|npend
return|;
block|}
end_function

begin_comment
comment|/*  * Stop transmit on the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_stop_tx_dma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
name|timeout
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
comment|/*      * If we call abort txdma instead, no need to stop RX.      * Otherwise, the RX logic might not be restarted properly.      */
name|ahp
operator|->
name|ah_abort_txdma_norx
operator|=
name|AH_FALSE
expr_stmt|;
comment|/*      * Directly call abort.  It is better, hardware-wise, to stop all      * queues at once than individual ones.      */
return|return
name|ar9300_abort_tx_dma
argument_list|(
name|ah
argument_list|)
return|;
if|#
directive|if
literal|0
define|#
directive|define
name|AH_TX_STOP_DMA_TIMEOUT
value|4000
comment|/* usec */
define|#
directive|define
name|AH_TIME_QUANTUM
value|100
comment|/* usec */
block|u_int wait;      HALASSERT(q< AH_PRIVATE(ah)->ah_caps.hal_total_queues);      HALASSERT(AH9300(ah)->ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);      if (timeout == 0) {         timeout = AH_TX_STOP_DMA_TIMEOUT;     }      OS_REG_WRITE(ah, AR_Q_TXD, 1<< q);      for (wait = timeout / AH_TIME_QUANTUM; wait != 0; wait--) {         if (ar9300_num_tx_pending(ah, q) == 0) {             break;         }         OS_DELAY(AH_TIME_QUANTUM);
comment|/* XXX get actual value */
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
block|if (wait == 0) {         HALDEBUG(ah, HAL_DEBUG_QUEUE,             "%s: queue %u DMA did not stop in 100 msec\n", __func__, q);         HALDEBUG(ah, HAL_DEBUG_QUEUE,             "%s: QSTS 0x%x Q_TXE 0x%x Q_TXD 0x%x Q_CBR 0x%x\n",             __func__,             OS_REG_READ(ah, AR_QSTS(q)),             OS_REG_READ(ah, AR_Q_TXE),             OS_REG_READ(ah, AR_Q_TXD),             OS_REG_READ(ah, AR_QCBRCFG(q)));         HALDEBUG(ah, HAL_DEBUG_QUEUE,             "%s: Q_MISC 0x%x Q_RDYTIMECFG 0x%x Q_RDYTIMESHDN 0x%x\n",             __func__,             OS_REG_READ(ah, AR_QMISC(q)),             OS_REG_READ(ah, AR_QRDYTIMECFG(q)),             OS_REG_READ(ah, AR_Q_RDYTIMESHDN));     }
endif|#
directive|endif
comment|/* AH_DEBUG */
comment|/* 2413+ and up can kill packets at the PCU level */
block|if (ar9300_num_tx_pending(ah, q)) {         u_int32_t tsf_low, j;          HALDEBUG(ah, HAL_DEBUG_QUEUE, "%s: Num of pending TX Frames %d on Q %d\n",                  __func__, ar9300_num_tx_pending(ah, q), q);
comment|/* Kill last PCU Tx Frame */
comment|/* TODO - save off and restore current values of Q1/Q2? */
block|for (j = 0; j< 2; j++) {             tsf_low = OS_REG_READ(ah, AR_TSF_L32);             OS_REG_WRITE(ah, AR_QUIET2, SM(10, AR_QUIET2_QUIET_DUR));             OS_REG_WRITE(ah, AR_QUIET_PERIOD, 100);             OS_REG_WRITE(ah, AR_NEXT_QUIET_TIMER, tsf_low>> 10);             OS_REG_SET_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);              if ((OS_REG_READ(ah, AR_TSF_L32)>> 10) == (tsf_low>> 10)) {                 break;             }              HALDEBUG(ah, HAL_DEBUG_QUEUE,                 "%s: TSF have moved while trying to set "                 "quiet time TSF: 0x%08x\n",                 __func__, tsf_low);
comment|/* TSF shouldn't count twice or reg access is taking forever */
block|HALASSERT(j< 1);         }          OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);
comment|/* Allow the quiet mechanism to do its work */
block|OS_DELAY(200);         OS_REG_CLR_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);
comment|/* Verify all transmit is dead */
block|wait = timeout / AH_TIME_QUANTUM;         while (ar9300_num_tx_pending(ah, q)) {             if ((--wait) == 0) {                 HALDEBUG(ah, HAL_DEBUG_TX,                     "%s: Failed to stop Tx DMA in %d msec "                     "after killing last frame\n",                     __func__, timeout / 1000);                 break;             }             OS_DELAY(AH_TIME_QUANTUM);         }          OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);     }      OS_REG_WRITE(ah, AR_Q_TXD, 0);     return (wait != 0);
undef|#
directive|undef
name|AH_TX_STOP_DMA_TIMEOUT
undef|#
directive|undef
name|AH_TIME_QUANTUM
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Really Stop transmit on the specified queue  */
end_comment

begin_function
name|HAL_BOOL
name|ar9300_stop_tx_dma_indv_que
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int
name|q
parameter_list|,
name|u_int
name|timeout
parameter_list|)
block|{
define|#
directive|define
name|AH_TX_STOP_DMA_TIMEOUT
value|4000
comment|/* usec */
define|#
directive|define
name|AH_TIME_QUANTUM
value|100
comment|/* usec */
name|u_int
name|wait
decl_stmt|;
name|HALASSERT
argument_list|(
name|q
operator|<
name|AH_PRIVATE
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_caps
operator|.
name|hal_total_queues
argument_list|)
expr_stmt|;
name|HALASSERT
argument_list|(
name|AH9300
argument_list|(
name|ah
argument_list|)
operator|->
name|ah_txq
index|[
name|q
index|]
operator|.
name|tqi_type
operator|!=
name|HAL_TX_QUEUE_INACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|timeout
operator|=
name|AH_TX_STOP_DMA_TIMEOUT
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
literal|1
operator|<<
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|wait
operator|=
name|timeout
operator|/
name|AH_TIME_QUANTUM
init|;
name|wait
operator|!=
literal|0
condition|;
name|wait
operator|--
control|)
block|{
if|if
condition|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
name|AH_TIME_QUANTUM
argument_list|)
expr_stmt|;
comment|/* XXX get actual value */
block|}
ifdef|#
directive|ifdef
name|AH_DEBUG
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: queue %u DMA did not stop in 100 msec\n"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: QSTS 0x%x Q_TXE 0x%x Q_TXD 0x%x Q_CBR 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QSTS
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QCBRCFG
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: Q_MISC 0x%x Q_RDYTIMECFG 0x%x Q_RDYTIMESHDN 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QMISC
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_QRDYTIMECFG
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_RDYTIMESHDN
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AH_DEBUG */
comment|/* 2413+ and up can kill packets at the PCU level */
if|if
condition|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|u_int32_t
name|tsf_low
decl_stmt|,
name|j
decl_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: Num of pending TX Frames %d on Q %d\n"
argument_list|,
name|__func__
argument_list|,
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Kill last PCU Tx Frame */
comment|/* TODO - save off and restore current values of Q1/Q2? */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tsf_low
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QUIET2
argument_list|,
name|SM
argument_list|(
literal|10
argument_list|,
name|AR_QUIET2_QUIET_DUR
argument_list|)
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_QUIET_PERIOD
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_QUIET_TIMER
argument_list|,
name|tsf_low
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|,
name|AR_QUIET_TIMER_EN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
operator|>>
literal|10
operator|)
operator|==
operator|(
name|tsf_low
operator|>>
literal|10
operator|)
condition|)
block|{
break|break;
block|}
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: TSF have moved while trying to set "
literal|"quiet time TSF: 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|tsf_low
argument_list|)
expr_stmt|;
comment|/* TSF shouldn't count twice or reg access is taking forever */
name|HALASSERT
argument_list|(
name|j
operator|<
literal|1
argument_list|)
expr_stmt|;
block|}
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_FORCE_CH_IDLE_HIGH
argument_list|)
expr_stmt|;
comment|/* Allow the quiet mechanism to do its work */
name|OS_DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_TIMER_MODE
argument_list|,
name|AR_QUIET_TIMER_EN
argument_list|)
expr_stmt|;
comment|/* Verify all transmit is dead */
name|wait
operator|=
name|timeout
operator|/
name|AH_TIME_QUANTUM
expr_stmt|;
while|while
condition|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|wait
operator|)
operator|==
literal|0
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TX
argument_list|,
literal|"%s: Failed to stop Tx DMA in %d msec "
literal|"after killing last frame\n"
argument_list|,
name|__func__
argument_list|,
name|timeout
operator|/
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
name|OS_DELAY
argument_list|(
name|AH_TIME_QUANTUM
argument_list|)
expr_stmt|;
block|}
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_FORCE_CH_IDLE_HIGH
argument_list|)
expr_stmt|;
block|}
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|wait
operator|!=
literal|0
operator|)
return|;
undef|#
directive|undef
name|AH_TX_STOP_DMA_TIMEOUT
undef|#
directive|undef
name|AH_TIME_QUANTUM
block|}
end_function

begin_comment
comment|/*  * Abort transmit on all queues  */
end_comment

begin_define
define|#
directive|define
name|AR9300_ABORT_LOOPS
value|1000
end_define

begin_define
define|#
directive|define
name|AR9300_ABORT_WAIT
value|5
end_define

begin_define
define|#
directive|define
name|NEXT_TBTT_NOW
value|10
end_define

begin_function
name|HAL_BOOL
name|ar9300_abort_tx_dma
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|q
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|,
name|nextdba
decl_stmt|,
name|tsf_tbtt
decl_stmt|,
name|tbtt
decl_stmt|,
name|dba
decl_stmt|;
name|HAL_BOOL
name|stopped
decl_stmt|;
name|HAL_BOOL
name|status
init|=
name|AH_TRUE
decl_stmt|;
if|if
condition|(
name|ahp
operator|->
name|ah_abort_txdma_norx
condition|)
block|{
comment|/*          * First of all, make sure RX has been stopped          */
if|if
condition|(
name|ar9300_get_power_mode
argument_list|(
name|ah
argument_list|)
operator|!=
name|HAL_PM_FULL_SLEEP
condition|)
block|{
comment|/* Need to stop RX DMA before reset otherwise chip might hang */
name|stopped
operator|=
name|ar9300_set_rx_abort
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
comment|/* abort and disable PCU */
name|ar9300_set_rx_filter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stopped
operator|&=
name|ar9300_stop_dma_receive
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* stop and disable RX DMA */
if|if
condition|(
operator|!
name|stopped
condition|)
block|{
comment|/*                  * During the transition from full sleep to reset,                  * recv DMA regs are not available to be read                  */
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s[%d]: ar9300_stop_dma_receive failed\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|//We still continue to stop TX dma
comment|//return AH_FALSE;
block|}
block|}
else|else
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"%s[%d]: Chip is already in full sleep\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * set txd on all queues      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
name|AR_Q_TXD_M
argument_list|)
expr_stmt|;
comment|/*      * set tx abort bits (also disable rx)      */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|,
name|AR_PCU_FORCE_QUIET_COLL
operator||
name|AR_PCU_CLEAR_VMF
argument_list|)
expr_stmt|;
comment|/* Add a new receipe from K31 code */
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_FORCE_CH_IDLE_HIGH
operator||
name|AR_DIAG_RX_DIS
operator||
name|AR_DIAG_RX_ABORT
operator||
name|AR_DIAG_FORCE_RX_CLEAR
argument_list|)
expr_stmt|;
comment|/* beacon Q flush */
name|nexttbtt
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_TBTT_TIMER
argument_list|)
expr_stmt|;
name|nextdba
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_DMA_BEACON_ALERT
argument_list|)
expr_stmt|;
comment|//printk("%s[%d]:dba: %d, nt: %d \n", __func__, __LINE__, nextdba, nexttbtt);
name|tsf_tbtt
operator|=
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_TSF_L32
argument_list|)
expr_stmt|;
name|tbtt
operator|=
name|tsf_tbtt
operator|+
name|NEXT_TBTT_NOW
expr_stmt|;
name|dba
operator|=
name|tsf_tbtt
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_DMA_BEACON_ALERT
argument_list|,
name|dba
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_TBTT_TIMER
argument_list|,
name|tbtt
argument_list|)
expr_stmt|;
name|OS_REG_SET_BIT
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_MISC
argument_list|,
name|AR_D_GBL_IFS_MISC_IGNORE_BACKOFF
argument_list|)
expr_stmt|;
comment|/*      * Let TXE (all queues) clear before waiting for any pending frames       * This is needed before starting the RF_BUS GRANT sequence other wise causes kernel       * panic       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9300_ABORT_LOOPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|OS_REG_READ
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXE
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
name|AR9300_ABORT_WAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|AR9300_ABORT_LOOPS
condition|)
block|{
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_TX
argument_list|,
literal|"%s[%d] reached max wait on TXE\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
comment|/*      * wait on all tx queues      * This need to be checked in the last to gain extra 50 usec. on avg.       * Currently checked first since we dont have a previous channel information currently.       * Which is needed to revert the rf changes.       */
for|for
control|(
name|q
operator|=
name|AR_NUM_QCU
operator|-
literal|1
init|;
name|q
operator|>=
literal|0
condition|;
name|q
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AR9300_ABORT_LOOPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|OS_DELAY
argument_list|(
name|AR9300_ABORT_WAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|AR9300_ABORT_LOOPS
condition|)
block|{
name|status
operator|=
name|AH_FALSE
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"ABORT LOOP finsihsed for Q: %d, num_pending: %d \n"
argument_list|,
name|q
argument_list|,
name|ar9300_num_tx_pending
argument_list|(
name|ah
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
block|}
comment|/* Updating the beacon alert register with correct value */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_DMA_BEACON_ALERT
argument_list|,
name|nextdba
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_NEXT_TBTT_TIMER
argument_list|,
name|nexttbtt
argument_list|)
expr_stmt|;
name|exit
label|:
comment|/*      * clear tx abort bits      */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_PCU_MISC
argument_list|,
name|AR_PCU_FORCE_QUIET_COLL
operator||
name|AR_PCU_CLEAR_VMF
argument_list|)
expr_stmt|;
comment|/* Added a new receipe from K31 code */
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_DIAG_SW
argument_list|,
name|AR_DIAG_FORCE_CH_IDLE_HIGH
operator||
name|AR_DIAG_RX_DIS
operator||
name|AR_DIAG_RX_ABORT
operator||
name|AR_DIAG_FORCE_RX_CLEAR
argument_list|)
expr_stmt|;
name|OS_REG_CLR_BIT
argument_list|(
name|ah
argument_list|,
name|AR_D_GBL_IFS_MISC
argument_list|,
name|AR_D_GBL_IFS_MISC_IGNORE_BACKOFF
argument_list|)
expr_stmt|;
comment|/*      * clear txd      */
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_TXD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahp
operator|->
name|ah_abort_txdma_norx
operator|=
name|AH_TRUE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Determine which tx queues need interrupt servicing.  */
end_comment

begin_function
name|void
name|ar9300_get_tx_intr_queue
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|u_int32_t
modifier|*
name|txqs
parameter_list|)
block|{
name|HALDEBUG
argument_list|(
name|AH_NULL
argument_list|,
name|HAL_DEBUG_UNMASKABLE
argument_list|,
literal|"ar9300_get_tx_intr_queue: Should not be called\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|struct ath_hal_9300 *ahp = AH9300(ah);     *txqs&= ahp->ah_intr_txqs;     ahp->ah_intr_txqs&= ~(*txqs);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ar9300_reset_tx_status_ring
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|ts_tail
operator|=
literal|0
expr_stmt|;
comment|/* Zero out the status descriptors */
name|OS_MEMZERO
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahp
operator|->
name|ts_ring
argument_list|,
name|ahp
operator|->
name|ts_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ar9300_txs
argument_list|)
argument_list|)
expr_stmt|;
name|HALDEBUG
argument_list|(
name|ah
argument_list|,
name|HAL_DEBUG_QUEUE
argument_list|,
literal|"%s: TS Start 0x%x End 0x%x Virt %p, Size %d\n"
argument_list|,
name|__func__
argument_list|,
name|ahp
operator|->
name|ts_paddr_start
argument_list|,
name|ahp
operator|->
name|ts_paddr_end
argument_list|,
name|ahp
operator|->
name|ts_ring
argument_list|,
name|ahp
operator|->
name|ts_size
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_STATUS_RING_START
argument_list|,
name|ahp
operator|->
name|ts_paddr_start
argument_list|)
expr_stmt|;
name|OS_REG_WRITE
argument_list|(
name|ah
argument_list|,
name|AR_Q_STATUS_RING_END
argument_list|,
name|ahp
operator|->
name|ts_paddr_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ar9300_setup_tx_status_ring
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|ts_start
parameter_list|,
name|u_int32_t
name|ts_paddr_start
parameter_list|,
name|u_int16_t
name|size
parameter_list|)
block|{
name|struct
name|ath_hal_9300
modifier|*
name|ahp
init|=
name|AH9300
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|ahp
operator|->
name|ts_paddr_start
operator|=
name|ts_paddr_start
expr_stmt|;
name|ahp
operator|->
name|ts_paddr_end
operator|=
name|ts_paddr_start
operator|+
operator|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ar9300_txs
argument_list|)
operator|)
expr_stmt|;
name|ahp
operator|->
name|ts_size
operator|=
name|size
expr_stmt|;
name|ahp
operator|->
name|ts_ring
operator|=
operator|(
expr|struct
name|ar9300_txs
operator|*
operator|)
name|ts_start
expr_stmt|;
name|ar9300_reset_tx_status_ring
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

