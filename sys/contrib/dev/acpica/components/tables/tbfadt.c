begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: tbfadt   - FADT table utilities  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2016, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/actables.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_TABLES
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"tbfadt"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|AcpiTbInitGenericAddress
parameter_list|(
name|ACPI_GENERIC_ADDRESS
modifier|*
name|GenericAddress
parameter_list|,
name|UINT8
name|SpaceId
parameter_list|,
name|UINT8
name|ByteWidth
parameter_list|,
name|UINT64
name|Address
parameter_list|,
specifier|const
name|char
modifier|*
name|RegisterName
parameter_list|,
name|UINT8
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiTbConvertFadt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiTbSetupFadtRegisters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT64
name|AcpiTbSelectAddress
parameter_list|(
name|char
modifier|*
name|RegisterName
parameter_list|,
name|UINT32
name|Address32
parameter_list|,
name|UINT64
name|Address64
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table for conversion of FADT to common internal format and FADT validation */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|acpi_fadt_info
block|{
specifier|const
name|char
modifier|*
name|Name
decl_stmt|;
name|UINT16
name|Address64
decl_stmt|;
name|UINT16
name|Address32
decl_stmt|;
name|UINT16
name|Length
decl_stmt|;
name|UINT8
name|DefaultLength
decl_stmt|;
name|UINT8
name|Flags
decl_stmt|;
block|}
name|ACPI_FADT_INFO
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ACPI_FADT_OPTIONAL
value|0
end_define

begin_define
define|#
directive|define
name|ACPI_FADT_REQUIRED
value|1
end_define

begin_define
define|#
directive|define
name|ACPI_FADT_SEPARATE_LENGTH
value|2
end_define

begin_define
define|#
directive|define
name|ACPI_FADT_GPE_REGISTER
value|4
end_define

begin_decl_stmt
specifier|static
name|ACPI_FADT_INFO
name|FadtInfoTable
index|[]
init|=
block|{
block|{
literal|"Pm1aEventBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1aEventBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1aEventBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1EventLength
argument_list|)
block|,
name|ACPI_PM1_REGISTER_WIDTH
operator|*
literal|2
block|,
comment|/* Enable + Status register */
name|ACPI_FADT_REQUIRED
block|}
block|,
block|{
literal|"Pm1bEventBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1bEventBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1bEventBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1EventLength
argument_list|)
block|,
name|ACPI_PM1_REGISTER_WIDTH
operator|*
literal|2
block|,
comment|/* Enable + Status register */
name|ACPI_FADT_OPTIONAL
block|}
block|,
block|{
literal|"Pm1aControlBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1aControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1aControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1ControlLength
argument_list|)
block|,
name|ACPI_PM1_REGISTER_WIDTH
block|,
name|ACPI_FADT_REQUIRED
block|}
block|,
block|{
literal|"Pm1bControlBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1bControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1bControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm1ControlLength
argument_list|)
block|,
name|ACPI_PM1_REGISTER_WIDTH
block|,
name|ACPI_FADT_OPTIONAL
block|}
block|,
block|{
literal|"Pm2ControlBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm2ControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm2ControlBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Pm2ControlLength
argument_list|)
block|,
name|ACPI_PM2_REGISTER_WIDTH
block|,
name|ACPI_FADT_SEPARATE_LENGTH
block|}
block|,
block|{
literal|"PmTimerBlock"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPmTimerBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|PmTimerBlock
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|PmTimerLength
argument_list|)
block|,
name|ACPI_PM_TIMER_WIDTH
block|,
name|ACPI_FADT_SEPARATE_LENGTH
block|}
block|,
comment|/* ACPI 5.0A: Timer is optional */
block|{
literal|"Gpe0Block"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XGpe0Block
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Gpe0Block
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Gpe0BlockLength
argument_list|)
block|,
literal|0
block|,
name|ACPI_FADT_SEPARATE_LENGTH
operator||
name|ACPI_FADT_GPE_REGISTER
block|}
block|,
block|{
literal|"Gpe1Block"
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XGpe1Block
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Gpe1Block
argument_list|)
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|Gpe1BlockLength
argument_list|)
block|,
literal|0
block|,
name|ACPI_FADT_SEPARATE_LENGTH
operator||
name|ACPI_FADT_GPE_REGISTER
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACPI_FADT_INFO_ENTRIES
define|\
value|(sizeof (FadtInfoTable) / sizeof (ACPI_FADT_INFO))
end_define

begin_comment
comment|/* Table used to split Event Blocks into separate status/enable registers */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|acpi_fadt_pm_info
block|{
name|ACPI_GENERIC_ADDRESS
modifier|*
name|Target
decl_stmt|;
name|UINT16
name|Source
decl_stmt|;
name|UINT8
name|RegisterNum
decl_stmt|;
block|}
name|ACPI_FADT_PM_INFO
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ACPI_FADT_PM_INFO
name|FadtPmInfoTable
index|[]
init|=
block|{
block|{
operator|&
name|AcpiGbl_XPm1aStatus
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1aEventBlock
argument_list|)
block|,
literal|0
block|}
block|,
block|{
operator|&
name|AcpiGbl_XPm1aEnable
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1aEventBlock
argument_list|)
block|,
literal|1
block|}
block|,
block|{
operator|&
name|AcpiGbl_XPm1bStatus
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1bEventBlock
argument_list|)
block|,
literal|0
block|}
block|,
block|{
operator|&
name|AcpiGbl_XPm1bEnable
block|,
name|ACPI_FADT_OFFSET
argument_list|(
name|XPm1bEventBlock
argument_list|)
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ACPI_FADT_PM_INFO_ENTRIES
define|\
value|(sizeof (FadtPmInfoTable) / sizeof (ACPI_FADT_PM_INFO))
end_define

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbInitGenericAddress  *  * PARAMETERS:  GenericAddress      - GAS struct to be initialized  *              SpaceId             - ACPI Space ID for this register  *              ByteWidth           - Width of this register  *              Address             - Address of the register  *              RegisterName        - ASCII name of the ACPI register  *  * RETURN:      None  *  * DESCRIPTION: Initialize a Generic Address Structure (GAS)  *              See the ACPI specification for a full description and  *              definition of this structure.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiTbInitGenericAddress
parameter_list|(
name|ACPI_GENERIC_ADDRESS
modifier|*
name|GenericAddress
parameter_list|,
name|UINT8
name|SpaceId
parameter_list|,
name|UINT8
name|ByteWidth
parameter_list|,
name|UINT64
name|Address
parameter_list|,
specifier|const
name|char
modifier|*
name|RegisterName
parameter_list|,
name|UINT8
name|Flags
parameter_list|)
block|{
name|UINT8
name|BitWidth
decl_stmt|;
comment|/*      * Bit width field in the GAS is only one byte long, 255 max.      * Check for BitWidth overflow in GAS.      */
name|BitWidth
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|ByteWidth
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ByteWidth
operator|>
literal|31
condition|)
comment|/* (31*8)=248, (32*8)=256 */
block|{
comment|/*          * No error for GPE blocks, because we do not use the BitWidth          * for GPEs, the legacy length (ByteWidth) is used instead to          * allow for a large number of GPEs.          */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_FADT_GPE_REGISTER
operator|)
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"%s - 32-bit FADT register is too long (%u bytes, %u bits) "
literal|"to convert to GAS struct - 255 bits max, truncating"
operator|,
name|RegisterName
operator|,
name|ByteWidth
operator|,
operator|(
name|ByteWidth
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|BitWidth
operator|=
literal|255
expr_stmt|;
block|}
comment|/*      * The 64-bit Address field is non-aligned in the byte packed      * GAS struct.      */
name|ACPI_MOVE_64_TO_64
argument_list|(
operator|&
name|GenericAddress
operator|->
name|Address
argument_list|,
operator|&
name|Address
argument_list|)
expr_stmt|;
comment|/* All other fields are byte-wide */
name|GenericAddress
operator|->
name|SpaceId
operator|=
name|SpaceId
expr_stmt|;
name|GenericAddress
operator|->
name|BitWidth
operator|=
name|BitWidth
expr_stmt|;
name|GenericAddress
operator|->
name|BitOffset
operator|=
literal|0
expr_stmt|;
name|GenericAddress
operator|->
name|AccessWidth
operator|=
literal|0
expr_stmt|;
comment|/* Access width ANY */
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbSelectAddress  *  * PARAMETERS:  RegisterName        - ASCII name of the ACPI register  *              Address32           - 32-bit address of the register  *              Address64           - 64-bit address of the register  *  * RETURN:      The resolved 64-bit address  *  * DESCRIPTION: Select between 32-bit and 64-bit versions of addresses within  *              the FADT. Used for the FACS and DSDT addresses.  *  * NOTES:  *  * Check for FACS and DSDT address mismatches. An address mismatch between  * the 32-bit and 64-bit address fields (FIRMWARE_CTRL/X_FIRMWARE_CTRL and  * DSDT/X_DSDT) could be a corrupted address field or it might indicate  * the presence of two FACS or two DSDT tables.  *  * November 2013:  * By default, as per the ACPICA specification, a valid 64-bit address is  * used regardless of the value of the 32-bit address. However, this  * behavior can be overridden via the AcpiGbl_Use32BitFadtAddresses flag.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT64
name|AcpiTbSelectAddress
parameter_list|(
name|char
modifier|*
name|RegisterName
parameter_list|,
name|UINT32
name|Address32
parameter_list|,
name|UINT64
name|Address64
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Address64
condition|)
block|{
comment|/* 64-bit address is zero, use 32-bit address */
return|return
operator|(
operator|(
name|UINT64
operator|)
name|Address32
operator|)
return|;
block|}
if|if
condition|(
name|Address32
operator|&&
operator|(
name|Address64
operator|!=
operator|(
name|UINT64
operator|)
name|Address32
operator|)
condition|)
block|{
comment|/* Address mismatch between 32-bit and 64-bit versions */
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"32/64X %s address mismatch in FADT: "
literal|"0x%8.8X/0x%8.8X%8.8X, using %u-bit address"
operator|,
name|RegisterName
operator|,
name|Address32
operator|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Address64
argument_list|)
operator|,
name|AcpiGbl_Use32BitFadtAddresses
condition|?
literal|32
else|:
literal|64
operator|)
argument_list|)
expr_stmt|;
comment|/* 32-bit address override */
if|if
condition|(
name|AcpiGbl_Use32BitFadtAddresses
condition|)
block|{
return|return
operator|(
operator|(
name|UINT64
operator|)
name|Address32
operator|)
return|;
block|}
block|}
comment|/* Default is to use the 64-bit address */
return|return
operator|(
name|Address64
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbParseFadt  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Initialize the FADT, DSDT and FACS tables  *              (FADT contains the addresses of the DSDT and FACS)  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiTbParseFadt
parameter_list|(
name|void
parameter_list|)
block|{
name|UINT32
name|Length
decl_stmt|;
name|ACPI_TABLE_HEADER
modifier|*
name|Table
decl_stmt|;
comment|/*      * The FADT has multiple versions with different lengths,      * and it contains pointers to both the DSDT and FACS tables.      *      * Get a local copy of the FADT and convert it to a common format      * Map entire FADT, assumed to be smaller than one page.      */
name|Length
operator|=
name|AcpiGbl_RootTableList
operator|.
name|Tables
index|[
name|AcpiGbl_FadtIndex
index|]
operator|.
name|Length
expr_stmt|;
name|Table
operator|=
name|AcpiOsMapMemory
argument_list|(
name|AcpiGbl_RootTableList
operator|.
name|Tables
index|[
name|AcpiGbl_FadtIndex
index|]
operator|.
name|Address
argument_list|,
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Table
condition|)
block|{
return|return;
block|}
comment|/*      * Validate the FADT checksum before we copy the table. Ignore      * checksum error as we want to try to get the DSDT and FACS.      */
operator|(
name|void
operator|)
name|AcpiTbVerifyChecksum
argument_list|(
name|Table
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|/* Create a local copy of the FADT in common ACPI 2.0+ format */
name|AcpiTbCreateLocalFadt
argument_list|(
name|Table
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|/* All done with the real FADT, unmap it */
name|AcpiOsUnmapMemory
argument_list|(
name|Table
argument_list|,
name|Length
argument_list|)
expr_stmt|;
comment|/* Obtain the DSDT and FACS tables via their addresses within the FADT */
name|AcpiTbInstallStandardTable
argument_list|(
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|AcpiGbl_FADT
operator|.
name|XDsdt
argument_list|,
name|ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|AcpiGbl_DsdtIndex
argument_list|)
expr_stmt|;
comment|/* If Hardware Reduced flag is set, there is no FACS */
if|if
condition|(
operator|!
name|AcpiGbl_ReducedHardware
condition|)
block|{
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|Facs
condition|)
block|{
name|AcpiTbInstallStandardTable
argument_list|(
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|AcpiGbl_FADT
operator|.
name|Facs
argument_list|,
name|ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|AcpiGbl_FacsIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|XFacs
condition|)
block|{
name|AcpiTbInstallStandardTable
argument_list|(
operator|(
name|ACPI_PHYSICAL_ADDRESS
operator|)
name|AcpiGbl_FADT
operator|.
name|XFacs
argument_list|,
name|ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|AcpiGbl_XFacsIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbCreateLocalFadt  *  * PARAMETERS:  Table               - Pointer to BIOS FADT  *              Length              - Length of the table  *  * RETURN:      None  *  * DESCRIPTION: Get a local copy of the FADT and convert it to a common format.  *              Performs validation on some important FADT fields.  *  * NOTE:        We create a local copy of the FADT regardless of the version.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiTbCreateLocalFadt
parameter_list|(
name|ACPI_TABLE_HEADER
modifier|*
name|Table
parameter_list|,
name|UINT32
name|Length
parameter_list|)
block|{
comment|/*      * Check if the FADT is larger than the largest table that we expect      * (typically the current ACPI specification version). If so, truncate      * the table, and issue a warning.      */
if|if
condition|(
name|Length
operator|>
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_FADT
argument_list|)
condition|)
block|{
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"FADT (revision %u) is longer than %s length, "
literal|"truncating length %u to %u"
operator|,
name|Table
operator|->
name|Revision
operator|,
name|ACPI_FADT_CONFORMANCE
operator|,
name|Length
operator|,
operator|(
name|UINT32
operator|)
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_FADT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the entire local FADT */
name|memset
argument_list|(
operator|&
name|AcpiGbl_FADT
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_FADT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the original FADT, up to sizeof (ACPI_TABLE_FADT) */
name|memcpy
argument_list|(
operator|&
name|AcpiGbl_FADT
argument_list|,
name|Table
argument_list|,
name|ACPI_MIN
argument_list|(
name|Length
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_FADT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Take a copy of the Hardware Reduced flag */
name|AcpiGbl_ReducedHardware
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|Flags
operator|&
name|ACPI_FADT_HW_REDUCED
condition|)
block|{
name|AcpiGbl_ReducedHardware
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Convert the local copy of the FADT to the common internal format */
name|AcpiTbConvertFadt
argument_list|()
expr_stmt|;
comment|/* Initialize the global ACPI register structures */
name|AcpiTbSetupFadtRegisters
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbConvertFadt  *  * PARAMETERS:  None - AcpiGbl_FADT is used.  *  * RETURN:      None  *  * DESCRIPTION: Converts all versions of the FADT to a common internal format.  *              Expand 32-bit addresses to 64-bit as necessary. Also validate  *              important fields within the FADT.  *  * NOTE:        AcpiGbl_FADT must be of size (ACPI_TABLE_FADT), and must  *              contain a copy of the actual BIOS-provided FADT.  *  * Notes on 64-bit register addresses:  *  * After this FADT conversion, later ACPICA code will only use the 64-bit "X"  * fields of the FADT for all ACPI register addresses.  *  * The 64-bit X fields are optional extensions to the original 32-bit FADT  * V1.0 fields. Even if they are present in the FADT, they are optional and  * are unused if the BIOS sets them to zero. Therefore, we must copy/expand  * 32-bit V1.0 fields to the 64-bit X fields if the the 64-bit X field is  * originally zero.  *  * For ACPI 1.0 FADTs (that contain no 64-bit addresses), all 32-bit address  * fields are expanded to the corresponding 64-bit X fields in the internal  * common FADT.  *  * For ACPI 2.0+ FADTs, all valid (non-zero) 32-bit address fields are expanded  * to the corresponding 64-bit X fields, if the 64-bit field is originally  * zero. Adhering to the ACPI specification, we completely ignore the 32-bit  * field if the 64-bit field is valid, regardless of whether the host OS is  * 32-bit or 64-bit.  *  * Possible additional checks:  *  (AcpiGbl_FADT.Pm1EventLength>= 4)  *  (AcpiGbl_FADT.Pm1ControlLength>= 2)  *  (AcpiGbl_FADT.PmTimerLength>= 4)  *  Gpe block lengths must be multiple of 2  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiTbConvertFadt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|Name
decl_stmt|;
name|ACPI_GENERIC_ADDRESS
modifier|*
name|Address64
decl_stmt|;
name|UINT32
name|Address32
decl_stmt|;
name|UINT8
name|Length
decl_stmt|;
name|UINT8
name|Flags
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/*      * For ACPI 1.0 FADTs (revision 1), ensure that reserved fields which      * should be zero are indeed zero. This will workaround BIOSs that      * inadvertently place values in these fields.      *      * The ACPI 1.0 reserved fields that will be zeroed are the bytes located      * at offset 45, 55, 95, and the word located at offset 109, 110.      *      * Note: The FADT revision value is unreliable because of BIOS errors.      * The table length is instead used as the final word on the version.      *      * Note: FADT revision 3 is the ACPI 2.0 version of the FADT.      */
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|Header
operator|.
name|Length
operator|<=
name|ACPI_FADT_V3_SIZE
condition|)
block|{
name|AcpiGbl_FADT
operator|.
name|PreferredProfile
operator|=
literal|0
expr_stmt|;
name|AcpiGbl_FADT
operator|.
name|PstateControl
operator|=
literal|0
expr_stmt|;
name|AcpiGbl_FADT
operator|.
name|CstControl
operator|=
literal|0
expr_stmt|;
name|AcpiGbl_FADT
operator|.
name|BootFlags
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Now we can update the local FADT length to the length of the      * current FADT version as defined by the ACPI specification.      * Thus, we will have a common FADT internally.      */
name|AcpiGbl_FADT
operator|.
name|Header
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|ACPI_TABLE_FADT
argument_list|)
expr_stmt|;
comment|/*      * Expand the 32-bit DSDT addresses to 64-bit as necessary.      * Later ACPICA code will always use the X 64-bit field.      */
name|AcpiGbl_FADT
operator|.
name|XDsdt
operator|=
name|AcpiTbSelectAddress
argument_list|(
literal|"DSDT"
argument_list|,
name|AcpiGbl_FADT
operator|.
name|Dsdt
argument_list|,
name|AcpiGbl_FADT
operator|.
name|XDsdt
argument_list|)
expr_stmt|;
comment|/* If Hardware Reduced flag is set, we are all done */
if|if
condition|(
name|AcpiGbl_ReducedHardware
condition|)
block|{
return|return;
block|}
comment|/* Examine all of the 64-bit extended address fields (X fields) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_FADT_INFO_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
comment|/*          * Get the 32-bit and 64-bit addresses, as well as the register          * length and register name.          */
name|Address32
operator|=
operator|*
name|ACPI_ADD_PTR
argument_list|(
name|UINT32
argument_list|,
operator|&
name|AcpiGbl_FADT
argument_list|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Address32
argument_list|)
expr_stmt|;
name|Address64
operator|=
name|ACPI_ADD_PTR
argument_list|(
name|ACPI_GENERIC_ADDRESS
argument_list|,
operator|&
name|AcpiGbl_FADT
argument_list|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Address64
argument_list|)
expr_stmt|;
name|Length
operator|=
operator|*
name|ACPI_ADD_PTR
argument_list|(
name|UINT8
argument_list|,
operator|&
name|AcpiGbl_FADT
argument_list|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Length
argument_list|)
expr_stmt|;
name|Name
operator|=
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Name
expr_stmt|;
name|Flags
operator|=
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Flags
expr_stmt|;
comment|/*          * Expand the ACPI 1.0 32-bit addresses to the ACPI 2.0 64-bit "X"          * generic address structures as necessary. Later code will always use          * the 64-bit address structures.          *          * November 2013:          * Now always use the 64-bit address if it is valid (non-zero), in          * accordance with the ACPI specification which states that a 64-bit          * address supersedes the 32-bit version. This behavior can be          * overridden by the AcpiGbl_Use32BitFadtAddresses flag.          *          * During 64-bit address construction and verification,          * these cases are handled:          *          * Address32 zero, Address64 [don't care]   - Use Address64          *          * No override: if AcpiGbl_Use32BitFadtAddresses is FALSE, and:          * Address32 non-zero, Address64 zero       - Copy/use Address32          * Address32 non-zero == Address64 non-zero - Use Address64          * Address32 non-zero != Address64 non-zero - Warning, use Address64          *          * Override: if AcpiGbl_Use32BitFadtAddresses is TRUE, and:          * Address32 non-zero, Address64 zero       - Copy/use Address32          * Address32 non-zero == Address64 non-zero - Copy/use Address32          * Address32 non-zero != Address64 non-zero - Warning, copy/use Address32          *          * Note: SpaceId is always I/O for 32-bit legacy address fields          */
if|if
condition|(
name|Address32
condition|)
block|{
if|if
condition|(
name|Address64
operator|->
name|Address
condition|)
block|{
if|if
condition|(
name|Address64
operator|->
name|Address
operator|!=
operator|(
name|UINT64
operator|)
name|Address32
condition|)
block|{
comment|/* Address mismatch */
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"32/64X address mismatch in FADT/%s: "
literal|"0x%8.8X/0x%8.8X%8.8X, using %u-bit address"
operator|,
name|Name
operator|,
name|Address32
operator|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Address64
operator|->
name|Address
argument_list|)
operator|,
name|AcpiGbl_Use32BitFadtAddresses
condition|?
literal|32
else|:
literal|64
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*                  * For each extended field, check for length mismatch                  * between the legacy length field and the corresponding                  * 64-bit X length field.                  * Note: If the legacy length field is> 0xFF bits, ignore                  * this check. (GPE registers can be larger than the                  * 64-bit GAS structure can accomodate, 0xFF bits).                  */
if|if
condition|(
operator|(
name|ACPI_MUL_8
argument_list|(
name|Length
argument_list|)
operator|<=
name|ACPI_UINT8_MAX
operator|)
operator|&&
operator|(
name|Address64
operator|->
name|BitWidth
operator|!=
name|ACPI_MUL_8
argument_list|(
name|Length
argument_list|)
operator|)
condition|)
block|{
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"32/64X length mismatch in FADT/%s: %u/%u"
operator|,
name|Name
operator|,
name|ACPI_MUL_8
argument_list|(
name|Length
argument_list|)
operator|,
name|Address64
operator|->
name|BitWidth
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*              * Hardware register access code always uses the 64-bit fields.              * So if the 64-bit field is zero or is to be overridden,              * initialize it with the 32-bit fields.              * Note that when the 32-bit address favor is specified, the              * 64-bit fields are always re-initialized so that              * AccessSize/BitWidth/BitOffset fields can be correctly              * configured to the values to trigger a 32-bit compatible              * access mode in the hardware register access code.              */
if|if
condition|(
operator|!
name|Address64
operator|->
name|Address
operator|||
name|AcpiGbl_Use32BitFadtAddresses
condition|)
block|{
name|AcpiTbInitGenericAddress
argument_list|(
name|Address64
argument_list|,
name|ACPI_ADR_SPACE_SYSTEM_IO
argument_list|,
name|Length
argument_list|,
operator|(
name|UINT64
operator|)
name|Address32
argument_list|,
name|Name
argument_list|,
name|Flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Flags
operator|&
name|ACPI_FADT_REQUIRED
condition|)
block|{
comment|/*              * Field is required (PM1aEvent, PM1aControl).              * Both the address and length must be non-zero.              */
if|if
condition|(
operator|!
name|Address64
operator|->
name|Address
operator|||
operator|!
name|Length
condition|)
block|{
name|ACPI_BIOS_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Required FADT field %s has zero address and/or length: "
literal|"0x%8.8X%8.8X/0x%X"
operator|,
name|Name
operator|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Address64
operator|->
name|Address
argument_list|)
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Flags
operator|&
name|ACPI_FADT_SEPARATE_LENGTH
condition|)
block|{
comment|/*              * Field is optional (PM2Control, GPE0, GPE1) AND has its own              * length field. If present, both the address and length must              * be valid.              */
if|if
condition|(
operator|(
name|Address64
operator|->
name|Address
operator|&&
operator|!
name|Length
operator|)
operator|||
operator|(
operator|!
name|Address64
operator|->
name|Address
operator|&&
name|Length
operator|)
condition|)
block|{
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Optional FADT field %s has valid %s but zero %s: "
literal|"0x%8.8X%8.8X/0x%X"
operator|,
name|Name
operator|,
operator|(
name|Length
condition|?
literal|"Length"
else|:
literal|"Address"
operator|)
operator|,
operator|(
name|Length
condition|?
literal|"Address"
else|:
literal|"Length"
operator|)
operator|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Address64
operator|->
name|Address
argument_list|)
operator|,
name|Length
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTbSetupFadtRegisters  *  * PARAMETERS:  None, uses AcpiGbl_FADT.  *  * RETURN:      None  *  * DESCRIPTION: Initialize global ACPI PM1 register definitions. Optionally,  *              force FADT register definitions to their default lengths.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiTbSetupFadtRegisters
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_GENERIC_ADDRESS
modifier|*
name|Target64
decl_stmt|;
name|ACPI_GENERIC_ADDRESS
modifier|*
name|Source64
decl_stmt|;
name|UINT8
name|Pm1RegisterByteWidth
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/*      * Optionally check all register lengths against the default values and      * update them if they are incorrect.      */
if|if
condition|(
name|AcpiGbl_UseDefaultRegisterWidths
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_FADT_INFO_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|Target64
operator|=
name|ACPI_ADD_PTR
argument_list|(
name|ACPI_GENERIC_ADDRESS
argument_list|,
operator|&
name|AcpiGbl_FADT
argument_list|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Address64
argument_list|)
expr_stmt|;
comment|/*              * If a valid register (Address != 0) and the (DefaultLength> 0)              * (Not a GPE register), then check the width against the default.              */
if|if
condition|(
operator|(
name|Target64
operator|->
name|Address
operator|)
operator|&&
operator|(
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|DefaultLength
operator|>
literal|0
operator|)
operator|&&
operator|(
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|DefaultLength
operator|!=
name|Target64
operator|->
name|BitWidth
operator|)
condition|)
block|{
name|ACPI_BIOS_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Invalid length for FADT/%s: %u, using default %u"
operator|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|Name
operator|,
name|Target64
operator|->
name|BitWidth
operator|,
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|DefaultLength
operator|)
argument_list|)
expr_stmt|;
comment|/* Incorrect size, set width to the default */
name|Target64
operator|->
name|BitWidth
operator|=
name|FadtInfoTable
index|[
name|i
index|]
operator|.
name|DefaultLength
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Get the length of the individual PM1 registers (enable and status).      * Each register is defined to be (event block length / 2). Extra divide      * by 8 converts bits to bytes.      */
name|Pm1RegisterByteWidth
operator|=
operator|(
name|UINT8
operator|)
name|ACPI_DIV_16
argument_list|(
name|AcpiGbl_FADT
operator|.
name|XPm1aEventBlock
operator|.
name|BitWidth
argument_list|)
expr_stmt|;
comment|/*      * Calculate separate GAS structs for the PM1x (A/B) Status and Enable      * registers. These addresses do not appear (directly) in the FADT, so it      * is useful to pre-calculate them from the PM1 Event Block definitions.      *      * The PM event blocks are split into two register blocks, first is the      * PM Status Register block, followed immediately by the PM Enable      * Register block. Each is of length (Pm1EventLength/2)      *      * Note: The PM1A event block is required by the ACPI specification.      * However, the PM1B event block is optional and is rarely, if ever,      * used.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_FADT_PM_INFO_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|Source64
operator|=
name|ACPI_ADD_PTR
argument_list|(
name|ACPI_GENERIC_ADDRESS
argument_list|,
operator|&
name|AcpiGbl_FADT
argument_list|,
name|FadtPmInfoTable
index|[
name|i
index|]
operator|.
name|Source
argument_list|)
expr_stmt|;
if|if
condition|(
name|Source64
operator|->
name|Address
condition|)
block|{
name|AcpiTbInitGenericAddress
argument_list|(
name|FadtPmInfoTable
index|[
name|i
index|]
operator|.
name|Target
argument_list|,
name|Source64
operator|->
name|SpaceId
argument_list|,
name|Pm1RegisterByteWidth
argument_list|,
name|Source64
operator|->
name|Address
operator|+
operator|(
name|FadtPmInfoTable
index|[
name|i
index|]
operator|.
name|RegisterNum
operator|*
name|Pm1RegisterByteWidth
operator|)
argument_list|,
literal|"PmRegisters"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

