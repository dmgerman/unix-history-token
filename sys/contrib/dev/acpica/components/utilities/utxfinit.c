begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: utxfinit - External interfaces for ACPICA initialization  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2015, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|EXPORT_ACPI_INTERFACES
end_define

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acevents.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdebug.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/actables.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_UTILITIES
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"utxfinit"
argument_list|)
end_macro

begin_comment
comment|/* For AcpiExec only */
end_comment

begin_function_decl
name|void
name|AeDoObjectOverrides
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiInitializeSubsystem  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Initializes all global variables. This is the first function  *              called, so any early initialization belongs here.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInitializeSubsystem
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiInitializeSubsystem
argument_list|)
expr_stmt|;
name|AcpiGbl_StartupFlags
operator|=
name|ACPI_SUBSYSTEM_INITIALIZE
expr_stmt|;
name|ACPI_DEBUG_EXEC
argument_list|(
name|AcpiUtInitStackPtrTrace
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Initialize the OS-Dependent layer */
name|Status
operator|=
name|AcpiOsInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During OSL initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize all globals used by the subsystem */
name|Status
operator|=
name|AcpiUtInitGlobals
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During initialization of globals"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Create the default mutex objects */
name|Status
operator|=
name|AcpiUtMutexInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During Global Mutex creation"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize the namespace manager and      * the root of the namespace tree      */
name|Status
operator|=
name|AcpiNsRootInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During Namespace initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the global OSI interfaces list with the static names */
name|Status
operator|=
name|AcpiUtInitializeInterfaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During OSI interfaces initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* If configured, initialize the AML debugger */
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
name|Status
operator|=
name|AcpiDbInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During Debugger initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL_INIT
argument_list|(
argument|AcpiInitializeSubsystem
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiEnableSubsystem  *  * PARAMETERS:  Flags               - Init/enable Options  *  * RETURN:      Status  *  * DESCRIPTION: Completes the subsystem initialization including hardware.  *              Puts system into ACPI mode if it isn't already.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiEnableSubsystem
parameter_list|(
name|UINT32
name|Flags
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiEnableSubsystem
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
operator|!
name|ACPI_REDUCED_HARDWARE
operator|)
comment|/* Enable ACPI mode */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ACPI_ENABLE
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Going into ACPI mode\n"
operator|)
argument_list|)
expr_stmt|;
name|AcpiGbl_OriginalMode
operator|=
name|AcpiHwGetMode
argument_list|()
expr_stmt|;
name|Status
operator|=
name|AcpiEnable
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"AcpiEnable failed"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Obtain a permanent mapping for the FACS. This is required for the      * Global Lock and the Firmware Waking Vector      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_FACS_INIT
operator|)
condition|)
block|{
name|Status
operator|=
name|AcpiTbInitializeFacs
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Could not map the FACS table"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !ACPI_REDUCED_HARDWARE */
comment|/*      * Install the default OpRegion handlers. These are installed unless      * other handlers have already been installed via the      * InstallAddressSpaceHandler interface.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ADDRESS_SPACE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Installing default address space handlers\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInstallRegionHandlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
operator|!
name|ACPI_REDUCED_HARDWARE
operator|)
comment|/*      * Initialize ACPI Event handling (Fixed and General Purpose)      *      * Note1: We must have the hardware and events initialized before we can      * execute any control methods safely. Any control method can require      * ACPI hardware support, so the hardware must be fully initialized before      * any method execution!      *      * Note2: Fixed events are initialized and enabled here. GPEs are      * initialized, but cannot be enabled until after the hardware is      * completely initialized (SCI and GlobalLock activated) and the various      * initialization control methods are run (_REG, _STA, _INI) on the      * entire namespace.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_EVENT_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Initializing ACPI events\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInitializeEvents
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Install the SCI handler and Global Lock handler. This completes the      * hardware initialization.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_HANDLER_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Installing SCI/GL handlers\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInstallXruptHandlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !ACPI_REDUCED_HARDWARE */
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL_INIT
argument_list|(
argument|AcpiEnableSubsystem
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiInitializeObjects  *  * PARAMETERS:  Flags               - Init/enable Options  *  * RETURN:      Status  *  * DESCRIPTION: Completes namespace initialization by initializing device  *              objects and executing AML code for Regions, buffers, etc.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInitializeObjects
parameter_list|(
name|UINT32
name|Flags
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiInitializeObjects
argument_list|)
expr_stmt|;
comment|/*      * Run all _REG methods      *      * Note: Any objects accessed by the _REG methods will be automatically      * initialized, even if they contain executable AML (see the call to      * AcpiNsInitializeObjects below).      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ADDRESS_SPACE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Executing _REG OpRegion methods\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInitializeOpRegions
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ACPI_EXEC_APP
comment|/*      * This call implements the "initialization file" option for AcpiExec.      * This is the precise point that we want to perform the overrides.      */
name|AeDoObjectOverrides
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Execute any module-level code that was detected during the table load      * phase. Although illegal since ACPI 2.0, there are many machines that      * contain this type of code. Each block of detected executable AML code      * outside of any control method is wrapped with a temporary control      * method object and placed on a global list. The methods on this list      * are executed below.      */
name|AcpiNsExecModuleCodeList
argument_list|()
expr_stmt|;
comment|/*      * Initialize the objects that remain uninitialized. This runs the      * executable AML that may be part of the declaration of these objects:      * OperationRegions, BufferFields, Buffers, and Packages.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_OBJECT_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Completing Initialization of ACPI Objects\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiNsInitializeObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Initialize all device objects in the namespace. This runs the device      * _STA and _INI methods.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_DEVICE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Initializing ACPI Devices\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiNsInitializeDevices
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Empty the caches (delete the cached objects) on the assumption that      * the table load filled them up more than they will be at runtime --      * thus wasting non-paged memory.      */
name|Status
operator|=
name|AcpiPurgeCachedObjects
argument_list|()
expr_stmt|;
name|AcpiGbl_StartupFlags
operator||=
name|ACPI_INITIALIZED_OK
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL_INIT
argument_list|(
argument|AcpiInitializeObjects
argument_list|)
end_macro

end_unit

