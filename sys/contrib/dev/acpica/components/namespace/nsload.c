begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: nsload - namespace loading/expanding/contracting procedures  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2016, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdispat.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/actables.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acinterp.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_NAMESPACE
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"nsload"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_FUTURE_IMPLEMENTATION
end_ifdef

begin_function_decl
name|ACPI_STATUS
name|AcpiNsUnloadNamespace
parameter_list|(
name|ACPI_HANDLE
name|Handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiNsDeleteSubtree
parameter_list|(
name|ACPI_HANDLE
name|StartHandle
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ACPI_NO_METHOD_EXECUTION
end_ifndef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsLoadTable  *  * PARAMETERS:  TableIndex      - Index for table to be loaded  *              Node            - Owning NS node  *  * RETURN:      Status  *  * DESCRIPTION: Load one ACPI table into the namespace  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiNsLoadTable
parameter_list|(
name|UINT32
name|TableIndex
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsLoadTable
argument_list|)
expr_stmt|;
comment|/* If table already loaded into namespace, just return */
if|if
condition|(
name|AcpiTbIsTableLoaded
argument_list|(
name|TableIndex
argument_list|)
condition|)
block|{
name|Status
operator|=
name|AE_ALREADY_EXISTS
expr_stmt|;
goto|goto
name|Unlock
goto|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"**** Loading table into namespace ****\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiTbAllocateOwnerId
argument_list|(
name|TableIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Unlock
goto|;
block|}
comment|/*      * Parse the table and load the namespace with all named      * objects found within. Control methods are NOT parsed      * at this time. In fact, the control methods cannot be      * parsed until the entire namespace is loaded, because      * if a control method makes a forward reference (call)      * to another control method, we can't continue parsing      * because we don't know how many arguments to parse next!      */
name|Status
operator|=
name|AcpiNsParseTable
argument_list|(
name|TableIndex
argument_list|,
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiTbSetTableLoadedFlag
argument_list|(
name|TableIndex
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * On error, delete any namespace objects created by this table.          * We cannot initialize these objects, so delete them. There are          * a couple of expecially bad cases:          * AE_ALREADY_EXISTS - namespace collision.          * AE_NOT_FOUND - the target of a Scope operator does not          * exist. This target of Scope must already exist in the          * namespace, as per the ACPI specification.          */
name|AcpiNsDeleteNamespaceByOwner
argument_list|(
name|AcpiGbl_RootTableList
operator|.
name|Tables
index|[
name|TableIndex
index|]
operator|.
name|OwnerId
argument_list|)
expr_stmt|;
name|AcpiTbReleaseOwnerId
argument_list|(
name|TableIndex
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
name|Unlock
label|:
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now we can parse the control methods. We always parse      * them here for a sanity check, and if configured for      * just-in-time parsing, we delete the control method      * parse trees.      */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"**** Begin Table Object Initialization\n"
operator|)
argument_list|)
expr_stmt|;
name|AcpiExEnterInterpreter
argument_list|()
expr_stmt|;
name|Status
operator|=
name|AcpiDsInitializeObjects
argument_list|(
name|TableIndex
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|AcpiExExitInterpreter
argument_list|()
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"**** Completed Table Object Initialization\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Execute any module-level code that was detected during the table load      * phase. Although illegal since ACPI 2.0, there are many machines that      * contain this type of code. Each block of detected executable AML code      * outside of any control method is wrapped with a temporary control      * method object and placed on a global list. The methods on this list      * are executed below.      *      * This case executes the module-level code for each table immediately      * after the table has been loaded. This provides compatibility with      * other ACPI implementations. Optionally, the execution can be deferred      * until later, see AcpiInitializeObjects.      */
if|if
condition|(
operator|!
name|AcpiGbl_ParseTableAsTermList
operator|&&
operator|!
name|AcpiGbl_GroupModuleLevelCode
condition|)
block|{
name|AcpiNsExecModuleCodeList
argument_list|()
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_OBSOLETE_FUNCTIONS
end_ifdef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiLoadNamespace  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Load the name space from what ever is pointed to by DSDT.  *              (DSDT points to either the BIOS or a buffer.)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiNsLoadNamespace
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiLoadNameSpace
argument_list|)
expr_stmt|;
comment|/* There must be at least a DSDT installed */
if|if
condition|(
name|AcpiGbl_DSDT
operator|==
name|NULL
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"DSDT is not in memory"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_ACPI_TABLES
argument_list|)
expr_stmt|;
block|}
comment|/*      * Load the namespace. The DSDT is required,      * but the SSDT and PSDT tables are optional.      */
name|Status
operator|=
name|AcpiNsLoadTableByType
argument_list|(
name|ACPI_TABLE_ID_DSDT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore exceptions from these */
operator|(
name|void
operator|)
name|AcpiNsLoadTableByType
argument_list|(
name|ACPI_TABLE_ID_SSDT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiNsLoadTableByType
argument_list|(
name|ACPI_TABLE_ID_PSDT
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT_RAW
argument_list|(
operator|(
name|ACPI_DB_INIT
operator|,
literal|"ACPI Namespace successfully loaded at root %p\n"
operator|,
name|AcpiGbl_RootNode
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_FUTURE_IMPLEMENTATION
end_ifdef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDeleteSubtree  *  * PARAMETERS:  StartHandle         - Handle in namespace where search begins  *  * RETURNS      Status  *  * DESCRIPTION: Walks the namespace starting at the given handle and deletes  *              all objects, entries, and scopes in the entire subtree.  *  *              Namespace/Interpreter should be locked or the subsystem should  *              be in shutdown before this routine is called.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiNsDeleteSubtree
parameter_list|(
name|ACPI_HANDLE
name|StartHandle
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_HANDLE
name|ChildHandle
decl_stmt|;
name|ACPI_HANDLE
name|ParentHandle
decl_stmt|;
name|ACPI_HANDLE
name|NextChildHandle
decl_stmt|;
name|ACPI_HANDLE
name|Dummy
decl_stmt|;
name|UINT32
name|Level
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsDeleteSubtree
argument_list|)
expr_stmt|;
name|ParentHandle
operator|=
name|StartHandle
expr_stmt|;
name|ChildHandle
operator|=
name|NULL
expr_stmt|;
name|Level
operator|=
literal|1
expr_stmt|;
comment|/*      * Traverse the tree of objects until we bubble back up      * to where we started.      */
while|while
condition|(
name|Level
operator|>
literal|0
condition|)
block|{
comment|/* Attempt to get the next object in this scope */
name|Status
operator|=
name|AcpiGetNextObject
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ParentHandle
argument_list|,
name|ChildHandle
argument_list|,
operator|&
name|NextChildHandle
argument_list|)
expr_stmt|;
name|ChildHandle
operator|=
name|NextChildHandle
expr_stmt|;
comment|/* Did we get a new object? */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|Status
argument_list|)
condition|)
block|{
comment|/* Check if this object has any children */
if|if
condition|(
name|ACPI_SUCCESS
argument_list|(
name|AcpiGetNextObject
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ChildHandle
argument_list|,
name|NULL
argument_list|,
operator|&
name|Dummy
argument_list|)
argument_list|)
condition|)
block|{
comment|/*                  * There is at least one child of this object,                  * visit the object                  */
name|Level
operator|++
expr_stmt|;
name|ParentHandle
operator|=
name|ChildHandle
expr_stmt|;
name|ChildHandle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * No more children in this object, go back up to              * the object's parent              */
name|Level
operator|--
expr_stmt|;
comment|/* Delete all children now */
name|AcpiNsDeleteChildren
argument_list|(
name|ChildHandle
argument_list|)
expr_stmt|;
name|ChildHandle
operator|=
name|ParentHandle
expr_stmt|;
name|Status
operator|=
name|AcpiGetParent
argument_list|(
name|ParentHandle
argument_list|,
operator|&
name|ParentHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now delete the starting object, and we are done */
name|AcpiNsRemoveNode
argument_list|(
name|ChildHandle
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  *  FUNCTION:       AcpiNsUnloadNameSpace  *  *  PARAMETERS:     Handle          - Root of namespace subtree to be deleted  *  *  RETURN:         Status  *  *  DESCRIPTION:    Shrinks the namespace, typically in response to an undocking  *                  event. Deletes an entire subtree starting from (and  *                  including) the given handle.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiNsUnloadNamespace
parameter_list|(
name|ACPI_HANDLE
name|Handle
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsUnloadNameSpace
argument_list|)
expr_stmt|;
comment|/* Parameter validation */
if|if
condition|(
operator|!
name|AcpiGbl_RootNode
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_NAMESPACE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Handle
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|/* This function does the real work */
name|Status
operator|=
name|AcpiNsDeleteSubtree
argument_list|(
name|Handle
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

