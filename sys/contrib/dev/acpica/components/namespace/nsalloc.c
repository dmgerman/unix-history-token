begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  *  * Module Name: nsalloc - Namespace allocation and deletion utilities  *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2014, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|__NSALLOC_C__
end_define

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_NAMESPACE
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"nsalloc"
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsCreateNode  *  * PARAMETERS:  Name            - Name of the new node (4 char ACPI name)  *  * RETURN:      New namespace node (Null on failure)  *  * DESCRIPTION: Create a namespace node  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_NAMESPACE_NODE
modifier|*
name|AcpiNsCreateNode
parameter_list|(
name|UINT32
name|Name
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DBG_TRACK_ALLOCATIONS
name|UINT32
name|Temp
decl_stmt|;
endif|#
directive|endif
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsCreateNode
argument_list|)
expr_stmt|;
name|Node
operator|=
name|AcpiOsAcquireObject
argument_list|(
name|AcpiGbl_NamespaceCache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
name|return_PTR
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ACPI_MEM_TRACKING
argument_list|(
name|AcpiGbl_NsNodeList
operator|->
name|TotalAllocated
operator|++
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DBG_TRACK_ALLOCATIONS
name|Temp
operator|=
name|AcpiGbl_NsNodeList
operator|->
name|TotalAllocated
operator|-
name|AcpiGbl_NsNodeList
operator|->
name|TotalFreed
expr_stmt|;
if|if
condition|(
name|Temp
operator|>
name|AcpiGbl_NsNodeList
operator|->
name|MaxOccupied
condition|)
block|{
name|AcpiGbl_NsNodeList
operator|->
name|MaxOccupied
operator|=
name|Temp
expr_stmt|;
block|}
endif|#
directive|endif
name|Node
operator|->
name|Name
operator|.
name|Integer
operator|=
name|Name
expr_stmt|;
name|ACPI_SET_DESCRIPTOR_TYPE
argument_list|(
name|Node
argument_list|,
name|ACPI_DESC_TYPE_NAMED
argument_list|)
expr_stmt|;
name|return_PTR
argument_list|(
name|Node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDeleteNode  *  * PARAMETERS:  Node            - Node to be deleted  *  * RETURN:      None  *  * DESCRIPTION: Delete a namespace node. All node deletions must come through  *              here. Detaches any attached objects, including any attached  *              data. If a handler is associated with attached data, it is  *              invoked before the node is deleted.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDeleteNode
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|)
block|{
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|NextDesc
decl_stmt|;
name|ACPI_FUNCTION_NAME
argument_list|(
name|NsDeleteNode
argument_list|)
expr_stmt|;
comment|/* Detach an object if there is one */
name|AcpiNsDetachObject
argument_list|(
name|Node
argument_list|)
expr_stmt|;
comment|/*      * Delete an attached data object list if present (objects that were      * attached via AcpiAttachData). Note: After any normal object is      * detached above, the only possible remaining object(s) are data      * objects, in a linked list.      */
name|ObjDesc
operator|=
name|Node
operator|->
name|Object
expr_stmt|;
while|while
condition|(
name|ObjDesc
operator|&&
operator|(
name|ObjDesc
operator|->
name|Common
operator|.
name|Type
operator|==
name|ACPI_TYPE_LOCAL_DATA
operator|)
condition|)
block|{
comment|/* Invoke the attached data deletion handler if present */
if|if
condition|(
name|ObjDesc
operator|->
name|Data
operator|.
name|Handler
condition|)
block|{
name|ObjDesc
operator|->
name|Data
operator|.
name|Handler
argument_list|(
name|Node
argument_list|,
name|ObjDesc
operator|->
name|Data
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
name|NextDesc
operator|=
name|ObjDesc
operator|->
name|Common
operator|.
name|NextObject
expr_stmt|;
name|AcpiUtRemoveReference
argument_list|(
name|ObjDesc
argument_list|)
expr_stmt|;
name|ObjDesc
operator|=
name|NextDesc
expr_stmt|;
block|}
comment|/* Special case for the statically allocated root node */
if|if
condition|(
name|Node
operator|==
name|AcpiGbl_RootNode
condition|)
block|{
return|return;
block|}
comment|/* Now we can delete the node */
operator|(
name|void
operator|)
name|AcpiOsReleaseObject
argument_list|(
name|AcpiGbl_NamespaceCache
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|ACPI_MEM_TRACKING
argument_list|(
name|AcpiGbl_NsNodeList
operator|->
name|TotalFreed
operator|++
argument_list|)
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_ALLOCATIONS
operator|,
literal|"Node %p, Remaining %X\n"
operator|,
name|Node
operator|,
name|AcpiGbl_CurrentNodeCount
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsRemoveNode  *  * PARAMETERS:  Node            - Node to be removed/deleted  *  * RETURN:      None  *  * DESCRIPTION: Remove (unlink) and delete a namespace node  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsRemoveNode
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|ParentNode
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|PrevNode
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|NextNode
decl_stmt|;
name|ACPI_FUNCTION_TRACE_PTR
argument_list|(
name|NsRemoveNode
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|ParentNode
operator|=
name|Node
operator|->
name|Parent
expr_stmt|;
name|PrevNode
operator|=
name|NULL
expr_stmt|;
name|NextNode
operator|=
name|ParentNode
operator|->
name|Child
expr_stmt|;
comment|/* Find the node that is the previous peer in the parent's child list */
while|while
condition|(
name|NextNode
operator|!=
name|Node
condition|)
block|{
name|PrevNode
operator|=
name|NextNode
expr_stmt|;
name|NextNode
operator|=
name|NextNode
operator|->
name|Peer
expr_stmt|;
block|}
if|if
condition|(
name|PrevNode
condition|)
block|{
comment|/* Node is not first child, unlink it */
name|PrevNode
operator|->
name|Peer
operator|=
name|Node
operator|->
name|Peer
expr_stmt|;
block|}
else|else
block|{
comment|/*          * Node is first child (has no previous peer).          * Link peer list to parent          */
name|ParentNode
operator|->
name|Child
operator|=
name|Node
operator|->
name|Peer
expr_stmt|;
block|}
comment|/* Delete the node and any attached objects */
name|AcpiNsDeleteNode
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsInstallNode  *  * PARAMETERS:  WalkState       - Current state of the walk  *              ParentNode      - The parent of the new Node  *              Node            - The new Node to install  *              Type            - ACPI object type of the new Node  *  * RETURN:      None  *  * DESCRIPTION: Initialize a new namespace node and install it amongst  *              its peers.  *  *              Note: Current namespace lookup is linear search. This appears  *              to be sufficient as namespace searches consume only a small  *              fraction of the execution time of the ACPI subsystem.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsInstallNode
parameter_list|(
name|ACPI_WALK_STATE
modifier|*
name|WalkState
parameter_list|,
name|ACPI_NAMESPACE_NODE
modifier|*
name|ParentNode
parameter_list|,
comment|/* Parent */
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
comment|/* New Child*/
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
block|{
name|ACPI_OWNER_ID
name|OwnerId
init|=
literal|0
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|ChildNode
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsInstallNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|WalkState
condition|)
block|{
comment|/*          * Get the owner ID from the Walk state. The owner ID is used to          * track table deletion and deletion of objects created by methods.          */
name|OwnerId
operator|=
name|WalkState
operator|->
name|OwnerId
expr_stmt|;
if|if
condition|(
operator|(
name|WalkState
operator|->
name|MethodDesc
operator|)
operator|&&
operator|(
name|ParentNode
operator|!=
name|WalkState
operator|->
name|MethodNode
operator|)
condition|)
block|{
comment|/*              * A method is creating a new node that is not a child of the              * method (it is non-local). Mark the executing method as having              * modified the namespace. This is used for cleanup when the              * method exits.              */
name|WalkState
operator|->
name|MethodDesc
operator|->
name|Method
operator|.
name|InfoFlags
operator||=
name|ACPI_METHOD_MODIFIED_NAMESPACE
expr_stmt|;
block|}
block|}
comment|/* Link the new entry into the parent and existing children */
name|Node
operator|->
name|Peer
operator|=
name|NULL
expr_stmt|;
name|Node
operator|->
name|Parent
operator|=
name|ParentNode
expr_stmt|;
name|ChildNode
operator|=
name|ParentNode
operator|->
name|Child
expr_stmt|;
if|if
condition|(
operator|!
name|ChildNode
condition|)
block|{
name|ParentNode
operator|->
name|Child
operator|=
name|Node
expr_stmt|;
block|}
else|else
block|{
comment|/* Add node to the end of the peer list */
while|while
condition|(
name|ChildNode
operator|->
name|Peer
condition|)
block|{
name|ChildNode
operator|=
name|ChildNode
operator|->
name|Peer
expr_stmt|;
block|}
name|ChildNode
operator|->
name|Peer
operator|=
name|Node
expr_stmt|;
block|}
comment|/* Init the new entry */
name|Node
operator|->
name|OwnerId
operator|=
name|OwnerId
expr_stmt|;
name|Node
operator|->
name|Type
operator|=
operator|(
name|UINT8
operator|)
name|Type
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_NAMES
operator|,
literal|"%4.4s (%s) [Node %p Owner %X] added to %4.4s (%s) [Node %p]\n"
operator|,
name|AcpiUtGetNodeName
argument_list|(
name|Node
argument_list|)
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|Node
operator|->
name|Type
argument_list|)
operator|,
name|Node
operator|,
name|OwnerId
operator|,
name|AcpiUtGetNodeName
argument_list|(
name|ParentNode
argument_list|)
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|ParentNode
operator|->
name|Type
argument_list|)
operator|,
name|ParentNode
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDeleteChildren  *  * PARAMETERS:  ParentNode      - Delete this objects children  *  * RETURN:      None.  *  * DESCRIPTION: Delete all children of the parent object. In other words,  *              deletes a "scope".  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDeleteChildren
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|ParentNode
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|NextNode
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|NodeToDelete
decl_stmt|;
name|ACPI_FUNCTION_TRACE_PTR
argument_list|(
name|NsDeleteChildren
argument_list|,
name|ParentNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ParentNode
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Deallocate all children at this level */
name|NextNode
operator|=
name|ParentNode
operator|->
name|Child
expr_stmt|;
while|while
condition|(
name|NextNode
condition|)
block|{
comment|/* Grandchildren should have all been deleted already */
if|if
condition|(
name|NextNode
operator|->
name|Child
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Found a grandchild! P=%p C=%p"
operator|,
name|ParentNode
operator|,
name|NextNode
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*          * Delete this child node and move on to the next child in the list.          * No need to unlink the node since we are deleting the entire branch.          */
name|NodeToDelete
operator|=
name|NextNode
expr_stmt|;
name|NextNode
operator|=
name|NextNode
operator|->
name|Peer
expr_stmt|;
name|AcpiNsDeleteNode
argument_list|(
name|NodeToDelete
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Clear the parent's child pointer */
name|ParentNode
operator|->
name|Child
operator|=
name|NULL
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDeleteNamespaceSubtree  *  * PARAMETERS:  ParentNode      - Root of the subtree to be deleted  *  * RETURN:      None.  *  * DESCRIPTION: Delete a subtree of the namespace. This includes all objects  *              stored within the subtree.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDeleteNamespaceSubtree
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|ParentNode
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|ChildNode
init|=
name|NULL
decl_stmt|;
name|UINT32
name|Level
init|=
literal|1
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsDeleteNamespaceSubtree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ParentNode
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Lock namespace for possible update */
name|Status
operator|=
name|AcpiUtAcquireMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/*      * Traverse the tree of objects until we bubble back up      * to where we started.      */
while|while
condition|(
name|Level
operator|>
literal|0
condition|)
block|{
comment|/* Get the next node in this scope (NULL if none) */
name|ChildNode
operator|=
name|AcpiNsGetNextNode
argument_list|(
name|ParentNode
argument_list|,
name|ChildNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ChildNode
condition|)
block|{
comment|/* Found a child node - detach any attached object */
name|AcpiNsDetachObject
argument_list|(
name|ChildNode
argument_list|)
expr_stmt|;
comment|/* Check if this node has any children */
if|if
condition|(
name|ChildNode
operator|->
name|Child
condition|)
block|{
comment|/*                  * There is at least one child of this node,                  * visit the node                  */
name|Level
operator|++
expr_stmt|;
name|ParentNode
operator|=
name|ChildNode
expr_stmt|;
name|ChildNode
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * No more children of this parent node.              * Move up to the grandparent.              */
name|Level
operator|--
expr_stmt|;
comment|/*              * Now delete all of the children of this parent              * all at the same time.              */
name|AcpiNsDeleteChildren
argument_list|(
name|ParentNode
argument_list|)
expr_stmt|;
comment|/* New "last child" is this parent node */
name|ChildNode
operator|=
name|ParentNode
expr_stmt|;
comment|/* Move up the tree to the grandparent */
name|ParentNode
operator|=
name|ParentNode
operator|->
name|Parent
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDeleteNamespaceByOwner  *  * PARAMETERS:  OwnerId     - All nodes with this owner will be deleted  *  * RETURN:      Status  *  * DESCRIPTION: Delete entries within the namespace that are owned by a  *              specific ID. Used to delete entire ACPI tables. All  *              reference counts are updated.  *  * MUTEX:       Locks namespace during deletion walk.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDeleteNamespaceByOwner
parameter_list|(
name|ACPI_OWNER_ID
name|OwnerId
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|ChildNode
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|DeletionNode
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|ParentNode
decl_stmt|;
name|UINT32
name|Level
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE_U32
argument_list|(
name|NsDeleteNamespaceByOwner
argument_list|,
name|OwnerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|OwnerId
operator|==
literal|0
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Lock namespace for possible update */
name|Status
operator|=
name|AcpiUtAcquireMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
name|DeletionNode
operator|=
name|NULL
expr_stmt|;
name|ParentNode
operator|=
name|AcpiGbl_RootNode
expr_stmt|;
name|ChildNode
operator|=
name|NULL
expr_stmt|;
name|Level
operator|=
literal|1
expr_stmt|;
comment|/*      * Traverse the tree of nodes until we bubble back up      * to where we started.      */
while|while
condition|(
name|Level
operator|>
literal|0
condition|)
block|{
comment|/*          * Get the next child of this parent node. When ChildNode is NULL,          * the first child of the parent is returned          */
name|ChildNode
operator|=
name|AcpiNsGetNextNode
argument_list|(
name|ParentNode
argument_list|,
name|ChildNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|DeletionNode
condition|)
block|{
name|AcpiNsDeleteChildren
argument_list|(
name|DeletionNode
argument_list|)
expr_stmt|;
name|AcpiNsRemoveNode
argument_list|(
name|DeletionNode
argument_list|)
expr_stmt|;
name|DeletionNode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ChildNode
condition|)
block|{
if|if
condition|(
name|ChildNode
operator|->
name|OwnerId
operator|==
name|OwnerId
condition|)
block|{
comment|/* Found a matching child node - detach any attached object */
name|AcpiNsDetachObject
argument_list|(
name|ChildNode
argument_list|)
expr_stmt|;
block|}
comment|/* Check if this node has any children */
if|if
condition|(
name|ChildNode
operator|->
name|Child
condition|)
block|{
comment|/*                  * There is at least one child of this node,                  * visit the node                  */
name|Level
operator|++
expr_stmt|;
name|ParentNode
operator|=
name|ChildNode
expr_stmt|;
name|ChildNode
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ChildNode
operator|->
name|OwnerId
operator|==
name|OwnerId
condition|)
block|{
name|DeletionNode
operator|=
name|ChildNode
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * No more children of this parent node.              * Move up to the grandparent.              */
name|Level
operator|--
expr_stmt|;
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ParentNode
operator|->
name|OwnerId
operator|==
name|OwnerId
condition|)
block|{
name|DeletionNode
operator|=
name|ParentNode
expr_stmt|;
block|}
block|}
comment|/* New "last child" is this parent node */
name|ChildNode
operator|=
name|ParentNode
expr_stmt|;
comment|/* Move up the tree to the grandparent */
name|ParentNode
operator|=
name|ParentNode
operator|->
name|Parent
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

end_unit

