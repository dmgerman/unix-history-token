begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: nsdump - table dumping routines for debug  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2014, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|__NSDUMP_C__
end_define

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acoutput.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_NAMESPACE
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"nsdump"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_OBSOLETE_FUNCTIONS
end_ifdef

begin_function_decl
name|void
name|AcpiNsDumpRootDevices
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiNsDumpOneDevice
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ACPI_DEBUG_OUTPUT
argument_list|)
operator|||
name|defined
argument_list|(
name|ACPI_DEBUGGER
argument_list|)
end_if

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiNsDumpOneObjectPath
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiNsGetMaxDepth
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsPrintPathname  *  * PARAMETERS:  NumSegments         - Number of ACPI name segments  *              Pathname            - The compressed (internal) path  *  * RETURN:      None  *  * DESCRIPTION: Print an object's full namespace pathname  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsPrintPathname
parameter_list|(
name|UINT32
name|NumSegments
parameter_list|,
name|char
modifier|*
name|Pathname
parameter_list|)
block|{
name|UINT32
name|i
decl_stmt|;
name|ACPI_FUNCTION_NAME
argument_list|(
name|NsPrintPathname
argument_list|)
expr_stmt|;
comment|/* Check if debug output enabled */
if|if
condition|(
operator|!
name|ACPI_IS_DEBUG_ENABLED
argument_list|(
name|ACPI_LV_NAMES
argument_list|,
name|ACPI_NAMESPACE
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Print the entire name */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_NAMES
operator|,
literal|"["
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|NumSegments
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ACPI_IS_PRINT
argument_list|(
name|Pathname
index|[
name|i
index|]
argument_list|)
condition|?
name|AcpiOsPrintf
argument_list|(
literal|"%c"
argument_list|,
name|Pathname
index|[
name|i
index|]
argument_list|)
else|:
name|AcpiOsPrintf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
name|Pathname
operator|+=
name|ACPI_NAME_SIZE
expr_stmt|;
name|NumSegments
operator|--
expr_stmt|;
if|if
condition|(
name|NumSegments
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
name|AcpiOsPrintf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpPathname  *  * PARAMETERS:  Handle              - Object  *              Msg                 - Prefix message  *              Level               - Desired debug level  *              Component           - Caller's component ID  *  * RETURN:      None  *  * DESCRIPTION: Print an object's full namespace pathname  *              Manages allocation/freeing of a pathname buffer  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDumpPathname
parameter_list|(
name|ACPI_HANDLE
name|Handle
parameter_list|,
name|char
modifier|*
name|Msg
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|UINT32
name|Component
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsDumpPathname
argument_list|)
expr_stmt|;
comment|/* Do this only if the requested debug level and component are enabled */
if|if
condition|(
operator|!
name|ACPI_IS_DEBUG_ENABLED
argument_list|(
name|Level
argument_list|,
name|Component
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Convert handle to a full pathname and print it (with supplied message) */
name|AcpiNsPrintNodePathname
argument_list|(
name|Handle
argument_list|,
name|Msg
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpOneObject  *  * PARAMETERS:  ObjHandle           - Node to be dumped  *              Level               - Nesting level of the handle  *              Context             - Passed into WalkNamespace  *              ReturnValue         - Not used  *  * RETURN:      Status  *  * DESCRIPTION: Dump a single Node  *              This procedure is a UserFunction called by AcpiNsWalkNamespace.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiNsDumpOneObject
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_WALK_INFO
modifier|*
name|Info
init|=
operator|(
name|ACPI_WALK_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|ThisNode
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|ObjType
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|Type
decl_stmt|;
name|UINT32
name|BytesToDump
decl_stmt|;
name|UINT32
name|DbgLevel
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|ACPI_FUNCTION_NAME
argument_list|(
name|NsDumpOneObject
argument_list|)
expr_stmt|;
comment|/* Is output enabled? */
if|if
condition|(
operator|!
operator|(
name|AcpiDbgLevel
operator|&
name|Info
operator|->
name|DebugLevel
operator|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ObjHandle
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"Null object handle\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|ThisNode
operator|=
name|AcpiNsValidateHandle
argument_list|(
name|ObjHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ThisNode
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"Invalid object handle %p\n"
operator|,
name|ObjHandle
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Type
operator|=
name|ThisNode
operator|->
name|Type
expr_stmt|;
comment|/* Check if the owner matches */
if|if
condition|(
operator|(
name|Info
operator|->
name|OwnerId
operator|!=
name|ACPI_OWNER_ID_MAX
operator|)
operator|&&
operator|(
name|Info
operator|->
name|OwnerId
operator|!=
name|ThisNode
operator|->
name|OwnerId
operator|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|Info
operator|->
name|DisplayType
operator|&
name|ACPI_DISPLAY_SHORT
operator|)
condition|)
block|{
comment|/* Indent the object according to the level */
name|AcpiOsPrintf
argument_list|(
literal|"%2d%*s"
argument_list|,
operator|(
name|UINT32
operator|)
name|Level
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|Level
operator|*
literal|2
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Check the node type and name */
if|if
condition|(
name|Type
operator|>
name|ACPI_TYPE_LOCAL_MAX
condition|)
block|{
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Invalid ACPI Object Type 0x%08X"
operator|,
name|Type
operator|)
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"%4.4s"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ThisNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can print out the pertinent information */
name|AcpiOsPrintf
argument_list|(
literal|" %-12s %p %2.2X "
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
argument_list|,
name|ThisNode
argument_list|,
name|ThisNode
operator|->
name|OwnerId
argument_list|)
expr_stmt|;
name|DbgLevel
operator|=
name|AcpiDbgLevel
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
name|ObjDesc
operator|=
name|AcpiNsGetAttachedObject
argument_list|(
name|ThisNode
argument_list|)
expr_stmt|;
name|AcpiDbgLevel
operator|=
name|DbgLevel
expr_stmt|;
comment|/* Temp nodes are those nodes created by a control method */
if|if
condition|(
name|ThisNode
operator|->
name|Flags
operator|&
name|ANOBJ_TEMPORARY
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"(T) "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|Info
operator|->
name|DisplayType
operator|&
name|ACPI_DISPLAY_MASK
condition|)
block|{
case|case
name|ACPI_DISPLAY_SUMMARY
case|:
if|if
condition|(
operator|!
name|ObjDesc
condition|)
block|{
comment|/* No attached object. Some types should always have an object */
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
case|case
name|ACPI_TYPE_PACKAGE
case|:
case|case
name|ACPI_TYPE_BUFFER
case|:
case|case
name|ACPI_TYPE_STRING
case|:
case|case
name|ACPI_TYPE_METHOD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"<No attached object>"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_PROCESSOR
case|:
name|AcpiOsPrintf
argument_list|(
literal|"ID %02X Len %02X Addr %p\n"
argument_list|,
name|ObjDesc
operator|->
name|Processor
operator|.
name|ProcId
argument_list|,
name|ObjDesc
operator|->
name|Processor
operator|.
name|Length
argument_list|,
name|ACPI_CAST_PTR
argument_list|(
name|void
argument_list|,
name|ObjDesc
operator|->
name|Processor
operator|.
name|Address
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_DEVICE
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Notify Object: %p\n"
argument_list|,
name|ObjDesc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_METHOD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Args %X Len %.4X Aml %p\n"
argument_list|,
operator|(
name|UINT32
operator|)
name|ObjDesc
operator|->
name|Method
operator|.
name|ParamCount
argument_list|,
name|ObjDesc
operator|->
name|Method
operator|.
name|AmlLength
argument_list|,
name|ObjDesc
operator|->
name|Method
operator|.
name|AmlStart
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_INTEGER
case|:
name|AcpiOsPrintf
argument_list|(
literal|"= %8.8X%8.8X\n"
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|ObjDesc
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
if|if
condition|(
name|ObjDesc
operator|->
name|Common
operator|.
name|Flags
operator|&
name|AOPOBJ_DATA_VALID
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Elements %.2X\n"
argument_list|,
name|ObjDesc
operator|->
name|Package
operator|.
name|Count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"[Length not yet evaluated]\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_TYPE_BUFFER
case|:
if|if
condition|(
name|ObjDesc
operator|->
name|Common
operator|.
name|Flags
operator|&
name|AOPOBJ_DATA_VALID
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Len %.2X"
argument_list|,
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Length
argument_list|)
expr_stmt|;
comment|/* Dump some of the buffer */
if|if
condition|(
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Length
operator|>
literal|0
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" ="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Length
operator|&&
name|i
operator|<
literal|12
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" %.2hX"
argument_list|,
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Pointer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"[Length not yet evaluated]\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_TYPE_STRING
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Len %.2X "
argument_list|,
name|ObjDesc
operator|->
name|String
operator|.
name|Length
argument_list|)
expr_stmt|;
name|AcpiUtPrintString
argument_list|(
name|ObjDesc
operator|->
name|String
operator|.
name|Pointer
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_REGION
case|:
name|AcpiOsPrintf
argument_list|(
literal|"[%s]"
argument_list|,
name|AcpiUtGetRegionName
argument_list|(
name|ObjDesc
operator|->
name|Region
operator|.
name|SpaceId
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ObjDesc
operator|->
name|Region
operator|.
name|Flags
operator|&
name|AOPOBJ_DATA_VALID
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" Addr %8.8X%8.8X Len %.4X\n"
argument_list|,
name|ACPI_FORMAT_NATIVE_UINT
argument_list|(
name|ObjDesc
operator|->
name|Region
operator|.
name|Address
argument_list|)
argument_list|,
name|ObjDesc
operator|->
name|Region
operator|.
name|Length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|" [Address/Length not yet evaluated]\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_TYPE_LOCAL_REFERENCE
case|:
name|AcpiOsPrintf
argument_list|(
literal|"[%s]\n"
argument_list|,
name|AcpiUtGetReferenceName
argument_list|(
name|ObjDesc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_BUFFER_FIELD
case|:
if|if
condition|(
name|ObjDesc
operator|->
name|BufferField
operator|.
name|BufferObj
operator|&&
name|ObjDesc
operator|->
name|BufferField
operator|.
name|BufferObj
operator|->
name|Buffer
operator|.
name|Node
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Buf [%4.4s]"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|BufferField
operator|.
name|BufferObj
operator|->
name|Buffer
operator|.
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Rgn [%4.4s]"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|CommonField
operator|.
name|RegionObj
operator|->
name|Region
operator|.
name|Node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_BANK_FIELD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Rgn [%4.4s] Bnk [%4.4s]"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|CommonField
operator|.
name|RegionObj
operator|->
name|Region
operator|.
name|Node
argument_list|)
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|BankField
operator|.
name|BankObj
operator|->
name|CommonField
operator|.
name|Node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_INDEX_FIELD
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Idx [%4.4s] Dat [%4.4s]"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|IndexField
operator|.
name|IndexObj
operator|->
name|CommonField
operator|.
name|Node
argument_list|)
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
operator|->
name|IndexField
operator|.
name|DataObj
operator|->
name|CommonField
operator|.
name|Node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_ALIAS
case|:
case|case
name|ACPI_TYPE_LOCAL_METHOD_ALIAS
case|:
name|AcpiOsPrintf
argument_list|(
literal|"Target %4.4s (%p)\n"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|ObjDesc
argument_list|)
argument_list|,
name|ObjDesc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|"Object %p\n"
argument_list|,
name|ObjDesc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Common field handling */
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_BUFFER_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_BANK_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_INDEX_FIELD
case|:
name|AcpiOsPrintf
argument_list|(
literal|" Off %.3X Len %.2X Acc %.2hd\n"
argument_list|,
operator|(
name|ObjDesc
operator|->
name|CommonField
operator|.
name|BaseByteOffset
operator|*
literal|8
operator|)
operator|+
name|ObjDesc
operator|->
name|CommonField
operator|.
name|StartFieldBitOffset
argument_list|,
name|ObjDesc
operator|->
name|CommonField
operator|.
name|BitLength
argument_list|,
name|ObjDesc
operator|->
name|CommonField
operator|.
name|AccessByteWidth
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|ACPI_DISPLAY_OBJECTS
case|:
name|AcpiOsPrintf
argument_list|(
literal|"O:%p"
argument_list|,
name|ObjDesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ObjDesc
condition|)
block|{
comment|/* No attached object, we are done */
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"(R%u)"
argument_list|,
name|ObjDesc
operator|->
name|Common
operator|.
name|ReferenceCount
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_METHOD
case|:
comment|/* Name is a Method and its AML offset/length are set */
name|AcpiOsPrintf
argument_list|(
literal|" M:%p-%X\n"
argument_list|,
name|ObjDesc
operator|->
name|Method
operator|.
name|AmlStart
argument_list|,
name|ObjDesc
operator|->
name|Method
operator|.
name|AmlLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_INTEGER
case|:
name|AcpiOsPrintf
argument_list|(
literal|" I:%8.8X8.8%X\n"
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|ObjDesc
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_STRING
case|:
name|AcpiOsPrintf
argument_list|(
literal|" S:%p-%X\n"
argument_list|,
name|ObjDesc
operator|->
name|String
operator|.
name|Pointer
argument_list|,
name|ObjDesc
operator|->
name|String
operator|.
name|Length
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_BUFFER
case|:
name|AcpiOsPrintf
argument_list|(
literal|" B:%p-%X\n"
argument_list|,
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Pointer
argument_list|,
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If debug turned off, done */
if|if
condition|(
operator|!
operator|(
name|AcpiDbgLevel
operator|&
name|ACPI_LV_VALUES
operator|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* If there is an attached object, display it */
name|DbgLevel
operator|=
name|AcpiDbgLevel
expr_stmt|;
name|AcpiDbgLevel
operator|=
literal|0
expr_stmt|;
name|ObjDesc
operator|=
name|AcpiNsGetAttachedObject
argument_list|(
name|ThisNode
argument_list|)
expr_stmt|;
name|AcpiDbgLevel
operator|=
name|DbgLevel
expr_stmt|;
comment|/* Dump attached objects */
while|while
condition|(
name|ObjDesc
condition|)
block|{
name|ObjType
operator|=
name|ACPI_TYPE_INVALID
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"Attached Object %p: "
argument_list|,
name|ObjDesc
argument_list|)
expr_stmt|;
comment|/* Decode the type of attached object and dump the contents */
switch|switch
condition|(
name|ACPI_GET_DESCRIPTOR_TYPE
argument_list|(
name|ObjDesc
argument_list|)
condition|)
block|{
case|case
name|ACPI_DESC_TYPE_NAMED
case|:
name|AcpiOsPrintf
argument_list|(
literal|"(Ptr to Node)\n"
argument_list|)
expr_stmt|;
name|BytesToDump
operator|=
sizeof|sizeof
argument_list|(
name|ACPI_NAMESPACE_NODE
argument_list|)
expr_stmt|;
name|ACPI_DUMP_BUFFER
argument_list|(
name|ObjDesc
argument_list|,
name|BytesToDump
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_DESC_TYPE_OPERAND
case|:
name|ObjType
operator|=
name|ObjDesc
operator|->
name|Common
operator|.
name|Type
expr_stmt|;
if|if
condition|(
name|ObjType
operator|>
name|ACPI_TYPE_LOCAL_MAX
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"(Pointer to ACPI Object type %.2X [UNKNOWN])\n"
argument_list|,
name|ObjType
argument_list|)
expr_stmt|;
name|BytesToDump
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"(Pointer to ACPI Object type %.2X [%s])\n"
argument_list|,
name|ObjType
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|ObjType
argument_list|)
argument_list|)
expr_stmt|;
name|BytesToDump
operator|=
sizeof|sizeof
argument_list|(
name|ACPI_OPERAND_OBJECT
argument_list|)
expr_stmt|;
block|}
name|ACPI_DUMP_BUFFER
argument_list|(
name|ObjDesc
argument_list|,
name|BytesToDump
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If value is NOT an internal object, we are done */
if|if
condition|(
name|ACPI_GET_DESCRIPTOR_TYPE
argument_list|(
name|ObjDesc
argument_list|)
operator|!=
name|ACPI_DESC_TYPE_OPERAND
condition|)
block|{
goto|goto
name|Cleanup
goto|;
block|}
comment|/* Valid object, get the pointer to next level, if any */
switch|switch
condition|(
name|ObjType
condition|)
block|{
case|case
name|ACPI_TYPE_BUFFER
case|:
case|case
name|ACPI_TYPE_STRING
case|:
comment|/*              * NOTE: takes advantage of common fields between string/buffer              */
name|BytesToDump
operator|=
name|ObjDesc
operator|->
name|String
operator|.
name|Length
expr_stmt|;
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|String
operator|.
name|Pointer
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"(Buffer/String pointer %p length %X)\n"
argument_list|,
name|ObjDesc
argument_list|,
name|BytesToDump
argument_list|)
expr_stmt|;
name|ACPI_DUMP_BUFFER
argument_list|(
name|ObjDesc
argument_list|,
name|BytesToDump
argument_list|)
expr_stmt|;
goto|goto
name|Cleanup
goto|;
case|case
name|ACPI_TYPE_BUFFER_FIELD
case|:
name|ObjDesc
operator|=
operator|(
name|ACPI_OPERAND_OBJECT
operator|*
operator|)
name|ObjDesc
operator|->
name|BufferField
operator|.
name|BufferObj
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_METHOD
case|:
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|Method
operator|.
name|AmlStart
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|Field
operator|.
name|RegionObj
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_BANK_FIELD
case|:
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|BankField
operator|.
name|RegionObj
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_LOCAL_INDEX_FIELD
case|:
name|ObjDesc
operator|=
operator|(
name|void
operator|*
operator|)
name|ObjDesc
operator|->
name|IndexField
operator|.
name|IndexObj
expr_stmt|;
break|break;
default|default:
goto|goto
name|Cleanup
goto|;
block|}
name|ObjType
operator|=
name|ACPI_TYPE_INVALID
expr_stmt|;
comment|/* Terminate loop after next pass */
block|}
name|Cleanup
label|:
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpObjects  *  * PARAMETERS:  Type                - Object type to be dumped  *              DisplayType         - 0 or ACPI_DISPLAY_SUMMARY  *              MaxDepth            - Maximum depth of dump. Use ACPI_UINT32_MAX  *                                    for an effectively unlimited depth.  *              OwnerId             - Dump only objects owned by this ID. Use  *                                    ACPI_UINT32_MAX to match all owners.  *              StartHandle         - Where in namespace to start/end search  *  * RETURN:      None  *  * DESCRIPTION: Dump typed objects within the loaded namespace. Uses  *              AcpiNsWalkNamespace in conjunction with AcpiNsDumpOneObject.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDumpObjects
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|,
name|UINT8
name|DisplayType
parameter_list|,
name|UINT32
name|MaxDepth
parameter_list|,
name|ACPI_OWNER_ID
name|OwnerId
parameter_list|,
name|ACPI_HANDLE
name|StartHandle
parameter_list|)
block|{
name|ACPI_WALK_INFO
name|Info
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_ENTRY
argument_list|()
expr_stmt|;
comment|/*      * Just lock the entire namespace for the duration of the dump.      * We don't want any changes to the namespace during this time,      * especially the temporary nodes since we are going to display      * them also.      */
name|Status
operator|=
name|AcpiUtAcquireMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not acquire namespace mutex\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Info
operator|.
name|DebugLevel
operator|=
name|ACPI_LV_TABLES
expr_stmt|;
name|Info
operator|.
name|OwnerId
operator|=
name|OwnerId
expr_stmt|;
name|Info
operator|.
name|DisplayType
operator|=
name|DisplayType
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiNsWalkNamespace
argument_list|(
name|Type
argument_list|,
name|StartHandle
argument_list|,
name|MaxDepth
argument_list|,
name|ACPI_NS_WALK_NO_UNLOCK
operator||
name|ACPI_NS_WALK_TEMP_NODES
argument_list|,
name|AcpiNsDumpOneObject
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpOneObjectPath, AcpiNsGetMaxDepth  *  * PARAMETERS:  ObjHandle           - Node to be dumped  *              Level               - Nesting level of the handle  *              Context             - Passed into WalkNamespace  *              ReturnValue         - Not used  *  * RETURN:      Status  *  * DESCRIPTION: Dump the full pathname to a namespace object. AcpNsGetMaxDepth  *              computes the maximum nesting depth in the namespace tree, in  *              order to simplify formatting in AcpiNsDumpOneObjectPath.  *              These procedures are UserFunctions called by AcpiNsWalkNamespace.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiNsDumpOneObjectPath
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|UINT32
name|MaxLevel
init|=
operator|*
operator|(
operator|(
name|UINT32
operator|*
operator|)
name|Context
operator|)
decl_stmt|;
name|char
modifier|*
name|Pathname
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|int
name|PathIndent
decl_stmt|;
if|if
condition|(
operator|!
name|ObjHandle
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Node
operator|=
name|AcpiNsValidateHandle
argument_list|(
name|ObjHandle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
comment|/* Ignore bad node during namespace walk */
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Pathname
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|PathIndent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Level
operator|<=
name|MaxLevel
condition|)
block|{
name|PathIndent
operator|=
name|MaxLevel
operator|-
name|Level
operator|+
literal|1
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"%2d%*s%-12s%*s"
argument_list|,
name|Level
argument_list|,
name|Level
argument_list|,
literal|" "
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Node
operator|->
name|Type
argument_list|)
argument_list|,
name|PathIndent
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|Pathname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiNsGetMaxDepth
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|UINT32
modifier|*
name|MaxLevel
init|=
operator|(
name|UINT32
operator|*
operator|)
name|Context
decl_stmt|;
if|if
condition|(
name|Level
operator|>
operator|*
name|MaxLevel
condition|)
block|{
operator|*
name|MaxLevel
operator|=
name|Level
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpObjectPaths  *  * PARAMETERS:  Type                - Object type to be dumped  *              DisplayType         - 0 or ACPI_DISPLAY_SUMMARY  *              MaxDepth            - Maximum depth of dump. Use ACPI_UINT32_MAX  *                                    for an effectively unlimited depth.  *              OwnerId             - Dump only objects owned by this ID. Use  *                                    ACPI_UINT32_MAX to match all owners.  *              StartHandle         - Where in namespace to start/end search  *  * RETURN:      None  *  * DESCRIPTION: Dump full object pathnames within the loaded namespace. Uses  *              AcpiNsWalkNamespace in conjunction with AcpiNsDumpOneObjectPath.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDumpObjectPaths
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|,
name|UINT8
name|DisplayType
parameter_list|,
name|UINT32
name|MaxDepth
parameter_list|,
name|ACPI_OWNER_ID
name|OwnerId
parameter_list|,
name|ACPI_HANDLE
name|StartHandle
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT32
name|MaxLevel
init|=
literal|0
decl_stmt|;
name|ACPI_FUNCTION_ENTRY
argument_list|()
expr_stmt|;
comment|/*      * Just lock the entire namespace for the duration of the dump.      * We don't want any changes to the namespace during this time,      * especially the temporary nodes since we are going to display      * them also.      */
name|Status
operator|=
name|AcpiUtAcquireMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not acquire namespace mutex\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the max depth of the namespace tree, for formatting later */
operator|(
name|void
operator|)
name|AcpiNsWalkNamespace
argument_list|(
name|Type
argument_list|,
name|StartHandle
argument_list|,
name|MaxDepth
argument_list|,
name|ACPI_NS_WALK_NO_UNLOCK
operator||
name|ACPI_NS_WALK_TEMP_NODES
argument_list|,
name|AcpiNsGetMaxDepth
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|MaxLevel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now dump the entire namespace */
operator|(
name|void
operator|)
name|AcpiNsWalkNamespace
argument_list|(
name|Type
argument_list|,
name|StartHandle
argument_list|,
name|MaxDepth
argument_list|,
name|ACPI_NS_WALK_NO_UNLOCK
operator||
name|ACPI_NS_WALK_TEMP_NODES
argument_list|,
name|AcpiNsDumpOneObjectPath
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|MaxLevel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpEntry  *  * PARAMETERS:  Handle              - Node to be dumped  *              DebugLevel          - Output level  *  * RETURN:      None  *  * DESCRIPTION: Dump a single Node  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDumpEntry
parameter_list|(
name|ACPI_HANDLE
name|Handle
parameter_list|,
name|UINT32
name|DebugLevel
parameter_list|)
block|{
name|ACPI_WALK_INFO
name|Info
decl_stmt|;
name|ACPI_FUNCTION_ENTRY
argument_list|()
expr_stmt|;
name|Info
operator|.
name|DebugLevel
operator|=
name|DebugLevel
expr_stmt|;
name|Info
operator|.
name|OwnerId
operator|=
name|ACPI_OWNER_ID_MAX
expr_stmt|;
name|Info
operator|.
name|DisplayType
operator|=
name|ACPI_DISPLAY_SUMMARY
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiNsDumpOneObject
argument_list|(
name|Handle
argument_list|,
literal|1
argument_list|,
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_ASL_COMPILER
end_ifdef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiNsDumpTables  *  * PARAMETERS:  SearchBase          - Root of subtree to be dumped, or  *                                    NS_ALL to dump the entire namespace  *              MaxDepth            - Maximum depth of dump. Use INT_MAX  *                                    for an effectively unlimited depth.  *  * RETURN:      None  *  * DESCRIPTION: Dump the name space, or a portion of it.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiNsDumpTables
parameter_list|(
name|ACPI_HANDLE
name|SearchBase
parameter_list|,
name|UINT32
name|MaxDepth
parameter_list|)
block|{
name|ACPI_HANDLE
name|SearchHandle
init|=
name|SearchBase
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|NsDumpTables
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_RootNode
condition|)
block|{
comment|/*          * If the name space has not been initialized,          * there is nothing to dump.          */
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_TABLES
operator|,
literal|"namespace not initialized!\n"
operator|)
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
if|if
condition|(
name|ACPI_NS_ALL
operator|==
name|SearchBase
condition|)
block|{
comment|/* Entire namespace */
name|SearchHandle
operator|=
name|AcpiGbl_RootNode
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_TABLES
operator|,
literal|"\\\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|AcpiNsDumpObjects
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_DISPLAY_OBJECTS
argument_list|,
name|MaxDepth
argument_list|,
name|ACPI_OWNER_ID_MAX
argument_list|,
name|SearchHandle
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

