begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  *  * Module Name: dbnames - Debugger commands for the acpi namespace  *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2017, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdebug.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpredef.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DEBUGGER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dbnames"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkAndMatchName
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForPredefinedNames
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForSpecificObjects
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForObjectCounts
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbIntegrityWalk
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForReferences
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbBusWalk
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Arguments for the Objects command  * These object types map directly to the ACPI_TYPES  */
end_comment

begin_decl_stmt
specifier|static
name|ACPI_DB_ARGUMENT_INFO
name|AcpiDbObjectTypes
index|[]
init|=
block|{
block|{
literal|"ANY"
block|}
block|,
block|{
literal|"INTEGERS"
block|}
block|,
block|{
literal|"STRINGS"
block|}
block|,
block|{
literal|"BUFFERS"
block|}
block|,
block|{
literal|"PACKAGES"
block|}
block|,
block|{
literal|"FIELDS"
block|}
block|,
block|{
literal|"DEVICES"
block|}
block|,
block|{
literal|"EVENTS"
block|}
block|,
block|{
literal|"METHODS"
block|}
block|,
block|{
literal|"MUTEXES"
block|}
block|,
block|{
literal|"REGIONS"
block|}
block|,
block|{
literal|"POWERRESOURCES"
block|}
block|,
block|{
literal|"PROCESSORS"
block|}
block|,
block|{
literal|"THERMALZONES"
block|}
block|,
block|{
literal|"BUFFERFIELDS"
block|}
block|,
block|{
literal|"DDBHANDLES"
block|}
block|,
block|{
literal|"DEBUG"
block|}
block|,
block|{
literal|"REGIONFIELDS"
block|}
block|,
block|{
literal|"BANKFIELDS"
block|}
block|,
block|{
literal|"INDEXFIELDS"
block|}
block|,
block|{
literal|"REFERENCES"
block|}
block|,
block|{
literal|"ALIASES"
block|}
block|,
block|{
literal|"METHODALIASES"
block|}
block|,
block|{
literal|"NOTIFY"
block|}
block|,
block|{
literal|"ADDRESSHANDLER"
block|}
block|,
block|{
literal|"RESOURCE"
block|}
block|,
block|{
literal|"RESOURCEFIELD"
block|}
block|,
block|{
literal|"SCOPES"
block|}
block|,
block|{
name|NULL
block|}
comment|/* Must be null terminated */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbSetScope  *  * PARAMETERS:  Name                - New scope path  *  * RETURN:      Status  *  * DESCRIPTION: Set the "current scope" as maintained by this utility.  *              The scope is used as a prefix to ACPI paths.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbSetScope
parameter_list|(
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
if|if
condition|(
operator|!
name|Name
operator|||
name|Name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Current scope: %s\n"
argument_list|,
name|AcpiGbl_DbScopeBuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|AcpiDbPrepNamestring
argument_list|(
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_IS_ROOT_PREFIX
argument_list|(
name|Name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Validate new scope from the root */
name|Status
operator|=
name|AcpiNsGetNode
argument_list|(
name|AcpiGbl_RootNode
argument_list|,
name|Name
argument_list|,
name|ACPI_NS_NO_UPSEARCH
argument_list|,
operator|&
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|ErrorExit
goto|;
block|}
name|AcpiGbl_DbScopeBuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Validate new scope relative to old scope */
name|Status
operator|=
name|AcpiNsGetNode
argument_list|(
name|AcpiGbl_DbScopeNode
argument_list|,
name|Name
argument_list|,
name|ACPI_NS_NO_UPSEARCH
argument_list|,
operator|&
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|ErrorExit
goto|;
block|}
block|}
comment|/* Build the final pathname */
if|if
condition|(
name|AcpiUtSafeStrcat
argument_list|(
name|AcpiGbl_DbScopeBuf
argument_list|,
sizeof|sizeof
argument_list|(
name|AcpiGbl_DbScopeBuf
argument_list|)
argument_list|,
name|Name
argument_list|)
condition|)
block|{
name|Status
operator|=
name|AE_BUFFER_OVERFLOW
expr_stmt|;
goto|goto
name|ErrorExit
goto|;
block|}
if|if
condition|(
name|AcpiUtSafeStrcat
argument_list|(
name|AcpiGbl_DbScopeBuf
argument_list|,
sizeof|sizeof
argument_list|(
name|AcpiGbl_DbScopeBuf
argument_list|)
argument_list|,
literal|"\\"
argument_list|)
condition|)
block|{
name|Status
operator|=
name|AE_BUFFER_OVERFLOW
expr_stmt|;
goto|goto
name|ErrorExit
goto|;
block|}
name|AcpiGbl_DbScopeNode
operator|=
name|Node
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"New scope: %s\n"
argument_list|,
name|AcpiGbl_DbScopeBuf
argument_list|)
expr_stmt|;
return|return;
name|ErrorExit
label|:
name|AcpiOsPrintf
argument_list|(
literal|"Could not attach scope: %s, %s\n"
argument_list|,
name|Name
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbDumpNamespace  *  * PARAMETERS:  StartArg        - Node to begin namespace dump  *              DepthArg        - Maximum tree depth to be dumped  *  * RETURN:      None  *  * DESCRIPTION: Dump entire namespace or a subtree. Each node is displayed  *              with type and other information.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbDumpNamespace
parameter_list|(
name|char
modifier|*
name|StartArg
parameter_list|,
name|char
modifier|*
name|DepthArg
parameter_list|)
block|{
name|ACPI_HANDLE
name|SubtreeEntry
init|=
name|AcpiGbl_RootNode
decl_stmt|;
name|UINT32
name|MaxDepth
init|=
name|ACPI_UINT32_MAX
decl_stmt|;
comment|/* No argument given, just start at the root and dump entire namespace */
if|if
condition|(
name|StartArg
condition|)
block|{
name|SubtreeEntry
operator|=
name|AcpiDbConvertToNode
argument_list|(
name|StartArg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SubtreeEntry
condition|)
block|{
return|return;
block|}
comment|/* Now we can check for the depth argument */
if|if
condition|(
name|DepthArg
condition|)
block|{
name|MaxDepth
operator|=
name|strtoul
argument_list|(
name|DepthArg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_DUPLICATE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"ACPI Namespace (from %4.4s (%p) subtree):\n"
argument_list|,
operator|(
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|SubtreeEntry
operator|)
operator|->
name|Name
operator|.
name|Ascii
argument_list|,
name|SubtreeEntry
argument_list|)
expr_stmt|;
comment|/* Display the subtree */
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_REDIRECTABLE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiNsDumpObjects
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_DISPLAY_SUMMARY
argument_list|,
name|MaxDepth
argument_list|,
name|ACPI_OWNER_ID_MAX
argument_list|,
name|SubtreeEntry
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_CONSOLE_OUTPUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbDumpNamespacePaths  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Dump entire namespace with full object pathnames and object  *              type information. Alternative to "namespace" command.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbDumpNamespacePaths
parameter_list|(
name|void
parameter_list|)
block|{
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_DUPLICATE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"ACPI Namespace (from root):\n"
argument_list|)
expr_stmt|;
comment|/* Display the entire namespace */
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_REDIRECTABLE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiNsDumpObjectPaths
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_DISPLAY_SUMMARY
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|ACPI_OWNER_ID_MAX
argument_list|,
name|AcpiGbl_RootNode
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_CONSOLE_OUTPUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbDumpNamespaceByOwner  *  * PARAMETERS:  OwnerArg        - Owner ID whose nodes will be displayed  *              DepthArg        - Maximum tree depth to be dumped  *  * RETURN:      None  *  * DESCRIPTION: Dump elements of the namespace that are owned by the OwnerId.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbDumpNamespaceByOwner
parameter_list|(
name|char
modifier|*
name|OwnerArg
parameter_list|,
name|char
modifier|*
name|DepthArg
parameter_list|)
block|{
name|ACPI_HANDLE
name|SubtreeEntry
init|=
name|AcpiGbl_RootNode
decl_stmt|;
name|UINT32
name|MaxDepth
init|=
name|ACPI_UINT32_MAX
decl_stmt|;
name|ACPI_OWNER_ID
name|OwnerId
decl_stmt|;
name|OwnerId
operator|=
operator|(
name|ACPI_OWNER_ID
operator|)
name|strtoul
argument_list|(
name|OwnerArg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now we can check for the depth argument */
if|if
condition|(
name|DepthArg
condition|)
block|{
name|MaxDepth
operator|=
name|strtoul
argument_list|(
name|DepthArg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_DUPLICATE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"ACPI Namespace by owner %X:\n"
argument_list|,
name|OwnerId
argument_list|)
expr_stmt|;
comment|/* Display the subtree */
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_REDIRECTABLE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiNsDumpObjects
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_DISPLAY_SUMMARY
argument_list|,
name|MaxDepth
argument_list|,
name|OwnerId
argument_list|,
name|SubtreeEntry
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_CONSOLE_OUTPUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWalkAndMatchName  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Find a particular name/names within the namespace. Wildcards  *              are supported -- '?' matches any character.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkAndMatchName
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|char
modifier|*
name|RequestedName
init|=
operator|(
name|char
operator|*
operator|)
name|Context
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|ACPI_BUFFER
name|Buffer
decl_stmt|;
name|ACPI_WALK_INFO
name|Info
decl_stmt|;
comment|/* Check for a name match */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* Wildcard support */
if|if
condition|(
operator|(
name|RequestedName
index|[
name|i
index|]
operator|!=
literal|'?'
operator|)
operator|&&
operator|(
name|RequestedName
index|[
name|i
index|]
operator|!=
operator|(
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
operator|)
operator|->
name|Name
operator|.
name|Ascii
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* No match, just exit */
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
block|}
comment|/* Get the full pathname to this object */
name|Buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_LOCAL_BUFFER
expr_stmt|;
name|Status
operator|=
name|AcpiNsHandleToPathname
argument_list|(
name|ObjHandle
argument_list|,
operator|&
name|Buffer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could Not get pathname for object %p\n"
argument_list|,
name|ObjHandle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Info
operator|.
name|OwnerId
operator|=
name|ACPI_OWNER_ID_MAX
expr_stmt|;
name|Info
operator|.
name|DebugLevel
operator|=
name|ACPI_UINT32_MAX
expr_stmt|;
name|Info
operator|.
name|DisplayType
operator|=
name|ACPI_DISPLAY_SUMMARY
operator||
name|ACPI_DISPLAY_SHORT
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%32s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiNsDumpOneObject
argument_list|(
name|ObjHandle
argument_list|,
name|NestingLevel
argument_list|,
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbFindNameInNamespace  *  * PARAMETERS:  NameArg         - The 4-character ACPI name to find.  *                                wildcards are supported.  *  * RETURN:      None  *  * DESCRIPTION: Search the namespace for a given name (with wildcards)  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiDbFindNameInNamespace
parameter_list|(
name|char
modifier|*
name|NameArg
parameter_list|)
block|{
name|char
name|AcpiName
index|[
literal|5
index|]
init|=
literal|"____"
decl_stmt|;
name|char
modifier|*
name|AcpiNamePtr
init|=
name|AcpiName
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|NameArg
argument_list|)
operator|>
name|ACPI_NAME_SIZE
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Name must be no longer than 4 characters\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Pad out name with underscores as necessary to create a 4-char name */
name|AcpiUtStrupr
argument_list|(
name|NameArg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|NameArg
condition|)
block|{
operator|*
name|AcpiNamePtr
operator|=
operator|*
name|NameArg
expr_stmt|;
name|AcpiNamePtr
operator|++
expr_stmt|;
name|NameArg
operator|++
expr_stmt|;
block|}
comment|/* Walk the namespace from the root */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbWalkAndMatchName
argument_list|,
name|NULL
argument_list|,
name|AcpiName
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_CONSOLE_OUTPUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWalkForPredefinedNames  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Detect and display predefined ACPI names (names that start with  *              an underscore)  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForPredefinedNames
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
name|UINT32
modifier|*
name|Count
init|=
operator|(
name|UINT32
operator|*
operator|)
name|Context
decl_stmt|;
specifier|const
name|ACPI_PREDEFINED_INFO
modifier|*
name|Predefined
decl_stmt|;
specifier|const
name|ACPI_PREDEFINED_INFO
modifier|*
name|Package
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|Pathname
decl_stmt|;
name|char
name|StringBuffer
index|[
literal|48
index|]
decl_stmt|;
name|Predefined
operator|=
name|AcpiUtMatchPredefinedMethod
argument_list|(
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Predefined
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Pathname
operator|=
name|AcpiNsGetNormalizedPathname
argument_list|(
name|Node
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pathname
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* If method returns a package, the info is in the next table entry */
if|if
condition|(
name|Predefined
operator|->
name|Info
operator|.
name|ExpectedBtypes
operator|&
name|ACPI_RTYPE_PACKAGE
condition|)
block|{
name|Package
operator|=
name|Predefined
operator|+
literal|1
expr_stmt|;
block|}
name|AcpiUtGetExpectedReturnTypes
argument_list|(
name|StringBuffer
argument_list|,
name|Predefined
operator|->
name|Info
operator|.
name|ExpectedBtypes
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%-32s Arguments %X, Return Types: %s"
argument_list|,
name|Pathname
argument_list|,
name|METHOD_GET_ARG_COUNT
argument_list|(
name|Predefined
operator|->
name|Info
operator|.
name|ArgumentList
argument_list|)
argument_list|,
name|StringBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|Package
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" (PkgType %2.2X, ObjType %2.2X, Count %2.2X)"
argument_list|,
name|Package
operator|->
name|RetInfo
operator|.
name|Type
argument_list|,
name|Package
operator|->
name|RetInfo
operator|.
name|ObjectType1
argument_list|,
name|Package
operator|->
name|RetInfo
operator|.
name|Count1
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Check that the declared argument count matches the ACPI spec */
name|AcpiNsCheckAcpiCompliance
argument_list|(
name|Pathname
argument_list|,
name|Node
argument_list|,
name|Predefined
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
operator|(
operator|*
name|Count
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbCheckPredefinedNames  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Validate all predefined names in the namespace  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbCheckPredefinedNames
parameter_list|(
name|void
parameter_list|)
block|{
name|UINT32
name|Count
init|=
literal|0
decl_stmt|;
comment|/* Search all nodes in namespace */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbWalkForPredefinedNames
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|Count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"Found %u predefined names in the namespace\n"
argument_list|,
name|Count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWalkForObjectCounts  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Display short info about objects in the namespace  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForObjectCounts
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_OBJECT_INFO
modifier|*
name|Info
init|=
operator|(
name|ACPI_OBJECT_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
if|if
condition|(
name|Node
operator|->
name|Type
operator|>
name|ACPI_TYPE_NS_NODE_MAX
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"[%4.4s]: Unknown object type %X\n"
argument_list|,
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|,
name|Node
operator|->
name|Type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Info
operator|->
name|Types
index|[
name|Node
operator|->
name|Type
index|]
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWalkForSpecificObjects  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Display short info about objects in the namespace  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForSpecificObjects
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_WALK_INFO
modifier|*
name|Info
init|=
operator|(
name|ACPI_WALK_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_BUFFER
name|Buffer
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|Info
operator|->
name|Count
operator|++
expr_stmt|;
comment|/* Get and display the full pathname to this object */
name|Buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_LOCAL_BUFFER
expr_stmt|;
name|Status
operator|=
name|AcpiNsHandleToPathname
argument_list|(
name|ObjHandle
argument_list|,
operator|&
name|Buffer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could Not get pathname for object %p\n"
argument_list|,
name|ObjHandle
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"%32s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
comment|/* Dump short info about the object */
operator|(
name|void
operator|)
name|AcpiNsDumpOneObject
argument_list|(
name|ObjHandle
argument_list|,
name|NestingLevel
argument_list|,
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbDisplayObjects  *  * PARAMETERS:  ObjTypeArg          - Type of object to display  *              DisplayCountArg     - Max depth to display  *  * RETURN:      None  *  * DESCRIPTION: Display objects in the namespace of the requested type  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiDbDisplayObjects
parameter_list|(
name|char
modifier|*
name|ObjTypeArg
parameter_list|,
name|char
modifier|*
name|DisplayCountArg
parameter_list|)
block|{
name|ACPI_WALK_INFO
name|Info
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|Type
decl_stmt|;
name|ACPI_OBJECT_INFO
modifier|*
name|ObjectInfo
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|UINT32
name|TotalObjects
init|=
literal|0
decl_stmt|;
comment|/* No argument means display summary/count of all object types */
if|if
condition|(
operator|!
name|ObjTypeArg
condition|)
block|{
name|ObjectInfo
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_OBJECT_INFO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk the namespace from the root */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbWalkForObjectCounts
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ObjectInfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\nSummary of namespace objects:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ACPI_TOTAL_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"%8u   %s\n"
argument_list|,
name|ObjectInfo
operator|->
name|Types
index|[
name|i
index|]
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|TotalObjects
operator|+=
name|ObjectInfo
operator|->
name|Types
index|[
name|i
index|]
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n%8u   Total namespace objects\n\n"
argument_list|,
name|TotalObjects
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|ObjectInfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Get the object type */
name|Type
operator|=
name|AcpiDbMatchArgument
argument_list|(
name|ObjTypeArg
argument_list|,
name|AcpiDbObjectTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_NOT_FOUND
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid or unsupported argument\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_DUPLICATE_OUTPUT
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"Objects of type [%s] defined in the current ACPI Namespace:\n"
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_REDIRECTABLE_OUTPUT
argument_list|)
expr_stmt|;
name|Info
operator|.
name|Count
operator|=
literal|0
expr_stmt|;
name|Info
operator|.
name|OwnerId
operator|=
name|ACPI_OWNER_ID_MAX
expr_stmt|;
name|Info
operator|.
name|DebugLevel
operator|=
name|ACPI_UINT32_MAX
expr_stmt|;
name|Info
operator|.
name|DisplayType
operator|=
name|ACPI_DISPLAY_SUMMARY
operator||
name|ACPI_DISPLAY_SHORT
expr_stmt|;
comment|/* Walk the namespace from the root */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|Type
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbWalkForSpecificObjects
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"\nFound %u objects of type [%s] in the current ACPI Namespace\n"
argument_list|,
name|Info
operator|.
name|Count
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiDbSetOutputDestination
argument_list|(
name|ACPI_DB_CONSOLE_OUTPUT
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbIntegrityWalk  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Examine one NS node for valid values.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbIntegrityWalk
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_INTEGRITY_INFO
modifier|*
name|Info
init|=
operator|(
name|ACPI_INTEGRITY_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|Object
decl_stmt|;
name|BOOLEAN
name|Alias
init|=
name|TRUE
decl_stmt|;
name|Info
operator|->
name|Nodes
operator|++
expr_stmt|;
comment|/* Verify the NS node, and dereference aliases */
while|while
condition|(
name|Alias
condition|)
block|{
if|if
condition|(
name|ACPI_GET_DESCRIPTOR_TYPE
argument_list|(
name|Node
argument_list|)
operator|!=
name|ACPI_DESC_TYPE_NAMED
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid Descriptor Type for Node %p [%s] - "
literal|"is %2.2X should be %2.2X\n"
argument_list|,
name|Node
argument_list|,
name|AcpiUtGetDescriptorName
argument_list|(
name|Node
argument_list|)
argument_list|,
name|ACPI_GET_DESCRIPTOR_TYPE
argument_list|(
name|Node
argument_list|)
argument_list|,
name|ACPI_DESC_TYPE_NAMED
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_ALIAS
operator|)
operator|||
operator|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_METHOD_ALIAS
operator|)
condition|)
block|{
name|Node
operator|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|Node
operator|->
name|Object
expr_stmt|;
block|}
else|else
block|{
name|Alias
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Node
operator|->
name|Type
operator|>
name|ACPI_TYPE_LOCAL_MAX
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid Object Type for Node %p, Type = %X\n"
argument_list|,
name|Node
argument_list|,
name|Node
operator|->
name|Type
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|AcpiUtValidNameseg
argument_list|(
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid AcpiName for Node %p\n"
argument_list|,
name|Node
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Object
operator|=
name|AcpiNsGetAttachedObject
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|Object
condition|)
block|{
name|Info
operator|->
name|Objects
operator|++
expr_stmt|;
if|if
condition|(
name|ACPI_GET_DESCRIPTOR_TYPE
argument_list|(
name|Object
argument_list|)
operator|!=
name|ACPI_DESC_TYPE_OPERAND
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid Descriptor Type for Object %p [%s]\n"
argument_list|,
name|Object
argument_list|,
name|AcpiUtGetDescriptorName
argument_list|(
name|Object
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbCheckIntegrity  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Check entire namespace for data structure integrity  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbCheckIntegrity
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_INTEGRITY_INFO
name|Info
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Search all nodes in namespace */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbIntegrityWalk
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"Verified %u namespace nodes with %u Objects\n"
argument_list|,
name|Info
operator|.
name|Nodes
argument_list|,
name|Info
operator|.
name|Objects
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWalkForReferences  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Check if this namespace object refers to the target object  *              that is passed in as the context value.  *  * Note: Currently doesn't check subobjects within the Node's object  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWalkForReferences
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
init|=
operator|(
name|ACPI_OPERAND_OBJECT
operator|*
operator|)
name|Context
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
comment|/* Check for match against the namespace node itself */
if|if
condition|(
name|Node
operator|==
operator|(
name|void
operator|*
operator|)
name|ObjDesc
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Object is a Node [%4.4s]\n"
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for match against the object attached to the node */
if|if
condition|(
name|AcpiNsGetAttachedObject
argument_list|(
name|Node
argument_list|)
operator|==
name|ObjDesc
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Reference at Node->Object %p [%4.4s]\n"
argument_list|,
name|Node
argument_list|,
name|AcpiUtGetNodeName
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbFindReferences  *  * PARAMETERS:  ObjectArg       - String with hex value of the object  *  * RETURN:      None  *  * DESCRIPTION: Search namespace for all references to the input object  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbFindReferences
parameter_list|(
name|char
modifier|*
name|ObjectArg
parameter_list|)
block|{
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
name|ACPI_SIZE
name|Address
decl_stmt|;
comment|/* Convert string to object pointer */
name|Address
operator|=
name|strtoul
argument_list|(
name|ObjectArg
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ObjDesc
operator|=
name|ACPI_TO_POINTER
argument_list|(
name|Address
argument_list|)
expr_stmt|;
comment|/* Search all nodes in namespace */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbWalkForReferences
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ObjDesc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbBusWalk  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Display info about device objects that have a corresponding  *              _PRT method.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbBusWalk
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_BUFFER
name|Buffer
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|TempNode
decl_stmt|;
name|ACPI_DEVICE_INFO
modifier|*
name|Info
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|Node
operator|->
name|Type
operator|!=
name|ACPI_TYPE_DEVICE
operator|)
operator|&&
operator|(
name|Node
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PROCESSOR
operator|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Exit if there is no _PRT under this device */
name|Status
operator|=
name|AcpiGetHandle
argument_list|(
name|Node
argument_list|,
name|METHOD_NAME__PRT
argument_list|,
name|ACPI_CAST_PTR
argument_list|(
name|ACPI_HANDLE
argument_list|,
operator|&
name|TempNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Get the full path to this device object */
name|Buffer
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_LOCAL_BUFFER
expr_stmt|;
name|Status
operator|=
name|AcpiNsHandleToPathname
argument_list|(
name|ObjHandle
argument_list|,
operator|&
name|Buffer
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could Not get pathname for object %p\n"
argument_list|,
name|ObjHandle
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Status
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|ObjHandle
argument_list|,
operator|&
name|Info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Display the full path */
name|AcpiOsPrintf
argument_list|(
literal|"%-32s Type %X"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buffer
operator|.
name|Pointer
argument_list|,
name|Node
operator|->
name|Type
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Buffer
operator|.
name|Pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|Info
operator|->
name|Flags
operator|&
name|ACPI_PCI_ROOT_BRIDGE
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"  - Is PCI Root Bridge"
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* _PRT info */
name|AcpiOsPrintf
argument_list|(
literal|"_PRT: %p\n"
argument_list|,
name|TempNode
argument_list|)
expr_stmt|;
comment|/* Dump _ADR, _HID, _UID, _CID */
if|if
condition|(
name|Info
operator|->
name|Valid
operator|&
name|ACPI_VALID_ADR
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_ADR: %8.8X%8.8X\n"
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Info
operator|->
name|Address
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_ADR:<Not Present>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Info
operator|->
name|Valid
operator|&
name|ACPI_VALID_HID
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_HID: %s\n"
argument_list|,
name|Info
operator|->
name|HardwareId
operator|.
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_HID:<Not Present>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Info
operator|->
name|Valid
operator|&
name|ACPI_VALID_UID
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_UID: %s\n"
argument_list|,
name|Info
operator|->
name|UniqueId
operator|.
name|String
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_UID:<Not Present>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Info
operator|->
name|Valid
operator|&
name|ACPI_VALID_CID
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Info
operator|->
name|CompatibleIdList
operator|.
name|Count
condition|;
name|i
operator|++
control|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_CID: %s\n"
argument_list|,
name|Info
operator|->
name|CompatibleIdList
operator|.
name|Ids
index|[
name|i
index|]
operator|.
name|String
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|"_CID:<Not Present>\n"
argument_list|)
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|Info
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbGetBusInfo  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Display info about system busses.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbGetBusInfo
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Search all nodes in namespace */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbBusWalk
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

