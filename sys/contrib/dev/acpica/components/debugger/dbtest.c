begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*******************************************************************************  *  * Module Name: dbtest - Various debug-related tests  *  ******************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2014, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdebug.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpredef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
end_ifdef

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DEBUGGER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dbtest"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|AcpiDbTestAllObjects
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbTestOneObject
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbTestIntegerType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|BitLength
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbTestBufferType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|BitLength
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbTestStringType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|ByteLength
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbReadFromObject
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|ACPI_OBJECT_TYPE
name|ExpectedType
parameter_list|,
name|ACPI_OBJECT
modifier|*
modifier|*
name|Value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbWriteToObject
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|ACPI_OBJECT
modifier|*
name|Value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDbEvaluateAllPredefinedNames
parameter_list|(
name|char
modifier|*
name|CountArg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDbEvaluateOnePredefinedName
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Test subcommands  */
end_comment

begin_decl_stmt
specifier|static
name|ACPI_DB_ARGUMENT_INFO
name|AcpiDbTestTypes
index|[]
init|=
block|{
block|{
literal|"OBJECTS"
block|}
block|,
block|{
literal|"PREDEFINED"
block|}
block|,
block|{
name|NULL
block|}
comment|/* Must be null terminated */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CMD_TEST_OBJECTS
value|0
end_define

begin_define
define|#
directive|define
name|CMD_TEST_PREDEFINED
value|1
end_define

begin_define
define|#
directive|define
name|BUFFER_FILL_VALUE
value|0xFF
end_define

begin_comment
comment|/*  * Support for the special debugger read/write control methods.  * These methods are installed into the current namespace and are  * used to read and write the various namespace objects. The point  * is to force the AML interpreter do all of the work.  */
end_comment

begin_define
define|#
directive|define
name|ACPI_DB_READ_METHOD
value|"\\_T98"
end_define

begin_define
define|#
directive|define
name|ACPI_DB_WRITE_METHOD
value|"\\_T99"
end_define

begin_decl_stmt
specifier|static
name|ACPI_HANDLE
name|ReadHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ACPI_HANDLE
name|WriteHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ASL Definitions of the debugger read/write control methods */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|DefinitionBlock ("ssdt.aml", "SSDT", 2, "Intel", "DEBUG", 0x00000001) {     Method (_T98, 1, NotSerialized)
comment|/* Read */
end_comment

begin_comment
unit|{         Return (DeRefOf (Arg0))     } } DefinitionBlock ("ssdt2.aml", "SSDT", 2, "Intel", "DEBUG", 0x00000001) {     Method (_T99, 2, NotSerialized)
comment|/* Write */
end_comment

begin_endif
unit|{         Store (Arg1, Arg0)     } }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ReadMethodCode
index|[]
init|=
block|{
literal|0x53
block|,
literal|0x53
block|,
literal|0x44
block|,
literal|0x54
block|,
literal|0x2E
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 00000000    "SSDT...." */
literal|0x02
block|,
literal|0xC9
block|,
literal|0x49
block|,
literal|0x6E
block|,
literal|0x74
block|,
literal|0x65
block|,
literal|0x6C
block|,
literal|0x00
block|,
comment|/* 00000008    "..Intel." */
literal|0x44
block|,
literal|0x45
block|,
literal|0x42
block|,
literal|0x55
block|,
literal|0x47
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 00000010    "DEBUG..." */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x49
block|,
literal|0x4E
block|,
literal|0x54
block|,
literal|0x4C
block|,
comment|/* 00000018    "....INTL" */
literal|0x18
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x20
block|,
literal|0x14
block|,
literal|0x09
block|,
literal|0x5F
block|,
literal|0x54
block|,
comment|/* 00000020    "... .._T" */
literal|0x39
block|,
literal|0x38
block|,
literal|0x01
block|,
literal|0xA4
block|,
literal|0x83
block|,
literal|0x68
comment|/* 00000028    "98...h"   */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|WriteMethodCode
index|[]
init|=
block|{
literal|0x53
block|,
literal|0x53
block|,
literal|0x44
block|,
literal|0x54
block|,
literal|0x2E
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 00000000    "SSDT...." */
literal|0x02
block|,
literal|0x15
block|,
literal|0x49
block|,
literal|0x6E
block|,
literal|0x74
block|,
literal|0x65
block|,
literal|0x6C
block|,
literal|0x00
block|,
comment|/* 00000008    "..Intel." */
literal|0x44
block|,
literal|0x45
block|,
literal|0x42
block|,
literal|0x55
block|,
literal|0x47
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* 00000010    "DEBUG..." */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x49
block|,
literal|0x4E
block|,
literal|0x54
block|,
literal|0x4C
block|,
comment|/* 00000018    "....INTL" */
literal|0x18
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x20
block|,
literal|0x14
block|,
literal|0x09
block|,
literal|0x5F
block|,
literal|0x54
block|,
comment|/* 00000020    "... .._T" */
literal|0x39
block|,
literal|0x39
block|,
literal|0x02
block|,
literal|0x70
block|,
literal|0x69
block|,
literal|0x68
comment|/* 00000028    "99.pih"   */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbExecuteTest  *  * PARAMETERS:  TypeArg         - Subcommand  *  * RETURN:      None  *  * DESCRIPTION: Execute various debug tests.  *  * Note: Code is prepared for future expansion of the TEST command.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDbExecuteTest
parameter_list|(
name|char
modifier|*
name|TypeArg
parameter_list|)
block|{
name|UINT32
name|Temp
decl_stmt|;
name|AcpiUtStrupr
argument_list|(
name|TypeArg
argument_list|)
expr_stmt|;
name|Temp
operator|=
name|AcpiDbMatchArgument
argument_list|(
name|TypeArg
argument_list|,
name|AcpiDbTestTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|Temp
operator|==
name|ACPI_TYPE_NOT_FOUND
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Invalid or unsupported argument\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|Temp
condition|)
block|{
case|case
name|CMD_TEST_OBJECTS
case|:
name|AcpiDbTestAllObjects
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_TEST_PREDEFINED
case|:
name|AcpiDbEvaluateAllPredefinedNames
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbTestAllObjects  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: This test implements the OBJECTS subcommand. It exercises the  *              namespace by reading/writing/comparing all data objects such  *              as integers, strings, buffers, fields, buffer fields, etc.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDbTestAllObjects
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
comment|/* Install the debugger read-object control method if necessary */
if|if
condition|(
operator|!
name|ReadHandle
condition|)
block|{
name|Status
operator|=
name|AcpiInstallMethod
argument_list|(
name|ReadMethodCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"%s, Could not install debugger read method\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Status
operator|=
name|AcpiGetHandle
argument_list|(
name|NULL
argument_list|,
name|ACPI_DB_READ_METHOD
argument_list|,
operator|&
name|ReadHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not obtain handle for debug method %s\n"
argument_list|,
name|ACPI_DB_READ_METHOD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Install the debugger write-object control method if necessary */
if|if
condition|(
operator|!
name|WriteHandle
condition|)
block|{
name|Status
operator|=
name|AcpiInstallMethod
argument_list|(
name|WriteMethodCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"%s, Could not install debugger write method\n"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Status
operator|=
name|AcpiGetHandle
argument_list|(
name|NULL
argument_list|,
name|ACPI_DB_WRITE_METHOD
argument_list|,
operator|&
name|WriteHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not obtain handle for debug method %s\n"
argument_list|,
name|ACPI_DB_WRITE_METHOD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Walk the entire namespace, testing each supported named data object */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbTestOneObject
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbTestOneObject  *  * PARAMETERS:  ACPI_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Test one namespace object. Supported types are Integer,  *              String, Buffer, BufferField, and FieldUnit. All other object  *              types are simply ignored.  *  *              Note: Support for Packages is not implemented.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbTestOneObject
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|RegionObj
decl_stmt|;
name|ACPI_OBJECT_TYPE
name|LocalType
decl_stmt|;
name|UINT32
name|BitLength
init|=
literal|0
decl_stmt|;
name|UINT32
name|ByteLength
init|=
literal|0
decl_stmt|;
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|Node
operator|=
name|ACPI_CAST_PTR
argument_list|(
name|ACPI_NAMESPACE_NODE
argument_list|,
name|ObjHandle
argument_list|)
expr_stmt|;
name|ObjDesc
operator|=
name|Node
operator|->
name|Object
expr_stmt|;
comment|/*      * For the supported types, get the actual bit length or      * byte length. Map the type to one of Integer/String/Buffer.      */
switch|switch
condition|(
name|Node
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
comment|/* Integer width is either 32 or 64 */
name|LocalType
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|BitLength
operator|=
name|AcpiGbl_IntegerBitWidth
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_STRING
case|:
name|LocalType
operator|=
name|ACPI_TYPE_STRING
expr_stmt|;
name|ByteLength
operator|=
name|ObjDesc
operator|->
name|String
operator|.
name|Length
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_BUFFER
case|:
name|LocalType
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|ByteLength
operator|=
name|ObjDesc
operator|->
name|Buffer
operator|.
name|Length
expr_stmt|;
name|BitLength
operator|=
name|ByteLength
operator|*
literal|8
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_FIELD_UNIT
case|:
case|case
name|ACPI_TYPE_BUFFER_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_INDEX_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_BANK_FIELD
case|:
name|LocalType
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
if|if
condition|(
name|ObjDesc
condition|)
block|{
comment|/*              * Returned object will be a Buffer if the field length              * is larger than the size of an Integer (32 or 64 bits              * depending on the DSDT version).              */
name|BitLength
operator|=
name|ObjDesc
operator|->
name|CommonField
operator|.
name|BitLength
expr_stmt|;
name|ByteLength
operator|=
name|ACPI_ROUND_BITS_UP_TO_BYTES
argument_list|(
name|BitLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitLength
operator|>
name|AcpiGbl_IntegerBitWidth
condition|)
block|{
name|LocalType
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* Ignore all other types */
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Emit the common prefix: Type:Name */
name|AcpiOsPrintf
argument_list|(
literal|"%14s: %4.4s"
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Node
operator|->
name|Type
argument_list|)
argument_list|,
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ObjDesc
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" Ignoring, no attached object\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/*      * Check for unsupported region types. Note: AcpiExec simulates      * access to SystemMemory, SystemIO, PCI_Config, and EC.      */
switch|switch
condition|(
name|Node
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
name|RegionObj
operator|=
name|ObjDesc
operator|->
name|Field
operator|.
name|RegionObj
expr_stmt|;
switch|switch
condition|(
name|RegionObj
operator|->
name|Region
operator|.
name|SpaceId
condition|)
block|{
case|case
name|ACPI_ADR_SPACE_SYSTEM_MEMORY
case|:
case|case
name|ACPI_ADR_SPACE_SYSTEM_IO
case|:
case|case
name|ACPI_ADR_SPACE_PCI_CONFIG
case|:
case|case
name|ACPI_ADR_SPACE_EC
case|:
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|"      %s space is not supported [%4.4s]\n"
argument_list|,
name|AcpiUtGetRegionName
argument_list|(
name|RegionObj
operator|->
name|Region
operator|.
name|SpaceId
argument_list|)
argument_list|,
name|RegionObj
operator|->
name|Region
operator|.
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* At this point, we have resolved the object to one of the major types */
switch|switch
condition|(
name|LocalType
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
name|Status
operator|=
name|AcpiDbTestIntegerType
argument_list|(
name|Node
argument_list|,
name|BitLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_STRING
case|:
name|Status
operator|=
name|AcpiDbTestStringType
argument_list|(
name|Node
argument_list|,
name|ByteLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_BUFFER
case|:
name|Status
operator|=
name|AcpiDbTestBufferType
argument_list|(
name|Node
argument_list|,
name|BitLength
argument_list|)
expr_stmt|;
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|" Ignoring, type not implemented (%2.2X)"
argument_list|,
name|LocalType
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Node
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
name|RegionObj
operator|=
name|ObjDesc
operator|->
name|Field
operator|.
name|RegionObj
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|" (%s)"
argument_list|,
name|AcpiUtGetRegionName
argument_list|(
name|RegionObj
operator|->
name|Region
operator|.
name|SpaceId
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbTestIntegerType  *  * PARAMETERS:  Node                - Parent NS node for the object  *              BitLength           - Actual length of the object. Used for  *                                    support of arbitrary length FieldUnit  *                                    and BufferField objects.  *  * RETURN:      Status  *  * DESCRIPTION: Test read/write for an Integer-valued object. Performs a  *              write/read/compare of an arbitrary new value, then performs  *              a write/read/compare of the original value.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbTestIntegerType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|BitLength
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|Temp1
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp2
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp3
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
name|WriteValue
decl_stmt|;
name|UINT64
name|ValueToWrite
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
if|if
condition|(
name|BitLength
operator|>
literal|64
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" Invalid length for an Integer: %u"
argument_list|,
name|BitLength
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Read the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_INTEGER
argument_list|,
operator|&
name|Temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|" (%4.4X/%3.3X) %8.8X%8.8X"
argument_list|,
name|BitLength
argument_list|,
name|ACPI_ROUND_BITS_UP_TO_BYTES
argument_list|(
name|BitLength
argument_list|)
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Temp1
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|)
expr_stmt|;
name|ValueToWrite
operator|=
name|ACPI_UINT64_MAX
operator|>>
operator|(
literal|64
operator|-
name|BitLength
operator|)
expr_stmt|;
if|if
condition|(
name|Temp1
operator|->
name|Integer
operator|.
name|Value
operator|==
name|ValueToWrite
condition|)
block|{
name|ValueToWrite
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write a new value */
name|WriteValue
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|WriteValue
operator|.
name|Integer
operator|.
name|Value
operator|=
name|ValueToWrite
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the new value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_INTEGER
argument_list|,
operator|&
name|Temp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|Temp2
operator|->
name|Integer
operator|.
name|Value
operator|!=
name|ValueToWrite
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 2: %8.8X%8.8X, expecting %8.8X%8.8X"
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Temp2
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|ValueToWrite
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write back the original value */
name|WriteValue
operator|.
name|Integer
operator|.
name|Value
operator|=
name|Temp1
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_INTEGER
argument_list|,
operator|&
name|Temp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|Temp3
operator|->
name|Integer
operator|.
name|Value
operator|!=
name|Temp1
operator|->
name|Integer
operator|.
name|Value
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 3: %8.8X%8.8X, expecting %8.8X%8.8X"
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Temp3
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|,
name|ACPI_FORMAT_UINT64
argument_list|(
name|Temp1
operator|->
name|Integer
operator|.
name|Value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|Temp1
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp2
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp3
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbTestBufferType  *  * PARAMETERS:  Node                - Parent NS node for the object  *              BitLength           - Actual length of the object.  *  * RETURN:      Status  *  * DESCRIPTION: Test read/write for an Buffer-valued object. Performs a  *              write/read/compare of an arbitrary new value, then performs  *              a write/read/compare of the original value.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbTestBufferType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|BitLength
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|Temp1
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp2
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp3
init|=
name|NULL
decl_stmt|;
name|UINT8
modifier|*
name|Buffer
decl_stmt|;
name|ACPI_OBJECT
name|WriteValue
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT32
name|ByteLength
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|UINT8
name|ExtraBits
decl_stmt|;
name|ByteLength
operator|=
name|ACPI_ROUND_BITS_UP_TO_BYTES
argument_list|(
name|BitLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|ByteLength
operator|==
literal|0
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" Ignoring zero length buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Allocate a local buffer */
name|Buffer
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|ByteLength
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Buffer
condition|)
block|{
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
comment|/* Read the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_BUFFER
argument_list|,
operator|&
name|Temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Emit a few bytes of the buffer */
name|AcpiOsPrintf
argument_list|(
literal|" (%4.4X/%3.3X)"
argument_list|,
name|BitLength
argument_list|,
name|Temp1
operator|->
name|Buffer
operator|.
name|Length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
literal|4
operator|)
operator|&&
operator|(
name|i
operator|<
name|ByteLength
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" %2.2X"
argument_list|,
name|Temp1
operator|->
name|Buffer
operator|.
name|Pointer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"...  "
argument_list|)
expr_stmt|;
comment|/*      * Write a new value.      *      * Handle possible extra bits at the end of the buffer. Can      * happen for FieldUnits larger than an integer, but the bit      * count is not an integral number of bytes. Zero out the      * unused bits.      */
name|ACPI_MEMSET
argument_list|(
name|Buffer
argument_list|,
name|BUFFER_FILL_VALUE
argument_list|,
name|ByteLength
argument_list|)
expr_stmt|;
name|ExtraBits
operator|=
name|BitLength
operator|%
literal|8
expr_stmt|;
if|if
condition|(
name|ExtraBits
condition|)
block|{
name|Buffer
index|[
name|ByteLength
operator|-
literal|1
index|]
operator|=
name|ACPI_MASK_BITS_ABOVE
argument_list|(
name|ExtraBits
argument_list|)
expr_stmt|;
block|}
name|WriteValue
operator|.
name|Type
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|WriteValue
operator|.
name|Buffer
operator|.
name|Length
operator|=
name|ByteLength
expr_stmt|;
name|WriteValue
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
name|Buffer
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the new value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_BUFFER
argument_list|,
operator|&
name|Temp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ACPI_MEMCMP
argument_list|(
name|Temp2
operator|->
name|Buffer
operator|.
name|Pointer
argument_list|,
name|Buffer
argument_list|,
name|ByteLength
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 2: New buffer value"
argument_list|)
expr_stmt|;
block|}
comment|/* Write back the original value */
name|WriteValue
operator|.
name|Buffer
operator|.
name|Length
operator|=
name|ByteLength
expr_stmt|;
name|WriteValue
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
name|Temp1
operator|->
name|Buffer
operator|.
name|Pointer
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_BUFFER
argument_list|,
operator|&
name|Temp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ACPI_MEMCMP
argument_list|(
name|Temp1
operator|->
name|Buffer
operator|.
name|Pointer
argument_list|,
name|Temp3
operator|->
name|Buffer
operator|.
name|Pointer
argument_list|,
name|ByteLength
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 3: While restoring original buffer"
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|ACPI_FREE
argument_list|(
name|Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|Temp1
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp2
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp3
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbTestStringType  *  * PARAMETERS:  Node                - Parent NS node for the object  *              ByteLength          - Actual length of the object.  *  * RETURN:      Status  *  * DESCRIPTION: Test read/write for an String-valued object. Performs a  *              write/read/compare of an arbitrary new value, then performs  *              a write/read/compare of the original value.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbTestStringType
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT32
name|ByteLength
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|Temp1
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp2
init|=
name|NULL
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|Temp3
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ValueToWrite
init|=
literal|"Test String from AML Debugger"
decl_stmt|;
name|ACPI_OBJECT
name|WriteValue
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
comment|/* Read the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_STRING
argument_list|,
operator|&
name|Temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|" (%4.4X/%3.3X) \"%s\""
argument_list|,
operator|(
name|Temp1
operator|->
name|String
operator|.
name|Length
operator|*
literal|8
operator|)
argument_list|,
name|Temp1
operator|->
name|String
operator|.
name|Length
argument_list|,
name|Temp1
operator|->
name|String
operator|.
name|Pointer
argument_list|)
expr_stmt|;
comment|/* Write a new value */
name|WriteValue
operator|.
name|Type
operator|=
name|ACPI_TYPE_STRING
expr_stmt|;
name|WriteValue
operator|.
name|String
operator|.
name|Length
operator|=
name|ACPI_STRLEN
argument_list|(
name|ValueToWrite
argument_list|)
expr_stmt|;
name|WriteValue
operator|.
name|String
operator|.
name|Pointer
operator|=
name|ValueToWrite
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the new value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_STRING
argument_list|,
operator|&
name|Temp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ACPI_STRCMP
argument_list|(
name|Temp2
operator|->
name|String
operator|.
name|Pointer
argument_list|,
name|ValueToWrite
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 2: %s, expecting %s"
argument_list|,
name|Temp2
operator|->
name|String
operator|.
name|Pointer
argument_list|,
name|ValueToWrite
argument_list|)
expr_stmt|;
block|}
comment|/* Write back the original value */
name|WriteValue
operator|.
name|String
operator|.
name|Length
operator|=
name|ACPI_STRLEN
argument_list|(
name|Temp1
operator|->
name|String
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|WriteValue
operator|.
name|String
operator|.
name|Pointer
operator|=
name|Temp1
operator|->
name|String
operator|.
name|Pointer
expr_stmt|;
name|Status
operator|=
name|AcpiDbWriteToObject
argument_list|(
name|Node
argument_list|,
operator|&
name|WriteValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
comment|/* Ensure that we can read back the original value */
name|Status
operator|=
name|AcpiDbReadFromObject
argument_list|(
name|Node
argument_list|,
name|ACPI_TYPE_STRING
argument_list|,
operator|&
name|Temp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ACPI_STRCMP
argument_list|(
name|Temp1
operator|->
name|String
operator|.
name|Pointer
argument_list|,
name|Temp3
operator|->
name|String
operator|.
name|Pointer
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" MISMATCH 3: %s, expecting %s"
argument_list|,
name|Temp3
operator|->
name|String
operator|.
name|Pointer
argument_list|,
name|Temp1
operator|->
name|String
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|Temp1
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp2
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Temp3
condition|)
block|{
name|AcpiOsFree
argument_list|(
name|Temp3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbReadFromObject  *  * PARAMETERS:  Node                - Parent NS node for the object  *              ExpectedType        - Object type expected from the read  *              Value               - Where the value read is returned  *  * RETURN:      Status  *  * DESCRIPTION: Performs a read from the specified object by invoking the  *              special debugger control method that reads the object. Thus,  *              the AML interpreter is doing all of the work, increasing the  *              validity of the test.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbReadFromObject
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|ACPI_OBJECT_TYPE
name|ExpectedType
parameter_list|,
name|ACPI_OBJECT
modifier|*
modifier|*
name|Value
parameter_list|)
block|{
name|ACPI_OBJECT
modifier|*
name|RetValue
decl_stmt|;
name|ACPI_OBJECT_LIST
name|ParamObjects
decl_stmt|;
name|ACPI_OBJECT
name|Params
index|[
literal|2
index|]
decl_stmt|;
name|ACPI_BUFFER
name|ReturnObj
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_LOCAL_REFERENCE
expr_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Reference
operator|.
name|ActualType
operator|=
name|Node
operator|->
name|Type
expr_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Reference
operator|.
name|Handle
operator|=
name|ACPI_CAST_PTR
argument_list|(
name|ACPI_HANDLE
argument_list|,
name|Node
argument_list|)
expr_stmt|;
name|ParamObjects
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|ParamObjects
operator|.
name|Pointer
operator|=
name|Params
expr_stmt|;
name|ReturnObj
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|AcpiGbl_MethodExecuting
operator|=
name|TRUE
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|ReadHandle
argument_list|,
name|NULL
argument_list|,
operator|&
name|ParamObjects
argument_list|,
operator|&
name|ReturnObj
argument_list|)
expr_stmt|;
name|AcpiGbl_MethodExecuting
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not read from object, %s"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|RetValue
operator|=
operator|(
name|ACPI_OBJECT
operator|*
operator|)
name|ReturnObj
operator|.
name|Pointer
expr_stmt|;
switch|switch
condition|(
name|RetValue
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
case|case
name|ACPI_TYPE_BUFFER
case|:
case|case
name|ACPI_TYPE_STRING
case|:
comment|/*          * Did we receive the type we wanted? Most important for the          * Integer/Buffer case (when a field is larger than an Integer,          * it should return a Buffer).          */
if|if
condition|(
name|RetValue
operator|->
name|Type
operator|!=
name|ExpectedType
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|" Type mismatch:  Expected %s, Received %s"
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|ExpectedType
argument_list|)
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|RetValue
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_TYPE
operator|)
return|;
block|}
operator|*
name|Value
operator|=
name|RetValue
expr_stmt|;
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|" Unsupported return object type, %s"
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|RetValue
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|ReturnObj
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_TYPE
operator|)
return|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbWriteToObject  *  * PARAMETERS:  Node                - Parent NS node for the object  *              Value               - Value to be written  *  * RETURN:      Status  *  * DESCRIPTION: Performs a write to the specified object by invoking the  *              special debugger control method that writes the object. Thus,  *              the AML interpreter is doing all of the work, increasing the  *              validity of the test.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbWriteToObject
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|ACPI_OBJECT
modifier|*
name|Value
parameter_list|)
block|{
name|ACPI_OBJECT_LIST
name|ParamObjects
decl_stmt|;
name|ACPI_OBJECT
name|Params
index|[
literal|2
index|]
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Type
operator|=
name|ACPI_TYPE_LOCAL_REFERENCE
expr_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Reference
operator|.
name|ActualType
operator|=
name|Node
operator|->
name|Type
expr_stmt|;
name|Params
index|[
literal|0
index|]
operator|.
name|Reference
operator|.
name|Handle
operator|=
name|ACPI_CAST_PTR
argument_list|(
name|ACPI_HANDLE
argument_list|,
name|Node
argument_list|)
expr_stmt|;
comment|/* Copy the incoming user parameter */
name|ACPI_MEMCPY
argument_list|(
operator|&
name|Params
index|[
literal|1
index|]
argument_list|,
name|Value
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_OBJECT
argument_list|)
argument_list|)
expr_stmt|;
name|ParamObjects
operator|.
name|Count
operator|=
literal|2
expr_stmt|;
name|ParamObjects
operator|.
name|Pointer
operator|=
name|Params
expr_stmt|;
name|AcpiGbl_MethodExecuting
operator|=
name|TRUE
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|WriteHandle
argument_list|,
name|NULL
argument_list|,
operator|&
name|ParamObjects
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiGbl_MethodExecuting
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Could not write to object, %s"
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbEvaluateAllPredefinedNames  *  * PARAMETERS:  CountArg            - Max number of methods to execute  *  * RETURN:      None  *  * DESCRIPTION: Namespace batch execution. Execute predefined names in the  *              namespace, up to the max count, if specified.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDbEvaluateAllPredefinedNames
parameter_list|(
name|char
modifier|*
name|CountArg
parameter_list|)
block|{
name|ACPI_DB_EXECUTE_WALK
name|Info
decl_stmt|;
name|Info
operator|.
name|Count
operator|=
literal|0
expr_stmt|;
name|Info
operator|.
name|MaxCount
operator|=
name|ACPI_UINT32_MAX
expr_stmt|;
if|if
condition|(
name|CountArg
condition|)
block|{
name|Info
operator|.
name|MaxCount
operator|=
name|ACPI_STRTOUL
argument_list|(
name|CountArg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Search all nodes in namespace */
operator|(
name|void
operator|)
name|AcpiWalkNamespace
argument_list|(
name|ACPI_TYPE_ANY
argument_list|,
name|ACPI_ROOT_OBJECT
argument_list|,
name|ACPI_UINT32_MAX
argument_list|,
name|AcpiDbEvaluateOnePredefinedName
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|Info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"Evaluated %u predefined names in the namespace\n"
argument_list|,
name|Info
operator|.
name|Count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDbEvaluateOnePredefinedName  *  * PARAMETERS:  Callback from WalkNamespace  *  * RETURN:      Status  *  * DESCRIPTION: Batch execution module. Currently only executes predefined  *              ACPI names.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDbEvaluateOnePredefinedName
parameter_list|(
name|ACPI_HANDLE
name|ObjHandle
parameter_list|,
name|UINT32
name|NestingLevel
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|,
name|void
modifier|*
modifier|*
name|ReturnValue
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
init|=
operator|(
name|ACPI_NAMESPACE_NODE
operator|*
operator|)
name|ObjHandle
decl_stmt|;
name|ACPI_DB_EXECUTE_WALK
modifier|*
name|Info
init|=
operator|(
name|ACPI_DB_EXECUTE_WALK
operator|*
operator|)
name|Context
decl_stmt|;
name|char
modifier|*
name|Pathname
decl_stmt|;
specifier|const
name|ACPI_PREDEFINED_INFO
modifier|*
name|Predefined
decl_stmt|;
name|ACPI_DEVICE_INFO
modifier|*
name|ObjInfo
decl_stmt|;
name|ACPI_OBJECT_LIST
name|ParamObjects
decl_stmt|;
name|ACPI_OBJECT
name|Params
index|[
name|ACPI_METHOD_NUM_ARGS
index|]
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|ThisParam
decl_stmt|;
name|ACPI_BUFFER
name|ReturnObj
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|UINT16
name|ArgTypeList
decl_stmt|;
name|UINT8
name|ArgCount
decl_stmt|;
name|UINT8
name|ArgType
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
comment|/* The name must be a predefined ACPI name */
name|Predefined
operator|=
name|AcpiUtMatchPredefinedMethod
argument_list|(
name|Node
operator|->
name|Name
operator|.
name|Ascii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Predefined
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
if|if
condition|(
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_SCOPE
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Pathname
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pathname
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Get the object info for number of method parameters */
name|Status
operator|=
name|AcpiGetObjectInfo
argument_list|(
name|ObjHandle
argument_list|,
operator|&
name|ObjInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
name|ParamObjects
operator|.
name|Count
operator|=
literal|0
expr_stmt|;
name|ParamObjects
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ObjInfo
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
comment|/* Setup default parameters (with proper types) */
name|ArgTypeList
operator|=
name|Predefined
operator|->
name|Info
operator|.
name|ArgumentList
expr_stmt|;
name|ArgCount
operator|=
name|METHOD_GET_ARG_COUNT
argument_list|(
name|ArgTypeList
argument_list|)
expr_stmt|;
comment|/*          * Setup the ACPI-required number of arguments, regardless of what          * the actual method defines. If there is a difference, then the          * method is wrong and a warning will be issued during execution.          */
name|ThisParam
operator|=
name|Params
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ArgCount
condition|;
name|i
operator|++
control|)
block|{
name|ArgType
operator|=
name|METHOD_GET_NEXT_TYPE
argument_list|(
name|ArgTypeList
argument_list|)
expr_stmt|;
name|ThisParam
operator|->
name|Type
operator|=
name|ArgType
expr_stmt|;
switch|switch
condition|(
name|ArgType
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
name|ThisParam
operator|->
name|Integer
operator|.
name|Value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_STRING
case|:
name|ThisParam
operator|->
name|String
operator|.
name|Pointer
operator|=
literal|"This is the default argument string"
expr_stmt|;
name|ThisParam
operator|->
name|String
operator|.
name|Length
operator|=
name|ACPI_STRLEN
argument_list|(
name|ThisParam
operator|->
name|String
operator|.
name|Pointer
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_BUFFER
case|:
name|ThisParam
operator|->
name|Buffer
operator|.
name|Pointer
operator|=
operator|(
name|UINT8
operator|*
operator|)
name|Params
expr_stmt|;
comment|/* just a garbage buffer */
name|ThisParam
operator|->
name|Buffer
operator|.
name|Length
operator|=
literal|48
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_PACKAGE
case|:
name|ThisParam
operator|->
name|Package
operator|.
name|Elements
operator|=
name|NULL
expr_stmt|;
name|ThisParam
operator|->
name|Package
operator|.
name|Count
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|AcpiOsPrintf
argument_list|(
literal|"%s: Unsupported argument type: %u\n"
argument_list|,
name|Pathname
argument_list|,
name|ArgType
argument_list|)
expr_stmt|;
break|break;
block|}
name|ThisParam
operator|++
expr_stmt|;
block|}
name|ParamObjects
operator|.
name|Count
operator|=
name|ArgCount
expr_stmt|;
name|ParamObjects
operator|.
name|Pointer
operator|=
name|Params
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|ObjInfo
argument_list|)
expr_stmt|;
name|ReturnObj
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|ReturnObj
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
comment|/* Do the actual method execution */
name|AcpiGbl_MethodExecuting
operator|=
name|TRUE
expr_stmt|;
name|Status
operator|=
name|AcpiEvaluateObject
argument_list|(
name|Node
argument_list|,
name|NULL
argument_list|,
operator|&
name|ParamObjects
argument_list|,
operator|&
name|ReturnObj
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%-32s returned %s\n"
argument_list|,
name|Pathname
argument_list|,
name|AcpiFormatException
argument_list|(
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiGbl_MethodExecuting
operator|=
name|FALSE
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
comment|/* Ignore status from method execution */
name|Status
operator|=
name|AE_OK
expr_stmt|;
comment|/* Update count, check if we have executed enough methods */
name|Info
operator|->
name|Count
operator|++
expr_stmt|;
if|if
condition|(
name|Info
operator|->
name|Count
operator|>=
name|Info
operator|->
name|MaxCount
condition|)
block|{
name|Status
operator|=
name|AE_CTRL_TERMINATE
expr_stmt|;
block|}
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ACPI_DEBUGGER */
end_comment

end_unit

