begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: aslanalyze.c - check for semantic errors  *  *****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  *  * 1. Copyright Notice  *  * Some or all of this work - Copyright (c) 1999 - 2009, Intel Corp.  * All rights reserved.  *  * 2. License  *  * 2.1. This is your license from Intel Corp. under its intellectual property  * rights.  You may have additional license terms from the party that provided  * you this software, covering your right to use that party's intellectual  * property rights.  *  * 2.2. Intel grants, free of charge, to any person ("Licensee") obtaining a  * copy of the source code appearing in this file ("Covered Code") an  * irrevocable, perpetual, worldwide license under Intel's copyrights in the  * base code distributed originally by Intel ("Original Intel Code") to copy,  * make derivatives, distribute, use and display any portion of the Covered  * Code in any form, with the right to sublicense such rights; and  *  * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent  * license (with the right to sublicense), under only those claims of Intel  * patents that are infringed by the Original Intel Code, to make, use, sell,  * offer to sell, and import the Covered Code and derivative works thereof  * solely to the minimum extent necessary to exercise the above copyright  * license, and in no event shall the patent license extend to any additions  * to or modifications of the Original Intel Code.  No other license or right  * is granted directly or by implication, estoppel or otherwise;  *  * The above copyright and patent license is granted only if the following  * conditions are met:  *  * 3. Conditions  *  * 3.1. Redistribution of Source with Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification with rights to further distribute source must include  * the above Copyright Notice, the above License, this list of Conditions,  * and the following Disclaimer and Export Compliance provision.  In addition,  * Licensee must cause all Covered Code to which Licensee contributes to  * contain a file documenting the changes Licensee made to create that Covered  * Code and the date of any change.  Licensee must include in that file the  * documentation of any changes made by any predecessor Licensee.  Licensee  * must include a prominent statement that the modification is derived,  * directly or indirectly, from Original Intel Code.  *  * 3.2. Redistribution of Source with no Rights to Further Distribute Source.  * Redistribution of source code of any substantial portion of the Covered  * Code or modification without rights to further distribute source must  * include the following Disclaimer and Export Compliance provision in the  * documentation and/or other materials provided with distribution.  In  * addition, Licensee may not authorize further sublicense of source of any  * portion of the Covered Code, and must include terms to the effect that the  * license from Licensee to its licensee is limited to the intellectual  * property embodied in the software Licensee provides to its licensee, and  * not to intellectual property embodied in modifications its licensee may  * make.  *  * 3.3. Redistribution of Executable. Redistribution in executable form of any  * substantial portion of the Covered Code or modification must reproduce the  * above Copyright Notice, and the following Disclaimer and Export Compliance  * provision in the documentation and/or other materials provided with the  * distribution.  *  * 3.4. Intel retains all right, title, and interest in and to the Original  * Intel Code.  *  * 3.5. Neither the name Intel nor any other trademark owned or controlled by  * Intel shall be used in advertising or otherwise to promote the sale, use or  * other dealings in products derived from or relating to the Covered Code  * without prior written authorization from Intel.  *  * 4. Disclaimer and Export Compliance  *  * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED  * HERE.  ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE  * IS PROVIDED "AS IS," AND INTEL WILL NOT PROVIDE ANY SUPPORT,  ASSISTANCE,  * INSTALLATION, TRAINING OR OTHER SERVICES.  INTEL WILL NOT PROVIDE ANY  * UPDATES, ENHANCEMENTS OR EXTENSIONS.  INTEL SPECIFICALLY DISCLAIMS ANY  * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A  * PARTICULAR PURPOSE.  *  * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES  * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR  * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,  * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY  * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL  * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES.  THESE LIMITATIONS  * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY  * LIMITED REMEDY.  *  * 4.3. Licensee shall not export, either directly or indirectly, any of this  * software or system incorporating such software without first obtaining any  * required license or other approval from the U. S. Department of Commerce or  * any other agency or department of the United States Government.  In the  * event Licensee exports any such software from the United States or  * re-exports any such software from a foreign destination, Licensee shall  * ensure that the distribution and export/re-export of the software is in  * compliance with all laws, regulations, orders, or other restrictions of the  * U.S. Export Administration Regulations. Licensee agrees that neither it nor  * any of its subsidiaries will export/re-export any technical data, process,  * software, or service, directly or indirectly, to any country for which the  * United States government or any agency thereof requires an export license,  * other governmental approval, or letter of assurance, without first obtaining  * such license, approval or letter.  *  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/compiler/aslcompiler.h>
end_include

begin_include
include|#
directive|include
file|"aslcompiler.y.h"
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acparser.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/amlcode.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_COMPILER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"aslanalyze"
argument_list|)
end_macro

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|UINT32
name|AnMapArgTypeToBtype
parameter_list|(
name|UINT32
name|ArgType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT32
name|AnMapEtypeToBtype
parameter_list|(
name|UINT32
name|Etype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AnFormatBtype
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|Btype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT32
name|AnGetBtype
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT32
name|AnCheckForReservedName
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AnCheckForReservedMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|ASL_METHOD_INFO
modifier|*
name|MethodInfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT32
name|AnMapObjTypeToBtype
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|AnLastStatementIsReturn
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AnCheckMethodReturnValue
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|ArgOp
parameter_list|,
name|UINT32
name|RequiredBtypes
parameter_list|,
name|UINT32
name|ThisNodeBtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BOOLEAN
name|AnIsInternalMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UINT32
name|AnGetInternalMethodReturnType
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BOOLEAN
name|AnIsResultUsed
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnIsInternalMethod  *  * PARAMETERS:  Op              - Current op  *  * RETURN:      Boolean  *  * DESCRIPTION: Check for an internal control method.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|AnIsInternalMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
literal|"\\_OSI"
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
literal|"_OSI"
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnGetInternalMethodReturnType  *  * PARAMETERS:  Op              - Current op  *  * RETURN:      Btype  *  * DESCRIPTION: Get the return type of an internal method  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnGetInternalMethodReturnType
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
literal|"\\_OSI"
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
literal|"_OSI"
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|ACPI_BTYPE_STRING
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMapArgTypeToBtype  *  * PARAMETERS:  ArgType      - The ARGI required type(s) for this argument,  *                             from the opcode info table  *  * RETURN:      The corresponding Bit-encoded types  *  * DESCRIPTION: Convert an encoded ARGI required argument type code into a  *              bitfield type code. Implements the implicit source conversion  *              rules.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnMapArgTypeToBtype
parameter_list|(
name|UINT32
name|ArgType
parameter_list|)
block|{
switch|switch
condition|(
name|ArgType
condition|)
block|{
comment|/* Simple types */
case|case
name|ARGI_ANYTYPE
case|:
return|return
operator|(
name|ACPI_BTYPE_OBJECTS_AND_REFS
operator|)
return|;
case|case
name|ARGI_PACKAGE
case|:
return|return
operator|(
name|ACPI_BTYPE_PACKAGE
operator|)
return|;
case|case
name|ARGI_EVENT
case|:
return|return
operator|(
name|ACPI_BTYPE_EVENT
operator|)
return|;
case|case
name|ARGI_MUTEX
case|:
return|return
operator|(
name|ACPI_BTYPE_MUTEX
operator|)
return|;
case|case
name|ARGI_DDBHANDLE
case|:
comment|/*          * DDBHandleObject := SuperName          * ACPI_BTYPE_REFERENCE: Index reference as parameter of Load/Unload          */
return|return
operator|(
name|ACPI_BTYPE_DDB_HANDLE
operator||
name|ACPI_BTYPE_REFERENCE
operator|)
return|;
comment|/* Interchangeable types */
comment|/*      * Source conversion rules:      * Integer, String, and Buffer are all interchangeable      */
case|case
name|ARGI_INTEGER
case|:
case|case
name|ARGI_STRING
case|:
case|case
name|ARGI_BUFFER
case|:
case|case
name|ARGI_BUFFER_OR_STRING
case|:
case|case
name|ARGI_COMPUTEDATA
case|:
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator|)
return|;
comment|/* References */
case|case
name|ARGI_INTEGER_REF
case|:
return|return
operator|(
name|ACPI_BTYPE_INTEGER
operator|)
return|;
case|case
name|ARGI_OBJECT_REF
case|:
return|return
operator|(
name|ACPI_BTYPE_ALL_OBJECTS
operator|)
return|;
case|case
name|ARGI_DEVICE_REF
case|:
return|return
operator|(
name|ACPI_BTYPE_DEVICE_OBJECTS
operator|)
return|;
case|case
name|ARGI_REFERENCE
case|:
return|return
operator|(
name|ACPI_BTYPE_REFERENCE
operator|)
return|;
case|case
name|ARGI_TARGETREF
case|:
case|case
name|ARGI_FIXED_TARGET
case|:
case|case
name|ARGI_SIMPLE_TARGET
case|:
return|return
operator|(
name|ACPI_BTYPE_OBJECTS_AND_REFS
operator|)
return|;
comment|/* Complex types */
case|case
name|ARGI_DATAOBJECT
case|:
comment|/*          * Buffer, string, package or reference to a Op -          * Used only by SizeOf operator          */
return|return
operator|(
name|ACPI_BTYPE_STRING
operator||
name|ACPI_BTYPE_BUFFER
operator||
name|ACPI_BTYPE_PACKAGE
operator||
name|ACPI_BTYPE_REFERENCE
operator|)
return|;
case|case
name|ARGI_COMPLEXOBJ
case|:
comment|/* Buffer, String, or package */
return|return
operator|(
name|ACPI_BTYPE_STRING
operator||
name|ACPI_BTYPE_BUFFER
operator||
name|ACPI_BTYPE_PACKAGE
operator|)
return|;
case|case
name|ARGI_REF_OR_STRING
case|:
return|return
operator|(
name|ACPI_BTYPE_STRING
operator||
name|ACPI_BTYPE_REFERENCE
operator|)
return|;
case|case
name|ARGI_REGION_OR_BUFFER
case|:
comment|/* Used by Load() only. Allow buffers in addition to regions/fields */
return|return
operator|(
name|ACPI_BTYPE_REGION
operator||
name|ACPI_BTYPE_BUFFER
operator||
name|ACPI_BTYPE_FIELD_UNIT
operator|)
return|;
case|case
name|ARGI_DATAREFOBJ
case|:
return|return
operator|(
name|ACPI_BTYPE_INTEGER
operator||
name|ACPI_BTYPE_STRING
operator||
name|ACPI_BTYPE_BUFFER
operator||
name|ACPI_BTYPE_PACKAGE
operator||
name|ACPI_BTYPE_REFERENCE
operator||
name|ACPI_BTYPE_DDB_HANDLE
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|ACPI_BTYPE_OBJECTS_AND_REFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMapEtypeToBtype  *  * PARAMETERS:  Etype           - Encoded ACPI Type  *  * RETURN:      Btype corresponding to the Etype  *  * DESCRIPTION: Convert an encoded ACPI type to a bitfield type applying the  *              operand conversion rules. In other words, returns the type(s)  *              this Etype is implicitly converted to during interpretation.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnMapEtypeToBtype
parameter_list|(
name|UINT32
name|Etype
parameter_list|)
block|{
if|if
condition|(
name|Etype
operator|==
name|ACPI_TYPE_ANY
condition|)
block|{
return|return
name|ACPI_BTYPE_OBJECTS_AND_REFS
return|;
block|}
comment|/* Try the standard ACPI data types */
if|if
condition|(
name|Etype
operator|<=
name|ACPI_TYPE_EXTERNAL_MAX
condition|)
block|{
comment|/*          * This switch statement implements the allowed operand conversion          * rules as per the "ASL Data Types" section of the ACPI          * specification.          */
switch|switch
condition|(
name|Etype
condition|)
block|{
case|case
name|ACPI_TYPE_INTEGER
case|:
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator||
name|ACPI_BTYPE_DDB_HANDLE
operator|)
return|;
case|case
name|ACPI_TYPE_STRING
case|:
case|case
name|ACPI_TYPE_BUFFER
case|:
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator|)
return|;
case|case
name|ACPI_TYPE_PACKAGE
case|:
return|return
operator|(
name|ACPI_BTYPE_PACKAGE
operator|)
return|;
case|case
name|ACPI_TYPE_FIELD_UNIT
case|:
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator||
name|ACPI_BTYPE_FIELD_UNIT
operator|)
return|;
case|case
name|ACPI_TYPE_BUFFER_FIELD
case|:
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator||
name|ACPI_BTYPE_BUFFER_FIELD
operator|)
return|;
case|case
name|ACPI_TYPE_DDB_HANDLE
case|:
return|return
operator|(
name|ACPI_BTYPE_INTEGER
operator||
name|ACPI_BTYPE_DDB_HANDLE
operator|)
return|;
case|case
name|ACPI_BTYPE_DEBUG_OBJECT
case|:
comment|/* Cannot be used as a source operand */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|<<
operator|(
name|Etype
operator|-
literal|1
operator|)
operator|)
return|;
block|}
block|}
comment|/* Try the internal data types */
switch|switch
condition|(
name|Etype
condition|)
block|{
case|case
name|ACPI_TYPE_LOCAL_REGION_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_BANK_FIELD
case|:
case|case
name|ACPI_TYPE_LOCAL_INDEX_FIELD
case|:
comment|/* Named fields can be either Integer/Buffer/String */
return|return
operator|(
name|ACPI_BTYPE_COMPUTE_DATA
operator||
name|ACPI_BTYPE_FIELD_UNIT
operator|)
return|;
case|case
name|ACPI_TYPE_LOCAL_ALIAS
case|:
return|return
operator|(
name|ACPI_BTYPE_INTEGER
operator|)
return|;
case|case
name|ACPI_TYPE_LOCAL_RESOURCE
case|:
case|case
name|ACPI_TYPE_LOCAL_RESOURCE_FIELD
case|:
return|return
operator|(
name|ACPI_BTYPE_REFERENCE
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"Unhandled encoded type: %X\n"
argument_list|,
name|Etype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnFormatBtype  *  * PARAMETERS:  Btype               - Bitfield of ACPI types  *              Buffer              - Where to put the ascii string  *  * RETURN:      None.  *  * DESCRIPTION: Convert a Btype to a string of ACPI types  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AnFormatBtype
parameter_list|(
name|char
modifier|*
name|Buffer
parameter_list|,
name|UINT32
name|Btype
parameter_list|)
block|{
name|UINT32
name|Type
decl_stmt|;
name|BOOLEAN
name|First
init|=
name|TRUE
decl_stmt|;
operator|*
name|Buffer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Btype
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"NoReturnValue"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|Type
operator|=
literal|1
init|;
name|Type
operator|<=
name|ACPI_TYPE_EXTERNAL_MAX
condition|;
name|Type
operator|++
control|)
block|{
if|if
condition|(
name|Btype
operator|&
literal|0x00000001
condition|)
block|{
if|if
condition|(
operator|!
name|First
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
block|}
name|First
operator|=
name|FALSE
expr_stmt|;
name|strcat
argument_list|(
name|Buffer
argument_list|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Btype
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Btype
operator|&
literal|0x00000001
condition|)
block|{
if|if
condition|(
operator|!
name|First
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
block|}
name|First
operator|=
name|FALSE
expr_stmt|;
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"Reference"
argument_list|)
expr_stmt|;
block|}
name|Btype
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|Btype
operator|&
literal|0x00000001
condition|)
block|{
if|if
condition|(
operator|!
name|First
condition|)
block|{
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
block|}
name|First
operator|=
name|FALSE
expr_stmt|;
name|strcat
argument_list|(
name|Buffer
argument_list|,
literal|"Resource"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnGetBtype  *  * PARAMETERS:  Op          - Parse node whose type will be returned.  *  * RETURN:      The Btype associated with the Op.  *  * DESCRIPTION: Get the (bitfield) ACPI type associated with the parse node.  *              Handles the case where the node is a name or method call and  *              the actual type must be obtained from the namespace node.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnGetBtype
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|ReferencedNode
decl_stmt|;
name|UINT32
name|ThisNodeBtype
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESEG
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_NAMESTRING
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
condition|)
block|{
name|Node
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
name|DbgPrint
argument_list|(
name|ASL_DEBUG_OUTPUT
argument_list|,
literal|"No attached Nsnode: [%s] at line %d name [%s], ignoring typecheck\n"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ParseOpName
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|LineNumber
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
name|ACPI_UINT32_MAX
return|;
block|}
name|ThisNodeBtype
operator|=
name|AnMapEtypeToBtype
argument_list|(
name|Node
operator|->
name|Type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ThisNodeBtype
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_COMPILER_INTERNAL
argument_list|,
name|Op
argument_list|,
literal|"could not map type"
argument_list|)
expr_stmt|;
block|}
comment|/*          * Since it was a named reference, enable the          * reference bit also          */
name|ThisNodeBtype
operator||=
name|ACPI_BTYPE_REFERENCE
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
condition|)
block|{
name|ReferencedNode
operator|=
name|Node
operator|->
name|Op
expr_stmt|;
if|if
condition|(
operator|!
name|ReferencedNode
condition|)
block|{
comment|/* Check for an internal method */
if|if
condition|(
name|AnIsInternalMethod
argument_list|(
name|Op
argument_list|)
condition|)
block|{
return|return
operator|(
name|AnGetInternalMethodReturnType
argument_list|(
name|Op
argument_list|)
operator|)
return|;
block|}
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_COMPILER_INTERNAL
argument_list|,
name|Op
argument_list|,
literal|"null Op pointer"
argument_list|)
expr_stmt|;
return|return
name|ACPI_UINT32_MAX
return|;
block|}
if|if
condition|(
name|ReferencedNode
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_METHOD_TYPED
condition|)
block|{
name|ThisNodeBtype
operator|=
name|ReferencedNode
operator|->
name|Asl
operator|.
name|AcpiBtype
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ACPI_UINT32_MAX
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|ThisNodeBtype
operator|=
name|Op
operator|->
name|Asl
operator|.
name|AcpiBtype
expr_stmt|;
block|}
return|return
operator|(
name|ThisNodeBtype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnCheckForReservedName  *  * PARAMETERS:  Op              - A parse node  *              Name            - NameSeg to check  *  * RETURN:      None  *  * DESCRIPTION: Check a NameSeg against the reserved list.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnCheckForReservedName
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Name
parameter_list|)
block|{
name|UINT32
name|i
decl_stmt|;
if|if
condition|(
name|Name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"Found a null name, external = %s\n"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
comment|/* All reserved names are prefixed with a single underscore */
if|if
condition|(
name|Name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
return|return
operator|(
name|ACPI_NOT_RESERVED_NAME
operator|)
return|;
block|}
comment|/* Check for a standard reserved method name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|Name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ACPI_COMPARE_NAME
argument_list|(
name|Name
argument_list|,
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|Flags
operator|&
name|ASL_RSVD_SCOPE
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESERVED_WORD
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_PREDEFINED_NAME
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|Flags
operator|&
name|ASL_RSVD_RESOURCE_NAME
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESERVED_WORD
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_PREDEFINED_NAME
operator|)
return|;
block|}
comment|/* Return index into reserved array */
return|return
name|i
return|;
block|}
block|}
comment|/*      * Now check for the "special" reserved names --      * GPE:  _Lxx      * GPE:  _Exx      * EC:   _Qxx      */
if|if
condition|(
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'Q'
operator|)
condition|)
block|{
comment|/* The next two characters must be hex digits */
if|if
condition|(
operator|(
name|isxdigit
argument_list|(
name|Name
index|[
literal|2
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|isxdigit
argument_list|(
name|Name
index|[
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|ACPI_EVENT_RESERVED_NAME
operator|)
return|;
block|}
block|}
comment|/* Check for the names reserved for the compiler itself: _T_x */
elseif|else
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
comment|/* Ignore if actually emitted by the compiler */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_COMPILER_EMITTED
condition|)
block|{
return|return
operator|(
name|ACPI_NOT_RESERVED_NAME
operator|)
return|;
block|}
comment|/*          * Was not actually emitted by the compiler. This is a special case,          * however. If the ASL code being compiled was the result of a          * dissasembly, it may possibly contain valid compiler-emitted names          * of the form "_T_x". We don't want to issue an error or even a          * warning and force the user to manually change the names. So, we          * will issue a remark instead.          */
name|AslError
argument_list|(
name|ASL_REMARK
argument_list|,
name|ASL_MSG_COMPILER_RESERVED
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_COMPILER_RESERVED_NAME
operator|)
return|;
block|}
comment|/*      * The name didn't match any of the known reserved names. Flag it as a      * warning, since the entire namespace starting with an underscore is      * reserved by the ACPI spec.      */
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_UNKNOWN_RESERVED_NAME
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACPI_NOT_RESERVED_NAME
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnCheckForReservedMethod  *  * PARAMETERS:  Op              - A parse node of type "METHOD".  *              MethodInfo      - Saved info about this method  *  * RETURN:      None  *  * DESCRIPTION: If method is a reserved name, check that the number of arguments  *              and the return type (returns a value or not) is correct.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AnCheckForReservedMethod
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|ASL_METHOD_INFO
modifier|*
name|MethodInfo
parameter_list|)
block|{
name|UINT32
name|Index
decl_stmt|;
name|UINT32
name|RequiredArgsCurrent
decl_stmt|;
name|UINT32
name|RequiredArgsOld
decl_stmt|;
comment|/* Check for a match against the reserved name list */
name|Index
operator|=
name|AnCheckForReservedName
argument_list|(
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|NameSeg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Index
condition|)
block|{
case|case
name|ACPI_NOT_RESERVED_NAME
case|:
case|case
name|ACPI_PREDEFINED_NAME
case|:
case|case
name|ACPI_COMPILER_RESERVED_NAME
case|:
comment|/* Just return, nothing to do */
break|break;
case|case
name|ACPI_EVENT_RESERVED_NAME
case|:
name|Gbl_ReservedMethods
operator|++
expr_stmt|;
comment|/* NumArguments must be zero for all _Lxx, _Exx, and _Qxx methods */
if|if
condition|(
name|MethodInfo
operator|->
name|NumArguments
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"%s requires %d"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESERVED_ARG_COUNT_HI
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|Gbl_ReservedMethods
operator|++
expr_stmt|;
comment|/*          * Matched a reserved method name          *          * Validate the ASL-defined argument count. Allow two different legal          * arg counts.          */
name|RequiredArgsCurrent
operator|=
name|ReservedMethods
index|[
name|Index
index|]
operator|.
name|NumArguments
operator|&
literal|0x0F
expr_stmt|;
name|RequiredArgsOld
operator|=
name|ReservedMethods
index|[
name|Index
index|]
operator|.
name|NumArguments
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|MethodInfo
operator|->
name|NumArguments
operator|!=
name|RequiredArgsCurrent
operator|)
operator|&&
operator|(
name|MethodInfo
operator|->
name|NumArguments
operator|!=
name|RequiredArgsOld
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"%s requires %d"
argument_list|,
name|ReservedMethods
index|[
name|Index
index|]
operator|.
name|Name
argument_list|,
name|RequiredArgsCurrent
argument_list|)
expr_stmt|;
if|if
condition|(
name|MethodInfo
operator|->
name|NumArguments
operator|>
name|RequiredArgsCurrent
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESERVED_ARG_COUNT_HI
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESERVED_ARG_COUNT_LO
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|MethodInfo
operator|->
name|NumReturnNoValue
operator|&&
name|ReservedMethods
index|[
name|Index
index|]
operator|.
name|Flags
operator|&
name|ASL_RSVD_RETURN_VALUE
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"%s"
argument_list|,
name|ReservedMethods
index|[
name|Index
index|]
operator|.
name|Name
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESERVED_RETURN_VALUE
argument_list|,
name|Op
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMapObjTypeToBtype  *  * PARAMETERS:  Op              - A parse node  *  * RETURN:      A Btype  *  * DESCRIPTION: Map object to the associated "Btype"  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|UINT32
name|AnMapObjTypeToBtype
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_OBJECTTYPE_BFF
case|:
comment|/* "BuffFieldObj" */
return|return
operator|(
name|ACPI_BTYPE_BUFFER_FIELD
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_BUF
case|:
comment|/* "BuffObj" */
return|return
operator|(
name|ACPI_BTYPE_BUFFER
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_DDB
case|:
comment|/* "DDBHandleObj" */
return|return
operator|(
name|ACPI_BTYPE_DDB_HANDLE
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_DEV
case|:
comment|/* "DeviceObj" */
return|return
operator|(
name|ACPI_BTYPE_DEVICE
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_EVT
case|:
comment|/* "EventObj" */
return|return
operator|(
name|ACPI_BTYPE_EVENT
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_FLD
case|:
comment|/* "FieldUnitObj" */
return|return
operator|(
name|ACPI_BTYPE_FIELD_UNIT
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_INT
case|:
comment|/* "IntObj" */
return|return
operator|(
name|ACPI_BTYPE_INTEGER
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_MTH
case|:
comment|/* "MethodObj" */
return|return
operator|(
name|ACPI_BTYPE_METHOD
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_MTX
case|:
comment|/* "MutexObj" */
return|return
operator|(
name|ACPI_BTYPE_MUTEX
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_OPR
case|:
comment|/* "OpRegionObj" */
return|return
operator|(
name|ACPI_BTYPE_REGION
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_PKG
case|:
comment|/* "PkgObj" */
return|return
operator|(
name|ACPI_BTYPE_PACKAGE
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_POW
case|:
comment|/* "PowerResObj" */
return|return
operator|(
name|ACPI_BTYPE_POWER
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_STR
case|:
comment|/* "StrObj" */
return|return
operator|(
name|ACPI_BTYPE_STRING
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_THZ
case|:
comment|/* "ThermalZoneObj" */
return|return
operator|(
name|ACPI_BTYPE_THERMAL
operator|)
return|;
case|case
name|PARSEOP_OBJECTTYPE_UNK
case|:
comment|/* "UnknownObj" */
return|return
operator|(
name|ACPI_BTYPE_OBJECTS_AND_REFS
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMethodAnalysisWalkBegin  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Descending callback for the analysis walk. Check methods for:  *              1) Initialized local variables  *              2) Valid arguments  *              3) Return types  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnMethodAnalysisWalkBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|ASL_ANALYSIS_WALK_INFO
modifier|*
name|WalkInfo
init|=
operator|(
name|ASL_ANALYSIS_WALK_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ASL_METHOD_INFO
modifier|*
name|MethodInfo
init|=
name|WalkInfo
operator|->
name|MethodStack
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|Next
decl_stmt|;
name|UINT32
name|RegisterNumber
decl_stmt|;
name|UINT32
name|i
decl_stmt|;
name|char
name|LocalName
index|[]
init|=
literal|"Local0"
decl_stmt|;
name|char
name|ArgName
index|[]
init|=
literal|"Arg0"
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|ArgNode
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|NextType
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|NextParamType
decl_stmt|;
name|UINT8
name|ActualArgs
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_METHOD
case|:
name|TotalMethods
operator|++
expr_stmt|;
comment|/* Create and init method info */
name|MethodInfo
operator|=
name|UtLocalCalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASL_METHOD_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|MethodInfo
operator|->
name|Next
operator|=
name|WalkInfo
operator|->
name|MethodStack
expr_stmt|;
name|MethodInfo
operator|->
name|Op
operator|=
name|Op
expr_stmt|;
name|WalkInfo
operator|->
name|MethodStack
operator|=
name|MethodInfo
expr_stmt|;
comment|/* Get the name node, ignored here */
name|Next
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
comment|/* Get the NumArguments node */
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|MethodInfo
operator|->
name|NumArguments
operator|=
call|(
name|UINT8
call|)
argument_list|(
operator|(
operator|(
name|UINT8
operator|)
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|)
operator|&
literal|0x07
argument_list|)
expr_stmt|;
comment|/* Get the SerializeRule and SyncLevel nodes, ignored here */
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|ArgNode
operator|=
name|Next
expr_stmt|;
comment|/* Get the ReturnType node */
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|NextType
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
name|NextType
condition|)
block|{
comment|/* Get and map each of the ReturnTypes */
name|MethodInfo
operator|->
name|ValidReturnTypes
operator||=
name|AnMapObjTypeToBtype
argument_list|(
name|NextType
argument_list|)
expr_stmt|;
name|NextType
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_DEFAULT_ARG
expr_stmt|;
name|NextType
operator|=
name|NextType
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
comment|/* Get the ParameterType node */
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|NextType
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
name|NextType
condition|)
block|{
if|if
condition|(
name|NextType
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_DEFAULT_ARG
condition|)
block|{
name|NextParamType
operator|=
name|NextType
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
name|NextParamType
condition|)
block|{
name|MethodInfo
operator|->
name|ValidArgTypes
index|[
name|ActualArgs
index|]
operator||=
name|AnMapObjTypeToBtype
argument_list|(
name|NextParamType
argument_list|)
expr_stmt|;
name|NextParamType
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_DEFAULT_ARG
expr_stmt|;
name|NextParamType
operator|=
name|NextParamType
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
block|}
else|else
block|{
name|MethodInfo
operator|->
name|ValidArgTypes
index|[
name|ActualArgs
index|]
operator|=
name|AnMapObjTypeToBtype
argument_list|(
name|NextType
argument_list|)
expr_stmt|;
name|NextType
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|=
name|PARSEOP_DEFAULT_ARG
expr_stmt|;
name|ActualArgs
operator|++
expr_stmt|;
block|}
name|NextType
operator|=
name|NextType
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|MethodInfo
operator|->
name|NumArguments
operator|)
operator|&&
operator|(
name|MethodInfo
operator|->
name|NumArguments
operator|!=
name|ActualArgs
operator|)
condition|)
block|{
comment|/* error: Param list did not match number of args */
block|}
comment|/* Allow numarguments == 0 for Function() */
if|if
condition|(
operator|(
operator|!
name|MethodInfo
operator|->
name|NumArguments
operator|)
operator|&&
operator|(
name|ActualArgs
operator|)
condition|)
block|{
name|MethodInfo
operator|->
name|NumArguments
operator|=
name|ActualArgs
expr_stmt|;
name|ArgNode
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator||=
name|ActualArgs
expr_stmt|;
block|}
comment|/*          * Actual arguments are initialized at method entry.          * All other ArgX "registers" can be used as locals, so we          * track their initialization.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MethodInfo
operator|->
name|NumArguments
condition|;
name|i
operator|++
control|)
block|{
name|MethodInfo
operator|->
name|ArgInitialized
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_METHODCALL
case|:
if|if
condition|(
name|MethodInfo
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Node
operator|==
name|MethodInfo
operator|->
name|Op
operator|->
name|Asl
operator|.
name|Node
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_REMARK
argument_list|,
name|ASL_MSG_RECURSION
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_LOCAL0
case|:
case|case
name|PARSEOP_LOCAL1
case|:
case|case
name|PARSEOP_LOCAL2
case|:
case|case
name|PARSEOP_LOCAL3
case|:
case|case
name|PARSEOP_LOCAL4
case|:
case|case
name|PARSEOP_LOCAL5
case|:
case|case
name|PARSEOP_LOCAL6
case|:
case|case
name|PARSEOP_LOCAL7
case|:
if|if
condition|(
operator|!
name|MethodInfo
condition|)
block|{
comment|/*              * Local was used outside a control method, or there was an error              * in the method declaration.              */
name|AslError
argument_list|(
name|ASL_REMARK
argument_list|,
name|ASL_MSG_LOCAL_OUTSIDE_METHOD
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
name|RegisterNumber
operator|=
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|&
literal|0x000F
operator|)
expr_stmt|;
comment|/*          * If the local is being used as a target, mark the local          * initialized          */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_TARGET
condition|)
block|{
name|MethodInfo
operator|->
name|LocalInitialized
index|[
name|RegisterNumber
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*          * Otherwise, this is a reference, check if the local          * has been previously initialized.          *          * The only operator that accepts an uninitialized value is ObjectType()          */
elseif|else
if|if
condition|(
operator|(
operator|!
name|MethodInfo
operator|->
name|LocalInitialized
index|[
name|RegisterNumber
index|]
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_OBJECTTYPE
operator|)
condition|)
block|{
name|LocalName
index|[
name|strlen
argument_list|(
name|LocalName
argument_list|)
operator|-
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|RegisterNumber
operator|+
literal|0x30
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_LOCAL_INIT
argument_list|,
name|Op
argument_list|,
name|LocalName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_ARG0
case|:
case|case
name|PARSEOP_ARG1
case|:
case|case
name|PARSEOP_ARG2
case|:
case|case
name|PARSEOP_ARG3
case|:
case|case
name|PARSEOP_ARG4
case|:
case|case
name|PARSEOP_ARG5
case|:
case|case
name|PARSEOP_ARG6
case|:
if|if
condition|(
operator|!
name|MethodInfo
condition|)
block|{
comment|/*              * Arg was used outside a control method, or there was an error              * in the method declaration.              */
name|AslError
argument_list|(
name|ASL_REMARK
argument_list|,
name|ASL_MSG_LOCAL_OUTSIDE_METHOD
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
name|RegisterNumber
operator|=
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|&
literal|0x000F
operator|)
operator|-
literal|8
expr_stmt|;
name|ArgName
index|[
name|strlen
argument_list|(
name|ArgName
argument_list|)
operator|-
literal|1
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|RegisterNumber
operator|+
literal|0x30
argument_list|)
expr_stmt|;
comment|/*          * If the Arg is being used as a target, mark the local          * initialized          */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IS_TARGET
condition|)
block|{
name|MethodInfo
operator|->
name|ArgInitialized
index|[
name|RegisterNumber
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*          * Otherwise, this is a reference, check if the Arg          * has been previously initialized.          *          * The only operator that accepts an uninitialized value is ObjectType()          */
elseif|else
if|if
condition|(
operator|(
operator|!
name|MethodInfo
operator|->
name|ArgInitialized
index|[
name|RegisterNumber
index|]
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_OBJECTTYPE
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ARG_INIT
argument_list|,
name|Op
argument_list|,
name|ArgName
argument_list|)
expr_stmt|;
block|}
comment|/* Flag this arg if it is not a "real" argument to the method */
if|if
condition|(
name|RegisterNumber
operator|>=
name|MethodInfo
operator|->
name|NumArguments
condition|)
block|{
name|AslError
argument_list|(
name|ASL_REMARK
argument_list|,
name|ASL_MSG_NOT_PARAMETER
argument_list|,
name|Op
argument_list|,
name|ArgName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_RETURN
case|:
if|if
condition|(
operator|!
name|MethodInfo
condition|)
block|{
comment|/*              * Probably was an error in the method declaration,              * no additional error here              */
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"%p, No parent method"
operator|,
name|Op
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
comment|/* Child indicates a return value */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_DEFAULT_ARG
operator|)
condition|)
block|{
name|MethodInfo
operator|->
name|NumReturnWithValue
operator|++
expr_stmt|;
block|}
else|else
block|{
name|MethodInfo
operator|->
name|NumReturnNoValue
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_BREAK
case|:
case|case
name|PARSEOP_CONTINUE
case|:
name|Next
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
while|while
condition|(
name|Next
condition|)
block|{
if|if
condition|(
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_WHILE
condition|)
block|{
break|break;
block|}
name|Next
operator|=
name|Next
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Next
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NO_WHILE
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_STALL
case|:
comment|/* We can range check if the argument is an integer */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_INTEGER
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|>
name|ACPI_UINT8_MAX
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_TIME
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_DEVICE
case|:
case|case
name|PARSEOP_EVENT
case|:
case|case
name|PARSEOP_MUTEX
case|:
case|case
name|PARSEOP_OPERATIONREGION
case|:
case|case
name|PARSEOP_POWERRESOURCE
case|:
case|case
name|PARSEOP_PROCESSOR
case|:
case|case
name|PARSEOP_THERMALZONE
case|:
comment|/*          * The first operand is a name to be created in the namespace.          * Check against the reserved list.          */
name|i
operator|=
name|AnCheckForReservedName
argument_list|(
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|NameSeg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ACPI_VALID_RESERVED_NAME_MAX
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESERVED_USE
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_NAME
case|:
name|i
operator|=
name|AnCheckForReservedName
argument_list|(
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|NameSeg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ACPI_VALID_RESERVED_NAME_MAX
condition|)
block|{
if|if
condition|(
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|NumArguments
operator|>
literal|0
condition|)
block|{
comment|/*                  * This reserved name must be a control method because                  * it must have arguments                  */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESERVED_METHOD
argument_list|,
name|Op
argument_list|,
literal|"with arguments"
argument_list|)
expr_stmt|;
block|}
comment|/* Typechecking for _HID */
elseif|else
if|if
condition|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|METHOD_NAME__HID
argument_list|,
name|ReservedMethods
index|[
name|i
index|]
operator|.
name|Name
argument_list|)
condition|)
block|{
comment|/* Examine the second operand to typecheck it */
name|Next
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
if|if
condition|(
operator|(
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_INTEGER
operator|)
operator|&&
operator|(
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_STRING_LITERAL
operator|)
condition|)
block|{
comment|/* _HID must be a string or an integer */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESERVED_OPERAND_TYPE
argument_list|,
name|Next
argument_list|,
literal|"String or Integer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_STRING_LITERAL
condition|)
block|{
comment|/*                      * _HID is a string, all characters must be alphanumeric.                      * One of the things we want to catch here is the use of                      * a leading asterisk in the string.                      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_ALPHANUMERIC_STRING
argument_list|,
name|Next
argument_list|,
name|Next
operator|->
name|Asl
operator|.
name|Value
operator|.
name|String
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnLastStatementIsReturn  *  * PARAMETERS:  Op            - A method parse node  *  * RETURN:      TRUE if last statement is an ASL RETURN. False otherwise  *  * DESCRIPTION: Walk down the list of top level statements within a method  *              to find the last one. Check if that last statement is in  *              fact a RETURN statement.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|BOOLEAN
name|AnLastStatementIsReturn
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|Next
decl_stmt|;
comment|/*      * Check if last statement is a return      */
name|Next
operator|=
name|ASL_GET_CHILD_NODE
argument_list|(
name|Op
argument_list|)
expr_stmt|;
while|while
condition|(
name|Next
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|Next
operator|->
name|Asl
operator|.
name|Next
operator|)
operator|&&
operator|(
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_RETURN
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|Next
operator|=
name|ASL_GET_PEER_NODE
argument_list|(
name|Next
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMethodAnalysisWalkEnd  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Ascending callback for analysis walk. Complete method  *              return analysis.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnMethodAnalysisWalkEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|ASL_ANALYSIS_WALK_INFO
modifier|*
name|WalkInfo
init|=
operator|(
name|ASL_ANALYSIS_WALK_INFO
operator|*
operator|)
name|Context
decl_stmt|;
name|ASL_METHOD_INFO
modifier|*
name|MethodInfo
init|=
name|WalkInfo
operator|->
name|MethodStack
decl_stmt|;
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_METHOD
case|:
case|case
name|PARSEOP_RETURN
case|:
if|if
condition|(
operator|!
name|MethodInfo
condition|)
block|{
name|printf
argument_list|(
literal|"No method info for method! [%s]\n"
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|Namepath
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_COMPILER_INTERNAL
argument_list|,
name|Op
argument_list|,
literal|"No method info for this method"
argument_list|)
expr_stmt|;
name|CmCleanupAndExit
argument_list|()
expr_stmt|;
return|return
operator|(
name|AE_AML_INTERNAL
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_METHOD
case|:
name|WalkInfo
operator|->
name|MethodStack
operator|=
name|MethodInfo
operator|->
name|Next
expr_stmt|;
comment|/*          * Check if there is no return statement at the end of the          * method AND we can actually get there -- i.e., the execution          * of the method can possibly terminate without a return statement.          */
if|if
condition|(
operator|(
operator|!
name|AnLastStatementIsReturn
argument_list|(
name|Op
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_HAS_NO_EXIT
operator|)
operator|)
condition|)
block|{
comment|/*              * No return statement, and execution can possibly exit              * via this path. This is equivalent to Return ()              */
name|MethodInfo
operator|->
name|NumReturnNoValue
operator|++
expr_stmt|;
block|}
comment|/*          * Check for case where some return statements have a return value          * and some do not. Exit without a return statement is a return with          * no value          */
if|if
condition|(
name|MethodInfo
operator|->
name|NumReturnNoValue
operator|&&
name|MethodInfo
operator|->
name|NumReturnWithValue
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RETURN_TYPES
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
comment|/*          * If there are any RETURN() statements with no value, or there is a          * control path that allows the method to exit without a return value,          * we mark the method as a method that does not return a value. This          * knowledge can be used to check method invocations that expect a          * returned value.          */
if|if
condition|(
name|MethodInfo
operator|->
name|NumReturnNoValue
condition|)
block|{
if|if
condition|(
name|MethodInfo
operator|->
name|NumReturnWithValue
condition|)
block|{
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_METHOD_SOME_NO_RETVAL
expr_stmt|;
block|}
else|else
block|{
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_METHOD_NO_RETVAL
expr_stmt|;
block|}
block|}
comment|/*          * Check predefined method names for correct return behavior          * and correct number of arguments          */
name|AnCheckForReservedMethod
argument_list|(
name|Op
argument_list|,
name|MethodInfo
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|MethodInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEOP_RETURN
case|:
comment|/*          * The parent block does not "exit" and continue execution -- the          * method is terminated here with the Return() statement.          */
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_HAS_NO_EXIT
expr_stmt|;
comment|/* Used in the "typing" pass later */
name|Op
operator|->
name|Asl
operator|.
name|ParentMethod
operator|=
name|MethodInfo
operator|->
name|Op
expr_stmt|;
comment|/*          * If there is a peer node after the return statement, then this          * node is unreachable code -- i.e., it won't be executed because of          * the preceeding Return() statement.          */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Next
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_UNREACHABLE_CODE
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|Next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_IF
case|:
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_HAS_NO_EXIT
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Next
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Next
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ELSE
operator|)
condition|)
block|{
comment|/*              * This IF has a corresponding ELSE. The IF block has no exit,              * (it contains an unconditional Return)              * mark the ELSE block to remember this fact.              */
name|Op
operator|->
name|Asl
operator|.
name|Next
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_IF_HAS_NO_EXIT
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_ELSE
case|:
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_HAS_NO_EXIT
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_IF_HAS_NO_EXIT
operator|)
condition|)
block|{
comment|/*              * This ELSE block has no exit and the corresponding IF block              * has no exit either. Therefore, the parent node has no exit.              */
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_HAS_NO_EXIT
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_HAS_NO_EXIT
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|)
condition|)
block|{
comment|/* If this node has no exit, then the parent has no exit either */
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_HAS_NO_EXIT
expr_stmt|;
block|}
break|break;
block|}
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMethodTypingWalkBegin  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Descending callback for the typing walk.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnMethodTypingWalkBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMethodTypingWalkEnd  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Ascending callback for typing walk. Complete the method  *              return analysis. Check methods for:  *              1) Initialized local variables  *              2) Valid arguments  *              3) Return types  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnMethodTypingWalkEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|UINT32
name|ThisNodeBtype
decl_stmt|;
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_METHOD
case|:
name|Op
operator|->
name|Asl
operator|.
name|CompileFlags
operator||=
name|NODE_METHOD_TYPED
expr_stmt|;
break|break;
case|case
name|PARSEOP_RETURN
case|:
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|!=
name|PARSEOP_DEFAULT_ARG
operator|)
condition|)
block|{
name|ThisNodeBtype
operator|=
name|AnGetBtype
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|Child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
operator|&&
operator|(
name|ThisNodeBtype
operator|==
operator|(
name|ACPI_UINT32_MAX
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/*                  * The called method is untyped at this time (typically a                  * forward reference).                  *                  * Check for a recursive method call first.                  */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParentMethod
operator|!=
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Node
operator|->
name|Op
condition|)
block|{
comment|/* We must type the method here */
name|TrWalkParseTree
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|Child
operator|->
name|Asl
operator|.
name|Node
operator|->
name|Op
argument_list|,
name|ASL_WALK_VISIT_TWICE
argument_list|,
name|AnMethodTypingWalkBegin
argument_list|,
name|AnMethodTypingWalkEnd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ThisNodeBtype
operator|=
name|AnGetBtype
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|Child
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Returns a value, save the value type */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParentMethod
condition|)
block|{
name|Op
operator|->
name|Asl
operator|.
name|ParentMethod
operator|->
name|Asl
operator|.
name|AcpiBtype
operator||=
name|ThisNodeBtype
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnCheckMethodReturnValue  *  * PARAMETERS:  Op                  - Parent  *              OpInfo              - Parent info  *              ArgOp               - Method invocation op  *              RequiredBtypes      - What caller requires  *              ThisNodeBtype       - What this node returns (if anything)  *  * RETURN:      None  *  * DESCRIPTION: Check a method invocation for 1) A return value and if it does  *              in fact return a value, 2) check the type of the return value.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AnCheckMethodReturnValue
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
parameter_list|,
name|ACPI_PARSE_OBJECT
modifier|*
name|ArgOp
parameter_list|,
name|UINT32
name|RequiredBtypes
parameter_list|,
name|UINT32
name|ThisNodeBtype
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|OwningOp
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|Node
operator|=
name|ArgOp
operator|->
name|Asl
operator|.
name|Node
expr_stmt|;
comment|/* Examine the parent op of this method */
name|OwningOp
operator|=
name|Node
operator|->
name|Op
expr_stmt|;
if|if
condition|(
name|OwningOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_METHOD_NO_RETVAL
condition|)
block|{
comment|/* Method NEVER returns a value */
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NO_RETVAL
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OwningOp
operator|->
name|Asl
operator|.
name|CompileFlags
operator|&
name|NODE_METHOD_SOME_NO_RETVAL
condition|)
block|{
comment|/* Method SOMETIMES returns a value, SOMETIMES not */
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_SOME_NO_RETVAL
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ThisNodeBtype
operator|&
name|RequiredBtypes
operator|)
condition|)
block|{
comment|/* Method returns a value, but the type is wrong */
name|AnFormatBtype
argument_list|(
name|StringBuffer
argument_list|,
name|ThisNodeBtype
argument_list|)
expr_stmt|;
name|AnFormatBtype
argument_list|(
name|StringBuffer2
argument_list|,
name|RequiredBtypes
argument_list|)
expr_stmt|;
comment|/*          * The case where the method does not return any value at all          * was already handled in the namespace cross reference          * -- Only issue an error if the method in fact returns a value,          * but it is of the wrong type          */
if|if
condition|(
name|ThisNodeBtype
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"Method returns [%s], %s operator requires [%s]"
argument_list|,
name|StringBuffer
argument_list|,
name|OpInfo
operator|->
name|Name
argument_list|,
name|StringBuffer2
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_TYPE
argument_list|,
name|ArgOp
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnOperandTypecheckWalkBegin  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Descending callback for the analysis walk. Check methods for:  *              1) Initialized local variables  *              2) Valid arguments  *              3) Return types  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnOperandTypecheckWalkBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnOperandTypecheckWalkEnd  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Ascending callback for analysis walk. Complete method  *              return analysis.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnOperandTypecheckWalkEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
decl_stmt|;
name|UINT32
name|RuntimeArgTypes
decl_stmt|;
name|UINT32
name|RuntimeArgTypes2
decl_stmt|;
name|UINT32
name|RequiredBtypes
decl_stmt|;
name|UINT32
name|ThisNodeBtype
decl_stmt|;
name|UINT32
name|CommonBtypes
decl_stmt|;
name|UINT32
name|OpcodeClass
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|ArgOp
decl_stmt|;
name|UINT32
name|ArgType
decl_stmt|;
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
condition|)
block|{
case|case
name|AML_RAW_DATA_BYTE
case|:
case|case
name|AML_RAW_DATA_WORD
case|:
case|case
name|AML_RAW_DATA_DWORD
case|:
case|case
name|AML_RAW_DATA_QWORD
case|:
case|case
name|AML_RAW_DATA_BUFFER
case|:
case|case
name|AML_RAW_DATA_CHAIN
case|:
case|case
name|AML_PACKAGE_LENGTH
case|:
case|case
name|AML_UNASSIGNED_OPCODE
case|:
case|case
name|AML_DEFAULT_ARG_OP
case|:
comment|/* Ignore the internal (compiler-only) AML opcodes */
return|return
operator|(
name|AE_OK
operator|)
return|;
default|default:
break|break;
block|}
name|OpInfo
operator|=
name|AcpiPsGetOpcodeInfo
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OpInfo
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|ArgOp
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
name|RuntimeArgTypes
operator|=
name|OpInfo
operator|->
name|RuntimeArgs
expr_stmt|;
name|OpcodeClass
operator|=
name|OpInfo
operator|->
name|Class
expr_stmt|;
ifdef|#
directive|ifdef
name|ASL_ERROR_NAMED_OBJECT_IN_WHILE
comment|/*      * Update 11/2008: In practice, we can't perform this check. A simple      * analysis is not sufficient. Also, it can cause errors when compiling      * disassembled code because of the way Switch operators are implemented      * (a While(One) loop with a named temp variable created within.)      */
comment|/*      * If we are creating a named object, check if we are within a while loop      * by checking if the parent is a WHILE op. This is a simple analysis, but      * probably sufficient for many cases.      *      * Allow Scope(), Buffer(), and Package().      */
if|if
condition|(
operator|(
operator|(
name|OpcodeClass
operator|==
name|AML_CLASS_NAMED_OBJECT
operator|)
operator|&&
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|!=
name|AML_SCOPE_OP
operator|)
operator|)
operator|||
operator|(
operator|(
name|OpcodeClass
operator|==
name|AML_CLASS_CREATE
operator|)
operator|&&
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_NSNODE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|Parent
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_WHILE_OP
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NAMED_OBJECT_IN_WHILE
argument_list|,
name|Op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*      * Special case for control opcodes IF/RETURN/WHILE since they      * have no runtime arg list (at this time)      */
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
condition|)
block|{
case|case
name|AML_IF_OP
case|:
case|case
name|AML_WHILE_OP
case|:
case|case
name|AML_RETURN_OP
case|:
if|if
condition|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
condition|)
block|{
comment|/* Check for an internal method */
if|if
condition|(
name|AnIsInternalMethod
argument_list|(
name|ArgOp
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* The lone arg is a method call, check it */
name|RequiredBtypes
operator|=
name|AnMapArgTypeToBtype
argument_list|(
name|ARGI_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_RETURN_OP
condition|)
block|{
name|RequiredBtypes
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|ThisNodeBtype
operator|=
name|AnGetBtype
argument_list|(
name|ArgOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ThisNodeBtype
operator|==
name|ACPI_UINT32_MAX
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|AnCheckMethodReturnValue
argument_list|(
name|Op
argument_list|,
name|OpInfo
argument_list|,
name|ArgOp
argument_list|,
name|RequiredBtypes
argument_list|,
name|ThisNodeBtype
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
default|default:
break|break;
block|}
comment|/* Ignore the non-executable opcodes */
if|if
condition|(
name|RuntimeArgTypes
operator|==
name|ARGI_INVALID_OPCODE
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
switch|switch
condition|(
name|OpcodeClass
condition|)
block|{
case|case
name|AML_CLASS_EXECUTE
case|:
case|case
name|AML_CLASS_CREATE
case|:
case|case
name|AML_CLASS_CONTROL
case|:
case|case
name|AML_CLASS_RETURN_VALUE
case|:
comment|/* TBD: Change class or fix typechecking for these */
if|if
condition|(
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_BUFFER_OP
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_PACKAGE_OP
operator|)
operator|||
operator|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_VAR_PACKAGE_OP
operator|)
condition|)
block|{
break|break;
block|}
comment|/* Reverse the runtime argument list */
name|RuntimeArgTypes2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ArgType
operator|=
name|GET_CURRENT_ARG_TYPE
argument_list|(
name|RuntimeArgTypes
argument_list|)
operator|)
condition|)
block|{
name|RuntimeArgTypes2
operator|<<=
name|ARG_TYPE_WIDTH
expr_stmt|;
name|RuntimeArgTypes2
operator||=
name|ArgType
expr_stmt|;
name|INCREMENT_ARG_LIST
argument_list|(
name|RuntimeArgTypes
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ArgType
operator|=
name|GET_CURRENT_ARG_TYPE
argument_list|(
name|RuntimeArgTypes2
argument_list|)
operator|)
condition|)
block|{
name|RequiredBtypes
operator|=
name|AnMapArgTypeToBtype
argument_list|(
name|ArgType
argument_list|)
expr_stmt|;
name|ThisNodeBtype
operator|=
name|AnGetBtype
argument_list|(
name|ArgOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ThisNodeBtype
operator|==
name|ACPI_UINT32_MAX
condition|)
block|{
goto|goto
name|NextArgument
goto|;
block|}
comment|/* Examine the arg based on the required type of the arg */
switch|switch
condition|(
name|ArgType
condition|)
block|{
case|case
name|ARGI_TARGETREF
case|:
if|if
condition|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ZERO
condition|)
block|{
comment|/* ZERO is the placeholder for "don't store result" */
name|ThisNodeBtype
operator|=
name|RequiredBtypes
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_INTEGER
condition|)
block|{
comment|/*                      * This is the case where an original reference to a resource                      * descriptor field has been replaced by an (Integer) offset.                      * These named fields are supported at compile-time only;                      * the names are not passed to the interpreter (via the AML).                      */
if|if
condition|(
operator|(
name|ArgOp
operator|->
name|Asl
operator|.
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_RESOURCE_FIELD
operator|)
operator|||
operator|(
name|ArgOp
operator|->
name|Asl
operator|.
name|Node
operator|->
name|Type
operator|==
name|ACPI_TYPE_LOCAL_RESOURCE
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_RESOURCE_FIELD
argument_list|,
name|ArgOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_TYPE
argument_list|,
name|ArgOp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
operator|)
operator|||
operator|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_DEREFOF
operator|)
condition|)
block|{
break|break;
block|}
name|ThisNodeBtype
operator|=
name|RequiredBtypes
expr_stmt|;
break|break;
case|case
name|ARGI_REFERENCE
case|:
comment|/* References */
case|case
name|ARGI_INTEGER_REF
case|:
case|case
name|ARGI_OBJECT_REF
case|:
case|case
name|ARGI_DEVICE_REF
case|:
switch|switch
condition|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_LOCAL0
case|:
case|case
name|PARSEOP_LOCAL1
case|:
case|case
name|PARSEOP_LOCAL2
case|:
case|case
name|PARSEOP_LOCAL3
case|:
case|case
name|PARSEOP_LOCAL4
case|:
case|case
name|PARSEOP_LOCAL5
case|:
case|case
name|PARSEOP_LOCAL6
case|:
case|case
name|PARSEOP_LOCAL7
case|:
comment|/* TBD: implement analysis of current value (type) of the local */
comment|/* For now, just treat any local as a typematch */
comment|/*ThisNodeBtype = RequiredBtypes;*/
break|break;
case|case
name|PARSEOP_ARG0
case|:
case|case
name|PARSEOP_ARG1
case|:
case|case
name|PARSEOP_ARG2
case|:
case|case
name|PARSEOP_ARG3
case|:
case|case
name|PARSEOP_ARG4
case|:
case|case
name|PARSEOP_ARG5
case|:
case|case
name|PARSEOP_ARG6
case|:
comment|/* Hard to analyze argument types, sow we won't */
comment|/* For now, just treat any arg as a typematch */
comment|/* ThisNodeBtype = RequiredBtypes; */
break|break;
case|case
name|PARSEOP_DEBUG
case|:
break|break;
case|case
name|PARSEOP_REFOF
case|:
case|case
name|PARSEOP_INDEX
case|:
default|default:
break|break;
block|}
break|break;
case|case
name|ARGI_INTEGER
case|:
default|default:
break|break;
block|}
name|CommonBtypes
operator|=
name|ThisNodeBtype
operator|&
name|RequiredBtypes
expr_stmt|;
if|if
condition|(
name|ArgOp
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_METHODCALL
condition|)
block|{
if|if
condition|(
name|AnIsInternalMethod
argument_list|(
name|ArgOp
argument_list|)
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
comment|/* Check a method call for a valid return value */
name|AnCheckMethodReturnValue
argument_list|(
name|Op
argument_list|,
name|OpInfo
argument_list|,
name|ArgOp
argument_list|,
name|RequiredBtypes
argument_list|,
name|ThisNodeBtype
argument_list|)
expr_stmt|;
block|}
comment|/*              * Now check if the actual type(s) match at least one              * bit to the required type              */
elseif|else
if|if
condition|(
operator|!
name|CommonBtypes
condition|)
block|{
comment|/* No match -- this is a type mismatch error */
name|AnFormatBtype
argument_list|(
name|StringBuffer
argument_list|,
name|ThisNodeBtype
argument_list|)
expr_stmt|;
name|AnFormatBtype
argument_list|(
name|StringBuffer2
argument_list|,
name|RequiredBtypes
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|MsgBuffer
argument_list|,
literal|"[%s] found, %s operator requires [%s]"
argument_list|,
name|StringBuffer
argument_list|,
name|OpInfo
operator|->
name|Name
argument_list|,
name|StringBuffer2
argument_list|)
expr_stmt|;
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_INVALID_TYPE
argument_list|,
name|ArgOp
argument_list|,
name|MsgBuffer
argument_list|)
expr_stmt|;
block|}
name|NextArgument
label|:
name|ArgOp
operator|=
name|ArgOp
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|INCREMENT_ARG_LIST
argument_list|(
name|RuntimeArgTypes2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnIsResultUsed  *  * PARAMETERS:  Op              - Parent op for the operator  *  * RETURN:      TRUE if result from this operation is actually consumed  *  * DESCRIPTION: Determine if the function result value from an operator is  *              used.  *  ******************************************************************************/
end_comment

begin_function
name|BOOLEAN
name|AnIsResultUsed
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|Parent
decl_stmt|;
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_INCREMENT
case|:
case|case
name|PARSEOP_DECREMENT
case|:
comment|/* These are standalone operators, no return value */
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
break|break;
block|}
comment|/* Examine parent to determine if the return value is used */
name|Parent
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Parent
expr_stmt|;
switch|switch
condition|(
name|Parent
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
comment|/* If/While - check if the operator is the predicate */
case|case
name|PARSEOP_IF
case|:
case|case
name|PARSEOP_WHILE
case|:
comment|/* First child is the predicate */
if|if
condition|(
name|Parent
operator|->
name|Asl
operator|.
name|Child
operator|==
name|Op
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Not used if one of these is the parent */
case|case
name|PARSEOP_METHOD
case|:
case|case
name|PARSEOP_DEFINITIONBLOCK
case|:
case|case
name|PARSEOP_ELSE
case|:
return|return
operator|(
name|FALSE
operator|)
return|;
default|default:
comment|/* Any other type of parent means that the result is used */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnOtherSemanticAnalysisWalkBegin  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Descending callback for the analysis walk. Checks for  *              miscellaneous issues in the code.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnOtherSemanticAnalysisWalkBegin
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
name|ACPI_PARSE_OBJECT
modifier|*
name|ArgNode
decl_stmt|;
name|ACPI_PARSE_OBJECT
modifier|*
name|PrevArgNode
init|=
name|NULL
decl_stmt|;
specifier|const
name|ACPI_OPCODE_INFO
modifier|*
name|OpInfo
decl_stmt|;
name|OpInfo
operator|=
name|AcpiPsGetOpcodeInfo
argument_list|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
argument_list|)
expr_stmt|;
comment|/*      * Determine if an execution class operator actually does something by      * checking if it has a target and/or the function return value is used.      * (Target is optional, so a standalone statement can actually do nothing.)      */
if|if
condition|(
operator|(
name|OpInfo
operator|->
name|Class
operator|==
name|AML_CLASS_EXECUTE
operator|)
operator|&&
operator|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_HAS_RETVAL
operator|)
operator|&&
operator|(
operator|!
name|AnIsResultUsed
argument_list|(
name|Op
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|OpInfo
operator|->
name|Flags
operator|&
name|AML_HAS_TARGET
condition|)
block|{
comment|/*              * Find the target node, it is always the last child. If the traget              * is not specified in the ASL, a default node of type Zero was              * created by the parser.              */
name|ArgNode
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
while|while
condition|(
name|ArgNode
operator|->
name|Asl
operator|.
name|Next
condition|)
block|{
name|PrevArgNode
operator|=
name|ArgNode
expr_stmt|;
name|ArgNode
operator|=
name|ArgNode
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
block|}
comment|/* Divide() is the only weird case, it has two targets */
if|if
condition|(
name|Op
operator|->
name|Asl
operator|.
name|AmlOpcode
operator|==
name|AML_DIVIDE_OP
condition|)
block|{
if|if
condition|(
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ZERO
operator|)
operator|&&
operator|(
name|PrevArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ZERO
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESULT_NOT_USED
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ZERO
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESULT_NOT_USED
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*              * Has no target and the result is not used. Only a couple opcodes              * can have this combination.              */
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_ACQUIRE
case|:
case|case
name|PARSEOP_WAIT
case|:
case|case
name|PARSEOP_LOADTABLE
case|:
break|break;
default|default:
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_RESULT_NOT_USED
argument_list|,
name|Op
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*      * Semantic checks for individual ASL operators      */
switch|switch
condition|(
name|Op
operator|->
name|Asl
operator|.
name|ParseOpcode
condition|)
block|{
case|case
name|PARSEOP_ACQUIRE
case|:
case|case
name|PARSEOP_WAIT
case|:
comment|/*          * Emit a warning if the timeout parameter for these operators is not          * ACPI_WAIT_FOREVER, and the result value from the operator is not          * checked, meaning that a timeout could happen, but the code          * would not know about it.          */
comment|/* First child is the namepath, 2nd child is timeout */
name|ArgNode
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
name|ArgNode
operator|=
name|ArgNode
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
comment|/*          * Check for the WAIT_FOREVER case - defined by the ACPI spec to be          * 0xFFFF or greater          */
if|if
condition|(
operator|(
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_WORDCONST
operator|)
operator|||
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_INTEGER
operator|)
operator|)
operator|&&
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|>=
operator|(
name|ACPI_INTEGER
operator|)
name|ACPI_WAIT_FOREVER
operator|)
condition|)
block|{
break|break;
block|}
comment|/*          * The operation could timeout. If the return value is not used          * (indicates timeout occurred), issue a warning          */
if|if
condition|(
operator|!
name|AnIsResultUsed
argument_list|(
name|Op
argument_list|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_WARNING
argument_list|,
name|ASL_MSG_TIMEOUT
argument_list|,
name|ArgNode
argument_list|,
name|Op
operator|->
name|Asl
operator|.
name|ExternalName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARSEOP_CREATEFIELD
case|:
comment|/*          * Check for a zero Length (NumBits) operand. NumBits is the 3rd operand          */
name|ArgNode
operator|=
name|Op
operator|->
name|Asl
operator|.
name|Child
expr_stmt|;
name|ArgNode
operator|=
name|ArgNode
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
name|ArgNode
operator|=
name|ArgNode
operator|->
name|Asl
operator|.
name|Next
expr_stmt|;
if|if
condition|(
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_ZERO
operator|)
operator|||
operator|(
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|ParseOpcode
operator|==
name|PARSEOP_INTEGER
operator|)
operator|&&
operator|(
name|ArgNode
operator|->
name|Asl
operator|.
name|Value
operator|.
name|Integer
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|AslError
argument_list|(
name|ASL_ERROR
argument_list|,
name|ASL_MSG_NON_ZERO
argument_list|,
name|ArgNode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|AE_OK
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnOtherSemanticAnalysisWalkEnd  *  * PARAMETERS:  ASL_WALK_CALLBACK  *  * RETURN:      Status  *  * DESCRIPTION: Ascending callback for analysis walk. Complete method  *              return analysis.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AnOtherSemanticAnalysisWalkEnd
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|UINT32
name|Level
parameter_list|,
name|void
modifier|*
name|Context
parameter_list|)
block|{
return|return
name|AE_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_OBSOLETE_FUNCTIONS
end_ifdef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AnMapBtypeToEtype  *  * PARAMETERS:  Btype               - Bitfield of ACPI types  *  * RETURN:      The Etype corresponding the the Btype  *  * DESCRIPTION: Convert a bitfield type to an encoded type  *  ******************************************************************************/
end_comment

begin_function
name|UINT32
name|AnMapBtypeToEtype
parameter_list|(
name|UINT32
name|Btype
parameter_list|)
block|{
name|UINT32
name|i
decl_stmt|;
name|UINT32
name|Etype
decl_stmt|;
if|if
condition|(
name|Btype
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Etype
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|Btype
condition|;
name|i
operator|*=
literal|2
control|)
block|{
name|Etype
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|Etype
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

