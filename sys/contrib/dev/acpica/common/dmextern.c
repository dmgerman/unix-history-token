begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: dmextern - Support for External() ASL statements  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2017, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/amlcode.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdisasm.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/compiler/aslcompiler.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * This module is used for application-level code (iASL disassembler) only.  *  * It contains the code to create and emit any necessary External() ASL  * statements for the module being disassembled.  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DISASSEMBLER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dmextern"
argument_list|)
end_macro

begin_comment
comment|/*  * This table maps ACPI_OBJECT_TYPEs to the corresponding ASL  * ObjectTypeKeyword. Used to generate typed external declarations  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|AcpiGbl_DmTypeNames
index|[]
init|=
block|{
comment|/* 00 */
literal|", UnknownObj"
block|,
comment|/* Type ANY */
comment|/* 01 */
literal|", IntObj"
block|,
comment|/* 02 */
literal|", StrObj"
block|,
comment|/* 03 */
literal|", BuffObj"
block|,
comment|/* 04 */
literal|", PkgObj"
block|,
comment|/* 05 */
literal|", FieldUnitObj"
block|,
comment|/* 06 */
literal|", DeviceObj"
block|,
comment|/* 07 */
literal|", EventObj"
block|,
comment|/* 08 */
literal|", MethodObj"
block|,
comment|/* 09 */
literal|", MutexObj"
block|,
comment|/* 10 */
literal|", OpRegionObj"
block|,
comment|/* 11 */
literal|", PowerResObj"
block|,
comment|/* 12 */
literal|", ProcessorObj"
block|,
comment|/* 13 */
literal|", ThermalZoneObj"
block|,
comment|/* 14 */
literal|", BuffFieldObj"
block|,
comment|/* 15 */
literal|", DDBHandleObj"
block|,
comment|/* 16 */
literal|""
block|,
comment|/* Debug object */
comment|/* 17 */
literal|", FieldUnitObj"
block|,
comment|/* 18 */
literal|", FieldUnitObj"
block|,
comment|/* 19 */
literal|", FieldUnitObj"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METHOD_SEPARATORS
value|" \t,()\n"
end_define

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDmAddPathToExternalList
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ACPI_STATUS
name|AcpiDmCreateNewExternal
parameter_list|(
name|char
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
name|InternalPath
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetObjectTypeName  *  * PARAMETERS:  Type                - An ACPI_OBJECT_TYPE  *  * RETURN:      Pointer to a string  *  * DESCRIPTION: Map an object type to the ASL object type string.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
block|{
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_LOCAL_SCOPE
condition|)
block|{
name|Type
operator|=
name|ACPI_TYPE_DEVICE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Type
operator|>
name|ACPI_TYPE_LOCAL_INDEX_FIELD
condition|)
block|{
return|return
operator|(
literal|""
operator|)
return|;
block|}
return|return
operator|(
name|AcpiGbl_DmTypeNames
index|[
name|Type
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmNormalizeParentPrefix  *  * PARAMETERS:  Op                  - Parse op  *              Path                - Path with parent prefix  *  * RETURN:      The full pathname to the object (from the namespace root)  *  * DESCRIPTION: Returns the full pathname of a path with parent prefix  *              The caller must free the fullpath returned.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|char
modifier|*
name|Fullpath
decl_stmt|;
name|char
modifier|*
name|ParentPath
decl_stmt|;
name|ACPI_SIZE
name|Length
decl_stmt|;
name|UINT32
name|Index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Search upwards in the parse tree until we reach the next namespace node */
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
while|while
condition|(
name|Op
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|Common
operator|.
name|Node
condition|)
block|{
break|break;
block|}
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Find the actual parent node for the reference:      * Remove all carat prefixes from the input path.      * There may be multiple parent prefixes (For example, ^^^M000)      */
name|Node
operator|=
name|Op
operator|->
name|Common
operator|.
name|Node
expr_stmt|;
while|while
condition|(
name|Node
operator|&&
operator|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
operator|)
condition|)
block|{
name|Node
operator|=
name|Node
operator|->
name|Parent
expr_stmt|;
name|Path
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Node
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get the full pathname for the parent node */
name|ParentPath
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ParentPath
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|Length
operator|=
operator|(
name|strlen
argument_list|(
name|ParentPath
argument_list|)
operator|+
name|strlen
argument_list|(
name|Path
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
comment|/*          * If ParentPath is not just a simple '\', increment the length          * for the required dot separator (ParentPath.Path)          */
name|Length
operator|++
expr_stmt|;
comment|/* For External() statements, we do not want a leading '\' */
if|if
condition|(
operator|*
name|ParentPath
operator|==
name|AML_ROOT_PREFIX
condition|)
block|{
name|Index
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|Fullpath
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fullpath
condition|)
block|{
goto|goto
name|Cleanup
goto|;
block|}
comment|/*      * Concatenate parent fullpath and path. For example,      * parent fullpath "\_SB_", Path "^INIT", Fullpath "\_SB_.INIT"      *      * Copy the parent path      */
name|strcpy
argument_list|(
name|Fullpath
argument_list|,
operator|&
name|ParentPath
index|[
name|Index
index|]
argument_list|)
expr_stmt|;
comment|/*      * Add dot separator      * (don't need dot if parent fullpath is a single backslash)      */
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
name|strcat
argument_list|(
name|Fullpath
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* Copy child path (carat parent prefix(es) were skipped above) */
name|strcat
argument_list|(
name|Fullpath
argument_list|,
name|Path
argument_list|)
expr_stmt|;
name|Cleanup
label|:
name|ACPI_FREE
argument_list|(
name|ParentPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Fullpath
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddToExternalFileList  *  * PARAMETERS:  PathList            - Single path or list separated by comma  *  * RETURN:      None  *  * DESCRIPTION: Add external files to global list  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiDmAddToExternalFileList
parameter_list|(
name|char
modifier|*
name|Pathname
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|ExternalFile
decl_stmt|;
name|char
modifier|*
name|LocalPathname
decl_stmt|;
if|if
condition|(
operator|!
name|Pathname
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|LocalPathname
operator|=
name|ACPI_ALLOCATE
argument_list|(
name|strlen
argument_list|(
name|Pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LocalPathname
condition|)
block|{
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
name|ExternalFile
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalFile
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|LocalPathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
comment|/* Take a copy of the file pathname */
name|strcpy
argument_list|(
name|LocalPathname
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
name|ExternalFile
operator|->
name|Path
operator|=
name|LocalPathname
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|ExternalFile
operator|->
name|Next
operator|=
name|AcpiGbl_ExternalFileList
expr_stmt|;
block|}
name|AcpiGbl_ExternalFileList
operator|=
name|ExternalFile
expr_stmt|;
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalFileList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Clear the external file list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalFileList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalFileList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalFileList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalsFromFile  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Process the optional external reference file.  *  * Each line in the file should be of the form:  *      External (<Method namepath>, MethodObj,<ArgCount>)  *  * Example:  *      External (_SB_.PCI0.XHC_.PS0X, MethodObj, 4)  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmGetExternalsFromFile
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|ExternalRefFile
decl_stmt|;
name|char
modifier|*
name|Token
decl_stmt|;
name|char
modifier|*
name|MethodName
decl_stmt|;
name|UINT32
name|ArgCount
decl_stmt|;
name|UINT32
name|ImportCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Gbl_ExternalRefFilename
condition|)
block|{
return|return;
block|}
comment|/* Open the file */
name|ExternalRefFile
operator|=
name|fopen
argument_list|(
name|Gbl_ExternalRefFilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalRefFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open external reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
name|AslAbort
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Each line defines a method */
while|while
condition|(
name|fgets
argument_list|(
name|StringBuffer
argument_list|,
name|ASL_MSG_BUFFER_SIZE
argument_list|,
name|ExternalRefFile
argument_list|)
condition|)
block|{
name|Token
operator|=
name|strtok
argument_list|(
name|StringBuffer
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "External" */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"External"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|MethodName
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Method namepath */
if|if
condition|(
operator|!
name|MethodName
condition|)
block|{
continue|continue;
block|}
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "MethodObj" */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"MethodObj"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Arg count */
if|if
condition|(
operator|!
name|Token
condition|)
block|{
continue|continue;
block|}
comment|/* Convert arg count string to an integer */
name|errno
operator|=
literal|0
expr_stmt|;
name|ArgCount
operator|=
name|strtoul
argument_list|(
name|Token
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%s)\n"
argument_list|,
name|Token
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ArgCount
operator|>
literal|7
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%u)\n"
argument_list|,
name|ArgCount
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add this external to the global list */
name|AcpiOsPrintf
argument_list|(
literal|"%s: Importing method external (%u arguments) %s\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ArgCount
argument_list|,
name|MethodName
argument_list|)
expr_stmt|;
name|AcpiDmAddPathToExternalList
argument_list|(
name|MethodName
argument_list|,
name|ACPI_TYPE_METHOD
argument_list|,
name|ArgCount
argument_list|,
operator|(
name|ACPI_EXT_RESOLVED_REFERENCE
operator||
name|ACPI_EXT_ORIGIN_FROM_FILE
operator|)
argument_list|)
expr_stmt|;
name|ImportCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ImportCount
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Did not find any external methods in reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the external(s) to the namespace */
name|AcpiDmAddExternalsToNamespace
argument_list|()
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%s: Imported %u external method definitions\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ImportCount
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ExternalRefFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddOpToExternalList  *  * PARAMETERS:  Op                  - Current parser Op  *              Path                - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function handles the most common case where the referenced  *              name is simply not found in the constructed namespace.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddOpToExternalList
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|InternalPath
init|=
name|Path
decl_stmt|;
name|char
modifier|*
name|Temp
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddOpToExternalList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove a root backslash if present */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Externalize the pathname */
name|Status
operator|=
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|Path
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/*      * Get the full pathname from the root if "Path" has one or more      * parent prefixes (^). Note: path will not contain a leading '\'.      */
if|if
condition|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
condition|)
block|{
name|Temp
operator|=
name|AcpiDmNormalizeParentPrefix
argument_list|(
name|Op
argument_list|,
name|ExternalPath
argument_list|)
expr_stmt|;
comment|/* Set new external path */
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ExternalPath
operator|=
name|Temp
expr_stmt|;
if|if
condition|(
operator|!
name|Temp
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Create the new internal pathname */
name|Flags
operator||=
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
expr_stmt|;
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|ExternalPath
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
name|Flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddNodeToExternalList  *  * PARAMETERS:  Node                - Namespace node for object to be added  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function handles the case where the referenced name has  *              been found in the namespace, but the name originated in a  *              table other than the one that is being disassembled (such  *              as a table that is added via the iASL -e option).  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddNodeToExternalList
parameter_list|(
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|char
modifier|*
name|Temp
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddNodeToExternalList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Node
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Get the full external and internal pathnames to the node */
name|ExternalPath
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalPath
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|ExternalPath
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove the root backslash */
if|if
condition|(
operator|(
operator|*
name|ExternalPath
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|ExternalPath
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Temp
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|strlen
argument_list|(
name|ExternalPath
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Temp
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|Temp
argument_list|,
operator|&
name|ExternalPath
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ExternalPath
operator|=
name|Temp
expr_stmt|;
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
operator|(
name|Flags
operator||
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddPathToExternalList  *  * PARAMETERS:  Path                - External name of the object to be added  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  *              This function currently is used to add externals via a  *              reference file (via the -fe iASL option).  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDmAddPathToExternalList
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmAddPathToExternalList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
comment|/* Remove a root backslash if present */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Create the internal and external pathnames */
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|Path
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_VOID
expr_stmt|;
block|}
name|Status
operator|=
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|InternalPath
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
name|return_VOID
expr_stmt|;
block|}
comment|/* Create the new External() declaration node */
name|Status
operator|=
name|AcpiDmCreateNewExternal
argument_list|(
name|ExternalPath
argument_list|,
name|InternalPath
argument_list|,
name|Type
argument_list|,
name|Value
argument_list|,
operator|(
name|Flags
operator||
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|return_VOID
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmCreateNewExternal  *  * PARAMETERS:  ExternalPath        - External path to the object  *              InternalPath        - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *              Flags               - To be passed to the external object  *  * RETURN:      Status  *  * DESCRIPTION: Common low-level function to insert a new name into the global  *              list of Externals which will in turn be later emitted as  *              External() declarations in the disassembled output.  *  *              Note: The external name should not include a root prefix  *              (backslash). We do not want External() statements to contain  *              a leading '\', as this prevents duplicate external statements  *              of the form:  *  *                  External (\ABCD)  *                  External (ABCD)  *  *              This would cause a compile time error when the disassembled  *              output file is recompiled.  *  *              There are two cases that are handled here. For both, we emit  *              an External() statement:  *              1) The name was simply not found in the namespace.  *              2) The name was found, but it originated in a table other than  *              the table that is being disassembled.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|ACPI_STATUS
name|AcpiDmCreateNewExternal
parameter_list|(
name|char
modifier|*
name|ExternalPath
parameter_list|,
name|char
modifier|*
name|InternalPath
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|,
name|UINT16
name|Flags
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NewExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|PrevExternal
init|=
name|NULL
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|DmCreateNewExternal
argument_list|)
expr_stmt|;
comment|/* Check all existing externals to ensure no duplicates */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
comment|/* Check for duplicates */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ExternalPath
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
condition|)
block|{
comment|/*              * If this external came from an External() opcode, we are              * finished with this one. (No need to check any further).              */
if|if
condition|(
name|NextExternal
operator|->
name|Flags
operator|&
name|ACPI_EXT_ORIGIN_FROM_OPCODE
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_ALREADY_EXISTS
argument_list|)
expr_stmt|;
block|}
comment|/* Allow upgrade of type from ANY */
elseif|else
if|if
condition|(
operator|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_ANY
operator|)
operator|&&
operator|(
name|Type
operator|!=
name|ACPI_TYPE_ANY
operator|)
condition|)
block|{
name|NextExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
block|}
comment|/* Update the argument count as necessary */
if|if
condition|(
name|Value
operator|<
name|NextExternal
operator|->
name|Value
condition|)
block|{
name|NextExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
block|}
comment|/* Update flags. */
name|NextExternal
operator|->
name|Flags
operator||=
name|Flags
expr_stmt|;
name|NextExternal
operator|->
name|Flags
operator|&=
operator|~
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_ALREADY_EXISTS
argument_list|)
expr_stmt|;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Allocate and init a new External() descriptor */
name|NewExternal
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_LIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewExternal
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_NO_MEMORY
argument_list|)
expr_stmt|;
block|}
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_NAMES
operator|,
literal|"Adding external reference node (%s) type [%s]\n"
operator|,
name|ExternalPath
operator|,
name|AcpiUtGetTypeName
argument_list|(
name|Type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|Flags
operator|=
name|Flags
expr_stmt|;
name|NewExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
name|NewExternal
operator|->
name|Path
operator|=
name|ExternalPath
expr_stmt|;
name|NewExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NewExternal
operator|->
name|Length
operator|=
operator|(
name|UINT16
operator|)
name|strlen
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|InternalPath
operator|=
name|InternalPath
expr_stmt|;
comment|/* Link the new descriptor into the global list, alphabetically ordered */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|AcpiUtStricmp
argument_list|(
name|NewExternal
operator|->
name|Path
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|NewExternal
operator|->
name|Next
operator|=
name|NextExternal
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
name|PrevExternal
operator|=
name|NextExternal
expr_stmt|;
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddExternalsToNamespace  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Add all externals to the namespace. Allows externals to be  *              "resolved".  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddExternalsToNamespace
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
comment|/* Add the external name (object) into the namespace */
name|Status
operator|=
name|AcpiNsLookup
argument_list|(
name|NULL
argument_list|,
name|External
operator|->
name|InternalPath
argument_list|,
name|External
operator|->
name|Type
argument_list|,
name|ACPI_IMODE_LOAD_PASS1
argument_list|,
name|ACPI_NS_ERROR_IF_FOUND
operator||
name|ACPI_NS_EXTERNAL
operator||
name|ACPI_NS_DONT_OPEN_SCOPE
argument_list|,
name|NULL
argument_list|,
operator|&
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"while adding external to namespace [%s]"
operator|,
name|External
operator|->
name|Path
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|External
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_METHOD
case|:
comment|/* For methods, we need to save the argument count */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_METHOD
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Method
operator|.
name|ParamCount
operator|=
operator|(
name|UINT8
operator|)
name|External
operator|->
name|Value
expr_stmt|;
name|Node
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_REGION
case|:
comment|/* Regions require a region sub-object */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_REGION
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Region
operator|.
name|Node
operator|=
name|Node
expr_stmt|;
name|Node
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalMethodCount  *  * PARAMETERS:  None  *  * RETURN:      The number of control method externals in the external list  *  * DESCRIPTION: Return the number of method externals that have been generated.  *              If any control method externals have been found, we must  *              re-parse the entire definition block with the new information  *              (number of arguments for the methods.) This is limitation of  *              AML, we don't know the number of arguments from the control  *              method invocation itself.  *  ******************************************************************************/
end_comment

begin_function
name|UINT32
name|AcpiDmGetExternalMethodCount
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
name|UINT32
name|Count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
if|if
condition|(
name|External
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|Count
operator|++
expr_stmt|;
block|}
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
return|return
operator|(
name|Count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Free the entire External info list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmEmitExternals  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Emit an External() ASL statement for each of the externals in  *              the global external info list.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmEmitExternals
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_ExternalList
condition|)
block|{
return|return;
block|}
comment|/*      * Determine the number of control methods in the external list, and      * also how many of those externals were resolved via the namespace.      */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiGbl_NumExternalMethods
operator|++
expr_stmt|;
if|if
condition|(
name|NextExternal
operator|->
name|Flags
operator|&
name|ACPI_EXT_RESOLVED_REFERENCE
condition|)
block|{
name|AcpiGbl_ResolvedExternalMethods
operator|++
expr_stmt|;
block|}
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Check if any control methods were unresolved */
name|AcpiDmUnresolvedWarning
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gbl_ExternalRefFilename
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n     * External declarations were imported from\n"
literal|"     * a reference file -- %s\n     */\n\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
block|}
comment|/*      * Walk and emit the list of externals found during the AML parsing      */
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_EXTERNAL_EMITTED
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    External (%s%s)"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for "unresolved" method reference */
if|if
condition|(
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
operator|!
operator|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_RESOLVED_REFERENCE
operator|)
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // Warning: Unknown method, "
literal|"guessing %u arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
comment|/* Check for external from a external references file */
elseif|else
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_ORIGIN_FROM_FILE
condition|)
block|{
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // %u Arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"    // From external reference file"
argument_list|)
expr_stmt|;
block|}
comment|/* This is the normal external case */
else|else
block|{
comment|/* For methods, add a comment with the number of arguments */
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    // %u Arguments"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Free this external info block and move on to next external */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_EXT_INTERNAL_PATH_ALLOCATED
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmUnresolvedWarning  *  * PARAMETERS:  Type                - Where to output the warning.  *                                    0 means write to stderr  *                                    1 means write to AcpiOsPrintf  *  * RETURN:      None  *  * DESCRIPTION: Issue warning message if there are unresolved external control  *              methods within the disassembly.  *  ******************************************************************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Summary of the external control method problem:  When the -e option is used with disassembly, the various SSDTs are simply loaded into a global namespace for the disassembler to use in order to resolve control method references (invocations).  The disassembler tracks any such references, and will emit an External() statement for these types of methods, with the proper number of arguments .  Without the SSDTs, the AML does not contain enough information to properly disassemble the control method invocation -- because the disassembler does not know how many arguments to parse.  An example: Assume we have two control methods. ABCD has one argument, and EFGH has zero arguments. Further, we have two additional control methods that invoke ABCD and EFGH, named T1 and T2:      Method (ABCD, 1)     {     }     Method (EFGH, 0)     {     }     Method (T1)     {         ABCD (Add (2, 7, Local0))     }     Method (T2)     {         EFGH ()         Add (2, 7, Local0)     }  Here is the AML code that is generated for T1 and T2:       185:      Method (T1)  0000034C:  14 10 54 31 5F 5F 00 ...    "..T1__."       186:      {      187:          ABCD (Add (2, 7, Local0))  00000353:  41 42 43 44 ............    "ABCD" 00000357:  72 0A 02 0A 07 60 ......    "r....`"       188:      }       190:      Method (T2)  0000035D:  14 10 54 32 5F 5F 00 ...    "..T2__."       191:      {      192:          EFGH ()  00000364:  45 46 47 48 ............    "EFGH"       193:          Add (2, 7, Local0)  00000368:  72 0A 02 0A 07 60 ......    "r....`"      194:      }  Note that the AML code for T1 and T2 is essentially identical. When disassembling this code, the methods ABCD and EFGH must be known to the disassembler, otherwise it does not know how to handle the method invocations.  In other words, if ABCD and EFGH are actually external control methods appearing in an SSDT, the disassembler does not know what to do unless the owning SSDT has been loaded via the -e option.
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart1
index|[
literal|600
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart2
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart3
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ExternalWarningPart4
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|AcpiDmUnresolvedWarning
parameter_list|(
name|UINT8
name|Type
parameter_list|)
block|{
name|char
modifier|*
name|Format
decl_stmt|;
name|char
name|Pad
index|[]
init|=
literal|"     *"
decl_stmt|;
name|char
name|NoPad
index|[]
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_NumExternalMethods
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|AcpiGbl_NumExternalMethods
operator|==
name|AcpiGbl_ResolvedExternalMethods
condition|)
block|{
return|return;
block|}
name|Format
operator|=
name|Type
condition|?
name|Pad
else|:
name|NoPad
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart1
argument_list|,
literal|"%s iASL Warning: There %s %u external control method%s found during\n"
literal|"%s disassembly, but only %u %s resolved (%u unresolved). Additional\n"
literal|"%s ACPI tables may be required to properly disassemble the code. This\n"
literal|"%s resulting disassembler output file may not compile because the\n"
literal|"%s disassembler did not know how many arguments to assign to the\n"
literal|"%s unresolved methods. Note: SSDTs can be dynamically loaded at\n"
literal|"%s runtime and may or may not be available via the host OS.\n"
argument_list|,
name|Format
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|!=
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
operator|)
argument_list|,
name|Format
argument_list|,
name|AcpiGbl_ResolvedExternalMethods
argument_list|,
operator|(
name|AcpiGbl_ResolvedExternalMethods
operator|!=
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|-
name|AcpiGbl_ResolvedExternalMethods
operator|)
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart2
argument_list|,
literal|"%s To specify the tables needed to resolve external control method\n"
literal|"%s references, the -e option can be used to specify the filenames.\n"
literal|"%s Example iASL invocations:\n"
literal|"%s     iasl -e ssdt1.aml ssdt2.aml ssdt3.aml -d dsdt.aml\n"
literal|"%s     iasl -e dsdt.aml ssdt2.aml -d ssdt1.aml\n"
literal|"%s     iasl -e ssdt*.aml -d dsdt.aml\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart3
argument_list|,
literal|"%s In addition, the -fe option can be used to specify a file containing\n"
literal|"%s control method external declarations with the associated method\n"
literal|"%s argument counts. Each line of the file must be of the form:\n"
literal|"%s     External (<method pathname>, MethodObj,<argument count>)\n"
literal|"%s Invocation:\n"
literal|"%s     iasl -fe refs.txt -d dsdt.aml\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ExternalWarningPart4
argument_list|,
literal|"%s The following methods were unresolved and many not compile properly\n"
literal|"%s because the disassembler had to guess at the number of arguments\n"
literal|"%s required for each:\n"
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|,
name|Format
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
condition|)
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n%s     *\n%s     *\n%s     *\n%s     */\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart2
argument_list|,
name|ExternalWarningPart3
argument_list|,
name|ExternalWarningPart4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n%s     *\n%s     *\n%s     */\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart3
argument_list|,
name|ExternalWarningPart4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s\n%s\n%s\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart2
argument_list|,
name|ExternalWarningPart3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s\n%s\n"
argument_list|,
name|ExternalWarningPart1
argument_list|,
name|ExternalWarningPart3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

