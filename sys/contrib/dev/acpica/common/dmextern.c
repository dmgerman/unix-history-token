begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: dmextern - Support for External() ASL statements  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2013, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/amlcode.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdisasm.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/compiler/aslcompiler.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * This module is used for application-level code (iASL disassembler) only.  *  * It contains the code to create and emit any necessary External() ASL  * statements for the module being disassembled.  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_CA_DISASSEMBLER
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"dmextern"
argument_list|)
end_macro

begin_comment
comment|/*  * This table maps ACPI_OBJECT_TYPEs to the corresponding ASL  * ObjectTypeKeyword. Used to generate typed external declarations  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|AcpiGbl_DmTypeNames
index|[]
init|=
block|{
comment|/* 00 */
literal|""
block|,
comment|/* Type ANY */
comment|/* 01 */
literal|", IntObj"
block|,
comment|/* 02 */
literal|", StrObj"
block|,
comment|/* 03 */
literal|", BuffObj"
block|,
comment|/* 04 */
literal|", PkgObj"
block|,
comment|/* 05 */
literal|", FieldUnitObj"
block|,
comment|/* 06 */
literal|", DeviceObj"
block|,
comment|/* 07 */
literal|", EventObj"
block|,
comment|/* 08 */
literal|", MethodObj"
block|,
comment|/* 09 */
literal|", MutexObj"
block|,
comment|/* 10 */
literal|", OpRegionObj"
block|,
comment|/* 11 */
literal|", PowerResObj"
block|,
comment|/* 12 */
literal|", ProcessorObj"
block|,
comment|/* 13 */
literal|", ThermalZoneObj"
block|,
comment|/* 14 */
literal|", BuffFieldObj"
block|,
comment|/* 15 */
literal|", DDBHandleObj"
block|,
comment|/* 16 */
literal|""
block|,
comment|/* Debug object */
comment|/* 17 */
literal|", FieldUnitObj"
block|,
comment|/* 18 */
literal|", FieldUnitObj"
block|,
comment|/* 19 */
literal|", FieldUnitObj"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|METHOD_SEPARATORS
value|" \t,()\n"
end_define

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|AcpiDmAddToExternalListFromFile
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetObjectTypeName  *  * PARAMETERS:  Type                - An ACPI_OBJECT_TYPE  *  * RETURN:      Pointer to a string  *  * DESCRIPTION: Map an object type to the ASL object type string.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|AcpiDmGetObjectTypeName
parameter_list|(
name|ACPI_OBJECT_TYPE
name|Type
parameter_list|)
block|{
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_LOCAL_SCOPE
condition|)
block|{
name|Type
operator|=
name|ACPI_TYPE_DEVICE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Type
operator|>
name|ACPI_TYPE_LOCAL_INDEX_FIELD
condition|)
block|{
return|return
operator|(
literal|""
operator|)
return|;
block|}
return|return
operator|(
name|AcpiGbl_DmTypeNames
index|[
name|Type
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmNormalizeParentPrefix  *  * PARAMETERS:  Op                  - Parse op  *              Path                - Path with parent prefix  *  * RETURN:      The full pathname to the object (from the namespace root)  *  * DESCRIPTION: Returns the full pathname of a path with parent prefix  *              The caller must free the fullpath returned.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|AcpiDmNormalizeParentPrefix
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|)
block|{
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|char
modifier|*
name|Fullpath
decl_stmt|;
name|char
modifier|*
name|ParentPath
decl_stmt|;
name|ACPI_SIZE
name|Length
decl_stmt|;
name|UINT32
name|Index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Search upwards in the parse tree until we reach the next namespace node */
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
while|while
condition|(
name|Op
condition|)
block|{
if|if
condition|(
name|Op
operator|->
name|Common
operator|.
name|Node
condition|)
block|{
break|break;
block|}
name|Op
operator|=
name|Op
operator|->
name|Common
operator|.
name|Parent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Op
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Find the actual parent node for the reference:      * Remove all carat prefixes from the input path.      * There may be multiple parent prefixes (For example, ^^^M000)      */
name|Node
operator|=
name|Op
operator|->
name|Common
operator|.
name|Node
expr_stmt|;
while|while
condition|(
name|Node
operator|&&
operator|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
operator|)
condition|)
block|{
name|Node
operator|=
name|Node
operator|->
name|Parent
expr_stmt|;
name|Path
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Node
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get the full pathname for the parent node */
name|ParentPath
operator|=
name|AcpiNsGetExternalPathname
argument_list|(
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ParentPath
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|Length
operator|=
operator|(
name|ACPI_STRLEN
argument_list|(
name|ParentPath
argument_list|)
operator|+
name|ACPI_STRLEN
argument_list|(
name|Path
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
comment|/*          * If ParentPath is not just a simple '\', increment the length          * for the required dot separator (ParentPath.Path)          */
name|Length
operator|++
expr_stmt|;
comment|/* For External() statements, we do not want a leading '\' */
if|if
condition|(
operator|*
name|ParentPath
operator|==
name|AML_ROOT_PREFIX
condition|)
block|{
name|Index
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|Fullpath
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|Length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fullpath
condition|)
block|{
goto|goto
name|Cleanup
goto|;
block|}
comment|/*      * Concatenate parent fullpath and path. For example,      * parent fullpath "\_SB_", Path "^INIT", Fullpath "\_SB_.INIT"      *      * Copy the parent path      */
name|ACPI_STRCPY
argument_list|(
name|Fullpath
argument_list|,
operator|&
name|ParentPath
index|[
name|Index
index|]
argument_list|)
expr_stmt|;
comment|/*      * Add dot separator      * (don't need dot if parent fullpath is a single backslash)      */
if|if
condition|(
name|ParentPath
index|[
literal|1
index|]
condition|)
block|{
name|ACPI_STRCAT
argument_list|(
name|Fullpath
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* Copy child path (carat parent prefix(es) were skipped above) */
name|ACPI_STRCAT
argument_list|(
name|Fullpath
argument_list|,
name|Path
argument_list|)
expr_stmt|;
name|Cleanup
label|:
name|ACPI_FREE
argument_list|(
name|ParentPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|Fullpath
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddToExternalFileList  *  * PARAMETERS:  PathList            - Single path or list separated by comma  *  * RETURN:      None  *  * DESCRIPTION: Add external files to global list  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiDmAddToExternalFileList
parameter_list|(
name|char
modifier|*
name|PathList
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|ExternalFile
decl_stmt|;
name|char
modifier|*
name|Path
decl_stmt|;
name|char
modifier|*
name|TmpPath
decl_stmt|;
if|if
condition|(
operator|!
name|PathList
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
name|Path
operator|=
name|strtok
argument_list|(
name|PathList
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|Path
condition|)
block|{
name|TmpPath
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
name|ACPI_STRLEN
argument_list|(
name|Path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TmpPath
condition|)
block|{
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
name|ACPI_STRCPY
argument_list|(
name|TmpPath
argument_list|,
name|Path
argument_list|)
expr_stmt|;
name|ExternalFile
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_FILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalFile
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|TmpPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|AE_NO_MEMORY
operator|)
return|;
block|}
name|ExternalFile
operator|->
name|Path
operator|=
name|TmpPath
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|ExternalFile
operator|->
name|Next
operator|=
name|AcpiGbl_ExternalFileList
expr_stmt|;
block|}
name|AcpiGbl_ExternalFileList
operator|=
name|ExternalFile
expr_stmt|;
name|Path
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalFileList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Clear the external file list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalFileList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_FILE
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalFileList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalFileList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalFileList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalFileList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddToExternalList  *  * PARAMETERS:  Op                  - Current parser Op  *              Path                - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddToExternalList
parameter_list|(
name|ACPI_PARSE_OBJECT
modifier|*
name|Op
parameter_list|,
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|)
block|{
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|char
modifier|*
name|Fullpath
init|=
name|NULL
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NewExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|PrevExternal
init|=
name|NULL
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|BOOLEAN
name|Resolved
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
if|if
condition|(
name|Value
operator|&
literal|0x80
condition|)
block|{
name|Resolved
operator|=
name|TRUE
expr_stmt|;
block|}
name|Value
operator|&=
literal|0x07
expr_stmt|;
block|}
comment|/*      * We don't want External() statements to contain a leading '\'.      * This prevents duplicate external statements of the form:      *      *    External (\ABCD)      *    External (ABCD)      *      * This would cause a compile time error when the disassembled      * output file is recompiled.      */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Externalize the ACPI pathname */
name|Status
operator|=
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|Path
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/*      * Get the full pathname from the root if "Path" has one or more      * parent prefixes (^). Note: path will not contain a leading '\'.      */
if|if
condition|(
operator|*
name|Path
operator|==
operator|(
name|UINT8
operator|)
name|AML_PARENT_PREFIX
condition|)
block|{
name|Fullpath
operator|=
name|AcpiDmNormalizeParentPrefix
argument_list|(
name|Op
argument_list|,
name|ExternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fullpath
condition|)
block|{
comment|/* Set new external path */
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ExternalPath
operator|=
name|Fullpath
expr_stmt|;
block|}
block|}
comment|/* Check all existing externals to ensure no duplicates */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|ExternalPath
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
condition|)
block|{
comment|/* Duplicate method, check that the Value (ArgCount) is the same */
if|if
condition|(
operator|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
name|NextExternal
operator|->
name|Value
operator|!=
name|Value
operator|)
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"External method arg count mismatch %s: Current %u, attempted %u"
operator|,
name|NextExternal
operator|->
name|Path
operator|,
name|NextExternal
operator|->
name|Value
operator|,
name|Value
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allow upgrade of type from ANY */
elseif|else
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_ANY
condition|)
block|{
name|NextExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NextExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Allocate and init a new External() descriptor */
name|NewExternal
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_LIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewExternal
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
return|return;
block|}
name|NewExternal
operator|->
name|Path
operator|=
name|ExternalPath
expr_stmt|;
name|NewExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NewExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
name|NewExternal
operator|->
name|Resolved
operator|=
name|Resolved
expr_stmt|;
name|NewExternal
operator|->
name|Length
operator|=
operator|(
name|UINT16
operator|)
name|ACPI_STRLEN
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
comment|/* Was the external path with parent prefix normalized to a fullpath? */
if|if
condition|(
name|Fullpath
operator|==
name|ExternalPath
condition|)
block|{
comment|/* Get new internal path */
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|ExternalPath
argument_list|,
operator|&
name|Path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|ExternalPath
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|NewExternal
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set flag to indicate External->InternalPath need to be freed */
name|NewExternal
operator|->
name|Flags
operator||=
name|ACPI_IPATH_ALLOCATED
expr_stmt|;
block|}
name|NewExternal
operator|->
name|InternalPath
operator|=
name|Path
expr_stmt|;
comment|/* Link the new descriptor into the global list, alphabetically ordered */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|AcpiUtStricmp
argument_list|(
name|NewExternal
operator|->
name|Path
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|NewExternal
operator|->
name|Next
operator|=
name|NextExternal
expr_stmt|;
return|return;
block|}
name|PrevExternal
operator|=
name|NextExternal
expr_stmt|;
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalsFromFile  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Process the optional external reference file.  *  * Each line in the file should be of the form:  *      External (<Method namepath>, MethodObj,<ArgCount>)  *  * Example:  *      External (_SB_.PCI0.XHC_.PS0X, MethodObj, 4)  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmGetExternalsFromFile
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|ExternalRefFile
decl_stmt|;
name|char
modifier|*
name|Token
decl_stmt|;
name|char
modifier|*
name|MethodName
decl_stmt|;
name|UINT32
name|ArgCount
decl_stmt|;
name|UINT32
name|ImportCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|Gbl_ExternalRefFilename
condition|)
block|{
return|return;
block|}
comment|/* Open the file */
name|ExternalRefFile
operator|=
name|fopen
argument_list|(
name|Gbl_ExternalRefFilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ExternalRefFile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open external reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Each line defines a method */
while|while
condition|(
name|fgets
argument_list|(
name|StringBuffer
argument_list|,
name|ASL_MSG_BUFFER_SIZE
argument_list|,
name|ExternalRefFile
argument_list|)
condition|)
block|{
name|Token
operator|=
name|strtok
argument_list|(
name|StringBuffer
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "External" */
if|if
condition|(
operator|!
name|Token
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"External"
argument_list|)
condition|)
continue|continue;
name|MethodName
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Method namepath */
if|if
condition|(
operator|!
name|MethodName
condition|)
continue|continue;
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* "MethodObj" */
if|if
condition|(
operator|!
name|Token
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|Token
argument_list|,
literal|"MethodObj"
argument_list|)
condition|)
continue|continue;
name|Token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|METHOD_SEPARATORS
argument_list|)
expr_stmt|;
comment|/* Arg count */
if|if
condition|(
operator|!
name|Token
condition|)
continue|continue;
comment|/* Convert arg count string to an integer */
name|errno
operator|=
literal|0
expr_stmt|;
name|ArgCount
operator|=
name|strtoul
argument_list|(
name|Token
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%s)\n"
argument_list|,
name|Token
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ArgCount
operator|>
literal|7
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid argument count (%u)\n"
argument_list|,
name|ArgCount
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add this external to the global list */
name|AcpiOsPrintf
argument_list|(
literal|"%s: Importing method external (%u arguments) %s\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ArgCount
argument_list|,
name|MethodName
argument_list|)
expr_stmt|;
name|AcpiDmAddToExternalListFromFile
argument_list|(
name|MethodName
argument_list|,
name|ACPI_TYPE_METHOD
argument_list|,
name|ArgCount
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|ImportCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ImportCount
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Did not find any external methods in reference file \"%s\"\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the external(s) to the namespace */
name|AcpiDmAddExternalsToNamespace
argument_list|()
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|"%s: Imported %u external method definitions\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|,
name|ImportCount
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ExternalRefFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddToExternalListFromFile  *  * PARAMETERS:  Path                - Internal (AML) path to the object  *              Type                - ACPI object type to be added  *              Value               - Arg count if adding a Method object  *  * RETURN:      None  *  * DESCRIPTION: Insert a new name into the global list of Externals which  *              will in turn be later emitted as an External() declaration  *              in the disassembled output.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|AcpiDmAddToExternalListFromFile
parameter_list|(
name|char
modifier|*
name|Path
parameter_list|,
name|UINT8
name|Type
parameter_list|,
name|UINT32
name|Value
parameter_list|)
block|{
name|char
modifier|*
name|InternalPath
decl_stmt|;
name|char
modifier|*
name|ExternalPath
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NewExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|PrevExternal
init|=
name|NULL
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|BOOLEAN
name|Resolved
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|Path
condition|)
block|{
return|return;
block|}
comment|/* TBD: Add a flags parameter */
if|if
condition|(
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
if|if
condition|(
name|Value
operator|&
literal|0x80
condition|)
block|{
name|Resolved
operator|=
name|TRUE
expr_stmt|;
block|}
name|Value
operator|&=
literal|0x07
expr_stmt|;
block|}
comment|/*      * We don't want External() statements to contain a leading '\'.      * This prevents duplicate external statements of the form:      *      *    External (\ABCD)      *    External (ABCD)      *      * This would cause a compile time error when the disassembled      * output file is recompiled.      */
if|if
condition|(
operator|(
operator|*
name|Path
operator|==
name|AML_ROOT_PREFIX
operator|)
operator|&&
operator|(
name|Path
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|Path
operator|++
expr_stmt|;
block|}
comment|/* Check all existing externals to ensure no duplicates */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
operator|!
name|ACPI_STRCMP
argument_list|(
name|Path
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
condition|)
block|{
comment|/* Duplicate method, check that the Value (ArgCount) is the same */
if|if
condition|(
operator|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
name|NextExternal
operator|->
name|Value
operator|!=
name|Value
operator|)
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"(File) External method arg count mismatch %s: Current %u, override to %u"
operator|,
name|NextExternal
operator|->
name|Path
operator|,
name|NextExternal
operator|->
name|Value
operator|,
name|Value
operator|)
argument_list|)
expr_stmt|;
comment|/* Override, since new value came from external reference file */
name|NextExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
block|}
comment|/* Allow upgrade of type from ANY */
elseif|else
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_ANY
condition|)
block|{
name|NextExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NextExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
block|}
return|return;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Get the internal pathname (AML format) */
name|Status
operator|=
name|AcpiNsInternalizeName
argument_list|(
name|Path
argument_list|,
operator|&
name|InternalPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Allocate and init a new External() descriptor */
name|NewExternal
operator|=
name|ACPI_ALLOCATE_ZEROED
argument_list|(
sizeof|sizeof
argument_list|(
name|ACPI_EXTERNAL_LIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewExternal
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|InternalPath
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Must copy and normalize the input path */
name|AcpiNsExternalizeName
argument_list|(
name|ACPI_UINT32_MAX
argument_list|,
name|InternalPath
argument_list|,
name|NULL
argument_list|,
operator|&
name|ExternalPath
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|Path
operator|=
name|ExternalPath
expr_stmt|;
name|NewExternal
operator|->
name|Type
operator|=
name|Type
expr_stmt|;
name|NewExternal
operator|->
name|Value
operator|=
name|Value
expr_stmt|;
name|NewExternal
operator|->
name|Resolved
operator|=
name|Resolved
expr_stmt|;
name|NewExternal
operator|->
name|Length
operator|=
operator|(
name|UINT16
operator|)
name|ACPI_STRLEN
argument_list|(
name|Path
argument_list|)
expr_stmt|;
name|NewExternal
operator|->
name|InternalPath
operator|=
name|InternalPath
expr_stmt|;
comment|/* Set flag to indicate External->InternalPath needs to be freed */
name|NewExternal
operator|->
name|Flags
operator||=
name|ACPI_IPATH_ALLOCATED
operator||
name|ACPI_FROM_REFERENCE_FILE
expr_stmt|;
comment|/* Link the new descriptor into the global list, alphabetically ordered */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|AcpiUtStricmp
argument_list|(
name|NewExternal
operator|->
name|Path
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
name|NewExternal
operator|->
name|Next
operator|=
name|NextExternal
expr_stmt|;
return|return;
block|}
name|PrevExternal
operator|=
name|NextExternal
expr_stmt|;
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
if|if
condition|(
name|PrevExternal
condition|)
block|{
name|PrevExternal
operator|->
name|Next
operator|=
name|NewExternal
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_ExternalList
operator|=
name|NewExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmAddExternalsToNamespace  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Add all externals to the namespace. Allows externals to be  *              "resolved".  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmAddExternalsToNamespace
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_NAMESPACE_NODE
modifier|*
name|Node
decl_stmt|;
name|ACPI_OPERAND_OBJECT
modifier|*
name|ObjDesc
decl_stmt|;
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
comment|/* Add the external name (object) into the namespace */
name|Status
operator|=
name|AcpiNsLookup
argument_list|(
name|NULL
argument_list|,
name|External
operator|->
name|InternalPath
argument_list|,
name|External
operator|->
name|Type
argument_list|,
name|ACPI_IMODE_LOAD_PASS1
argument_list|,
name|ACPI_NS_ERROR_IF_FOUND
operator||
name|ACPI_NS_EXTERNAL
operator||
name|ACPI_NS_DONT_OPEN_SCOPE
argument_list|,
name|NULL
argument_list|,
operator|&
name|Node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"while adding external to namespace [%s]"
operator|,
name|External
operator|->
name|Path
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|External
operator|->
name|Type
condition|)
block|{
case|case
name|ACPI_TYPE_METHOD
case|:
comment|/* For methods, we need to save the argument count */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_METHOD
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Method
operator|.
name|ParamCount
operator|=
operator|(
name|UINT8
operator|)
name|External
operator|->
name|Value
expr_stmt|;
name|Node
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
case|case
name|ACPI_TYPE_REGION
case|:
comment|/* Regions require a region sub-object */
name|ObjDesc
operator|=
name|AcpiUtCreateInternalObject
argument_list|(
name|ACPI_TYPE_REGION
argument_list|)
expr_stmt|;
name|ObjDesc
operator|->
name|Region
operator|.
name|Node
operator|=
name|Node
expr_stmt|;
name|Node
operator|->
name|Object
operator|=
name|ObjDesc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmGetExternalMethodCount  *  * PARAMETERS:  None  *  * RETURN:      The number of control method externals in the external list  *  * DESCRIPTION: Return the number of method externals that have been generated.  *              If any control method externals have been found, we must  *              re-parse the entire definition block with the new information  *              (number of arguments for the methods.) This is limitation of  *              AML, we don't know the number of arguments from the control  *              method invocation itself.  *  ******************************************************************************/
end_comment

begin_function
name|UINT32
name|AcpiDmGetExternalMethodCount
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|External
init|=
name|AcpiGbl_ExternalList
decl_stmt|;
name|UINT32
name|Count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|External
condition|)
block|{
if|if
condition|(
name|External
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|Count
operator|++
expr_stmt|;
block|}
name|External
operator|=
name|External
operator|->
name|Next
expr_stmt|;
block|}
return|return
operator|(
name|Count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmClearExternalList  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Free the entire External info list  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmClearExternalList
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmEmitExternals  *  * PARAMETERS:  None  *  * RETURN:      None  *  * DESCRIPTION: Emit an External() ASL statement for each of the externals in  *              the global external info list.  *  ******************************************************************************/
end_comment

begin_function
name|void
name|AcpiDmEmitExternals
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_EXTERNAL_LIST
modifier|*
name|NextExternal
decl_stmt|;
if|if
condition|(
operator|!
name|AcpiGbl_ExternalList
condition|)
block|{
return|return;
block|}
comment|/*      * Determine the number of control methods in the external list, and      * also how many of those externals were resolved via the namespace.      */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiGbl_NumExternalMethods
operator|++
expr_stmt|;
if|if
condition|(
name|NextExternal
operator|->
name|Resolved
condition|)
block|{
name|AcpiGbl_ResolvedExternalMethods
operator|++
expr_stmt|;
block|}
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
comment|/* Check if any control methods were unresolved */
name|AcpiDmUnresolvedWarning
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit any unresolved method externals in a single text block */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
operator|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
operator|)
operator|&&
operator|(
operator|!
name|NextExternal
operator|->
name|Resolved
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    External (%s%s"
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
name|NextExternal
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
name|AcpiOsPrintf
argument_list|(
literal|")    // Warning: Unresolved Method, "
literal|"guessing %u arguments (may be incorrect, see warning above)\n"
argument_list|,
name|NextExternal
operator|->
name|Value
argument_list|)
expr_stmt|;
name|NextExternal
operator|->
name|Emitted
operator|=
name|TRUE
expr_stmt|;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Emit externals that were imported from a file */
if|if
condition|(
name|Gbl_ExternalRefFilename
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n     * External declarations that were imported from\n"
literal|"     * the reference file [%s]\n     */\n"
argument_list|,
name|Gbl_ExternalRefFilename
argument_list|)
expr_stmt|;
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
expr_stmt|;
while|while
condition|(
name|NextExternal
condition|)
block|{
if|if
condition|(
operator|!
name|NextExternal
operator|->
name|Emitted
operator|&&
operator|(
name|NextExternal
operator|->
name|Flags
operator|&
name|ACPI_FROM_REFERENCE_FILE
operator|)
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    External (%s%s"
argument_list|,
name|NextExternal
operator|->
name|Path
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
name|NextExternal
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NextExternal
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|")    // %u Arguments\n"
argument_list|,
name|NextExternal
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|NextExternal
operator|->
name|Emitted
operator|=
name|TRUE
expr_stmt|;
block|}
name|NextExternal
operator|=
name|NextExternal
operator|->
name|Next
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Walk the list of externals found during the AML parsing      */
while|while
condition|(
name|AcpiGbl_ExternalList
condition|)
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalList
operator|->
name|Emitted
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|"    External (%s%s"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|,
name|AcpiDmGetObjectTypeName
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For methods, add a comment with the number of arguments */
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Type
operator|==
name|ACPI_TYPE_METHOD
condition|)
block|{
name|AcpiOsPrintf
argument_list|(
literal|")    // %u Arguments\n"
argument_list|,
name|AcpiGbl_ExternalList
operator|->
name|Value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AcpiOsPrintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free this external info block and move on to next external */
name|NextExternal
operator|=
name|AcpiGbl_ExternalList
operator|->
name|Next
expr_stmt|;
if|if
condition|(
name|AcpiGbl_ExternalList
operator|->
name|Flags
operator|&
name|ACPI_IPATH_ALLOCATED
condition|)
block|{
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|InternalPath
argument_list|)
expr_stmt|;
block|}
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
operator|->
name|Path
argument_list|)
expr_stmt|;
name|ACPI_FREE
argument_list|(
name|AcpiGbl_ExternalList
argument_list|)
expr_stmt|;
name|AcpiGbl_ExternalList
operator|=
name|NextExternal
expr_stmt|;
block|}
name|AcpiOsPrintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiDmUnresolvedWarning  *  * PARAMETERS:  Type                - Where to output the warning.  *                                    0 means write to stderr  *                                    1 means write to AcpiOsPrintf  *  * RETURN:      None  *  * DESCRIPTION: Issue warning message if there are unresolved external control  *              methods within the disassembly.  *  ******************************************************************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|Summary of the external control method problem:  When the -e option is used with disassembly, the various SSDTs are simply loaded into a global namespace for the disassembler to use in order to resolve control method references (invocations).  The disassembler tracks any such references, and will emit an External() statement for these types of methods, with the proper number of arguments .  Without the SSDTs, the AML does not contain enough information to properly disassemble the control method invocation -- because the disassembler does not know how many arguments to parse.  An example: Assume we have two control methods. ABCD has one argument, and EFGH has zero arguments. Further, we have two additional control methods that invoke ABCD and EFGH, named T1 and T2:      Method (ABCD, 1)     {     }     Method (EFGH, 0)     {     }     Method (T1)     {         ABCD (Add (2, 7, Local0))     }     Method (T2)     {         EFGH ()         Add (2, 7, Local0)     }  Here is the AML code that is generated for T1 and T2:       185:      Method (T1)  0000034C:  14 10 54 31 5F 5F 00 ...    "..T1__."       186:      {      187:          ABCD (Add (2, 7, Local0))  00000353:  41 42 43 44 ............    "ABCD" 00000357:  72 0A 02 0A 07 60 ......    "r....`"       188:      }       190:      Method (T2)  0000035D:  14 10 54 32 5F 5F 00 ...    "..T2__."       191:      {      192:          EFGH ()  00000364:  45 46 47 48 ............    "EFGH"       193:          Add (2, 7, Local0)  00000368:  72 0A 02 0A 07 60 ......    "r....`"      194:      }  Note that the AML code for T1 and T2 is essentially identical. When disassembling this code, the methods ABCD and EFGH must be known to the disassembler, otherwise it does not know how to handle the method invocations.  In other words, if ABCD and EFGH are actually external control methods appearing in an SSDT, the disassembler does not know what to do unless the owning SSDT has been loaded via the -e option.
endif|#
directive|endif
end_endif

begin_function
name|void
name|AcpiDmUnresolvedWarning
parameter_list|(
name|UINT8
name|Type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|AcpiGbl_NumExternalMethods
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|Type
condition|)
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n"
literal|"     * iASL Warning: There were %u external control methods found during\n"
literal|"     * disassembly, but additional ACPI tables to resolve these externals\n"
literal|"     * were not specified. This resulting disassembler output file may not\n"
literal|"     * compile because the disassembler did not know how many arguments\n"
literal|"     * to assign to these methods. To specify the tables needed to resolve\n"
literal|"     * external control method references, use the one of the following\n"
literal|"     * example iASL invocations:\n"
literal|"     *     iasl -e<ssdt1.aml,ssdt2.aml...> -d<dsdt.aml>\n"
literal|"     *     iasl -e<dsdt.aml,ssdt2.aml...> -d<ssdt1.aml>\n"
literal|"     */\n"
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AcpiGbl_NumExternalMethods
operator|!=
name|AcpiGbl_ResolvedExternalMethods
condition|)
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|AcpiOsPrintf
argument_list|(
literal|"    /*\n"
literal|"     * iASL Warning: There were %u external control methods found during\n"
literal|"     * disassembly, but only %u %s resolved (%u unresolved). Additional\n"
literal|"     * ACPI tables are required to properly disassemble the code. This\n"
literal|"     * resulting disassembler output file may not compile because the\n"
literal|"     * disassembler did not know how many arguments to assign to the\n"
literal|"     * unresolved methods.\n"
literal|"     */\n"
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|,
name|AcpiGbl_ResolvedExternalMethods
argument_list|,
operator|(
name|AcpiGbl_ResolvedExternalMethods
operator|>
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|-
name|AcpiGbl_ResolvedExternalMethods
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|AcpiGbl_ExternalFileList
condition|)
block|{
comment|/* The -e option was not specified */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|"iASL Warning: There were %u external control methods found during\n"
literal|"disassembly, but additional ACPI tables to resolve these externals\n"
literal|"were not specified. The resulting disassembler output file may not\n"
literal|"compile because the disassembler did not know how many arguments\n"
literal|"to assign to these methods. To specify the tables needed to resolve\n"
literal|"external control method references, use the one of the following\n"
literal|"example iASL invocations:\n"
literal|"    iasl -e<ssdt1.aml,ssdt2.aml...> -d<dsdt.aml>\n"
literal|"    iasl -e<dsdt.aml,ssdt2.aml...> -d<ssdt1.aml>\n"
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AcpiGbl_NumExternalMethods
operator|!=
name|AcpiGbl_ResolvedExternalMethods
condition|)
block|{
comment|/* The -e option was specified, but there are still some unresolved externals */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|"iASL Warning: There were %u external control methods found during\n"
literal|"disassembly, but only %u %s resolved (%u unresolved). Additional\n"
literal|"ACPI tables are required to properly disassemble the code. The\n"
literal|"resulting disassembler output file may not compile because the\n"
literal|"disassembler did not know how many arguments to assign to the\n"
literal|"unresolved methods.\n"
argument_list|,
name|AcpiGbl_NumExternalMethods
argument_list|,
name|AcpiGbl_ResolvedExternalMethods
argument_list|,
operator|(
name|AcpiGbl_ResolvedExternalMethods
operator|>
literal|1
condition|?
literal|"were"
else|:
literal|"was"
operator|)
argument_list|,
operator|(
name|AcpiGbl_NumExternalMethods
operator|-
name|AcpiGbl_ResolvedExternalMethods
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

