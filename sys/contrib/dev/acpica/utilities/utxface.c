begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Module Name: utxface - External interfaces for "global" ACPI functions  *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Copyright (C) 2000 - 2012, Intel Corp.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_define
define|#
directive|define
name|__UTXFACE_C__
end_define

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acevents.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acnamesp.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acdebug.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/actables.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acinterp.h>
end_include

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_UTILITIES
end_define

begin_macro
name|ACPI_MODULE_NAME
argument_list|(
literal|"utxface"
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|ACPI_ASL_COMPILER
end_ifndef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiInitializeSubsystem  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Initializes all global variables.  This is the first function  *              called, so any early initialization belongs here.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInitializeSubsystem
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiInitializeSubsystem
argument_list|)
expr_stmt|;
name|AcpiGbl_StartupFlags
operator|=
name|ACPI_SUBSYSTEM_INITIALIZE
expr_stmt|;
name|ACPI_DEBUG_EXEC
argument_list|(
name|AcpiUtInitStackPtrTrace
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Initialize the OS-Dependent layer */
name|Status
operator|=
name|AcpiOsInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During OSL initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize all globals used by the subsystem */
name|Status
operator|=
name|AcpiUtInitGlobals
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During initialization of globals"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Create the default mutex objects */
name|Status
operator|=
name|AcpiUtMutexInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During Global Mutex creation"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize the namespace manager and      * the root of the namespace tree      */
name|Status
operator|=
name|AcpiNsRootInitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During Namespace initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the global OSI interfaces list with the static names */
name|Status
operator|=
name|AcpiUtInitializeInterfaces
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_EXCEPTION
argument_list|(
operator|(
name|AE_INFO
operator|,
name|Status
operator|,
literal|"During OSI interfaces initialization"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* If configured, initialize the AML debugger */
name|ACPI_DEBUGGER_EXEC
argument_list|(
name|Status
operator|=
name|AcpiDbInitialize
argument_list|()
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiInitializeSubsystem
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiEnableSubsystem  *  * PARAMETERS:  Flags           - Init/enable Options  *  * RETURN:      Status  *  * DESCRIPTION: Completes the subsystem initialization including hardware.  *              Puts system into ACPI mode if it isn't already.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiEnableSubsystem
parameter_list|(
name|UINT32
name|Flags
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiEnableSubsystem
argument_list|)
expr_stmt|;
comment|/* Enable ACPI mode */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ACPI_ENABLE
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Going into ACPI mode\n"
operator|)
argument_list|)
expr_stmt|;
name|AcpiGbl_OriginalMode
operator|=
name|AcpiHwGetMode
argument_list|()
expr_stmt|;
name|Status
operator|=
name|AcpiEnable
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"AcpiEnable failed"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Obtain a permanent mapping for the FACS. This is required for the      * Global Lock and the Firmware Waking Vector      */
name|Status
operator|=
name|AcpiTbInitializeFacs
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|ACPI_WARNING
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"Could not map the FACS table"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Install the default OpRegion handlers.  These are installed unless      * other handlers have already been installed via the      * InstallAddressSpaceHandler interface.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ADDRESS_SPACE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Installing default address space handlers\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInstallRegionHandlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Initialize ACPI Event handling (Fixed and General Purpose)      *      * Note1: We must have the hardware and events initialized before we can      * execute any control methods safely. Any control method can require      * ACPI hardware support, so the hardware must be fully initialized before      * any method execution!      *      * Note2: Fixed events are initialized and enabled here. GPEs are      * initialized, but cannot be enabled until after the hardware is      * completely initialized (SCI and GlobalLock activated) and the various      * initialization control methods are run (_REG, _STA, _INI) on the      * entire namespace.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_EVENT_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Initializing ACPI events\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInitializeEvents
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Install the SCI handler and Global Lock handler. This completes the      * hardware initialization.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_HANDLER_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Installing SCI/GL handlers\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInstallXruptHandlers
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiEnableSubsystem
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiInitializeObjects  *  * PARAMETERS:  Flags           - Init/enable Options  *  * RETURN:      Status  *  * DESCRIPTION: Completes namespace initialization by initializing device  *              objects and executing AML code for Regions, buffers, etc.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInitializeObjects
parameter_list|(
name|UINT32
name|Flags
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiInitializeObjects
argument_list|)
expr_stmt|;
comment|/*      * Run all _REG methods      *      * Note: Any objects accessed by the _REG methods will be automatically      * initialized, even if they contain executable AML (see the call to      * AcpiNsInitializeObjects below).      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_ADDRESS_SPACE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Executing _REG OpRegion methods\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiEvInitializeOpRegions
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Execute any module-level code that was detected during the table load      * phase. Although illegal since ACPI 2.0, there are many machines that      * contain this type of code. Each block of detected executable AML code      * outside of any control method is wrapped with a temporary control      * method object and placed on a global list. The methods on this list      * are executed below.      */
name|AcpiNsExecModuleCodeList
argument_list|()
expr_stmt|;
comment|/*      * Initialize the objects that remain uninitialized. This runs the      * executable AML that may be part of the declaration of these objects:      * OperationRegions, BufferFields, Buffers, and Packages.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_OBJECT_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Completing Initialization of ACPI Objects\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiNsInitializeObjects
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Initialize all device objects in the namespace. This runs the device      * _STA and _INI methods.      */
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|ACPI_NO_DEVICE_INIT
operator|)
condition|)
block|{
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_EXEC
operator|,
literal|"[Init] Initializing ACPI Devices\n"
operator|)
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiNsInitializeDevices
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Empty the caches (delete the cached objects) on the assumption that      * the table load filled them up more than they will be at runtime --      * thus wasting non-paged memory.      */
name|Status
operator|=
name|AcpiPurgeCachedObjects
argument_list|()
expr_stmt|;
name|AcpiGbl_StartupFlags
operator||=
name|ACPI_INITIALIZED_OK
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiInitializeObjects
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiTerminate  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Shutdown the ACPICA subsystem and release all resources.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiTerminate
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiTerminate
argument_list|)
expr_stmt|;
comment|/* Just exit if subsystem is already shutdown */
if|if
condition|(
name|AcpiGbl_Shutdown
condition|)
block|{
name|ACPI_ERROR
argument_list|(
operator|(
name|AE_INFO
operator|,
literal|"ACPI Subsystem is already terminated"
operator|)
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Subsystem appears active, go ahead and shut it down */
name|AcpiGbl_Shutdown
operator|=
name|TRUE
expr_stmt|;
name|AcpiGbl_StartupFlags
operator|=
literal|0
expr_stmt|;
name|ACPI_DEBUG_PRINT
argument_list|(
operator|(
name|ACPI_DB_INFO
operator|,
literal|"Shutting down ACPI Subsystem\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Terminate the AML Debugger if present */
name|ACPI_DEBUGGER_EXEC
argument_list|(
name|AcpiGbl_DbTerminateThreads
operator|=
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Shutdown and free all resources */
name|AcpiUtSubsystemShutdown
argument_list|()
expr_stmt|;
comment|/* Free the mutex objects */
name|AcpiUtMutexTerminate
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DEBUGGER
comment|/* Shut down the debugger */
name|AcpiDbTerminate
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Now we can shutdown the OS-dependent layer */
name|Status
operator|=
name|AcpiOsTerminate
argument_list|()
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiTerminate
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|ACPI_ASL_COMPILER
end_ifndef

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiSubsystemStatus  *  * PARAMETERS:  None  *  * RETURN:      Status of the ACPI subsystem  *  * DESCRIPTION: Other drivers that use the ACPI subsystem should call this  *              before making any other calls, to ensure the subsystem  *              initialized successfully.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiSubsystemStatus
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|AcpiGbl_StartupFlags
operator|&
name|ACPI_INITIALIZED_OK
condition|)
block|{
return|return
operator|(
name|AE_OK
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|AE_ERROR
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiSubsystemStatus
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiGetSystemInfo  *  * PARAMETERS:  OutBuffer       - A buffer to receive the resources for the  *                                device  *  * RETURN:      Status          - the status of the call  *  * DESCRIPTION: This function is called to get information about the current  *              state of the ACPI subsystem.  It will return system information  *              in the OutBuffer.  *  *              If the function fails an appropriate status will be returned  *              and the value of OutBuffer is undefined.  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiGetSystemInfo
parameter_list|(
name|ACPI_BUFFER
modifier|*
name|OutBuffer
parameter_list|)
block|{
name|ACPI_SYSTEM_INFO
modifier|*
name|InfoPtr
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiGetSystemInfo
argument_list|)
expr_stmt|;
comment|/* Parameter validation */
name|Status
operator|=
name|AcpiUtValidateBuffer
argument_list|(
name|OutBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/* Validate/Allocate/Clear caller buffer */
name|Status
operator|=
name|AcpiUtInitializeBuffer
argument_list|(
name|OutBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|ACPI_SYSTEM_INFO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
comment|/*      * Populate the return buffer      */
name|InfoPtr
operator|=
operator|(
name|ACPI_SYSTEM_INFO
operator|*
operator|)
name|OutBuffer
operator|->
name|Pointer
expr_stmt|;
name|InfoPtr
operator|->
name|AcpiCaVersion
operator|=
name|ACPI_CA_VERSION
expr_stmt|;
comment|/* System flags (ACPI capabilities) */
name|InfoPtr
operator|->
name|Flags
operator|=
name|ACPI_SYS_MODE_ACPI
expr_stmt|;
comment|/* Timer resolution - 24 or 32 bits  */
if|if
condition|(
name|AcpiGbl_FADT
operator|.
name|Flags
operator|&
name|ACPI_FADT_32BIT_TIMER
condition|)
block|{
name|InfoPtr
operator|->
name|TimerResolution
operator|=
literal|24
expr_stmt|;
block|}
else|else
block|{
name|InfoPtr
operator|->
name|TimerResolution
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Clear the reserved fields */
name|InfoPtr
operator|->
name|Reserved1
operator|=
literal|0
expr_stmt|;
name|InfoPtr
operator|->
name|Reserved2
operator|=
literal|0
expr_stmt|;
comment|/* Current debug levels */
name|InfoPtr
operator|->
name|DebugLayer
operator|=
name|AcpiDbgLayer
expr_stmt|;
name|InfoPtr
operator|->
name|DebugLevel
operator|=
name|AcpiDbgLevel
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiGetSystemInfo
argument_list|)
end_macro

begin_comment
comment|/*******************************************************************************  *  * FUNCTION:    AcpiGetStatistics  *  * PARAMETERS:  Stats           - Where the statistics are returned  *  * RETURN:      Status          - the status of the call  *  * DESCRIPTION: Get the contents of the various system counters  *  ******************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiGetStatistics
parameter_list|(
name|ACPI_STATISTICS
modifier|*
name|Stats
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiGetStatistics
argument_list|)
expr_stmt|;
comment|/* Parameter validation */
if|if
condition|(
operator|!
name|Stats
condition|)
block|{
name|return_ACPI_STATUS
argument_list|(
name|AE_BAD_PARAMETER
argument_list|)
expr_stmt|;
block|}
comment|/* Various interrupt-based event counters */
name|Stats
operator|->
name|SciCount
operator|=
name|AcpiSciCount
expr_stmt|;
name|Stats
operator|->
name|GpeCount
operator|=
name|AcpiGpeCount
expr_stmt|;
name|ACPI_MEMCPY
argument_list|(
name|Stats
operator|->
name|FixedEventCount
argument_list|,
name|AcpiFixedEventCount
argument_list|,
sizeof|sizeof
argument_list|(
name|AcpiFixedEventCount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Other counters */
name|Stats
operator|->
name|MethodCount
operator|=
name|AcpiMethodCount
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiGetStatistics
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiInstallInitializationHandler  *  * PARAMETERS:  Handler             - Callback procedure  *              Function            - Not (currently) used, see below  *  * RETURN:      Status  *  * DESCRIPTION: Install an initialization handler  *  * TBD: When a second function is added, must save the Function also.  *  ****************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInstallInitializationHandler
parameter_list|(
name|ACPI_INIT_HANDLER
name|Handler
parameter_list|,
name|UINT32
name|Function
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Handler
condition|)
block|{
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
if|if
condition|(
name|AcpiGbl_InitHandler
condition|)
block|{
return|return
operator|(
name|AE_ALREADY_EXISTS
operator|)
return|;
block|}
name|AcpiGbl_InitHandler
operator|=
name|Handler
expr_stmt|;
return|return
name|AE_OK
return|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiInstallInitializationHandler
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiPurgeCachedObjects  *  * PARAMETERS:  None  *  * RETURN:      Status  *  * DESCRIPTION: Empty all caches (delete the cached objects)  *  ****************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiPurgeCachedObjects
parameter_list|(
name|void
parameter_list|)
block|{
name|ACPI_FUNCTION_TRACE
argument_list|(
name|AcpiPurgeCachedObjects
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiOsPurgeCache
argument_list|(
name|AcpiGbl_StateCache
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiOsPurgeCache
argument_list|(
name|AcpiGbl_OperandCache
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiOsPurgeCache
argument_list|(
name|AcpiGbl_PsNodeCache
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiOsPurgeCache
argument_list|(
name|AcpiGbl_PsNodeExtCache
argument_list|)
expr_stmt|;
name|return_ACPI_STATUS
argument_list|(
name|AE_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiPurgeCachedObjects
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiInstallInterface  *  * PARAMETERS:  InterfaceName       - The interface to install  *  * RETURN:      Status  *  * DESCRIPTION: Install an _OSI interface to the global list  *  ****************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInstallInterface
parameter_list|(
name|ACPI_STRING
name|InterfaceName
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
name|ACPI_INTERFACE_INFO
modifier|*
name|InterfaceInfo
decl_stmt|;
comment|/* Parameter validation */
if|if
condition|(
operator|!
name|InterfaceName
operator|||
operator|(
name|ACPI_STRLEN
argument_list|(
name|InterfaceName
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|AcpiOsAcquireMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|,
name|ACPI_WAIT_FOREVER
argument_list|)
expr_stmt|;
comment|/* Check if the interface name is already in the global list */
name|InterfaceInfo
operator|=
name|AcpiUtGetInterface
argument_list|(
name|InterfaceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|InterfaceInfo
condition|)
block|{
comment|/*          * The interface already exists in the list. This is OK if the          * interface has been marked invalid -- just clear the bit.          */
if|if
condition|(
name|InterfaceInfo
operator|->
name|Flags
operator|&
name|ACPI_OSI_INVALID
condition|)
block|{
name|InterfaceInfo
operator|->
name|Flags
operator|&=
operator|~
name|ACPI_OSI_INVALID
expr_stmt|;
name|Status
operator|=
name|AE_OK
expr_stmt|;
block|}
else|else
block|{
name|Status
operator|=
name|AE_ALREADY_EXISTS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* New interface name, install into the global list */
name|Status
operator|=
name|AcpiUtInstallInterface
argument_list|(
name|InterfaceName
argument_list|)
expr_stmt|;
block|}
name|AcpiOsReleaseMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiInstallInterface
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiRemoveInterface  *  * PARAMETERS:  InterfaceName       - The interface to remove  *  * RETURN:      Status  *  * DESCRIPTION: Remove an _OSI interface from the global list  *  ****************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiRemoveInterface
parameter_list|(
name|ACPI_STRING
name|InterfaceName
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
decl_stmt|;
comment|/* Parameter validation */
if|if
condition|(
operator|!
name|InterfaceName
operator|||
operator|(
name|ACPI_STRLEN
argument_list|(
name|InterfaceName
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|AE_BAD_PARAMETER
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|AcpiOsAcquireMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|,
name|ACPI_WAIT_FOREVER
argument_list|)
expr_stmt|;
name|Status
operator|=
name|AcpiUtRemoveInterface
argument_list|(
name|InterfaceName
argument_list|)
expr_stmt|;
name|AcpiOsReleaseMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiRemoveInterface
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiInstallInterfaceHandler  *  * PARAMETERS:  Handler             - The _OSI interface handler to install  *                                    NULL means "remove existing handler"  *  * RETURN:      Status  *  * DESCRIPTION: Install a handler for the predefined _OSI ACPI method.  *              invoked during execution of the internal implementation of  *              _OSI. A NULL handler simply removes any existing handler.  *  ****************************************************************************/
end_comment

begin_function
name|ACPI_STATUS
name|AcpiInstallInterfaceHandler
parameter_list|(
name|ACPI_INTERFACE_HANDLER
name|Handler
parameter_list|)
block|{
name|ACPI_STATUS
name|Status
init|=
name|AE_OK
decl_stmt|;
operator|(
name|void
operator|)
name|AcpiOsAcquireMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|,
name|ACPI_WAIT_FOREVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|Handler
operator|&&
name|AcpiGbl_InterfaceHandler
condition|)
block|{
name|Status
operator|=
name|AE_ALREADY_EXISTS
expr_stmt|;
block|}
else|else
block|{
name|AcpiGbl_InterfaceHandler
operator|=
name|Handler
expr_stmt|;
block|}
name|AcpiOsReleaseMutex
argument_list|(
name|AcpiGbl_OsiMutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|Status
operator|)
return|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiInstallInterfaceHandler
argument_list|)
end_macro

begin_comment
comment|/*****************************************************************************  *  * FUNCTION:    AcpiCheckAddressRange  *  * PARAMETERS:  SpaceId             - Address space ID  *              Address             - Start address  *              Length              - Length  *              Warn                - TRUE if warning on overlap desired  *  * RETURN:      Count of the number of conflicts detected.  *  * DESCRIPTION: Check if the input address range overlaps any of the  *              ASL operation region address ranges.  *  ****************************************************************************/
end_comment

begin_function
name|UINT32
name|AcpiCheckAddressRange
parameter_list|(
name|ACPI_ADR_SPACE_TYPE
name|SpaceId
parameter_list|,
name|ACPI_PHYSICAL_ADDRESS
name|Address
parameter_list|,
name|ACPI_SIZE
name|Length
parameter_list|,
name|BOOLEAN
name|Warn
parameter_list|)
block|{
name|UINT32
name|Overlaps
decl_stmt|;
name|ACPI_STATUS
name|Status
decl_stmt|;
name|Status
operator|=
name|AcpiUtAcquireMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|Status
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|Overlaps
operator|=
name|AcpiUtCheckAddressRange
argument_list|(
name|SpaceId
argument_list|,
name|Address
argument_list|,
operator|(
name|UINT32
operator|)
name|Length
argument_list|,
name|Warn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcpiUtReleaseMutex
argument_list|(
name|ACPI_MTX_NAMESPACE
argument_list|)
expr_stmt|;
return|return
operator|(
name|Overlaps
operator|)
return|;
block|}
end_function

begin_macro
name|ACPI_EXPORT_SYMBOL
argument_list|(
argument|AcpiCheckAddressRange
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ACPI_ASL_COMPILER */
end_comment

end_unit

