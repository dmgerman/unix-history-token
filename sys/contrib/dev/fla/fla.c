begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$   *  */
end_comment

begin_include
include|#
directive|include
file|"fla.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|400000
end_if

begin_comment
comment|/* XXX ? */
end_comment

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_define
define|#
directive|define
name|dev2ul
parameter_list|(
name|foo
parameter_list|)
value|((unsigned long)dev2udev(foo))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
end_if

begin_comment
comment|/* XXX ? */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_define
define|#
directive|define
name|dev2ul
parameter_list|(
name|foo
parameter_list|)
value|((unsigned long)foo)
end_define

begin_function
specifier|static
name|int
name|physread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|cdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|d_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|physwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|cdevsw
index|[
name|major
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|d_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|nopoll
value|seltrue
end_define

begin_define
define|#
directive|define
name|noparms
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<../../contrib/dev/fla/msysosak.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FLA
argument_list|,
literal|"fla driver"
argument_list|,
literal|"fla driver storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fla_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|fladebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fla_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|102
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|28
end_define

begin_decl_stmt
specifier|static
name|d_strategy_t
name|flastrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|flaopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|flaclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|flaioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|flapsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fla_cdevsw
init|=
block|{
comment|/* open */
name|flaopen
block|,
comment|/* close */
name|flaclose
block|,
comment|/* read */
name|physread
block|,
comment|/* write */
name|physwrite
block|,
comment|/* ioctl */
name|flaioctl
block|,
comment|/* stop */
name|nostop
block|,
comment|/* reset */
name|noreset
block|,
comment|/* devtotty */
name|nodevtotty
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|flastrategy
block|,
comment|/* name */
literal|"fla"
block|,
comment|/* parms */
name|noparms
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|flapsize
block|,
comment|/* flags */
name|D_DISK
operator||
name|D_CANFREE
block|,
comment|/* maxio */
literal|0
block|,
comment|/* bmaj */
name|BDEV_MAJOR
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|doc2k_malloc
parameter_list|(
name|int
name|bytes
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_FLA
argument_list|,
name|M_WAITOK
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|doc2k_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|,
name|M_FLA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doc2k_delay
parameter_list|(
name|unsigned
name|msec
parameter_list|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
name|msec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doc2k_memcpy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|doc2k_memcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
return|return
operator|(
name|bcmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|doc2k_memset
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|int
name|c
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|fla_s
block|{
name|unsigned
name|nsect
decl_stmt|;
name|struct
name|doc2k_stat
name|ds
decl_stmt|;
name|struct
name|diskslices
modifier|*
name|dk_slices
decl_stmt|;
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
block|}
name|softc
index|[
name|NFLA
index|]
struct|;
end_struct

begin_function
specifier|static
name|int
name|flaopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
if|if
condition|(
name|fla_debug
condition|)
name|printf
argument_list|(
literal|"flaopen(%lx %x %x %p)\n"
argument_list|,
name|dev2ul
argument_list|(
name|dev
argument_list|)
argument_list|,
name|flag
argument_list|,
name|fmt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NFLA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|nsect
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|dk_dd
argument_list|,
sizeof|sizeof
argument_list|(
name|dk_dd
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|doc2k_size
argument_list|(
name|unit
argument_list|,
operator|&
name|dk_dd
operator|.
name|d_secperunit
argument_list|,
operator|&
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
operator|&
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
operator|&
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|error
operator|=
name|dsopen
argument_list|(
literal|"fla"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|dk_slices
argument_list|,
operator|&
name|dk_dd
argument_list|,
name|flastrategy
argument_list|,
name|NULL
argument_list|,
operator|&
name|fla_cdevsw
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flaclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|fla_debug
condition|)
name|printf
argument_list|(
literal|"flaclose(%lx %x %x %p)\n"
argument_list|,
name|dev2ul
argument_list|(
name|dev
argument_list|)
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|sc
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flaioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|fla_debug
condition|)
name|printf
argument_list|(
literal|"flaioctl(%lx %lx %p %x %p)\n"
argument_list|,
name|dev2ul
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
name|dsioctl
argument_list|(
literal|"fla"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|dk_slices
argument_list|,
name|flastrategy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|ENOTTY
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flastrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|u_long
name|ef
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
specifier|static
name|int
name|busy
decl_stmt|;
name|enum
name|doc2k_work
name|what
decl_stmt|;
if|if
condition|(
name|fla_debug
condition|)
name|printf
argument_list|(
literal|"flastrategy(%p) %lx %lx, %d, %ld, %p)\n"
argument_list|,
name|bp
argument_list|,
name|dev2ul
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
argument_list|,
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|sc
operator|->
name|dk_slices
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ef
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|bufqdisksort
argument_list|(
operator|&
name|sc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
condition|)
block|{
name|write_eflags
argument_list|(
name|ef
argument_list|)
expr_stmt|;
return|return;
block|}
name|busy
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|sc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|bufq_remove
argument_list|(
operator|&
name|sc
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|write_eflags
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
break|break;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FREEBUF
condition|)
name|what
operator|=
name|DOC2K_ERASE
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|what
operator|=
name|DOC2K_READ
expr_stmt|;
else|else
name|what
operator|=
name|DOC2K_WRITE
expr_stmt|;
name|error
operator|=
name|doc2k_rwe
argument_list|(
name|unit
argument_list|,
name|what
argument_list|,
name|bp
operator|->
name|b_pblkno
argument_list|,
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
argument_list|,
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fla_debug
operator|||
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"fla%d: %d = rwe(%p, %d, %d, %d, %ld, %p)\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|,
name|bp
argument_list|,
name|unit
argument_list|,
name|what
argument_list|,
name|bp
operator|->
name|b_pblkno
argument_list|,
name|bp
operator|->
name|b_bcount
operator|/
name|DEV_BSIZE
argument_list|,
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ef
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
block|}
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|flapsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|fla_debug
condition|)
name|printf
argument_list|(
literal|"flapsize(%lx)\n"
argument_list|,
name|dev2ul
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|nsect
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|dk_slices
argument_list|,
name|flaopen
argument_list|,
name|flaclose
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flarealprobe
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
comment|/* This is slightly ugly */
name|i
operator|=
name|doc2k_probe
argument_list|(
name|unit
argument_list|,
name|KERNBASE
operator|+
literal|0xc0000
argument_list|,
name|KERNBASE
operator|+
literal|0xe0000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|i
operator|=
name|doc2k_info
argument_list|(
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flarealattach
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|m
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
name|error
operator|=
name|doc2k_open
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"doc2k_open(%d) -> err %d\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|error
operator|=
name|doc2k_size
argument_list|(
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|nsect
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"doc2k_size(%d) -> err %d\n"
argument_list|,
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"fla%d:<%s %s>\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|product
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|model
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1024L
operator|*
literal|1024L
operator|/
name|DEV_BSIZE
expr_stmt|;
name|l
operator|=
operator|(
name|sc
operator|->
name|nsect
operator|*
literal|10
operator|+
name|m
operator|/
literal|2
operator|)
operator|/
name|m
expr_stmt|;
name|printf
argument_list|(
literal|"fla%d: %d.%01dMB (%u sectors),"
literal|" %d cyls, %d heads, %d S/T, 512 B/S\n"
argument_list|,
name|unit
argument_list|,
name|l
operator|/
literal|10
argument_list|,
name|l
operator|%
literal|10
argument_list|,
name|sc
operator|->
name|nsect
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"fla%d: JEDEC=0x%x unitsize=%ld mediasize=%ld"
literal|" chipsize=%ld interleave=%d window=%lx\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|type
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|unitSize
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|mediaSize
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|chipSize
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|interleaving
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|window
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|sc
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|400000
end_if

begin_comment
comment|/* XXX ? */
end_comment

begin_function
specifier|static
name|int
name|flaprobe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
name|i
operator|=
name|flarealprobe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ISA_SET_RESOURCE
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|ds
operator|.
name|window
operator|-
name|KERNBASE
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flaattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|i
operator|=
name|flarealattach
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|fla_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|flaprobe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|flaattach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fladriver
init|=
block|{
literal|"fla"
block|,
name|fla_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fla_s
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fla_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEV_DRIVER_MODULE
argument_list|(
name|fla
argument_list|,
name|isa
argument_list|,
name|fladriver
argument_list|,
name|fla_devclass
argument_list|,
name|fla_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400000
end_if

begin_comment
comment|/* XXX ? */
end_comment

begin_function
specifier|static
name|int
name|flaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|struct
name|fla_s
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|sc
operator|=
operator|&
name|softc
index|[
name|unit
index|]
expr_stmt|;
name|i
operator|=
name|flarealprobe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dvp
operator|->
name|id_maddr
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|ds
operator|.
name|window
expr_stmt|;
name|dvp
operator|->
name|id_msize
operator|=
literal|8192
expr_stmt|;
name|cdevsw_add_generic
argument_list|(
name|BDEV_MAJOR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|fla_cdevsw
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flaattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|i
operator|=
name|flarealattach
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|fladriver
init|=
block|{
name|flaprobe
block|,
name|flaattach
block|,
literal|"fla"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

