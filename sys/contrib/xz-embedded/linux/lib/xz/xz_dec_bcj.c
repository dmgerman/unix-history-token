begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Branch/Call/Jump (BCJ) filter decoders  *  * Authors: Lasse Collin<lasse.collin@tukaani.org>  *          Igor Pavlov<http://7-zip.org/>  *  * This file has been put into the public domain.  * You can do whatever you want with this file.  */
end_comment

begin_include
include|#
directive|include
file|"xz_private.h"
end_include

begin_comment
comment|/*  * The rest of the file is inside this ifdef. It makes things a little more  * convenient when building without support for any BCJ filters.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
end_ifdef

begin_struct
struct|struct
name|xz_dec_bcj
block|{
comment|/* Type of the BCJ filter being used */
enum|enum
block|{
name|BCJ_X86
init|=
literal|4
block|,
comment|/* x86 or x86-64 */
name|BCJ_POWERPC
init|=
literal|5
block|,
comment|/* Big endian only */
name|BCJ_IA64
init|=
literal|6
block|,
comment|/* Big or little endian */
name|BCJ_ARM
init|=
literal|7
block|,
comment|/* Little endian only */
name|BCJ_ARMTHUMB
init|=
literal|8
block|,
comment|/* Little endian only */
name|BCJ_SPARC
init|=
literal|9
comment|/* Big or little endian */
block|}
name|type
enum|;
comment|/* 	 * Return value of the next filter in the chain. We need to preserve 	 * this information across calls, because we must not call the next 	 * filter anymore once it has returned XZ_STREAM_END. 	 */
name|enum
name|xz_ret
name|ret
decl_stmt|;
comment|/* True if we are operating in single-call mode. */
name|bool
name|single_call
decl_stmt|;
comment|/* 	 * Absolute position relative to the beginning of the uncompressed 	 * data (in a single .xz Block). We care only about the lowest 32 	 * bits so this doesn't need to be uint64_t even with big files. 	 */
name|uint32_t
name|pos
decl_stmt|;
comment|/* x86 filter state */
name|uint32_t
name|x86_prev_mask
decl_stmt|;
comment|/* Temporary space to hold the variables from struct xz_buf */
name|uint8_t
modifier|*
name|out
decl_stmt|;
name|size_t
name|out_pos
decl_stmt|;
name|size_t
name|out_size
decl_stmt|;
struct|struct
block|{
comment|/* Amount of already filtered data in the beginning of buf */
name|size_t
name|filtered
decl_stmt|;
comment|/* Total amount of data currently stored in buf  */
name|size_t
name|size
decl_stmt|;
comment|/* 		 * Buffer to hold a mix of filtered and unfiltered data. This 		 * needs to be big enough to hold Alignment + 2 * Look-ahead: 		 * 		 * Type         Alignment   Look-ahead 		 * x86              1           4 		 * PowerPC          4           0 		 * IA-64           16           0 		 * ARM              4           0 		 * ARM-Thumb        2           2 		 * SPARC            4           0 		 */
name|uint8_t
name|buf
index|[
literal|16
index|]
decl_stmt|;
block|}
name|temp
struct|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_X86
end_ifdef

begin_comment
comment|/*  * This is used to test the most significant byte of a memory address  * in an x86 instruction.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bcj_x86_test_msbyte
parameter_list|(
name|uint8_t
name|b
parameter_list|)
block|{
return|return
name|b
operator|==
literal|0x00
operator|||
name|b
operator|==
literal|0xFF
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|bcj_x86
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|bool
name|mask_to_allowed_status
index|[
literal|8
index|]
init|=
block|{
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|false
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|mask_to_bit_num
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|prev_pos
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|prev_mask
init|=
name|s
operator|->
name|x86_prev_mask
decl_stmt|;
name|uint32_t
name|src
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|;
name|uint32_t
name|j
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
return|return
literal|0
return|;
name|size
operator|-=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|buf
index|[
name|i
index|]
operator|&
literal|0xFE
operator|)
operator|!=
literal|0xE8
condition|)
continue|continue;
name|prev_pos
operator|=
name|i
operator|-
name|prev_pos
expr_stmt|;
if|if
condition|(
name|prev_pos
operator|>
literal|3
condition|)
block|{
name|prev_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|prev_mask
operator|=
operator|(
name|prev_mask
operator|<<
operator|(
name|prev_pos
operator|-
literal|1
operator|)
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|prev_mask
operator|!=
literal|0
condition|)
block|{
name|b
operator|=
name|buf
index|[
name|i
operator|+
literal|4
operator|-
name|mask_to_bit_num
index|[
name|prev_mask
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mask_to_allowed_status
index|[
name|prev_mask
index|]
operator|||
name|bcj_x86_test_msbyte
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|prev_pos
operator|=
name|i
expr_stmt|;
name|prev_mask
operator|=
operator|(
name|prev_mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|prev_pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|bcj_x86_test_msbyte
argument_list|(
name|buf
index|[
name|i
operator|+
literal|4
index|]
argument_list|)
condition|)
block|{
name|src
operator|=
name|get_unaligned_le32
argument_list|(
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|dest
operator|=
name|src
operator|-
operator|(
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
operator|+
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|prev_mask
operator|==
literal|0
condition|)
break|break;
name|j
operator|=
name|mask_to_bit_num
index|[
name|prev_mask
index|]
operator|*
literal|8
expr_stmt|;
name|b
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|dest
operator|>>
operator|(
literal|24
operator|-
name|j
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcj_x86_test_msbyte
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|src
operator|=
name|dest
operator|^
operator|(
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
operator|(
literal|32
operator|-
name|j
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|dest
operator|&=
literal|0x01FFFFFF
expr_stmt|;
name|dest
operator||=
operator|(
name|uint32_t
operator|)
literal|0
operator|-
operator|(
name|dest
operator|&
literal|0x01000000
operator|)
expr_stmt|;
name|put_unaligned_le32
argument_list|(
name|dest
argument_list|,
name|buf
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|prev_mask
operator|=
operator|(
name|prev_mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
block|}
name|prev_pos
operator|=
name|i
operator|-
name|prev_pos
expr_stmt|;
name|s
operator|->
name|x86_prev_mask
operator|=
name|prev_pos
operator|>
literal|3
condition|?
literal|0
else|:
name|prev_mask
operator|<<
operator|(
name|prev_pos
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_POWERPC
end_ifdef

begin_function
specifier|static
name|size_t
name|bcj_powerpc
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<=
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|instr
operator|=
name|get_unaligned_be32
argument_list|(
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|&
literal|0xFC000003
operator|)
operator|==
literal|0x48000001
condition|)
block|{
name|instr
operator|&=
literal|0x03FFFFFC
expr_stmt|;
name|instr
operator|-=
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
expr_stmt|;
name|instr
operator|&=
literal|0x03FFFFFC
expr_stmt|;
name|instr
operator||=
literal|0x48000001
expr_stmt|;
name|put_unaligned_be32
argument_list|(
name|instr
argument_list|,
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_IA64
end_ifdef

begin_function
specifier|static
name|size_t
name|bcj_ia64
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|static
specifier|const
name|uint8_t
name|branch_table
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|7
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* 	 * The local variables take a little bit stack space, but it's less 	 * than what LZMA2 decoder takes, so it doesn't make sense to reduce 	 * stack usage here without doing that for the LZMA2 decoder too. 	 */
comment|/* Loop counters */
name|size_t
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
comment|/* Instruction slot (0, 1, or 2) in the 128-bit instruction word */
name|uint32_t
name|slot
decl_stmt|;
comment|/* Bitwise offset of the instruction indicated by slot */
name|uint32_t
name|bit_pos
decl_stmt|;
comment|/* bit_pos split into byte and bit parts */
name|uint32_t
name|byte_pos
decl_stmt|;
name|uint32_t
name|bit_res
decl_stmt|;
comment|/* Address part of an instruction */
name|uint32_t
name|addr
decl_stmt|;
comment|/* Mask used to detect which instructions to convert */
name|uint32_t
name|mask
decl_stmt|;
comment|/* 41-bit instruction stored somewhere in the lowest 48 bits */
name|uint64_t
name|instr
decl_stmt|;
comment|/* Instruction normalized with bit_res for easier manipulation */
name|uint64_t
name|norm
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|16
operator|<=
name|size
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|mask
operator|=
name|branch_table
index|[
name|buf
index|[
name|i
index|]
operator|&
literal|0x1F
index|]
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|bit_pos
operator|=
literal|5
init|;
name|slot
operator|<
literal|3
condition|;
operator|++
name|slot
operator|,
name|bit_pos
operator|+=
literal|41
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|mask
operator|>>
name|slot
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|byte_pos
operator|=
name|bit_pos
operator|>>
literal|3
expr_stmt|;
name|bit_res
operator|=
name|bit_pos
operator|&
literal|7
expr_stmt|;
name|instr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
operator|++
name|j
control|)
name|instr
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|buf
index|[
name|i
operator|+
name|j
operator|+
name|byte_pos
index|]
argument_list|)
operator|<<
operator|(
literal|8
operator|*
name|j
operator|)
expr_stmt|;
name|norm
operator|=
name|instr
operator|>>
name|bit_res
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|norm
operator|>>
literal|37
operator|)
operator|&
literal|0x0F
operator|)
operator|==
literal|0x05
operator|&&
operator|(
operator|(
name|norm
operator|>>
literal|9
operator|)
operator|&
literal|0x07
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
operator|(
name|norm
operator|>>
literal|13
operator|)
operator|&
literal|0x0FFFFF
expr_stmt|;
name|addr
operator||=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|norm
operator|>>
literal|36
argument_list|)
operator|&
literal|1
operator|)
operator|<<
literal|20
expr_stmt|;
name|addr
operator|<<=
literal|4
expr_stmt|;
name|addr
operator|-=
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
expr_stmt|;
name|addr
operator|>>=
literal|4
expr_stmt|;
name|norm
operator|&=
operator|~
operator|(
operator|(
name|uint64_t
operator|)
literal|0x8FFFFF
operator|<<
literal|13
operator|)
expr_stmt|;
name|norm
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|addr
operator|&
literal|0x0FFFFF
argument_list|)
operator|<<
literal|13
expr_stmt|;
name|norm
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|addr
operator|&
literal|0x100000
argument_list|)
operator|<<
operator|(
literal|36
operator|-
literal|20
operator|)
expr_stmt|;
name|instr
operator|&=
operator|(
literal|1
operator|<<
name|bit_res
operator|)
operator|-
literal|1
expr_stmt|;
name|instr
operator||=
name|norm
operator|<<
name|bit_res
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
name|buf
index|[
name|i
operator|+
name|j
operator|+
name|byte_pos
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|instr
operator|>>
operator|(
literal|8
operator|*
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_ARM
end_ifdef

begin_function
specifier|static
name|size_t
name|bcj_arm
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<=
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|0xEB
condition|)
block|{
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
index|]
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|addr
operator|<<=
literal|2
expr_stmt|;
name|addr
operator|-=
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
operator|+
literal|8
expr_stmt|;
name|addr
operator|>>=
literal|2
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|addr
expr_stmt|;
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_ARMTHUMB
end_ifdef

begin_function
specifier|static
name|size_t
name|bcj_armthumb
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<=
name|size
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
operator|&&
operator|(
name|buf
index|[
name|i
operator|+
literal|3
index|]
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF8
condition|)
block|{
name|addr
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|19
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
index|]
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
operator|+
literal|3
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint32_t
operator|)
name|buf
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|addr
operator|<<=
literal|1
expr_stmt|;
name|addr
operator|-=
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
operator|+
literal|4
expr_stmt|;
name|addr
operator|>>=
literal|1
expr_stmt|;
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
literal|0xF0
operator||
operator|(
operator|(
name|addr
operator|>>
literal|19
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|addr
operator|>>
literal|11
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|+
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
literal|0xF8
operator||
operator|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|addr
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_SPARC
end_ifdef

begin_function
specifier|static
name|size_t
name|bcj_sparc
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<=
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|instr
operator|=
name|get_unaligned_be32
argument_list|(
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|>>
literal|22
operator|)
operator|==
literal|0x100
operator|||
operator|(
name|instr
operator|>>
literal|22
operator|)
operator|==
literal|0x1FF
condition|)
block|{
name|instr
operator|<<=
literal|2
expr_stmt|;
name|instr
operator|-=
name|s
operator|->
name|pos
operator|+
operator|(
name|uint32_t
operator|)
name|i
expr_stmt|;
name|instr
operator|>>=
literal|2
expr_stmt|;
name|instr
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x40000000
operator|-
operator|(
name|instr
operator|&
literal|0x400000
operator|)
operator|)
operator||
literal|0x40000000
operator||
operator|(
name|instr
operator|&
literal|0x3FFFFF
operator|)
expr_stmt|;
name|put_unaligned_be32
argument_list|(
name|instr
argument_list|,
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Apply the selected BCJ filter. Update *pos and s->pos to match the amount  * of data that got filtered.  *  * NOTE: This is implemented as a switch statement to avoid using function  * pointers, which could be problematic in the kernel boot code, which must  * avoid pointers to static data (at least on x86).  */
end_comment

begin_function
specifier|static
name|void
name|bcj_apply
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|filtered
decl_stmt|;
name|buf
operator|+=
operator|*
name|pos
expr_stmt|;
name|size
operator|-=
operator|*
name|pos
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|XZ_DEC_X86
case|case
name|BCJ_X86
case|:
name|filtered
operator|=
name|bcj_x86
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_POWERPC
case|case
name|BCJ_POWERPC
case|:
name|filtered
operator|=
name|bcj_powerpc
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_IA64
case|case
name|BCJ_IA64
case|:
name|filtered
operator|=
name|bcj_ia64
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_ARM
case|case
name|BCJ_ARM
case|:
name|filtered
operator|=
name|bcj_arm
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_ARMTHUMB
case|case
name|BCJ_ARMTHUMB
case|:
name|filtered
operator|=
name|bcj_armthumb
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_SPARC
case|case
name|BCJ_SPARC
case|:
name|filtered
operator|=
name|bcj_sparc
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Never reached but silence compiler warnings. */
name|filtered
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|pos
operator|+=
name|filtered
expr_stmt|;
name|s
operator|->
name|pos
operator|+=
name|filtered
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush pending filtered data from temp to the output buffer.  * Move the remaining mixture of possibly filtered and unfiltered  * data to the beginning of temp.  */
end_comment

begin_function
specifier|static
name|void
name|bcj_flush
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|copy_size
decl_stmt|;
name|copy_size
operator|=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|s
operator|->
name|temp
operator|.
name|filtered
argument_list|,
name|b
operator|->
name|out_size
operator|-
name|b
operator|->
name|out_pos
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|b
operator|->
name|out_pos
operator|+=
name|copy_size
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|filtered
operator|-=
name|copy_size
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|-=
name|copy_size
expr_stmt|;
name|memmove
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|copy_size
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The BCJ filter functions are primitive in sense that they process the  * data in chunks of 1-16 bytes. To hide this issue, this function does  * some buffering.  */
end_comment

begin_function
name|XZ_EXTERN
name|enum
name|xz_ret
name|xz_dec_bcj_run
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|struct
name|xz_dec_lzma2
modifier|*
name|lzma2
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|out_start
decl_stmt|;
comment|/* 	 * Flush pending already filtered data to the output buffer. Return 	 * immediatelly if we couldn't flush everything, or if the next 	 * filter in the chain had already returned XZ_STREAM_END. 	 */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|filtered
operator|>
literal|0
condition|)
block|{
name|bcj_flush
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|filtered
operator|>
literal|0
condition|)
return|return
name|XZ_OK
return|;
if|if
condition|(
name|s
operator|->
name|ret
operator|==
name|XZ_STREAM_END
condition|)
return|return
name|XZ_STREAM_END
return|;
block|}
comment|/* 	 * If we have more output space than what is currently pending in 	 * temp, copy the unfiltered data from temp to the output buffer 	 * and try to fill the output buffer by decoding more data from the 	 * next filter in the chain. Apply the BCJ filter on the new data 	 * in the output buffer. If everything cannot be filtered, copy it 	 * to temp and rewind the output buffer position accordingly. 	 * 	 * This needs to be always run when temp.size == 0 to handle a special 	 * case where the output buffer is full and the next filter has no 	 * more output coming but hasn't returned XZ_STREAM_END yet. 	 */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|<
name|b
operator|->
name|out_size
operator|-
name|b
operator|->
name|out_pos
operator|||
name|s
operator|->
name|temp
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|out_start
operator|=
name|b
operator|->
name|out_pos
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
expr_stmt|;
name|b
operator|->
name|out_pos
operator|+=
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
name|s
operator|->
name|ret
operator|=
name|xz_dec_lzma2_run
argument_list|(
name|lzma2
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ret
operator|!=
name|XZ_STREAM_END
operator|&&
operator|(
name|s
operator|->
name|ret
operator|!=
name|XZ_OK
operator|||
name|s
operator|->
name|single_call
operator|)
condition|)
return|return
name|s
operator|->
name|ret
return|;
name|bcj_apply
argument_list|(
name|s
argument_list|,
name|b
operator|->
name|out
argument_list|,
operator|&
name|out_start
argument_list|,
name|b
operator|->
name|out_pos
argument_list|)
expr_stmt|;
comment|/* 		 * As an exception, if the next filter returned XZ_STREAM_END, 		 * we can do that too, since the last few bytes that remain 		 * unfiltered are meant to remain unfiltered. 		 */
if|if
condition|(
name|s
operator|->
name|ret
operator|==
name|XZ_STREAM_END
condition|)
return|return
name|XZ_STREAM_END
return|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|b
operator|->
name|out_pos
operator|-
name|out_start
expr_stmt|;
name|b
operator|->
name|out_pos
operator|-=
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * If there wasn't enough input to the next filter to fill 		 * the output buffer with unfiltered data, there's no point 		 * to try decoding more data to temp. 		 */
if|if
condition|(
name|b
operator|->
name|out_pos
operator|+
name|s
operator|->
name|temp
operator|.
name|size
operator|<
name|b
operator|->
name|out_size
condition|)
return|return
name|XZ_OK
return|;
block|}
comment|/* 	 * We have unfiltered data in temp. If the output buffer isn't full 	 * yet, try to fill the temp buffer by decoding more data from the 	 * next filter. Apply the BCJ filter on temp. Then we hopefully can 	 * fill the actual output buffer by copying filtered data from temp. 	 * A mix of filtered and unfiltered data may be left in temp; it will 	 * be taken care on the next call to this function. 	 */
if|if
condition|(
name|b
operator|->
name|out_pos
operator|<
name|b
operator|->
name|out_size
condition|)
block|{
comment|/* Make b->out{,_pos,_size} temporarily point to s->temp. */
name|s
operator|->
name|out
operator|=
name|b
operator|->
name|out
expr_stmt|;
name|s
operator|->
name|out_pos
operator|=
name|b
operator|->
name|out_pos
expr_stmt|;
name|s
operator|->
name|out_size
operator|=
name|b
operator|->
name|out_size
expr_stmt|;
name|b
operator|->
name|out
operator|=
name|s
operator|->
name|temp
operator|.
name|buf
expr_stmt|;
name|b
operator|->
name|out_pos
operator|=
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
name|b
operator|->
name|out_size
operator|=
sizeof|sizeof
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|ret
operator|=
name|xz_dec_lzma2_run
argument_list|(
name|lzma2
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|b
operator|->
name|out_pos
expr_stmt|;
name|b
operator|->
name|out
operator|=
name|s
operator|->
name|out
expr_stmt|;
name|b
operator|->
name|out_pos
operator|=
name|s
operator|->
name|out_pos
expr_stmt|;
name|b
operator|->
name|out_size
operator|=
name|s
operator|->
name|out_size
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ret
operator|!=
name|XZ_OK
operator|&&
name|s
operator|->
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|s
operator|->
name|ret
return|;
name|bcj_apply
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
operator|&
name|s
operator|->
name|temp
operator|.
name|filtered
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * If the next filter returned XZ_STREAM_END, we mark that 		 * everything is filtered, since the last unfiltered bytes 		 * of the stream are meant to be left as is. 		 */
if|if
condition|(
name|s
operator|->
name|ret
operator|==
name|XZ_STREAM_END
condition|)
name|s
operator|->
name|temp
operator|.
name|filtered
operator|=
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
name|bcj_flush
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|filtered
operator|>
literal|0
condition|)
return|return
name|XZ_OK
return|;
block|}
return|return
name|s
operator|->
name|ret
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|struct
name|xz_dec_bcj
modifier|*
name|xz_dec_bcj_create
parameter_list|(
name|bool
name|single_call
parameter_list|)
block|{
name|struct
name|xz_dec_bcj
modifier|*
name|s
init|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|single_call
operator|=
name|single_call
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|enum
name|xz_ret
name|xz_dec_bcj_reset
parameter_list|(
name|struct
name|xz_dec_bcj
modifier|*
name|s
parameter_list|,
name|uint8_t
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
ifdef|#
directive|ifdef
name|XZ_DEC_X86
case|case
name|BCJ_X86
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_POWERPC
case|case
name|BCJ_POWERPC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_IA64
case|case
name|BCJ_IA64
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_ARM
case|case
name|BCJ_ARM
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_ARMTHUMB
case|case
name|BCJ_ARMTHUMB
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XZ_DEC_SPARC
case|case
name|BCJ_SPARC
case|:
endif|#
directive|endif
break|break;
default|default:
comment|/* Unsupported Filter ID */
return|return
name|XZ_OPTIONS_ERROR
return|;
block|}
name|s
operator|->
name|type
operator|=
name|id
expr_stmt|;
name|s
operator|->
name|ret
operator|=
name|XZ_OK
expr_stmt|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|x86_prev_mask
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|filtered
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

