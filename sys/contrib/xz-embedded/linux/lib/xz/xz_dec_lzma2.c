begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * LZMA2 decoder  *  * Authors: Lasse Collin<lasse.collin@tukaani.org>  *          Igor Pavlov<http://7-zip.org/>  *  * This file has been put into the public domain.  * You can do whatever you want with this file.  */
end_comment

begin_include
include|#
directive|include
file|"xz_private.h"
end_include

begin_include
include|#
directive|include
file|"xz_lzma2.h"
end_include

begin_comment
comment|/*  * Range decoder initialization eats the first five bytes of each LZMA chunk.  */
end_comment

begin_define
define|#
directive|define
name|RC_INIT_BYTES
value|5
end_define

begin_comment
comment|/*  * Minimum number of usable input buffer to safely decode one LZMA symbol.  * The worst case is that we decode 22 bits using probabilities and 26  * direct bits. This may decode at maximum of 20 bytes of input. However,  * lzma_main() does an extra normalization before returning, thus we  * need to put 21 here.  */
end_comment

begin_define
define|#
directive|define
name|LZMA_IN_REQUIRED
value|21
end_define

begin_comment
comment|/*  * Dictionary (history buffer)  *  * These are always true:  *    start<= pos<= full<= end  *    pos<= limit<= end  *  * In multi-call mode, also these are true:  *    end == size  *    size<= size_max  *    allocated<= size  *  * Most of these variables are size_t to support single-call mode,  * in which the dictionary variables address the actual output  * buffer directly.  */
end_comment

begin_struct
struct|struct
name|dictionary
block|{
comment|/* Beginning of the history buffer */
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* Old position in buf (before decoding more data) */
name|size_t
name|start
decl_stmt|;
comment|/* Position in buf */
name|size_t
name|pos
decl_stmt|;
comment|/* 	 * How full dictionary is. This is used to detect corrupt input that 	 * would read beyond the beginning of the uncompressed stream. 	 */
name|size_t
name|full
decl_stmt|;
comment|/* Write limit; we don't write to buf[limit] or later bytes. */
name|size_t
name|limit
decl_stmt|;
comment|/* 	 * End of the dictionary buffer. In multi-call mode, this is 	 * the same as the dictionary size. In single-call mode, this 	 * indicates the size of the output buffer. 	 */
name|size_t
name|end
decl_stmt|;
comment|/* 	 * Size of the dictionary as specified in Block Header. This is used 	 * together with "full" to detect corrupt input that would make us 	 * read beyond the beginning of the uncompressed stream. 	 */
name|uint32_t
name|size
decl_stmt|;
comment|/* 	 * Maximum allowed dictionary size in multi-call mode. 	 * This is ignored in single-call mode. 	 */
name|uint32_t
name|size_max
decl_stmt|;
comment|/* 	 * Amount of memory currently allocated for the dictionary. 	 * This is used only with XZ_DYNALLOC. (With XZ_PREALLOC, 	 * size_max is always the same as the allocated size.) 	 */
name|uint32_t
name|allocated
decl_stmt|;
comment|/* Operation mode */
name|enum
name|xz_mode
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Range decoder */
end_comment

begin_struct
struct|struct
name|rc_dec
block|{
name|uint32_t
name|range
decl_stmt|;
name|uint32_t
name|code
decl_stmt|;
comment|/* 	 * Number of initializing bytes remaining to be read 	 * by rc_read_init(). 	 */
name|uint32_t
name|init_bytes_left
decl_stmt|;
comment|/* 	 * Buffer from which we read our input. It can be either 	 * temp.buf or the caller-provided input buffer. 	 */
specifier|const
name|uint8_t
modifier|*
name|in
decl_stmt|;
name|size_t
name|in_pos
decl_stmt|;
name|size_t
name|in_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Probabilities for a length decoder. */
end_comment

begin_struct
struct|struct
name|lzma_len_dec
block|{
comment|/* Probability of match length being at least 10 */
name|uint16_t
name|choice
decl_stmt|;
comment|/* Probability of match length being at least 18 */
name|uint16_t
name|choice2
decl_stmt|;
comment|/* Probabilities for match lengths 2-9 */
name|uint16_t
name|low
index|[
name|POS_STATES_MAX
index|]
index|[
name|LEN_LOW_SYMBOLS
index|]
decl_stmt|;
comment|/* Probabilities for match lengths 10-17 */
name|uint16_t
name|mid
index|[
name|POS_STATES_MAX
index|]
index|[
name|LEN_MID_SYMBOLS
index|]
decl_stmt|;
comment|/* Probabilities for match lengths 18-273 */
name|uint16_t
name|high
index|[
name|LEN_HIGH_SYMBOLS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lzma_dec
block|{
comment|/* Distances of latest four matches */
name|uint32_t
name|rep0
decl_stmt|;
name|uint32_t
name|rep1
decl_stmt|;
name|uint32_t
name|rep2
decl_stmt|;
name|uint32_t
name|rep3
decl_stmt|;
comment|/* Types of the most recently seen LZMA symbols */
name|enum
name|lzma_state
name|state
decl_stmt|;
comment|/* 	 * Length of a match. This is updated so that dict_repeat can 	 * be called again to finish repeating the whole match. 	 */
name|uint32_t
name|len
decl_stmt|;
comment|/* 	 * LZMA properties or related bit masks (number of literal 	 * context bits, a mask dervied from the number of literal 	 * position bits, and a mask dervied from the number 	 * position bits) 	 */
name|uint32_t
name|lc
decl_stmt|;
name|uint32_t
name|literal_pos_mask
decl_stmt|;
comment|/* (1<< lp) - 1 */
name|uint32_t
name|pos_mask
decl_stmt|;
comment|/* (1<< pb) - 1 */
comment|/* If 1, it's a match. Otherwise it's a single 8-bit literal. */
name|uint16_t
name|is_match
index|[
name|STATES
index|]
index|[
name|POS_STATES_MAX
index|]
decl_stmt|;
comment|/* If 1, it's a repeated match. The distance is one of rep0 .. rep3. */
name|uint16_t
name|is_rep
index|[
name|STATES
index|]
decl_stmt|;
comment|/* 	 * If 0, distance of a repeated match is rep0. 	 * Otherwise check is_rep1. 	 */
name|uint16_t
name|is_rep0
index|[
name|STATES
index|]
decl_stmt|;
comment|/* 	 * If 0, distance of a repeated match is rep1. 	 * Otherwise check is_rep2. 	 */
name|uint16_t
name|is_rep1
index|[
name|STATES
index|]
decl_stmt|;
comment|/* If 0, distance of a repeated match is rep2. Otherwise it is rep3. */
name|uint16_t
name|is_rep2
index|[
name|STATES
index|]
decl_stmt|;
comment|/* 	 * If 1, the repeated match has length of one byte. Otherwise 	 * the length is decoded from rep_len_decoder. 	 */
name|uint16_t
name|is_rep0_long
index|[
name|STATES
index|]
index|[
name|POS_STATES_MAX
index|]
decl_stmt|;
comment|/* 	 * Probability tree for the highest two bits of the match 	 * distance. There is a separate probability tree for match 	 * lengths of 2 (i.e. MATCH_LEN_MIN), 3, 4, and [5, 273]. 	 */
name|uint16_t
name|dist_slot
index|[
name|DIST_STATES
index|]
index|[
name|DIST_SLOTS
index|]
decl_stmt|;
comment|/* 	 * Probility trees for additional bits for match distance 	 * when the distance is in the range [4, 127]. 	 */
name|uint16_t
name|dist_special
index|[
name|FULL_DISTANCES
operator|-
name|DIST_MODEL_END
index|]
decl_stmt|;
comment|/* 	 * Probability tree for the lowest four bits of a match 	 * distance that is equal to or greater than 128. 	 */
name|uint16_t
name|dist_align
index|[
name|ALIGN_SIZE
index|]
decl_stmt|;
comment|/* Length of a normal match */
name|struct
name|lzma_len_dec
name|match_len_dec
decl_stmt|;
comment|/* Length of a repeated match */
name|struct
name|lzma_len_dec
name|rep_len_dec
decl_stmt|;
comment|/* Probabilities of literals */
name|uint16_t
name|literal
index|[
name|LITERAL_CODERS_MAX
index|]
index|[
name|LITERAL_CODER_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lzma2_dec
block|{
comment|/* Position in xz_dec_lzma2_run(). */
enum|enum
name|lzma2_seq
block|{
name|SEQ_CONTROL
block|,
name|SEQ_UNCOMPRESSED_1
block|,
name|SEQ_UNCOMPRESSED_2
block|,
name|SEQ_COMPRESSED_0
block|,
name|SEQ_COMPRESSED_1
block|,
name|SEQ_PROPERTIES
block|,
name|SEQ_LZMA_PREPARE
block|,
name|SEQ_LZMA_RUN
block|,
name|SEQ_COPY
block|}
name|sequence
enum|;
comment|/* Next position after decoding the compressed size of the chunk. */
name|enum
name|lzma2_seq
name|next_sequence
decl_stmt|;
comment|/* Uncompressed size of LZMA chunk (2 MiB at maximum) */
name|uint32_t
name|uncompressed
decl_stmt|;
comment|/* 	 * Compressed size of LZMA chunk or compressed/uncompressed 	 * size of uncompressed chunk (64 KiB at maximum) 	 */
name|uint32_t
name|compressed
decl_stmt|;
comment|/* 	 * True if dictionary reset is needed. This is false before 	 * the first chunk (LZMA or uncompressed). 	 */
name|bool
name|need_dict_reset
decl_stmt|;
comment|/* 	 * True if new LZMA properties are needed. This is false 	 * before the first LZMA chunk. 	 */
name|bool
name|need_props
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xz_dec_lzma2
block|{
comment|/* 	 * The order below is important on x86 to reduce code size and 	 * it shouldn't hurt on other platforms. Everything up to and 	 * including lzma.pos_mask are in the first 128 bytes on x86-32, 	 * which allows using smaller instructions to access those 	 * variables. On x86-64, fewer variables fit into the first 128 	 * bytes, but this is still the best order without sacrificing 	 * the readability by splitting the structures. 	 */
name|struct
name|rc_dec
name|rc
decl_stmt|;
name|struct
name|dictionary
name|dict
decl_stmt|;
name|struct
name|lzma2_dec
name|lzma2
decl_stmt|;
name|struct
name|lzma_dec
name|lzma
decl_stmt|;
comment|/* 	 * Temporary buffer which holds small number of input bytes between 	 * decoder calls. See lzma2_lzma() for details. 	 */
struct|struct
block|{
name|uint32_t
name|size
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|3
operator|*
name|LZMA_IN_REQUIRED
index|]
decl_stmt|;
block|}
name|temp
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/**************  * Dictionary *  **************/
end_comment

begin_comment
comment|/*  * Reset the dictionary state. When in single-call mode, set up the beginning  * of the dictionary to point to the actual output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|dict_reset
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|DEC_IS_SINGLE
argument_list|(
name|dict
operator|->
name|mode
argument_list|)
condition|)
block|{
name|dict
operator|->
name|buf
operator|=
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
expr_stmt|;
name|dict
operator|->
name|end
operator|=
name|b
operator|->
name|out_size
operator|-
name|b
operator|->
name|out_pos
expr_stmt|;
block|}
name|dict
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|dict
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|dict
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|dict
operator|->
name|full
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set dictionary write limit */
end_comment

begin_function
specifier|static
name|void
name|dict_limit
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|size_t
name|out_max
parameter_list|)
block|{
if|if
condition|(
name|dict
operator|->
name|end
operator|-
name|dict
operator|->
name|pos
operator|<=
name|out_max
condition|)
name|dict
operator|->
name|limit
operator|=
name|dict
operator|->
name|end
expr_stmt|;
else|else
name|dict
operator|->
name|limit
operator|=
name|dict
operator|->
name|pos
operator|+
name|out_max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if at least one byte can be written into the dictionary. */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|dict_has_space
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|)
block|{
return|return
name|dict
operator|->
name|pos
operator|<
name|dict
operator|->
name|limit
return|;
block|}
end_function

begin_comment
comment|/*  * Get a byte from the dictionary at the given distance. The distance is  * assumed to valid, or as a special case, zero when the dictionary is  * still empty. This special case is needed for single-call decoding to  * avoid writing a '\0' to the end of the destination buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|dict_get
parameter_list|(
specifier|const
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|uint32_t
name|dist
parameter_list|)
block|{
name|size_t
name|offset
init|=
name|dict
operator|->
name|pos
operator|-
name|dist
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|dist
operator|>=
name|dict
operator|->
name|pos
condition|)
name|offset
operator|+=
name|dict
operator|->
name|end
expr_stmt|;
return|return
name|dict
operator|->
name|full
operator|>
literal|0
condition|?
name|dict
operator|->
name|buf
index|[
name|offset
index|]
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Put one byte into the dictionary. It is assumed that there is space for it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|dict_put
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|dict
operator|->
name|buf
index|[
name|dict
operator|->
name|pos
operator|++
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|full
operator|<
name|dict
operator|->
name|pos
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Repeat given number of bytes from the given distance. If the distance is  * invalid, false is returned. On success, true is returned and *len is  * updated to indicate how many bytes were left to be repeated.  */
end_comment

begin_function
specifier|static
name|bool
name|dict_repeat
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|,
name|uint32_t
name|dist
parameter_list|)
block|{
name|size_t
name|back
decl_stmt|;
name|uint32_t
name|left
decl_stmt|;
if|if
condition|(
name|dist
operator|>=
name|dict
operator|->
name|full
operator|||
name|dist
operator|>=
name|dict
operator|->
name|size
condition|)
return|return
name|false
return|;
name|left
operator|=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|dict
operator|->
name|limit
operator|-
name|dict
operator|->
name|pos
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
operator|*
name|len
operator|-=
name|left
expr_stmt|;
name|back
operator|=
name|dict
operator|->
name|pos
operator|-
name|dist
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dist
operator|>=
name|dict
operator|->
name|pos
condition|)
name|back
operator|+=
name|dict
operator|->
name|end
expr_stmt|;
do|do
block|{
name|dict
operator|->
name|buf
index|[
name|dict
operator|->
name|pos
operator|++
index|]
operator|=
name|dict
operator|->
name|buf
index|[
name|back
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|back
operator|==
name|dict
operator|->
name|end
condition|)
name|back
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|left
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|dict
operator|->
name|full
operator|<
name|dict
operator|->
name|pos
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy uncompressed data as is from input to dictionary and output buffers. */
end_comment

begin_function
specifier|static
name|void
name|dict_uncompressed
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|,
name|uint32_t
modifier|*
name|left
parameter_list|)
block|{
name|size_t
name|copy_size
decl_stmt|;
while|while
condition|(
operator|*
name|left
operator|>
literal|0
operator|&&
name|b
operator|->
name|in_pos
operator|<
name|b
operator|->
name|in_size
operator|&&
name|b
operator|->
name|out_pos
operator|<
name|b
operator|->
name|out_size
condition|)
block|{
name|copy_size
operator|=
name|min
argument_list|(
name|b
operator|->
name|in_size
operator|-
name|b
operator|->
name|in_pos
argument_list|,
name|b
operator|->
name|out_size
operator|-
name|b
operator|->
name|out_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_size
operator|>
name|dict
operator|->
name|end
operator|-
name|dict
operator|->
name|pos
condition|)
name|copy_size
operator|=
name|dict
operator|->
name|end
operator|-
name|dict
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|copy_size
operator|>
operator|*
name|left
condition|)
name|copy_size
operator|=
operator|*
name|left
expr_stmt|;
operator|*
name|left
operator|-=
name|copy_size
expr_stmt|;
name|memcpy
argument_list|(
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
argument_list|,
name|b
operator|->
name|in
operator|+
name|b
operator|->
name|in_pos
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|dict
operator|->
name|pos
operator|+=
name|copy_size
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|full
operator|<
name|dict
operator|->
name|pos
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|DEC_IS_MULTI
argument_list|(
name|dict
operator|->
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|dict
operator|->
name|pos
operator|==
name|dict
operator|->
name|end
condition|)
name|dict
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
argument_list|,
name|b
operator|->
name|in
operator|+
name|b
operator|->
name|in_pos
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
block|}
name|dict
operator|->
name|start
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
name|b
operator|->
name|out_pos
operator|+=
name|copy_size
expr_stmt|;
name|b
operator|->
name|in_pos
operator|+=
name|copy_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flush pending data from dictionary to b->out. It is assumed that there is  * enough space in b->out. This is guaranteed because caller uses dict_limit()  * before decoding data into the dictionary.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|dict_flush
parameter_list|(
name|struct
name|dictionary
modifier|*
name|dict
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|copy_size
init|=
name|dict
operator|->
name|pos
operator|-
name|dict
operator|->
name|start
decl_stmt|;
if|if
condition|(
name|DEC_IS_MULTI
argument_list|(
name|dict
operator|->
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|dict
operator|->
name|pos
operator|==
name|dict
operator|->
name|end
condition|)
name|dict
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|out
operator|+
name|b
operator|->
name|out_pos
argument_list|,
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|start
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
block|}
name|dict
operator|->
name|start
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
name|b
operator|->
name|out_pos
operator|+=
name|copy_size
expr_stmt|;
return|return
name|copy_size
return|;
block|}
end_function

begin_comment
comment|/*****************  * Range decoder *  *****************/
end_comment

begin_comment
comment|/* Reset the range decoder. */
end_comment

begin_function
specifier|static
name|void
name|rc_reset
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|)
block|{
name|rc
operator|->
name|range
operator|=
operator|(
name|uint32_t
operator|)
operator|-
literal|1
expr_stmt|;
name|rc
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|init_bytes_left
operator|=
name|RC_INIT_BYTES
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the first five initial bytes into rc->code if they haven't been  * read already. (Yes, the first byte gets completely ignored.)  */
end_comment

begin_function
specifier|static
name|bool
name|rc_read_init
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
while|while
condition|(
name|rc
operator|->
name|init_bytes_left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
return|return
name|false
return|;
name|rc
operator|->
name|code
operator|=
operator|(
name|rc
operator|->
name|code
operator|<<
literal|8
operator|)
operator|+
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
expr_stmt|;
operator|--
name|rc
operator|->
name|init_bytes_left
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if there may not be enough input for the next decoding loop. */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rc_limit_exceeded
parameter_list|(
specifier|const
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|)
block|{
return|return
name|rc
operator|->
name|in_pos
operator|>
name|rc
operator|->
name|in_limit
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if it is possible (from point of view of range decoder) that  * we have reached the end of the LZMA chunk.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rc_is_finished
parameter_list|(
specifier|const
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|)
block|{
return|return
name|rc
operator|->
name|code
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read the next input byte if needed. */
end_comment

begin_function
specifier|static
name|__always_inline
name|void
name|rc_normalize
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|)
block|{
if|if
condition|(
name|rc
operator|->
name|range
operator|<
name|RC_TOP_VALUE
condition|)
block|{
name|rc
operator|->
name|range
operator|<<=
name|RC_SHIFT_BITS
expr_stmt|;
name|rc
operator|->
name|code
operator|=
operator|(
name|rc
operator|->
name|code
operator|<<
name|RC_SHIFT_BITS
operator|)
operator|+
name|rc
operator|->
name|in
index|[
name|rc
operator|->
name|in_pos
operator|++
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode one bit. In some versions, this function has been splitted in three  * functions so that the compiler is supposed to be able to more easily avoid  * an extra branch. In this particular version of the LZMA decoder, this  * doesn't seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3  * on x86). Using a non-splitted version results in nicer looking code too.  *  * NOTE: This must return an int. Do not make it return a bool or the speed  * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn't care,  * and it generates 10-20 % faster code than GCC 3.x from this file anyway.)  */
end_comment

begin_function
specifier|static
name|__always_inline
name|int
name|rc_bit
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|,
name|uint16_t
modifier|*
name|prob
parameter_list|)
block|{
name|uint32_t
name|bound
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|rc_normalize
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|bound
operator|=
operator|(
name|rc
operator|->
name|range
operator|>>
name|RC_BIT_MODEL_TOTAL_BITS
operator|)
operator|*
operator|*
name|prob
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|code
operator|<
name|bound
condition|)
block|{
name|rc
operator|->
name|range
operator|=
name|bound
expr_stmt|;
operator|*
name|prob
operator|+=
operator|(
name|RC_BIT_MODEL_TOTAL
operator|-
operator|*
name|prob
operator|)
operator|>>
name|RC_MOVE_BITS
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|->
name|range
operator|-=
name|bound
expr_stmt|;
name|rc
operator|->
name|code
operator|-=
name|bound
expr_stmt|;
operator|*
name|prob
operator|-=
operator|*
name|prob
operator|>>
name|RC_MOVE_BITS
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|bit
return|;
block|}
end_function

begin_comment
comment|/* Decode a bittree starting from the most significant bit. */
end_comment

begin_function
specifier|static
name|__always_inline
name|uint32_t
name|rc_bittree
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|,
name|uint16_t
modifier|*
name|probs
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|uint32_t
name|symbol
init|=
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|probs
index|[
name|symbol
index|]
argument_list|)
condition|)
name|symbol
operator|=
operator|(
name|symbol
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
else|else
name|symbol
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
name|limit
condition|)
do|;
return|return
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Decode a bittree starting from the least significant bit. */
end_comment

begin_function
specifier|static
name|__always_inline
name|void
name|rc_bittree_reverse
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|,
name|uint16_t
modifier|*
name|probs
parameter_list|,
name|uint32_t
modifier|*
name|dest
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|uint32_t
name|symbol
init|=
literal|1
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|probs
index|[
name|symbol
index|]
argument_list|)
condition|)
block|{
name|symbol
operator|=
operator|(
name|symbol
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
operator|*
name|dest
operator|+=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
else|else
block|{
name|symbol
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Decode direct bits (fixed fifty-fifty probability) */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rc_direct
parameter_list|(
name|struct
name|rc_dec
modifier|*
name|rc
parameter_list|,
name|uint32_t
modifier|*
name|dest
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|;
do|do
block|{
name|rc_normalize
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|->
name|range
operator|>>=
literal|1
expr_stmt|;
name|rc
operator|->
name|code
operator|-=
name|rc
operator|->
name|range
expr_stmt|;
name|mask
operator|=
operator|(
name|uint32_t
operator|)
literal|0
operator|-
operator|(
name|rc
operator|->
name|code
operator|>>
literal|31
operator|)
expr_stmt|;
name|rc
operator|->
name|code
operator|+=
name|rc
operator|->
name|range
operator|&
name|mask
expr_stmt|;
operator|*
name|dest
operator|=
operator|(
operator|*
name|dest
operator|<<
literal|1
operator|)
operator|+
operator|(
name|mask
operator|+
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|limit
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/********  * LZMA *  ********/
end_comment

begin_comment
comment|/* Get pointer to literal coder probability array. */
end_comment

begin_function
specifier|static
name|uint16_t
modifier|*
name|lzma_literal_probs
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|prev_byte
init|=
name|dict_get
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|uint32_t
name|low
init|=
name|prev_byte
operator|>>
operator|(
literal|8
operator|-
name|s
operator|->
name|lzma
operator|.
name|lc
operator|)
decl_stmt|;
name|uint32_t
name|high
init|=
operator|(
name|s
operator|->
name|dict
operator|.
name|pos
operator|&
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
operator|)
operator|<<
name|s
operator|->
name|lzma
operator|.
name|lc
decl_stmt|;
return|return
name|s
operator|->
name|lzma
operator|.
name|literal
index|[
name|low
operator|+
name|high
index|]
return|;
block|}
end_function

begin_comment
comment|/* Decode a literal (one 8-bit byte) */
end_comment

begin_function
specifier|static
name|void
name|lzma_literal
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|)
block|{
name|uint16_t
modifier|*
name|probs
decl_stmt|;
name|uint32_t
name|symbol
decl_stmt|;
name|uint32_t
name|match_byte
decl_stmt|;
name|uint32_t
name|match_bit
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|probs
operator|=
name|lzma_literal_probs
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzma_state_is_literal
argument_list|(
name|s
operator|->
name|lzma
operator|.
name|state
argument_list|)
condition|)
block|{
name|symbol
operator|=
name|rc_bittree
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|probs
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbol
operator|=
literal|1
expr_stmt|;
name|match_byte
operator|=
name|dict_get
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|offset
operator|=
literal|0x100
expr_stmt|;
do|do
block|{
name|match_bit
operator|=
name|match_byte
operator|&
name|offset
expr_stmt|;
name|match_byte
operator|<<=
literal|1
expr_stmt|;
name|i
operator|=
name|offset
operator|+
name|match_bit
operator|+
name|symbol
expr_stmt|;
if|if
condition|(
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|probs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|symbol
operator|=
operator|(
name|symbol
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|offset
operator|&=
name|match_bit
expr_stmt|;
block|}
else|else
block|{
name|symbol
operator|<<=
literal|1
expr_stmt|;
name|offset
operator|&=
operator|~
name|match_bit
expr_stmt|;
block|}
block|}
do|while
condition|(
name|symbol
operator|<
literal|0x100
condition|)
do|;
block|}
name|dict_put
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
operator|(
name|uint8_t
operator|)
name|symbol
argument_list|)
expr_stmt|;
name|lzma_state_literal
argument_list|(
operator|&
name|s
operator|->
name|lzma
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the length of the match into s->lzma.len. */
end_comment

begin_function
specifier|static
name|void
name|lzma_len
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|struct
name|lzma_len_dec
modifier|*
name|l
parameter_list|,
name|uint32_t
name|pos_state
parameter_list|)
block|{
name|uint16_t
modifier|*
name|probs
decl_stmt|;
name|uint32_t
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|l
operator|->
name|choice
argument_list|)
condition|)
block|{
name|probs
operator|=
name|l
operator|->
name|low
index|[
name|pos_state
index|]
expr_stmt|;
name|limit
operator|=
name|LEN_LOW_SYMBOLS
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|len
operator|=
name|MATCH_LEN_MIN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|l
operator|->
name|choice2
argument_list|)
condition|)
block|{
name|probs
operator|=
name|l
operator|->
name|mid
index|[
name|pos_state
index|]
expr_stmt|;
name|limit
operator|=
name|LEN_MID_SYMBOLS
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|len
operator|=
name|MATCH_LEN_MIN
operator|+
name|LEN_LOW_SYMBOLS
expr_stmt|;
block|}
else|else
block|{
name|probs
operator|=
name|l
operator|->
name|high
expr_stmt|;
name|limit
operator|=
name|LEN_HIGH_SYMBOLS
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|len
operator|=
name|MATCH_LEN_MIN
operator|+
name|LEN_LOW_SYMBOLS
operator|+
name|LEN_MID_SYMBOLS
expr_stmt|;
block|}
block|}
name|s
operator|->
name|lzma
operator|.
name|len
operator|+=
name|rc_bittree
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|probs
argument_list|,
name|limit
argument_list|)
operator|-
name|limit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode a match. The distance will be stored in s->lzma.rep0. */
end_comment

begin_function
specifier|static
name|void
name|lzma_match
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|uint32_t
name|pos_state
parameter_list|)
block|{
name|uint16_t
modifier|*
name|probs
decl_stmt|;
name|uint32_t
name|dist_slot
decl_stmt|;
name|uint32_t
name|limit
decl_stmt|;
name|lzma_state_match
argument_list|(
operator|&
name|s
operator|->
name|lzma
operator|.
name|state
argument_list|)
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep3
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep2
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep2
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep1
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep1
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep0
expr_stmt|;
name|lzma_len
argument_list|(
name|s
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|match_len_dec
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
name|probs
operator|=
name|s
operator|->
name|lzma
operator|.
name|dist_slot
index|[
name|lzma_get_dist_state
argument_list|(
name|s
operator|->
name|lzma
operator|.
name|len
argument_list|)
index|]
expr_stmt|;
name|dist_slot
operator|=
name|rc_bittree
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|probs
argument_list|,
name|DIST_SLOTS
argument_list|)
operator|-
name|DIST_SLOTS
expr_stmt|;
if|if
condition|(
name|dist_slot
operator|<
name|DIST_MODEL_START
condition|)
block|{
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|=
name|dist_slot
expr_stmt|;
block|}
else|else
block|{
name|limit
operator|=
operator|(
name|dist_slot
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|=
literal|2
operator|+
operator|(
name|dist_slot
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dist_slot
operator|<
name|DIST_MODEL_END
condition|)
block|{
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|<<=
name|limit
expr_stmt|;
name|probs
operator|=
name|s
operator|->
name|lzma
operator|.
name|dist_special
operator|+
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|-
name|dist_slot
operator|-
literal|1
expr_stmt|;
name|rc_bittree_reverse
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|probs
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_direct
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|,
name|limit
operator|-
name|ALIGN_BITS
argument_list|)
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|<<=
name|ALIGN_BITS
expr_stmt|;
name|rc_bittree_reverse
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|s
operator|->
name|lzma
operator|.
name|dist_align
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|,
name|ALIGN_BITS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Decode a repeated match. The distance is one of the four most recently  * seen matches. The distance will be stored in s->lzma.rep0.  */
end_comment

begin_function
specifier|static
name|void
name|lzma_rep_match
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|uint32_t
name|pos_state
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_rep0
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_rep0_long
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
condition|)
block|{
name|lzma_state_short_rep
argument_list|(
operator|&
name|s
operator|->
name|lzma
operator|.
name|state
argument_list|)
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|len
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_rep1
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_rep2
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep2
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep3
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep3
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep2
expr_stmt|;
block|}
name|s
operator|->
name|lzma
operator|.
name|rep2
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep1
expr_stmt|;
block|}
name|s
operator|->
name|lzma
operator|.
name|rep1
operator|=
name|s
operator|->
name|lzma
operator|.
name|rep0
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|=
name|tmp
expr_stmt|;
block|}
name|lzma_state_long_rep
argument_list|(
operator|&
name|s
operator|->
name|lzma
operator|.
name|state
argument_list|)
expr_stmt|;
name|lzma_len
argument_list|(
name|s
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|rep_len_dec
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LZMA decoder core */
end_comment

begin_function
specifier|static
name|bool
name|lzma_main
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|)
block|{
name|uint32_t
name|pos_state
decl_stmt|;
comment|/* 	 * If the dictionary was reached during the previous call, try to 	 * finish the possibly pending repeat in the dictionary. 	 */
if|if
condition|(
name|dict_has_space
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|)
operator|&&
name|s
operator|->
name|lzma
operator|.
name|len
operator|>
literal|0
condition|)
name|dict_repeat
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|len
argument_list|,
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|)
expr_stmt|;
comment|/* 	 * Decode more LZMA symbols. One iteration may consume up to 	 * LZMA_IN_REQUIRED - 1 bytes. 	 */
while|while
condition|(
name|dict_has_space
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|)
operator|&&
operator|!
name|rc_limit_exceeded
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|)
condition|)
block|{
name|pos_state
operator|=
name|s
operator|->
name|dict
operator|.
name|pos
operator|&
name|s
operator|->
name|lzma
operator|.
name|pos_mask
expr_stmt|;
if|if
condition|(
operator|!
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_match
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
condition|)
block|{
name|lzma_literal
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rc_bit
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|is_rep
index|[
name|s
operator|->
name|lzma
operator|.
name|state
index|]
argument_list|)
condition|)
name|lzma_rep_match
argument_list|(
name|s
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
else|else
name|lzma_match
argument_list|(
name|s
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dict_repeat
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
operator|&
name|s
operator|->
name|lzma
operator|.
name|len
argument_list|,
name|s
operator|->
name|lzma
operator|.
name|rep0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* 	 * Having the range decoder always normalized when we are outside 	 * this function makes it easier to correctly handle end of the chunk. 	 */
name|rc_normalize
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the LZMA decoder and range decoder state. Dictionary is nore reset  * here, because LZMA state may be reset without resetting the dictionary.  */
end_comment

begin_function
specifier|static
name|void
name|lzma_reset
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|)
block|{
name|uint16_t
modifier|*
name|probs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|s
operator|->
name|lzma
operator|.
name|state
operator|=
name|STATE_LIT_LIT
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep0
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep1
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep2
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|rep3
operator|=
literal|0
expr_stmt|;
comment|/* 	 * All probabilities are initialized to the same value. This hack 	 * makes the code smaller by avoiding a separate loop for each 	 * probability array. 	 * 	 * This could be optimized so that only that part of literal 	 * probabilities that are actually required. In the common case 	 * we would write 12 KiB less. 	 */
name|probs
operator|=
name|s
operator|->
name|lzma
operator|.
name|is_match
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROBS_TOTAL
condition|;
operator|++
name|i
control|)
name|probs
index|[
name|i
index|]
operator|=
name|RC_BIT_MODEL_TOTAL
operator|/
literal|2
expr_stmt|;
name|rc_reset
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode and validate LZMA properties (lc/lp/pb) and calculate the bit masks  * from the decoded lp and pb values. On success, the LZMA decoder state is  * reset and true is returned.  */
end_comment

begin_function
specifier|static
name|bool
name|lzma_props
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|uint8_t
name|props
parameter_list|)
block|{
if|if
condition|(
name|props
operator|>
operator|(
literal|4
operator|*
literal|5
operator|+
literal|4
operator|)
operator|*
literal|9
operator|+
literal|8
condition|)
return|return
name|false
return|;
name|s
operator|->
name|lzma
operator|.
name|pos_mask
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|props
operator|>=
literal|9
operator|*
literal|5
condition|)
block|{
name|props
operator|-=
literal|9
operator|*
literal|5
expr_stmt|;
operator|++
name|s
operator|->
name|lzma
operator|.
name|pos_mask
expr_stmt|;
block|}
name|s
operator|->
name|lzma
operator|.
name|pos_mask
operator|=
operator|(
literal|1
operator|<<
name|s
operator|->
name|lzma
operator|.
name|pos_mask
operator|)
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|props
operator|>=
literal|9
condition|)
block|{
name|props
operator|-=
literal|9
expr_stmt|;
operator|++
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
expr_stmt|;
block|}
name|s
operator|->
name|lzma
operator|.
name|lc
operator|=
name|props
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lzma
operator|.
name|lc
operator|+
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
operator|>
literal|4
condition|)
return|return
name|false
return|;
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
operator|=
operator|(
literal|1
operator|<<
name|s
operator|->
name|lzma
operator|.
name|literal_pos_mask
operator|)
operator|-
literal|1
expr_stmt|;
name|lzma_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*********  * LZMA2 *  *********/
end_comment

begin_comment
comment|/*  * The LZMA decoder assumes that if the input limit (s->rc.in_limit) hasn't  * been exceeded, it is safe to read up to LZMA_IN_REQUIRED bytes. This  * wrapper function takes care of making the LZMA decoder's assumption safe.  *  * As long as there is plenty of input left to be decoded in the current LZMA  * chunk, we decode directly from the caller-supplied input buffer until  * there's LZMA_IN_REQUIRED bytes left. Those remaining bytes are copied into  * s->temp.buf, which (hopefully) gets filled on the next call to this  * function. We decode a few bytes from the temporary buffer so that we can  * continue decoding from the caller-supplied input buffer again.  */
end_comment

begin_function
specifier|static
name|bool
name|lzma2_lzma
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|in_avail
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|in_avail
operator|=
name|b
operator|->
name|in_size
operator|-
name|b
operator|->
name|in_pos
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|>
literal|0
operator|||
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
literal|2
operator|*
name|LZMA_IN_REQUIRED
operator|-
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|-
name|s
operator|->
name|temp
operator|.
name|size
condition|)
name|tmp
operator|=
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|-
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|in_avail
condition|)
name|tmp
operator|=
name|in_avail
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|s
operator|->
name|temp
operator|.
name|size
argument_list|,
name|b
operator|->
name|in
operator|+
name|b
operator|->
name|in_pos
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
operator|==
name|s
operator|->
name|lzma2
operator|.
name|compressed
condition|)
block|{
name|memzero
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|)
operator|-
name|s
operator|->
name|temp
operator|.
name|size
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|s
operator|->
name|rc
operator|.
name|in_limit
operator|=
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
operator|<
name|LZMA_IN_REQUIRED
condition|)
block|{
name|s
operator|->
name|temp
operator|.
name|size
operator|+=
name|tmp
expr_stmt|;
name|b
operator|->
name|in_pos
operator|+=
name|tmp
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|s
operator|->
name|rc
operator|.
name|in_limit
operator|=
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
operator|-
name|LZMA_IN_REQUIRED
expr_stmt|;
block|}
name|s
operator|->
name|rc
operator|.
name|in
operator|=
name|s
operator|->
name|temp
operator|.
name|buf
expr_stmt|;
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|lzma_main
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|>
name|s
operator|->
name|temp
operator|.
name|size
operator|+
name|tmp
condition|)
return|return
name|false
return|;
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|-=
name|s
operator|->
name|rc
operator|.
name|in_pos
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|<
name|s
operator|->
name|temp
operator|.
name|size
condition|)
block|{
name|s
operator|->
name|temp
operator|.
name|size
operator|-=
name|s
operator|->
name|rc
operator|.
name|in_pos
expr_stmt|;
name|memmove
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|s
operator|->
name|rc
operator|.
name|in_pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|b
operator|->
name|in_pos
operator|+=
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|-
name|s
operator|->
name|temp
operator|.
name|size
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|in_avail
operator|=
name|b
operator|->
name|in_size
operator|-
name|b
operator|->
name|in_pos
expr_stmt|;
if|if
condition|(
name|in_avail
operator|>=
name|LZMA_IN_REQUIRED
condition|)
block|{
name|s
operator|->
name|rc
operator|.
name|in
operator|=
name|b
operator|->
name|in
expr_stmt|;
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|=
name|b
operator|->
name|in_pos
expr_stmt|;
if|if
condition|(
name|in_avail
operator|>=
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|+
name|LZMA_IN_REQUIRED
condition|)
name|s
operator|->
name|rc
operator|.
name|in_limit
operator|=
name|b
operator|->
name|in_pos
operator|+
name|s
operator|->
name|lzma2
operator|.
name|compressed
expr_stmt|;
else|else
name|s
operator|->
name|rc
operator|.
name|in_limit
operator|=
name|b
operator|->
name|in_size
operator|-
name|LZMA_IN_REQUIRED
expr_stmt|;
if|if
condition|(
operator|!
name|lzma_main
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|false
return|;
name|in_avail
operator|=
name|s
operator|->
name|rc
operator|.
name|in_pos
operator|-
name|b
operator|->
name|in_pos
expr_stmt|;
if|if
condition|(
name|in_avail
operator|>
name|s
operator|->
name|lzma2
operator|.
name|compressed
condition|)
return|return
name|false
return|;
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|-=
name|in_avail
expr_stmt|;
name|b
operator|->
name|in_pos
operator|=
name|s
operator|->
name|rc
operator|.
name|in_pos
expr_stmt|;
block|}
name|in_avail
operator|=
name|b
operator|->
name|in_size
operator|-
name|b
operator|->
name|in_pos
expr_stmt|;
if|if
condition|(
name|in_avail
operator|<
name|LZMA_IN_REQUIRED
condition|)
block|{
if|if
condition|(
name|in_avail
operator|>
name|s
operator|->
name|lzma2
operator|.
name|compressed
condition|)
name|in_avail
operator|=
name|s
operator|->
name|lzma2
operator|.
name|compressed
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|b
operator|->
name|in
operator|+
name|b
operator|->
name|in_pos
argument_list|,
name|in_avail
argument_list|)
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|in_avail
expr_stmt|;
name|b
operator|->
name|in_pos
operator|+=
name|in_avail
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Take care of the LZMA2 control layer, and forward the job of actual LZMA  * decoding or copying of uncompressed chunks to other functions.  */
end_comment

begin_function
name|XZ_EXTERN
name|enum
name|xz_ret
name|xz_dec_lzma2_run
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
while|while
condition|(
name|b
operator|->
name|in_pos
operator|<
name|b
operator|->
name|in_size
operator|||
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|==
name|SEQ_LZMA_RUN
condition|)
block|{
switch|switch
condition|(
name|s
operator|->
name|lzma2
operator|.
name|sequence
condition|)
block|{
case|case
name|SEQ_CONTROL
case|:
comment|/* 			 * LZMA2 control byte 			 * 			 * Exact values: 			 *   0x00   End marker 			 *   0x01   Dictionary reset followed by 			 *          an uncompressed chunk 			 *   0x02   Uncompressed chunk (no dictionary reset) 			 * 			 * Highest three bits (s->control& 0xE0): 			 *   0xE0   Dictionary reset, new properties and state 			 *          reset, followed by LZMA compressed chunk 			 *   0xC0   New properties and state reset, followed 			 *          by LZMA compressed chunk (no dictionary 			 *          reset) 			 *   0xA0   State reset using old properties, 			 *          followed by LZMA compressed chunk (no 			 *          dictionary reset) 			 *   0x80   LZMA chunk (no dictionary or state reset) 			 * 			 * For LZMA compressed chunks, the lowest five bits 			 * (s->control& 1F) are the highest bits of the 			 * uncompressed size (bits 16-20). 			 * 			 * A new LZMA2 stream must begin with a dictionary 			 * reset. The first LZMA chunk must set new 			 * properties and reset the LZMA state. 			 * 			 * Values that don't match anything described above 			 * are invalid and we return XZ_DATA_ERROR. 			 */
name|tmp
operator|=
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0x00
condition|)
return|return
name|XZ_STREAM_END
return|;
if|if
condition|(
name|tmp
operator|>=
literal|0xE0
operator|||
name|tmp
operator|==
literal|0x01
condition|)
block|{
name|s
operator|->
name|lzma2
operator|.
name|need_props
operator|=
name|true
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|need_dict_reset
operator|=
name|false
expr_stmt|;
name|dict_reset
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|need_dict_reset
condition|)
block|{
return|return
name|XZ_DATA_ERROR
return|;
block|}
if|if
condition|(
name|tmp
operator|>=
literal|0x80
condition|)
block|{
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
operator|=
operator|(
name|tmp
operator|&
literal|0x1F
operator|)
operator|<<
literal|16
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_UNCOMPRESSED_1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0xC0
condition|)
block|{
comment|/* 					 * When there are new properties, 					 * state reset is done at 					 * SEQ_PROPERTIES. 					 */
name|s
operator|->
name|lzma2
operator|.
name|need_props
operator|=
name|false
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|next_sequence
operator|=
name|SEQ_PROPERTIES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|need_props
condition|)
block|{
return|return
name|XZ_DATA_ERROR
return|;
block|}
else|else
block|{
name|s
operator|->
name|lzma2
operator|.
name|next_sequence
operator|=
name|SEQ_LZMA_PREPARE
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0xA0
condition|)
name|lzma_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tmp
operator|>
literal|0x02
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_COMPRESSED_0
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|next_sequence
operator|=
name|SEQ_COPY
expr_stmt|;
block|}
break|break;
case|case
name|SEQ_UNCOMPRESSED_1
case|:
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
operator|+=
operator|(
name|uint32_t
operator|)
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|<<
literal|8
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_UNCOMPRESSED_2
expr_stmt|;
break|break;
case|case
name|SEQ_UNCOMPRESSED_2
case|:
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
operator|+=
operator|(
name|uint32_t
operator|)
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_COMPRESSED_0
expr_stmt|;
break|break;
case|case
name|SEQ_COMPRESSED_0
case|:
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|=
operator|(
name|uint32_t
operator|)
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|<<
literal|8
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_COMPRESSED_1
expr_stmt|;
break|break;
case|case
name|SEQ_COMPRESSED_1
case|:
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|+=
operator|(
name|uint32_t
operator|)
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|s
operator|->
name|lzma2
operator|.
name|next_sequence
expr_stmt|;
break|break;
case|case
name|SEQ_PROPERTIES
case|:
if|if
condition|(
operator|!
name|lzma_props
argument_list|(
name|s
argument_list|,
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_LZMA_PREPARE
expr_stmt|;
case|case
name|SEQ_LZMA_PREPARE
case|:
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|<
name|RC_INIT_BYTES
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
operator|!
name|rc_read_init
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|XZ_OK
return|;
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|-=
name|RC_INIT_BYTES
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_LZMA_RUN
expr_stmt|;
case|case
name|SEQ_LZMA_RUN
case|:
comment|/* 			 * Set dictionary limit to indicate how much we want 			 * to be encoded at maximum. Decode new data into the 			 * dictionary. Flush the new data from dictionary to 			 * b->out. Check if we finished decoding this chunk. 			 * In case the dictionary got full but we didn't fill 			 * the output buffer yet, we may run this loop 			 * multiple times without changing s->lzma2.sequence. 			 */
name|dict_limit
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
name|min_t
argument_list|(
name|size_t
argument_list|,
name|b
operator|->
name|out_size
operator|-
name|b
operator|->
name|out_pos
argument_list|,
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lzma2_lzma
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
operator|-=
name|dict_flush
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|uncompressed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|>
literal|0
operator|||
name|s
operator|->
name|lzma
operator|.
name|len
operator|>
literal|0
operator|||
operator|!
name|rc_is_finished
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|rc_reset
argument_list|(
operator|&
name|s
operator|->
name|rc
argument_list|)
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_CONTROL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|out_pos
operator|==
name|b
operator|->
name|out_size
operator|||
operator|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
operator|&&
name|s
operator|->
name|temp
operator|.
name|size
operator|<
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|)
condition|)
block|{
return|return
name|XZ_OK
return|;
block|}
break|break;
case|case
name|SEQ_COPY
case|:
name|dict_uncompressed
argument_list|(
operator|&
name|s
operator|->
name|dict
argument_list|,
name|b
argument_list|,
operator|&
name|s
operator|->
name|lzma2
operator|.
name|compressed
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lzma2
operator|.
name|compressed
operator|>
literal|0
condition|)
return|return
name|XZ_OK
return|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_CONTROL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|XZ_OK
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|struct
name|xz_dec_lzma2
modifier|*
name|xz_dec_lzma2_create
parameter_list|(
name|enum
name|xz_mode
name|mode
parameter_list|,
name|uint32_t
name|dict_max
parameter_list|)
block|{
name|struct
name|xz_dec_lzma2
modifier|*
name|s
init|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|->
name|dict
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|s
operator|->
name|dict
operator|.
name|size_max
operator|=
name|dict_max
expr_stmt|;
if|if
condition|(
name|DEC_IS_PREALLOC
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|s
operator|->
name|dict
operator|.
name|buf
operator|=
name|vmalloc
argument_list|(
name|dict_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|dict
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|kfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEC_IS_DYNALLOC
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|s
operator|->
name|dict
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|dict
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|enum
name|xz_ret
name|xz_dec_lzma2_reset
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|,
name|uint8_t
name|props
parameter_list|)
block|{
comment|/* This limits dictionary size to 3 GiB to keep parsing simpler. */
if|if
condition|(
name|props
operator|>
literal|39
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
name|s
operator|->
name|dict
operator|.
name|size
operator|=
literal|2
operator|+
operator|(
name|props
operator|&
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|dict
operator|.
name|size
operator|<<=
operator|(
name|props
operator|>>
literal|1
operator|)
operator|+
literal|11
expr_stmt|;
if|if
condition|(
name|DEC_IS_MULTI
argument_list|(
name|s
operator|->
name|dict
operator|.
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|dict
operator|.
name|size
operator|>
name|s
operator|->
name|dict
operator|.
name|size_max
condition|)
return|return
name|XZ_MEMLIMIT_ERROR
return|;
name|s
operator|->
name|dict
operator|.
name|end
operator|=
name|s
operator|->
name|dict
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|DEC_IS_DYNALLOC
argument_list|(
name|s
operator|->
name|dict
operator|.
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|dict
operator|.
name|allocated
operator|<
name|s
operator|->
name|dict
operator|.
name|size
condition|)
block|{
name|vfree
argument_list|(
name|s
operator|->
name|dict
operator|.
name|buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|dict
operator|.
name|buf
operator|=
name|vmalloc
argument_list|(
name|s
operator|->
name|dict
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|dict
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|dict
operator|.
name|allocated
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_MEM_ERROR
return|;
block|}
block|}
block|}
block|}
name|s
operator|->
name|lzma
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|sequence
operator|=
name|SEQ_CONTROL
expr_stmt|;
name|s
operator|->
name|lzma2
operator|.
name|need_dict_reset
operator|=
name|true
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_OK
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|void
name|xz_dec_lzma2_end
parameter_list|(
name|struct
name|xz_dec_lzma2
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|DEC_IS_MULTI
argument_list|(
name|s
operator|->
name|dict
operator|.
name|mode
argument_list|)
condition|)
name|vfree
argument_list|(
name|s
operator|->
name|dict
operator|.
name|buf
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

