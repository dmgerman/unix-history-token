begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * .xz Stream decoder  *  * Author: Lasse Collin<lasse.collin@tukaani.org>  *  * This file has been put into the public domain.  * You can do whatever you want with this file.  */
end_comment

begin_include
include|#
directive|include
file|"xz_private.h"
end_include

begin_include
include|#
directive|include
file|"xz_stream.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_USE_CRC64
end_ifdef

begin_define
define|#
directive|define
name|IS_CRC64
parameter_list|(
name|check_type
parameter_list|)
value|((check_type) == XZ_CHECK_CRC64)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_CRC64
parameter_list|(
name|check_type
parameter_list|)
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hash used to validate the Index field */
end_comment

begin_struct
struct|struct
name|xz_dec_hash
block|{
name|vli_type
name|unpadded
decl_stmt|;
name|vli_type
name|uncompressed
decl_stmt|;
name|uint32_t
name|crc32
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xz_dec
block|{
comment|/* Position in dec_main() */
enum|enum
block|{
name|SEQ_STREAM_HEADER
block|,
name|SEQ_BLOCK_START
block|,
name|SEQ_BLOCK_HEADER
block|,
name|SEQ_BLOCK_UNCOMPRESS
block|,
name|SEQ_BLOCK_PADDING
block|,
name|SEQ_BLOCK_CHECK
block|,
name|SEQ_INDEX
block|,
name|SEQ_INDEX_PADDING
block|,
name|SEQ_INDEX_CRC32
block|,
name|SEQ_STREAM_FOOTER
block|}
name|sequence
enum|;
comment|/* Position in variable-length integers and Check fields */
name|uint32_t
name|pos
decl_stmt|;
comment|/* Variable-length integer decoded by dec_vli() */
name|vli_type
name|vli
decl_stmt|;
comment|/* Saved in_pos and out_pos */
name|size_t
name|in_start
decl_stmt|;
name|size_t
name|out_start
decl_stmt|;
ifdef|#
directive|ifdef
name|XZ_USE_CRC64
comment|/* CRC32 or CRC64 value in Block or CRC32 value in Index */
name|uint64_t
name|crc
decl_stmt|;
else|#
directive|else
comment|/* CRC32 value in Block or Index */
name|uint32_t
name|crc
decl_stmt|;
endif|#
directive|endif
comment|/* Type of the integrity check calculated from uncompressed data */
name|enum
name|xz_check
name|check_type
decl_stmt|;
comment|/* Operation mode */
name|enum
name|xz_mode
name|mode
decl_stmt|;
comment|/* 	 * True if the next call to xz_dec_run() is allowed to return 	 * XZ_BUF_ERROR. 	 */
name|bool
name|allow_buf_error
decl_stmt|;
comment|/* Information stored in Block Header */
struct|struct
block|{
comment|/* 		 * Value stored in the Compressed Size field, or 		 * VLI_UNKNOWN if Compressed Size is not present. 		 */
name|vli_type
name|compressed
decl_stmt|;
comment|/* 		 * Value stored in the Uncompressed Size field, or 		 * VLI_UNKNOWN if Uncompressed Size is not present. 		 */
name|vli_type
name|uncompressed
decl_stmt|;
comment|/* Size of the Block Header field */
name|uint32_t
name|size
decl_stmt|;
block|}
name|block_header
struct|;
comment|/* Information collected when decoding Blocks */
struct|struct
block|{
comment|/* Observed compressed size of the current Block */
name|vli_type
name|compressed
decl_stmt|;
comment|/* Observed uncompressed size of the current Block */
name|vli_type
name|uncompressed
decl_stmt|;
comment|/* Number of Blocks decoded so far */
name|vli_type
name|count
decl_stmt|;
comment|/* 		 * Hash calculated from the Block sizes. This is used to 		 * validate the Index field. 		 */
name|struct
name|xz_dec_hash
name|hash
decl_stmt|;
block|}
name|block
struct|;
comment|/* Variables needed when verifying the Index field */
struct|struct
block|{
comment|/* Position in dec_index() */
enum|enum
block|{
name|SEQ_INDEX_COUNT
block|,
name|SEQ_INDEX_UNPADDED
block|,
name|SEQ_INDEX_UNCOMPRESSED
block|}
name|sequence
enum|;
comment|/* Size of the Index in bytes */
name|vli_type
name|size
decl_stmt|;
comment|/* Number of Records (matches block.count in valid files) */
name|vli_type
name|count
decl_stmt|;
comment|/* 		 * Hash calculated from the Records (matches block.hash in 		 * valid files). 		 */
name|struct
name|xz_dec_hash
name|hash
decl_stmt|;
block|}
name|index
struct|;
comment|/* 	 * Temporary buffer needed to hold Stream Header, Block Header, 	 * and Stream Footer. The Block Header is the biggest (1 KiB) 	 * so we reserve space according to that. buf[] has to be aligned 	 * to a multiple of four bytes; the size_t variables before it 	 * should guarantee this. 	 */
struct|struct
block|{
name|size_t
name|pos
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|1024
index|]
decl_stmt|;
block|}
name|temp
struct|;
name|struct
name|xz_dec_lzma2
modifier|*
name|lzma2
decl_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
name|struct
name|xz_dec_bcj
modifier|*
name|bcj
decl_stmt|;
name|bool
name|bcj_active
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_ANY_CHECK
end_ifdef

begin_comment
comment|/* Sizes of the Check field with different Check IDs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|check_sizes
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fill s->temp by copying data starting from b->in[b->in_pos]. Caller  * must have set s->temp.pos to indicate how much data we are supposed  * to copy into s->temp.buf. Return true once s->temp.pos has reached  * s->temp.size.  */
end_comment

begin_function
specifier|static
name|bool
name|fill_temp
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|copy_size
init|=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|b
operator|->
name|in_size
operator|-
name|b
operator|->
name|in_pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
operator|-
name|s
operator|->
name|temp
operator|.
name|pos
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|s
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|b
operator|->
name|in
operator|+
name|b
operator|->
name|in_pos
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|b
operator|->
name|in_pos
operator|+=
name|copy_size
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|pos
operator|+=
name|copy_size
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|pos
operator|==
name|s
operator|->
name|temp
operator|.
name|size
condition|)
block|{
name|s
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Decode a variable-length integer (little-endian base-128 encoding) */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_vli
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
modifier|*
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|)
block|{
name|uint8_t
name|byte
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|pos
operator|==
literal|0
condition|)
name|s
operator|->
name|vli
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|in_pos
operator|<
name|in_size
condition|)
block|{
name|byte
operator|=
name|in
index|[
operator|*
name|in_pos
index|]
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|s
operator|->
name|vli
operator||=
call|(
name|vli_type
call|)
argument_list|(
name|byte
operator|&
literal|0x7F
argument_list|)
operator|<<
name|s
operator|->
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't allow non-minimal encodings. */
if|if
condition|(
name|byte
operator|==
literal|0
operator|&&
name|s
operator|->
name|pos
operator|!=
literal|0
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_STREAM_END
return|;
block|}
name|s
operator|->
name|pos
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pos
operator|==
literal|7
operator|*
name|VLI_BYTES_MAX
condition|)
return|return
name|XZ_DATA_ERROR
return|;
block|}
return|return
name|XZ_OK
return|;
block|}
end_function

begin_comment
comment|/*  * Decode the Compressed Data field from a Block. Update and validate  * the observed compressed and uncompressed sizes of the Block so that  * they don't exceed the values possibly stored in the Block Header  * (validation assumes that no integer overflow occurs, since vli_type  * is normally uint64_t). Update the CRC32 or CRC64 value if presence of  * the CRC32 or CRC64 field was indicated in Stream Header.  *  * Once the decoding is finished, validate that the observed sizes match  * the sizes possibly stored in the Block Header. Update the hash and  * Block count, which are later used to validate the Index field.  */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_block
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|enum
name|xz_ret
name|ret
decl_stmt|;
name|s
operator|->
name|in_start
operator|=
name|b
operator|->
name|in_pos
expr_stmt|;
name|s
operator|->
name|out_start
operator|=
name|b
operator|->
name|out_pos
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
if|if
condition|(
name|s
operator|->
name|bcj_active
condition|)
name|ret
operator|=
name|xz_dec_bcj_run
argument_list|(
name|s
operator|->
name|bcj
argument_list|,
name|s
operator|->
name|lzma2
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|ret
operator|=
name|xz_dec_lzma2_run
argument_list|(
name|s
operator|->
name|lzma2
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|block
operator|.
name|compressed
operator|+=
name|b
operator|->
name|in_pos
operator|-
name|s
operator|->
name|in_start
expr_stmt|;
name|s
operator|->
name|block
operator|.
name|uncompressed
operator|+=
name|b
operator|->
name|out_pos
operator|-
name|s
operator|->
name|out_start
expr_stmt|;
comment|/* 	 * There is no need to separately check for VLI_UNKNOWN, since 	 * the observed sizes are always smaller than VLI_UNKNOWN. 	 */
if|if
condition|(
name|s
operator|->
name|block
operator|.
name|compressed
operator|>
name|s
operator|->
name|block_header
operator|.
name|compressed
operator|||
name|s
operator|->
name|block
operator|.
name|uncompressed
operator|>
name|s
operator|->
name|block_header
operator|.
name|uncompressed
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|check_type
operator|==
name|XZ_CHECK_CRC32
condition|)
name|s
operator|->
name|crc
operator|=
name|xz_crc32
argument_list|(
name|b
operator|->
name|out
operator|+
name|s
operator|->
name|out_start
argument_list|,
name|b
operator|->
name|out_pos
operator|-
name|s
operator|->
name|out_start
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_USE_CRC64
elseif|else
if|if
condition|(
name|s
operator|->
name|check_type
operator|==
name|XZ_CHECK_CRC64
condition|)
name|s
operator|->
name|crc
operator|=
name|xz_crc64
argument_list|(
name|b
operator|->
name|out
operator|+
name|s
operator|->
name|out_start
argument_list|,
name|b
operator|->
name|out_pos
operator|-
name|s
operator|->
name|out_start
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
name|XZ_STREAM_END
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|block_header
operator|.
name|compressed
operator|!=
name|VLI_UNKNOWN
operator|&&
name|s
operator|->
name|block_header
operator|.
name|compressed
operator|!=
name|s
operator|->
name|block
operator|.
name|compressed
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|block_header
operator|.
name|uncompressed
operator|!=
name|VLI_UNKNOWN
operator|&&
name|s
operator|->
name|block_header
operator|.
name|uncompressed
operator|!=
name|s
operator|->
name|block
operator|.
name|uncompressed
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|unpadded
operator|+=
name|s
operator|->
name|block_header
operator|.
name|size
operator|+
name|s
operator|->
name|block
operator|.
name|compressed
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_ANY_CHECK
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|unpadded
operator|+=
name|check_sizes
index|[
name|s
operator|->
name|check_type
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|check_type
operator|==
name|XZ_CHECK_CRC32
condition|)
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|unpadded
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_CRC64
argument_list|(
name|s
operator|->
name|check_type
argument_list|)
condition|)
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|unpadded
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|uncompressed
operator|+=
name|s
operator|->
name|block
operator|.
name|uncompressed
expr_stmt|;
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|crc32
operator|=
name|xz_crc32
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|s
operator|->
name|block
operator|.
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|block
operator|.
name|hash
argument_list|)
argument_list|,
name|s
operator|->
name|block
operator|.
name|hash
operator|.
name|crc32
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|block
operator|.
name|count
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Update the Index size and the CRC32 value. */
end_comment

begin_function
specifier|static
name|void
name|index_update
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|in_used
init|=
name|b
operator|->
name|in_pos
operator|-
name|s
operator|->
name|in_start
decl_stmt|;
name|s
operator|->
name|index
operator|.
name|size
operator|+=
name|in_used
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|xz_crc32
argument_list|(
name|b
operator|->
name|in
operator|+
name|s
operator|->
name|in_start
argument_list|,
name|in_used
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode the Number of Records, Unpadded Size, and Uncompressed Size  * fields from the Index field. That is, Index Padding and CRC32 are not  * decoded by this function.  *  * This can return XZ_OK (more input needed), XZ_STREAM_END (everything  * successfully decoded), or XZ_DATA_ERROR (input is corrupt).  */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_index
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|enum
name|xz_ret
name|ret
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|dec_vli
argument_list|(
name|s
argument_list|,
name|b
operator|->
name|in
argument_list|,
operator|&
name|b
operator|->
name|in_pos
argument_list|,
name|b
operator|->
name|in_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
block|{
name|index_update
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
switch|switch
condition|(
name|s
operator|->
name|index
operator|.
name|sequence
condition|)
block|{
case|case
name|SEQ_INDEX_COUNT
case|:
name|s
operator|->
name|index
operator|.
name|count
operator|=
name|s
operator|->
name|vli
expr_stmt|;
comment|/* 			 * Validate that the Number of Records field 			 * indicates the same number of Records as 			 * there were Blocks in the Stream. 			 */
if|if
condition|(
name|s
operator|->
name|index
operator|.
name|count
operator|!=
name|s
operator|->
name|block
operator|.
name|count
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|index
operator|.
name|sequence
operator|=
name|SEQ_INDEX_UNPADDED
expr_stmt|;
break|break;
case|case
name|SEQ_INDEX_UNPADDED
case|:
name|s
operator|->
name|index
operator|.
name|hash
operator|.
name|unpadded
operator|+=
name|s
operator|->
name|vli
expr_stmt|;
name|s
operator|->
name|index
operator|.
name|sequence
operator|=
name|SEQ_INDEX_UNCOMPRESSED
expr_stmt|;
break|break;
case|case
name|SEQ_INDEX_UNCOMPRESSED
case|:
name|s
operator|->
name|index
operator|.
name|hash
operator|.
name|uncompressed
operator|+=
name|s
operator|->
name|vli
expr_stmt|;
name|s
operator|->
name|index
operator|.
name|hash
operator|.
name|crc32
operator|=
name|xz_crc32
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|s
operator|->
name|index
operator|.
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|index
operator|.
name|hash
argument_list|)
argument_list|,
name|s
operator|->
name|index
operator|.
name|hash
operator|.
name|crc32
argument_list|)
expr_stmt|;
operator|--
name|s
operator|->
name|index
operator|.
name|count
expr_stmt|;
name|s
operator|->
name|index
operator|.
name|sequence
operator|=
name|SEQ_INDEX_UNPADDED
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|s
operator|->
name|index
operator|.
name|count
operator|>
literal|0
condition|)
do|;
return|return
name|XZ_STREAM_END
return|;
block|}
end_function

begin_comment
comment|/*  * Validate that the next four or eight input bytes match the value  * of s->crc. s->pos must be zero when starting to validate the first byte.  * The "bits" argument allows using the same code for both CRC32 and CRC64.  */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|crc_validate
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
return|return
name|XZ_OK
return|;
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|crc
operator|>>
name|s
operator|->
name|pos
operator|)
operator|&
literal|0xFF
operator|)
operator|!=
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|pos
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|->
name|pos
operator|<
name|bits
condition|)
do|;
name|s
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_STREAM_END
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XZ_DEC_ANY_CHECK
end_ifdef

begin_comment
comment|/*  * Skip over the Check field when the Check ID is not supported.  * Returns true once the whole Check field has been skipped over.  */
end_comment

begin_function
specifier|static
name|bool
name|check_skip
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
while|while
condition|(
name|s
operator|->
name|pos
operator|<
name|check_sizes
index|[
name|s
operator|->
name|check_type
index|]
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
return|return
name|false
return|;
operator|++
name|b
operator|->
name|in_pos
expr_stmt|;
operator|++
name|s
operator|->
name|pos
expr_stmt|;
block|}
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decode the Stream Header field (the first 12 bytes of the .xz Stream). */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_stream_header
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|memeq
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|HEADER_MAGIC
argument_list|,
name|HEADER_MAGIC_SIZE
argument_list|)
condition|)
return|return
name|XZ_FORMAT_ERROR
return|;
if|if
condition|(
name|xz_crc32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|HEADER_MAGIC_SIZE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
operator|!=
name|get_le32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|HEADER_MAGIC_SIZE
operator|+
literal|2
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|HEADER_MAGIC_SIZE
index|]
operator|!=
literal|0
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
comment|/* 	 * Of integrity checks, we support none (Check ID = 0), 	 * CRC32 (Check ID = 1), and optionally CRC64 (Check ID = 4). 	 * However, if XZ_DEC_ANY_CHECK is defined, we will accept other 	 * check types too, but then the check won't be verified and 	 * a warning (XZ_UNSUPPORTED_CHECK) will be given. 	 */
name|s
operator|->
name|check_type
operator|=
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|HEADER_MAGIC_SIZE
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_ANY_CHECK
if|if
condition|(
name|s
operator|->
name|check_type
operator|>
name|XZ_CHECK_MAX
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|check_type
operator|>
name|XZ_CHECK_CRC32
operator|&&
operator|!
name|IS_CRC64
argument_list|(
name|s
operator|->
name|check_type
argument_list|)
condition|)
return|return
name|XZ_UNSUPPORTED_CHECK
return|;
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|check_type
operator|>
name|XZ_CHECK_CRC32
operator|&&
operator|!
name|IS_CRC64
argument_list|(
name|s
operator|->
name|check_type
argument_list|)
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
endif|#
directive|endif
return|return
name|XZ_OK
return|;
block|}
end_function

begin_comment
comment|/* Decode the Stream Footer field (the last 12 bytes of the .xz Stream) */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_stream_footer
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|!
name|memeq
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
literal|10
argument_list|,
name|FOOTER_MAGIC
argument_list|,
name|FOOTER_MAGIC_SIZE
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
name|xz_crc32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
literal|4
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
operator|!=
name|get_le32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
comment|/* 	 * Validate Backward Size. Note that we never added the size of the 	 * Index CRC32 field to s->index.size, thus we use s->index.size / 4 	 * instead of s->index.size / 4 - 1. 	 */
if|if
condition|(
operator|(
name|s
operator|->
name|index
operator|.
name|size
operator|>>
literal|2
operator|)
operator|!=
name|get_le32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
literal|4
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|8
index|]
operator|!=
literal|0
operator|||
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|9
index|]
operator|!=
name|s
operator|->
name|check_type
condition|)
return|return
name|XZ_DATA_ERROR
return|;
comment|/* 	 * Use XZ_STREAM_END instead of XZ_OK to be more convenient 	 * for the caller. 	 */
return|return
name|XZ_STREAM_END
return|;
block|}
end_function

begin_comment
comment|/* Decode the Block Header and initialize the filter chain. */
end_comment

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_block_header
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|)
block|{
name|enum
name|xz_ret
name|ret
decl_stmt|;
comment|/* 	 * Validate the CRC32. We know that the temp buffer is at least 	 * eight bytes so this is safe. 	 */
name|s
operator|->
name|temp
operator|.
name|size
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|xz_crc32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|,
literal|0
argument_list|)
operator|!=
name|get_le32
argument_list|(
name|s
operator|->
name|temp
operator|.
name|buf
operator|+
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|temp
operator|.
name|pos
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Catch unsupported Block Flags. We support only one or two filters 	 * in the chain, so we catch that with the same test. 	 */
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|1
index|]
operator|&
literal|0x3E
condition|)
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|1
index|]
operator|&
literal|0x3F
condition|)
endif|#
directive|endif
return|return
name|XZ_OPTIONS_ERROR
return|;
comment|/* Compressed Size */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|1
index|]
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
name|dec_vli
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
operator|&
name|s
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|block_header
operator|.
name|compressed
operator|=
name|s
operator|->
name|vli
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|block_header
operator|.
name|compressed
operator|=
name|VLI_UNKNOWN
expr_stmt|;
block|}
comment|/* Uncompressed Size */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|1
index|]
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|dec_vli
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
argument_list|,
operator|&
name|s
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|s
operator|->
name|temp
operator|.
name|size
argument_list|)
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|block_header
operator|.
name|uncompressed
operator|=
name|s
operator|->
name|vli
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|block_header
operator|.
name|uncompressed
operator|=
name|VLI_UNKNOWN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
comment|/* If there are two filters, the first one must be a BCJ filter. */
name|s
operator|->
name|bcj_active
operator|=
name|s
operator|->
name|temp
operator|.
name|buf
index|[
literal|1
index|]
operator|&
literal|0x01
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bcj_active
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|-
name|s
operator|->
name|temp
operator|.
name|pos
operator|<
literal|2
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
name|ret
operator|=
name|xz_dec_bcj_reset
argument_list|(
name|s
operator|->
name|bcj
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_OK
condition|)
return|return
name|ret
return|;
comment|/* 		 * We don't support custom start offset, 		 * so Size of Properties must be zero. 		 */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
operator|!=
literal|0x00
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
block|}
endif|#
directive|endif
comment|/* Valid Filter Flags always take at least two bytes. */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|-
name|s
operator|->
name|temp
operator|.
name|pos
operator|<
literal|2
condition|)
return|return
name|XZ_DATA_ERROR
return|;
comment|/* Filter ID = LZMA2 */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
operator|!=
literal|0x21
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
comment|/* Size of Properties = 1-byte Filter Properties */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
operator|!=
literal|0x01
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
comment|/* Filter Properties contains LZMA2 dictionary size. */
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|size
operator|-
name|s
operator|->
name|temp
operator|.
name|pos
operator|<
literal|1
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|ret
operator|=
name|xz_dec_lzma2_reset
argument_list|(
name|s
operator|->
name|lzma2
argument_list|,
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_OK
condition|)
return|return
name|ret
return|;
comment|/* The rest must be Header Padding. */
while|while
condition|(
name|s
operator|->
name|temp
operator|.
name|pos
operator|<
name|s
operator|->
name|temp
operator|.
name|size
condition|)
if|if
condition|(
name|s
operator|->
name|temp
operator|.
name|buf
index|[
name|s
operator|->
name|temp
operator|.
name|pos
operator|++
index|]
operator|!=
literal|0x00
condition|)
return|return
name|XZ_OPTIONS_ERROR
return|;
name|s
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|block
operator|.
name|compressed
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|block
operator|.
name|uncompressed
operator|=
literal|0
expr_stmt|;
return|return
name|XZ_OK
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xz_ret
name|dec_main
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|enum
name|xz_ret
name|ret
decl_stmt|;
comment|/* 	 * Store the start position for the case when we are in the middle 	 * of the Index field. 	 */
name|s
operator|->
name|in_start
operator|=
name|b
operator|->
name|in_pos
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|s
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_STREAM_HEADER
case|:
comment|/* 			 * Stream Header is copied to s->temp, and then 			 * decoded from there. This way if the caller 			 * gives us only little input at a time, we can 			 * still keep the Stream Header decoding code 			 * simple. Similar approach is used in many places 			 * in this file. 			 */
if|if
condition|(
operator|!
name|fill_temp
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|XZ_OK
return|;
comment|/* 			 * If dec_stream_header() returns 			 * XZ_UNSUPPORTED_CHECK, it is still possible 			 * to continue decoding if working in multi-call 			 * mode. Thus, update s->sequence before calling 			 * dec_stream_header(). 			 */
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_START
expr_stmt|;
name|ret
operator|=
name|dec_stream_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_OK
condition|)
return|return
name|ret
return|;
case|case
name|SEQ_BLOCK_START
case|:
comment|/* We need one byte of input to continue. */
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
return|return
name|XZ_OK
return|;
comment|/* See if this is the beginning of the Index field. */
if|if
condition|(
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
index|]
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|in_start
operator|=
name|b
operator|->
name|in_pos
operator|++
expr_stmt|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_INDEX
expr_stmt|;
break|break;
block|}
comment|/* 			 * Calculate the size of the Block Header and 			 * prepare to decode it. 			 */
name|s
operator|->
name|block_header
operator|.
name|size
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
index|]
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|s
operator|->
name|block_header
operator|.
name|size
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_HEADER
expr_stmt|;
case|case
name|SEQ_BLOCK_HEADER
case|:
if|if
condition|(
operator|!
name|fill_temp
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|XZ_OK
return|;
name|ret
operator|=
name|dec_block_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_OK
condition|)
return|return
name|ret
return|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_UNCOMPRESS
expr_stmt|;
case|case
name|SEQ_BLOCK_UNCOMPRESS
case|:
name|ret
operator|=
name|dec_block
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|ret
return|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_PADDING
expr_stmt|;
case|case
name|SEQ_BLOCK_PADDING
case|:
comment|/* 			 * Size of Compressed Data + Block Padding 			 * must be a multiple of four. We don't need 			 * s->block.compressed for anything else 			 * anymore, so we use it here to test the size 			 * of the Block Padding field. 			 */
while|while
condition|(
name|s
operator|->
name|block
operator|.
name|compressed
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
return|return
name|XZ_OK
return|;
if|if
condition|(
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|!=
literal|0
condition|)
return|return
name|XZ_DATA_ERROR
return|;
operator|++
name|s
operator|->
name|block
operator|.
name|compressed
expr_stmt|;
block|}
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_CHECK
expr_stmt|;
case|case
name|SEQ_BLOCK_CHECK
case|:
if|if
condition|(
name|s
operator|->
name|check_type
operator|==
name|XZ_CHECK_CRC32
condition|)
block|{
name|ret
operator|=
name|crc_validate
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|IS_CRC64
argument_list|(
name|s
operator|->
name|check_type
argument_list|)
condition|)
block|{
name|ret
operator|=
name|crc_validate
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|XZ_DEC_ANY_CHECK
elseif|else
if|if
condition|(
operator|!
name|check_skip
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
condition|)
block|{
return|return
name|XZ_OK
return|;
block|}
endif|#
directive|endif
name|s
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_START
expr_stmt|;
break|break;
case|case
name|SEQ_INDEX
case|:
name|ret
operator|=
name|dec_index
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|ret
return|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_INDEX_PADDING
expr_stmt|;
case|case
name|SEQ_INDEX_PADDING
case|:
while|while
condition|(
operator|(
name|s
operator|->
name|index
operator|.
name|size
operator|+
operator|(
name|b
operator|->
name|in_pos
operator|-
name|s
operator|->
name|in_start
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|)
block|{
name|index_update
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|XZ_OK
return|;
block|}
if|if
condition|(
name|b
operator|->
name|in
index|[
name|b
operator|->
name|in_pos
operator|++
index|]
operator|!=
literal|0
condition|)
return|return
name|XZ_DATA_ERROR
return|;
block|}
comment|/* Finish the CRC32 value and Index size. */
name|index_update
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Compare the hashes to validate the Index field. */
if|if
condition|(
operator|!
name|memeq
argument_list|(
operator|&
name|s
operator|->
name|block
operator|.
name|hash
argument_list|,
operator|&
name|s
operator|->
name|index
operator|.
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|block
operator|.
name|hash
argument_list|)
argument_list|)
condition|)
return|return
name|XZ_DATA_ERROR
return|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_INDEX_CRC32
expr_stmt|;
case|case
name|SEQ_INDEX_CRC32
case|:
name|ret
operator|=
name|crc_validate
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
return|return
name|ret
return|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|STREAM_HEADER_SIZE
expr_stmt|;
name|s
operator|->
name|sequence
operator|=
name|SEQ_STREAM_FOOTER
expr_stmt|;
case|case
name|SEQ_STREAM_FOOTER
case|:
if|if
condition|(
operator|!
name|fill_temp
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|XZ_OK
return|;
return|return
name|dec_stream_footer
argument_list|(
name|s
argument_list|)
return|;
block|}
block|}
comment|/* Never reached */
block|}
end_function

begin_comment
comment|/*  * xz_dec_run() is a wrapper for dec_main() to handle some special cases in  * multi-call and single-call decoding.  *  * In multi-call mode, we must return XZ_BUF_ERROR when it seems clear that we  * are not going to make any progress anymore. This is to prevent the caller  * from calling us infinitely when the input file is truncated or otherwise  * corrupt. Since zlib-style API allows that the caller fills the input buffer  * only when the decoder doesn't produce any new output, we have to be careful  * to avoid returning XZ_BUF_ERROR too easily: XZ_BUF_ERROR is returned only  * after the second consecutive call to xz_dec_run() that makes no progress.  *  * In single-call mode, if we couldn't decode everything and no error  * occurred, either the input is truncated or the output buffer is too small.  * Since we know that the last input byte never produces any output, we know  * that if all the input was consumed and decoding wasn't finished, the file  * must be corrupt. Otherwise the output buffer has to be too small or the  * file is corrupt in a way that decoding it produces too big output.  *  * If single-call decoding fails, we reset b->in_pos and b->out_pos back to  * their original values. This is because with some filter chains there won't  * be any valid uncompressed data in the output buffer unless the decoding  * actually succeeds (that's the price to pay of using the output buffer as  * the workspace).  */
end_comment

begin_function
name|XZ_EXTERN
name|enum
name|xz_ret
name|xz_dec_run
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|,
name|struct
name|xz_buf
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|in_start
decl_stmt|;
name|size_t
name|out_start
decl_stmt|;
name|enum
name|xz_ret
name|ret
decl_stmt|;
if|if
condition|(
name|DEC_IS_SINGLE
argument_list|(
name|s
operator|->
name|mode
argument_list|)
condition|)
name|xz_dec_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|in_start
operator|=
name|b
operator|->
name|in_pos
expr_stmt|;
name|out_start
operator|=
name|b
operator|->
name|out_pos
expr_stmt|;
name|ret
operator|=
name|dec_main
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEC_IS_SINGLE
argument_list|(
name|s
operator|->
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|XZ_OK
condition|)
name|ret
operator|=
name|b
operator|->
name|in_pos
operator|==
name|b
operator|->
name|in_size
condition|?
name|XZ_DATA_ERROR
else|:
name|XZ_BUF_ERROR
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|XZ_STREAM_END
condition|)
block|{
name|b
operator|->
name|in_pos
operator|=
name|in_start
expr_stmt|;
name|b
operator|->
name|out_pos
operator|=
name|out_start
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|XZ_OK
operator|&&
name|in_start
operator|==
name|b
operator|->
name|in_pos
operator|&&
name|out_start
operator|==
name|b
operator|->
name|out_pos
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|allow_buf_error
condition|)
name|ret
operator|=
name|XZ_BUF_ERROR
expr_stmt|;
name|s
operator|->
name|allow_buf_error
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|allow_buf_error
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|struct
name|xz_dec
modifier|*
name|xz_dec_init
parameter_list|(
name|enum
name|xz_mode
name|mode
parameter_list|,
name|uint32_t
name|dict_max
parameter_list|)
block|{
name|struct
name|xz_dec
modifier|*
name|s
init|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
name|s
operator|->
name|bcj
operator|=
name|xz_dec_bcj_create
argument_list|(
name|DEC_IS_SINGLE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bcj
operator|==
name|NULL
condition|)
goto|goto
name|error_bcj
goto|;
endif|#
directive|endif
name|s
operator|->
name|lzma2
operator|=
name|xz_dec_lzma2_create
argument_list|(
name|mode
argument_list|,
name|dict_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lzma2
operator|==
name|NULL
condition|)
goto|goto
name|error_lzma2
goto|;
name|xz_dec_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
name|error_lzma2
label|:
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
name|xz_dec_bcj_end
argument_list|(
name|s
operator|->
name|bcj
argument_list|)
expr_stmt|;
name|error_bcj
label|:
endif|#
directive|endif
name|kfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|void
name|xz_dec_reset
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|sequence
operator|=
name|SEQ_STREAM_HEADER
expr_stmt|;
name|s
operator|->
name|allow_buf_error
operator|=
name|false
expr_stmt|;
name|s
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|memzero
argument_list|(
operator|&
name|s
operator|->
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|memzero
argument_list|(
operator|&
name|s
operator|->
name|index
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|temp
operator|.
name|size
operator|=
name|STREAM_HEADER_SIZE
expr_stmt|;
block|}
end_function

begin_function
name|XZ_EXTERN
name|void
name|xz_dec_end
parameter_list|(
name|struct
name|xz_dec
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|xz_dec_lzma2_end
argument_list|(
name|s
operator|->
name|lzma2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XZ_DEC_BCJ
name|xz_dec_bcj_end
argument_list|(
name|s
operator|->
name|bcj
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

