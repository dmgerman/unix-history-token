begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/* Portions Copyright 2007 Shivakumar GN */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/gfs.h>
end_include

begin_comment
comment|/*  * Generic pseudo-filesystem routines.  *  * There are significant similarities between the implementation of certain file  * system entry points across different filesystems.  While one could attempt to  * "choke up on the bat" and incorporate common functionality into a VOP  * preamble or postamble, such an approach is limited in the benefit it can  * provide.  In this file we instead define a toolkit of routines which can be  * called from a filesystem (with in-kernel pseudo-filesystems being the focus  * of the exercise) in a more component-like fashion.  *  * There are three basic classes of routines:  *  * 1) Lowlevel support routines  *  *    These routines are designed to play a support role for existing  *    pseudo-filesystems (such as procfs).  They simplify common tasks,  *    without enforcing the filesystem to hand over management to GFS.  The  *    routines covered are:  *  *	gfs_readdir_init()  *	gfs_readdir_emit()  *	gfs_readdir_emitn()  *	gfs_readdir_pred()  *	gfs_readdir_fini()  *	gfs_lookup_dot()  *  * 2) Complete GFS management  *  *    These routines take a more active role in management of the  *    pseudo-filesystem.  They handle the relationship between vnode private  *    data and VFS data, as well as the relationship between vnodes in the  *    directory hierarchy.  *  *    In order to use these interfaces, the first member of every private  *    v_data must be a gfs_file_t or a gfs_dir_t.  This hands over all control  *    to GFS.  *  * 	gfs_file_create()  * 	gfs_dir_create()  * 	gfs_root_create()  *  *	gfs_file_inactive()  *	gfs_dir_inactive()  *	gfs_dir_lookup()  *	gfs_dir_readdir()  *  * 	gfs_vop_inactive()  * 	gfs_vop_lookup()  * 	gfs_vop_readdir()  * 	gfs_vop_map()  *  * 3) Single File pseudo-filesystems  *  *    This routine creates a rooted file to be overlayed ontop of another  *    file in the physical filespace.  *  *    Note that the parent is NULL (actually the vfs), but there is nothing  *    technically keeping such a file from utilizing the "Complete GFS  *    management" set of routines.  *  * 	gfs_root_create_file()  */
end_comment

begin_comment
comment|/*  * Low level directory routines  *  * These routines provide some simple abstractions for reading directories.  * They are designed to be used by existing pseudo filesystems (namely procfs)  * that already have a complicated management infrastructure.  */
end_comment

begin_comment
comment|/*  * gfs_readdir_init: initiate a generic readdir  *   st		- a pointer to an uninitialized gfs_readdir_state_t structure  *   name_max	- the directory's maximum file name length  *   ureclen	- the exported file-space record length (1 for non-legacy FSs)  *   uiop	- the uiop passed to readdir  *   parent	- the parent directory's inode  *   self	- this directory's inode  *  * Returns 0 or a non-zero errno.  *  * Typical VOP_READDIR usage of gfs_readdir_*:  *  *	if ((error = gfs_readdir_init(...)) != 0)  *		return (error);  *	eof = 0;  *	while ((error = gfs_readdir_pred(...,&voffset)) != 0) {  *		if (!consumer_entry_at(voffset))  *			voffset = consumer_next_entry(voffset);  *		if (consumer_eof(voffset)) {  *			eof = 1  *			break;  *		}  *		if ((error = gfs_readdir_emit(..., voffset,  *		    consumer_ino(voffset), consumer_name(voffset))) != 0)  *			break;  *	}  *	return (gfs_readdir_fini(..., error, eofp, eof));  *  * As you can see, a zero result from gfs_readdir_pred() or  * gfs_readdir_emit() indicates that processing should continue,  * whereas a non-zero result indicates that the loop should terminate.  * Most consumers need do nothing more than let gfs_readdir_fini()  * determine what the cause of failure was and return the appropriate  * value.  */
end_comment

begin_function
name|int
name|gfs_readdir_init
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|int
name|name_max
parameter_list|,
name|int
name|ureclen
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|ino64_t
name|parent
parameter_list|,
name|ino64_t
name|self
parameter_list|)
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uiop
operator|->
name|uio_resid
operator|<=
literal|0
operator|||
operator|(
name|uiop
operator|->
name|uio_loffset
operator|%
name|ureclen
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|st
operator|->
name|grd_ureclen
operator|=
name|ureclen
expr_stmt|;
name|st
operator|->
name|grd_oresid
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|st
operator|->
name|grd_namlen
operator|=
name|name_max
expr_stmt|;
name|st
operator|->
name|grd_dirent
operator|=
name|kmem_zalloc
argument_list|(
name|DIRENT64_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|st
operator|->
name|grd_parent
operator|=
name|parent
expr_stmt|;
name|st
operator|->
name|grd_self
operator|=
name|self
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_emit_int: internal routine to emit directory entry  *  *   st		- the current readdir state, which must have d_ino and d_name  *                set  *   uiop	- caller-supplied uio pointer  *   next	- the offset of the next entry  */
end_comment

begin_function
specifier|static
name|int
name|gfs_readdir_emit_int
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
name|next
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|)
block|{
name|int
name|reclen
decl_stmt|,
name|namlen
decl_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|st
operator|->
name|grd_dirent
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|uiop
operator|->
name|uio_resid
condition|)
block|{
comment|/* 		 * Error if no entries were returned yet 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|==
name|st
operator|->
name|grd_oresid
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|st
operator|->
name|grd_dirent
operator|->
name|d_reclen
operator|=
operator|(
name|ushort_t
operator|)
name|reclen
expr_stmt|;
name|st
operator|->
name|grd_dirent
operator|->
name|d_namlen
operator|=
name|namlen
expr_stmt|;
comment|/* TODO: d_type */
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|st
operator|->
name|grd_dirent
argument_list|,
name|reclen
argument_list|,
name|UIO_READ
argument_list|,
name|uiop
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uiop
operator|->
name|uio_loffset
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|cookies
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|*
name|cookies
operator|=
name|next
expr_stmt|;
operator|(
operator|*
name|cookies
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|ncookies
operator|)
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|ncookies
operator|>=
literal|0
argument_list|,
operator|(
literal|"ncookies=%d"
operator|,
operator|*
name|ncookies
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_emit: emit a directory entry  *   voff       - the virtual offset (obtained from gfs_readdir_pred)  *   ino        - the entry's inode  *   name       - the entry's name  *  * Returns a 0 on success, a non-zero errno on failure, or -1 if the  * readdir loop should terminate.  A non-zero result (either errno or  * -1) from this function is typically passed directly to  * gfs_readdir_fini().  */
end_comment

begin_function
name|int
name|gfs_readdir_emit
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
name|voff
parameter_list|,
name|ino64_t
name|ino
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|)
block|{
name|offset_t
name|off
init|=
operator|(
name|voff
operator|+
literal|2
operator|)
operator|*
name|st
operator|->
name|grd_ureclen
decl_stmt|;
name|st
operator|->
name|grd_dirent
operator|->
name|d_ino
operator|=
name|ino
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|st
operator|->
name|grd_dirent
operator|->
name|d_name
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
comment|/* TODO: d_type */
comment|/* 	 * Inter-entry offsets are invalid, so we assume a record size of 	 * grd_ureclen and explicitly set the offset appropriately. 	 */
return|return
operator|(
name|gfs_readdir_emit_int
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|off
operator|+
name|st
operator|->
name|grd_ureclen
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_pred: readdir loop predicate  *   voffp - a pointer in which the next virtual offset should be stored  *  * Returns a 0 on success, a non-zero errno on failure, or -1 if the  * readdir loop should terminate.  A non-zero result (either errno or  * -1) from this function is typically passed directly to  * gfs_readdir_fini().  */
end_comment

begin_function
name|int
name|gfs_readdir_pred
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
modifier|*
name|voffp
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|)
block|{
name|offset_t
name|off
decl_stmt|,
name|voff
decl_stmt|;
name|int
name|error
decl_stmt|;
name|top
label|:
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|off
operator|=
name|uiop
operator|->
name|uio_loffset
operator|/
name|st
operator|->
name|grd_ureclen
expr_stmt|;
name|voff
operator|=
name|off
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|voff
argument_list|,
name|st
operator|->
name|grd_self
argument_list|,
literal|"."
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|voff
argument_list|,
name|st
operator|->
name|grd_parent
argument_list|,
literal|".."
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
block|}
else|else
block|{
operator|*
name|voffp
operator|=
name|voff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_fini: generic readdir cleanup  *   error	- if positive, an error to return  *   eofp	- the eofp passed to readdir  *   eof	- the eof value  *  * Returns a 0 on success, a non-zero errno on failure.  This result  * should be returned from readdir.  */
end_comment

begin_function
name|int
name|gfs_readdir_fini
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|int
name|error
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|int
name|eof
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|st
operator|->
name|grd_dirent
argument_list|,
name|DIRENT64_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_lookup_dot  *  * Performs a basic check for "." and ".." directory entries.  */
end_comment

begin_function
name|int
name|gfs_lookup_dot
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|)
block|{
if|if
condition|(
operator|*
name|nm
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|nm
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|VN_HOLD
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|pvp
expr_stmt|;
block|}
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_file_create(): create a new GFS file  *  *   size	- size of private data structure (v_data)  *   pvp	- parent vnode (GFS directory)  *   ops	- vnode operations vector  *  * In order to use this interface, the parent vnode must have been created by  * gfs_dir_create(), and the private data stored in v_data must have a  * 'gfs_file_t' as its first field.  *  * Given these constraints, this routine will automatically:  *  * 	- Allocate v_data for the vnode  * 	- Initialize necessary fields in the vnode  * 	- Hold the parent  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_file_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|)
block|{
name|gfs_file_t
modifier|*
name|fp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Allocate vnode and internal data structure 	 */
name|fp
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"zfs"
argument_list|,
name|vfsp
argument_list|,
name|ops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
operator|(
name|caddr_t
operator|)
name|fp
expr_stmt|;
comment|/* 	 * Set up various pointers 	 */
name|fp
operator|->
name|gfs_vnode
operator|=
name|vp
expr_stmt|;
name|fp
operator|->
name|gfs_parent
operator|=
name|pvp
expr_stmt|;
name|fp
operator|->
name|gfs_size
operator|=
name|size
expr_stmt|;
name|fp
operator|->
name|gfs_type
operator|=
name|GFS_FILE
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"insmntque() failed: error %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize vnode and hold parent. 	 */
if|if
condition|(
name|pvp
condition|)
name|VN_HOLD
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_create: creates a new directory in the parent  *  *   size	- size of private data structure (v_data)  *   pvp	- parent vnode (GFS directory)  *   ops	- vnode operations vector  *   entries	- NULL-terminated list of static entries (if any)  *   maxlen	- maximum length of a directory entry  *   readdir_cb	- readdir callback (see gfs_dir_readdir)  *   inode_cb	- inode callback (see gfs_dir_readdir)  *   lookup_cb	- lookup callback (see gfs_dir_lookup)  *  * In order to use this function, the first member of the private vnode  * structure (v_data) must be a gfs_dir_t.  For each directory, there are  * static entries, defined when the structure is initialized, and dynamic  * entries, retrieved through callbacks.  *  * If a directory has static entries, then it must supply a inode callback,  * which will compute the inode number based on the parent and the index.  * For a directory with dynamic entries, the caller must supply a readdir  * callback and a lookup callback.  If a static lookup fails, we fall back to  * the supplied lookup callback, if any.  *  * This function also performs the same initialization as gfs_file_create().  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_dir_create
parameter_list|(
name|size_t
name|struct_size
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|,
name|gfs_dirent_t
modifier|*
name|entries
parameter_list|,
name|gfs_inode_cb
name|inode_cb
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|gfs_readdir_cb
name|readdir_cb
parameter_list|,
name|gfs_lookup_cb
name|lookup_cb
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
decl_stmt|;
name|gfs_dirent_t
modifier|*
name|de
decl_stmt|;
name|vp
operator|=
name|gfs_file_create
argument_list|(
name|struct_size
argument_list|,
name|pvp
argument_list|,
name|vfsp
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
name|dp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_type
operator|=
name|GFS_DIR
expr_stmt|;
name|dp
operator|->
name|gfsd_maxlen
operator|=
name|maxlen
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|de
operator|=
name|entries
init|;
name|de
operator|->
name|gfse_name
operator|!=
name|NULL
condition|;
name|de
operator|++
control|)
name|dp
operator|->
name|gfsd_nstatic
operator|++
expr_stmt|;
name|dp
operator|->
name|gfsd_static
operator|=
name|kmem_alloc
argument_list|(
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|entries
argument_list|,
name|dp
operator|->
name|gfsd_static
argument_list|,
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|gfsd_readdir
operator|=
name|readdir_cb
expr_stmt|;
name|dp
operator|->
name|gfsd_lookup
operator|=
name|lookup_cb
expr_stmt|;
name|dp
operator|->
name|gfsd_inode
operator|=
name|inode_cb
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|gfsd_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_root_create(): create a root vnode for a GFS filesystem  *  * Similar to gfs_dir_create(), this creates a root vnode for a filesystem.  The  * only difference is that it takes a vfs_t instead of a vnode_t as its parent.  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_root_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|,
name|ino64_t
name|ino
parameter_list|,
name|gfs_dirent_t
modifier|*
name|entries
parameter_list|,
name|gfs_inode_cb
name|inode_cb
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|gfs_readdir_cb
name|readdir_cb
parameter_list|,
name|gfs_lookup_cb
name|lookup_cb
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|VFS_HOLD
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|gfs_dir_create
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|,
name|vfsp
argument_list|,
name|ops
argument_list|,
name|entries
argument_list|,
name|inode_cb
argument_list|,
name|maxlen
argument_list|,
name|readdir_cb
argument_list|,
name|lookup_cb
argument_list|)
expr_stmt|;
comment|/* Manually set the inode */
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_ino
operator|=
name|ino
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_file_inactive()  *  * Called from the VOP_INACTIVE() routine.  If necessary, this routine will  * remove the given vnode from the parent directory and clean up any references  * in the VFS layer.  *  * If the vnode was not removed (due to a race with vget), then NULL is  * returned.  Otherwise, a pointer to the private data is returned.  */
end_comment

begin_function
name|void
modifier|*
name|gfs_file_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gfs_dirent_t
modifier|*
name|ge
init|=
name|NULL
decl_stmt|;
name|gfs_file_t
modifier|*
name|fp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|gfs_parent
operator|==
name|NULL
condition|)
goto|goto
name|found
goto|;
name|dp
operator|=
name|fp
operator|->
name|gfs_parent
operator|->
name|v_data
expr_stmt|;
comment|/* 	 * First, see if this vnode is cached in the parent. 	 */
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Find it in the set of static entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|;
name|i
operator|++
control|)
block|{
name|ge
operator|=
operator|&
name|dp
operator|->
name|gfsd_static
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
operator|==
name|vp
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* 	 * If 'ge' is NULL, then it is a dynamic entry. 	 */
name|ge
operator|=
name|NULL
expr_stmt|;
name|found
label|:
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_count
operator|<
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Really remove this vnode 	 */
name|data
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
if|if
condition|(
name|ge
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If this was a statically cached entry, simply set the 		 * cached vnode to NULL. 		 */
name|ge
operator|->
name|gfse_vnode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
name|vp
operator|->
name|v_usecount
operator|--
expr_stmt|;
name|vdropl
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free vnode and release parent 	 */
if|if
condition|(
name|fp
operator|->
name|gfs_parent
condition|)
block|{
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|fp
operator|->
name|gfs_parent
argument_list|)
expr_stmt|;
name|fp
operator|->
name|gfs_parent
operator|->
name|v_usecount
operator|--
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|fp
operator|->
name|gfs_parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_vfsp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VFS_RELE
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_inactive()  *  * Same as above, but for directories.  */
end_comment

begin_function
name|void
modifier|*
name|gfs_dir_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|gfs_dir_t
modifier|*
name|dp
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|gfs_file_inactive
argument_list|(
name|vp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|gfsd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|gfsd_nstatic
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|gfsd_static
argument_list|,
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_lookup()  *  * Looks up the given name in the directory and returns the corresponding vnode,  * if found.  *  * First, we search statically defined entries, if any.  If a match is found,  * and GFS_CACHE_VNODE is set and the vnode exists, we simply return the  * existing vnode.  Otherwise, we call the static entry's callback routine,  * caching the result if necessary.  *  * If no static entry is found, we invoke the lookup callback, if any.  The  * arguments to this callback are:  *  *	int gfs_lookup_cb(vnode_t *pvp, const char *nm, vnode_t **vpp);  *  *	pvp	- parent vnode  *	nm	- name of entry  *	vpp	- pointer to resulting vnode  *  * 	Returns 0 on success, non-zero on error.  */
end_comment

begin_function
name|int
name|gfs_dir_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gfs_dirent_t
modifier|*
name|ge
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfs_lookup_dot
argument_list|(
name|vpp
argument_list|,
name|dvp
argument_list|,
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_parent
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Search static entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|;
name|i
operator|++
control|)
block|{
name|ge
operator|=
operator|&
name|dp
operator|->
name|gfsd_static
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ge
operator|->
name|gfse_name
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
condition|)
block|{
name|ASSERT
argument_list|(
name|ge
operator|->
name|gfse_flags
operator|&
name|GFS_CACHE_VNODE
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_vnode
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * We drop the directory lock, as the constructor will 			 * need to do KM_SLEEP allocations.  If we return from 			 * the constructor only to find that a parallel 			 * operation has completed, and GFS_CACHE_VNODE is set 			 * for this entry, we discard the result in favor of the 			 * cached vnode. 			 */
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_ctor
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_index
operator|=
name|i
expr_stmt|;
comment|/* Set the inode according to the callback. */
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_ino
operator|=
name|dp
operator|->
name|gfsd_inode
argument_list|(
name|dvp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ge
operator|->
name|gfse_flags
operator|&
name|GFS_CACHE_VNODE
condition|)
block|{
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
operator|==
name|NULL
condition|)
block|{
name|ge
operator|->
name|gfse_vnode
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * A parallel constructor beat us to it; 					 * return existing vnode.  We have to be 					 * careful because we can't release the 					 * current vnode while holding the 					 * directory lock; its inactive routine 					 * will try to lock this directory. 					 */
name|vnode_t
modifier|*
name|oldvp
init|=
name|vp
decl_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_vnode
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|oldvp
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * See if there is a dynamic constructor. 	 */
if|if
condition|(
name|dp
operator|->
name|gfsd_lookup
condition|)
block|{
name|ino64_t
name|ino
decl_stmt|;
name|gfs_file_t
modifier|*
name|fp
decl_stmt|;
comment|/* 		 * Once again, drop the directory lock, as the lookup routine 		 * will need to allocate memory, or otherwise deadlock on this 		 * directory. 		 */
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dp
operator|->
name|gfsd_lookup
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|ino
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|fp
operator|=
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
expr_stmt|;
name|fp
operator|->
name|gfs_index
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|gfs_ino
operator|=
name|ino
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No static entry found, and there is no lookup callback, so 		 * return ENOENT. 		 */
name|ret
operator|=
name|ENOENT
expr_stmt|;
block|}
name|out
label|:
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
else|else
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_readdir: does a readdir() on the given directory  *  *    dvp	- directory vnode  *    uiop	- uio structure  *    eofp	- eof pointer  *    data	- arbitrary data passed to readdir callback  *  * This routine does all the readdir() dirty work.  Even so, the caller must  * supply two callbacks in order to get full compatibility.  *  * If the directory contains static entries, an inode callback must be  * specified.  This avoids having to create every vnode and call VOP_GETATTR()  * when reading the directory.  This function has the following arguments:  *  *	ino_t gfs_inode_cb(vnode_t *vp, int index);  *  * 	vp	- vnode for the directory  * 	index	- index in original gfs_dirent_t array  *  * 	Returns the inode number for the given entry.  *  * For directories with dynamic entries, a readdir callback must be provided.  * This is significantly more complex, thanks to the particulars of  * VOP_READDIR().  *  *	int gfs_readdir_cb(vnode_t *vp, struct dirent64 *dp, int *eofp,  *	    offset_t *off, offset_t *nextoff, void *data)  *  *	vp	- directory vnode  *	dp	- directory entry, sized according to maxlen given to  *		  gfs_dir_create().  callback must fill in d_name and  *		  d_ino.  *	eofp	- callback must set to 1 when EOF has been reached  *	off	- on entry, the last offset read from the directory.  Callback  *		  must set to the offset of the current entry, typically left  *		  untouched.  *	nextoff	- callback must set to offset of next entry.  Typically  *		  (off + 1)  *	data	- caller-supplied data  *  *	Return 0 on success, or error on failure.  */
end_comment

begin_function
name|int
name|gfs_dir_readdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|gfs_readdir_state_t
name|gstate
decl_stmt|;
name|int
name|error
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|ino64_t
name|ino
decl_stmt|,
name|pino
decl_stmt|;
name|offset_t
name|off
decl_stmt|,
name|next
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|ino
operator|=
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_ino
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_parent
operator|==
name|NULL
condition|)
name|pino
operator|=
name|ino
expr_stmt|;
comment|/* root of filesystem */
else|else
name|pino
operator|=
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
operator|(
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_parent
operator|->
name|v_data
operator|)
operator|)
operator|->
name|gfs_ino
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_init
argument_list|(
operator|&
name|gstate
argument_list|,
name|dp
operator|->
name|gfsd_maxlen
argument_list|,
literal|1
argument_list|,
name|uiop
argument_list|,
name|pino
argument_list|,
name|ino
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_pred
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
operator|&
name|off
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|eof
condition|)
block|{
if|if
condition|(
name|off
operator|>=
literal|0
operator|&&
name|off
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|)
block|{
name|ino
operator|=
name|dp
operator|->
name|gfsd_inode
argument_list|(
name|dvp
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
name|off
argument_list|,
name|ino
argument_list|,
name|dp
operator|->
name|gfsd_static
index|[
name|off
index|]
operator|.
name|gfse_name
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|gfsd_readdir
condition|)
block|{
name|off
operator|-=
name|dp
operator|->
name|gfsd_nstatic
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dp
operator|->
name|gfsd_readdir
argument_list|(
name|dvp
argument_list|,
name|gstate
operator|.
name|grd_dirent
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|next
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|eof
condition|)
break|break;
name|off
operator|+=
name|dp
operator|->
name|gfsd_nstatic
operator|+
literal|2
expr_stmt|;
name|next
operator|+=
name|dp
operator|->
name|gfsd_nstatic
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit_int
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
name|next
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* 			 * Offset is beyond the end of the static entries, and 			 * we have no dynamic entries.  Set EOF. 			 */
name|eof
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|gfs_readdir_fini
argument_list|(
operator|&
name|gstate
argument_list|,
name|error
argument_list|,
name|eofp
argument_list|,
name|eof
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_readdir: VOP_READDIR() entry point  *  * For use directly in vnode ops table.  Given a GFS directory, calls  * gfs_dir_readdir() as necessary.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|gfs_vop_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|uio_t
modifier|*
name|uiop
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
modifier|*
name|eofp
init|=
name|ap
operator|->
name|a_eofflag
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
block|{
comment|/* 		 * Minimum entry size is dirent size and 1 byte for a file name. 		 */
name|ncookies
operator|=
name|uiop
operator|->
name|uio_resid
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
operator|)
operator|->
name|d_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|cookies
operator|=
name|malloc
argument_list|(
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
expr_stmt|;
block|}
name|error
operator|=
name|gfs_dir_readdir
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|eofp
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Subtract unused cookies */
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
operator|*
name|ap
operator|->
name|a_ncookies
operator|-=
name|ncookies
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
block|{
name|free
argument_list|(
operator|*
name|ap
operator|->
name|a_cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|NULL
expr_stmt|;
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_inactive: VOP_INACTIVE() entry point  *  * Given a vnode that is a GFS file or directory, call gfs_file_inactive() or  * gfs_dir_inactive() as necessary, and kmem_free()s associated private data.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|gfs_vop_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|gfs_file_t
modifier|*
name|fp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|gfs_type
operator|==
name|GFS_DIR
condition|)
name|data
operator|=
name|gfs_dir_inactive
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|data
operator|=
name|gfs_file_inactive
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|data
argument_list|,
name|fp
operator|->
name|gfs_size
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

