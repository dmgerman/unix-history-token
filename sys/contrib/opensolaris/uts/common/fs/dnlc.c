begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
end_comment

begin_comment
comment|/*	  All Rights Reserved  	*/
end_comment

begin_comment
comment|/*  * University Copyright- Copyright (c) 1982, 1986, 1988  * The Regents of the University of California  * All Rights Reserved  *  * University Acknowledgment- Portions of this document are derived from  * software developed by the University of California, Berkeley, and its  * contributors.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_define
define|#
directive|define
name|TRACE_0
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|TRACE_2
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|TRACE_4
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|dnlc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS namecache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Directory name lookup cache.  * Based on code originally done by Robert Elz at Melbourne.  *  * Names found by directory scans are retained in a cache  * for future reference.  Each hash chain is ordered by LRU  * Cache is indexed by hash value obtained from (vp, name)  * where the vp refers to the directory containing the name.  */
end_comment

begin_comment
comment|/*  * Tunable nc_hashavelen is the average length desired for this chain, from  * which the size of the nc_hash table is derived at create time.  */
end_comment

begin_define
define|#
directive|define
name|NC_HASHAVELEN_DEFAULT
value|4
end_define

begin_decl_stmt
name|int
name|nc_hashavelen
init|=
name|NC_HASHAVELEN_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NC_MOVETOFRONT is the move-to-front threshold: if the hash lookup  * depth exceeds this value, we move the looked-up entry to the front of  * its hash chain.  The idea is to make sure that the most frequently  * accessed entries are found most quickly (by keeping them near the  * front of their hash chains).  */
end_comment

begin_define
define|#
directive|define
name|NC_MOVETOFRONT
value|2
end_define

begin_comment
comment|/*  *  * DNLC_MAX_RELE is used to size an array on the stack when releasing  * vnodes. This array is used rather than calling VN_RELE() inline because  * all dnlc locks must be dropped by that time in order to avoid a  * possible deadlock. This deadlock occurs when the dnlc holds the last  * reference to the vnode and so the VOP_INACTIVE vector is called which  * can in turn call back into the dnlc. A global array was used but had  * many problems:  *	1) Actually doesn't have an upper bound on the array size as  *	   entries can be added after starting the purge.  *	2) The locking scheme causes a hang.  *	3) Caused serialisation on the global lock.  *	4) The array was often unnecessarily huge.  *  * Note the current value 8 allows up to 4 cache entries (to be purged  * from each hash chain), before having to cycle around and retry.  * This ought to be ample given that nc_hashavelen is typically very small.  */
end_comment

begin_define
define|#
directive|define
name|DNLC_MAX_RELE
value|8
end_define

begin_comment
comment|/* must be even */
end_comment

begin_comment
comment|/*  * Hash table of name cache entries for fast lookup, dynamically  * allocated at startup.  */
end_comment

begin_decl_stmt
name|nc_hash_t
modifier|*
name|nc_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rotors. Used to select entries on a round-robin basis.  */
end_comment

begin_decl_stmt
specifier|static
name|nc_hash_t
modifier|*
name|dnlc_purge_fs1_rotor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|nc_hash_t
modifier|*
name|dnlc_free_rotor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * # of dnlc entries (uninitialized)  *  * the initial value was chosen as being  * a random string of bits, probably not  * normally chosen by a systems administrator  */
end_comment

begin_decl_stmt
name|int
name|ncsize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.dnlc.ncsize"
argument_list|,
operator|&
name|ncsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_dnlc
argument_list|,
name|OID_AUTO
argument_list|,
name|ncsize
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ncsize
argument_list|,
literal|0
argument_list|,
literal|"Number of DNLC entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|volatile
name|uint32_t
name|dnlc_nentries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current num of name cache entries */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_dnlc
argument_list|,
name|OID_AUTO
argument_list|,
name|nentries
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DEVOLATILE
argument_list|(
name|u_int
operator|*
argument_list|,
operator|&
name|dnlc_nentries
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of DNLC entries in use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nc_hashsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nc_hashmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table minus 1 */
end_comment

begin_comment
comment|/*  * The dnlc_reduce_cache() taskq queue is activated when there are  * ncsize name cache entries and if no parameter is provided, it reduces  * the size down to dnlc_nentries_low_water, which is by default one  * hundreth less (or 99%) of ncsize.  *  * If a parameter is provided to dnlc_reduce_cache(), then we reduce  * the size down based on ncsize_onepercent - where ncsize_onepercent  * is 1% of ncsize; however, we never let dnlc_reduce_cache() reduce  * the size below 3% of ncsize (ncsize_min_percent).  */
end_comment

begin_define
define|#
directive|define
name|DNLC_LOW_WATER_DIVISOR_DEFAULT
value|100
end_define

begin_decl_stmt
name|uint_t
name|dnlc_low_water_divisor
init|=
name|DNLC_LOW_WATER_DIVISOR_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint_t
name|dnlc_nentries_low_water
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dnlc_reduce_idle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no locking needed */
end_comment

begin_decl_stmt
name|uint_t
name|ncsize_onepercent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint_t
name|ncsize_min_percent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If dnlc_nentries hits dnlc_max_nentries (twice ncsize)  * then this means the dnlc_reduce_cache() taskq is failing to  * keep up. In this case we refuse to add new entries to the dnlc  * until the taskq catches up.  */
end_comment

begin_decl_stmt
name|uint_t
name|dnlc_max_nentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* twice ncsize */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_dnlc
argument_list|,
name|OID_AUTO
argument_list|,
name|max_nentries
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dnlc_max_nentries
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of DNLC entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|dnlc_max_nentries_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistic on times we failed */
end_comment

begin_comment
comment|/*  * Tunable to define when we should just remove items from  * the end of the chain.  */
end_comment

begin_define
define|#
directive|define
name|DNLC_LONG_CHAIN
value|8
end_define

begin_decl_stmt
name|uint_t
name|dnlc_long_chain
init|=
name|DNLC_LONG_CHAIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ncstats has been deprecated, due to the integer size of the counters  * which can easily overflow in the dnlc.  * It is maintained (at some expense) for compatability.  * The preferred interface is the kstat accessible nc_stats below.  */
end_comment

begin_decl_stmt
name|struct
name|ncstats
name|ncstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nc_stats
name|ncs
init|=
block|{
block|{
literal|"hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"negative_cache_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"enters"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"double_enters"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"purge_total_entries"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"purge_all"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"purge_vp"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"purge_vfs"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"purge_fs1"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"pick_free"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"pick_heuristic"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"pick_last"
block|,
name|KSTAT_DATA_UINT64
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doingcache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.dnlc.enable"
argument_list|,
operator|&
name|doingcache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_dnlc
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|doingcache
argument_list|,
literal|0
argument_list|,
literal|"Enable/disable name cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vnode_t
name|negative_cache_vnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Insert entry at the front of the queue  */
end_comment

begin_define
define|#
directive|define
name|nc_inshash
parameter_list|(
name|ncp
parameter_list|,
name|hp
parameter_list|)
define|\
value|{ \ 	(ncp)->hash_next = (hp)->hash_next; \ 	(ncp)->hash_prev = (ncache_t *)(hp); \ 	(hp)->hash_next->hash_prev = (ncp); \ 	(hp)->hash_next = (ncp); \ }
end_define

begin_comment
comment|/*  * Remove entry from hash queue  */
end_comment

begin_define
define|#
directive|define
name|nc_rmhash
parameter_list|(
name|ncp
parameter_list|)
define|\
value|{ \ 	(ncp)->hash_prev->hash_next = (ncp)->hash_next; \ 	(ncp)->hash_next->hash_prev = (ncp)->hash_prev; \ 	(ncp)->hash_prev = NULL; \ 	(ncp)->hash_next = NULL; \ }
end_define

begin_comment
comment|/*  * Free an entry.  */
end_comment

begin_define
define|#
directive|define
name|dnlc_free
parameter_list|(
name|ncp
parameter_list|)
define|\
value|{ \ 	kmem_free((ncp), sizeof (ncache_t) + (ncp)->namlen); \ 	atomic_add_32(&dnlc_nentries, -1); \ }
end_define

begin_comment
comment|/*  * Cached directory info.  * ======================  */
end_comment

begin_comment
comment|/*  * Cached directory free space hash function.  * Needs the free space handle and the dcp to get the hash table size  * Returns the hash index.  */
end_comment

begin_define
define|#
directive|define
name|DDFHASH
parameter_list|(
name|handle
parameter_list|,
name|dcp
parameter_list|)
value|((handle>> 2)& (dcp)->dc_fhash_mask)
end_define

begin_comment
comment|/*  * Cached directory name entry hash function.  * Uses the name and returns in the input arguments the hash and the name  * length.  */
end_comment

begin_define
define|#
directive|define
name|DNLC_DIR_HASH
parameter_list|(
name|name
parameter_list|,
name|hash
parameter_list|,
name|namelen
parameter_list|)
define|\
value|{							\ 		char Xc, *Xcp;					\ 		hash = *name;					\ 		for (Xcp = (name + 1); (Xc = *Xcp) != 0; Xcp++)	\ 			hash = (hash<< 4) + hash + Xc;		\ 		ASSERT((Xcp - (name))<= ((1<< NBBY) - 1));	\ 		namelen = Xcp - (name);				\ 	}
end_define

begin_comment
comment|/* special dircache_t pointer to indicate error should be returned */
end_comment

begin_comment
comment|/*  * The anchor directory cache pointer can contain 3 types of values,  * 1) NULL: No directory cache  * 2) DC_RET_LOW_MEM (-1): There was a directory cache that found to be  *    too big or a memory shortage occurred. This value remains in the  *    pointer until a dnlc_dir_start() which returns the a DNOMEM error.  *    This is kludgy but efficient and only visible in this source file.  * 3) A valid cache pointer.  */
end_comment

begin_define
define|#
directive|define
name|DC_RET_LOW_MEM
value|(dircache_t *)1
end_define

begin_define
define|#
directive|define
name|VALID_DIR_CACHE
parameter_list|(
name|dcp
parameter_list|)
value|((dircache_t *)(dcp)> DC_RET_LOW_MEM)
end_define

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|ncache_t
modifier|*
name|dnlc_get
parameter_list|(
name|uchar_t
name|namlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ncache_t
modifier|*
name|dnlc_search
parameter_list|(
name|vnode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
name|namlen
parameter_list|,
name|int
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_dnlc_reduce_cache
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dnlc_lowvnodes
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|int
name|nvnodes
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kstat_t
modifier|*
name|dnlc_ksp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dnlc_event_lowvnodes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the directory cache.  */
end_comment

begin_function
specifier|static
name|void
name|dnlc_init
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Set up the size of the dnlc (ncsize) and its low water mark. 	 */
if|if
condition|(
name|ncsize
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* calculate a reasonable size for the low water */
name|dnlc_nentries_low_water
operator|=
operator|(
name|desiredvnodes
operator|*
literal|49
operator|)
operator|/
literal|100
expr_stmt|;
name|ncsize
operator|=
name|dnlc_nentries_low_water
operator|+
operator|(
name|dnlc_nentries_low_water
operator|/
name|dnlc_low_water_divisor
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* don't change the user specified ncsize */
name|dnlc_nentries_low_water
operator|=
name|ncsize
operator|-
operator|(
name|ncsize
operator|/
name|dnlc_low_water_divisor
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ncsize
operator|<=
literal|0
condition|)
block|{
name|doingcache
operator|=
literal|0
expr_stmt|;
name|ncsize
operator|=
literal|0
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"name cache (dnlc) disabled"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnlc_max_nentries
operator|=
name|ncsize
operator|*
literal|2
expr_stmt|;
name|ncsize_onepercent
operator|=
name|ncsize
operator|/
literal|100
expr_stmt|;
name|ncsize_min_percent
operator|=
name|ncsize_onepercent
operator|*
literal|3
expr_stmt|;
comment|/* 	 * Initialise the hash table. 	 * Compute hash size rounding to the next power of two. 	 */
name|nc_hashsz
operator|=
name|ncsize
operator|/
name|nc_hashavelen
expr_stmt|;
name|nc_hashsz
operator|=
literal|1
operator|<<
name|highbit
argument_list|(
name|nc_hashsz
argument_list|)
expr_stmt|;
name|nc_hashmask
operator|=
name|nc_hashsz
operator|-
literal|1
expr_stmt|;
name|nc_hash
operator|=
name|kmem_zalloc
argument_list|(
name|nc_hashsz
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nc_hash
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nc_hashsz
condition|;
name|i
operator|++
control|)
block|{
name|hp
operator|=
operator|(
name|nc_hash_t
operator|*
operator|)
operator|&
name|nc_hash
index|[
name|i
index|]
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hp
operator|->
name|hash_next
operator|=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
expr_stmt|;
name|hp
operator|->
name|hash_prev
operator|=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
expr_stmt|;
block|}
comment|/* 	 * Initialize rotors 	 */
name|dnlc_free_rotor
operator|=
name|dnlc_purge_fs1_rotor
operator|=
operator|&
name|nc_hash
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Initialise the reference count of the negative cache vnode to 1 	 * so that it never goes away (VOP_INACTIVE isn't called on it). 	 */
name|negative_cache_vnode
operator|.
name|v_count
operator|=
literal|1
expr_stmt|;
name|negative_cache_vnode
operator|.
name|v_holdcnt
operator|=
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|negative_cache_vnode
operator|.
name|v_interlock
argument_list|,
literal|"vnode interlock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise kstats - both the old compatability raw kind and 	 * the more extensive named stats. 	 */
name|dnlc_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"dnlcstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|ncs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnlc_ksp
condition|)
block|{
name|dnlc_ksp
operator|->
name|ks_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ncs
expr_stmt|;
name|kstat_install
argument_list|(
name|dnlc_ksp
argument_list|)
expr_stmt|;
block|}
name|dnlc_event_lowvnodes
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vfs_lowvnodes
argument_list|,
name|dnlc_lowvnodes
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnlc_fini
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dnlc_event_lowvnodes
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vfs_lowvnodes
argument_list|,
name|dnlc_event_lowvnodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnlc_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|dnlc_ksp
argument_list|)
expr_stmt|;
name|dnlc_ksp
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|negative_cache_vnode
operator|.
name|v_interlock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nc_hashsz
condition|;
name|i
operator|++
control|)
block|{
name|hp
operator|=
operator|(
name|nc_hash_t
operator|*
operator|)
operator|&
name|nc_hash
index|[
name|i
index|]
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|nc_hash
argument_list|,
name|nc_hashsz
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nc_hash
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the directory cache.  *  * This function is basically identical with  * dnlc_enter().  The difference is that when the  * desired dnlc entry is found, the vnode in the  * ncache is compared with the vnode passed in.  *  * If they are not equal then the ncache is  * updated with the passed in vnode.  Otherwise  * it just frees up the newly allocated dnlc entry.  */
end_comment

begin_function
name|void
name|dnlc_update
parameter_list|(
name|vnode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|ncache_t
modifier|*
name|tcp
decl_stmt|;
name|vnode_t
modifier|*
name|tvp
decl_stmt|;
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|uchar_t
name|namlen
decl_stmt|;
name|TRACE_0
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_ENTER_START
argument_list|,
literal|"dnlc_update_start:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doingcache
condition|)
block|{
name|TRACE_2
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_ENTER_END
argument_list|,
literal|"dnlc_update_end:(%S) %d"
argument_list|,
literal|"not caching"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get a new dnlc entry and initialize it now. 	 * If we fail to get a new entry, call dnlc_remove() to purge 	 * any existing dnlc entry including negative cache (DNLC_NO_VNODE) 	 * entry. 	 * Failure to clear an existing entry could result in false dnlc 	 * lookup (negative/stale entry). 	 */
name|DNLCHASH
argument_list|(
name|name
argument_list|,
name|dp
argument_list|,
name|hash
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ncp
operator|=
name|dnlc_get
argument_list|(
name|namlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dnlc_remove
argument_list|(
name|dp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|ncp
operator|->
name|dp
operator|=
name|dp
expr_stmt|;
name|VN_HOLD
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ncp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|ncp
operator|->
name|name
argument_list|,
name|namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* name and null */
name|ncp
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|hp
operator|=
operator|&
name|nc_hash
index|[
name|hash
operator|&
name|nc_hashmask
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|dnlc_search
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|,
name|hash
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tcp
operator|->
name|vp
operator|!=
name|vp
condition|)
block|{
name|tvp
operator|=
name|tcp
operator|->
name|vp
expr_stmt|;
name|tcp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|ncstats
operator|.
name|enters
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_enters
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|TRACE_2
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_ENTER_END
argument_list|,
literal|"dnlc_update_end:(%S) %d"
argument_list|,
literal|"done"
argument_list|,
name|ncstats
operator|.
name|enters
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ncstats
operator|.
name|dbl_enters
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_dbl_enters
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|TRACE_2
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_ENTER_END
argument_list|,
literal|"dnlc_update_end:(%S) %d"
argument_list|,
literal|"dbl enter"
argument_list|,
name|ncstats
operator|.
name|dbl_enters
argument_list|)
expr_stmt|;
block|}
name|VN_RELE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dnlc_free
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
comment|/* crfree done here */
return|return;
block|}
comment|/* 	 * insert the new entry, since it is not in dnlc yet 	 */
name|nc_inshash
argument_list|(
name|ncp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|ncstats
operator|.
name|enters
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_enters
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|TRACE_2
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_ENTER_END
argument_list|,
literal|"dnlc_update_end:(%S) %d"
argument_list|,
literal|"done"
argument_list|,
name|ncstats
operator|.
name|enters
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a name in the directory name cache.  *  * Return a doubly-held vnode if found: one hold so that it may  * remain in the cache for other users, the other hold so that  * the cache is not re-cycled and the identity of the vnode is  * lost before the caller can use the vnode.  */
end_comment

begin_function
name|vnode_t
modifier|*
name|dnlc_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|hash
decl_stmt|,
name|depth
decl_stmt|;
name|uchar_t
name|namlen
decl_stmt|;
name|TRACE_2
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_LOOKUP_START
argument_list|,
literal|"dnlc_lookup_start:dp %x name %s"
argument_list|,
name|dp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doingcache
condition|)
block|{
name|TRACE_4
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_LOOKUP_END
argument_list|,
literal|"dnlc_lookup_end:%S %d vp %x name %s"
argument_list|,
literal|"not_caching"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DNLCHASH
argument_list|(
name|name
argument_list|,
name|dp
argument_list|,
name|hash
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
name|hp
operator|=
operator|&
name|nc_hash
index|[
name|hash
operator|&
name|nc_hashmask
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|ncp
operator|=
name|hp
operator|->
name|hash_next
init|;
name|ncp
operator|!=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|hash_next
control|)
block|{
if|if
condition|(
name|ncp
operator|->
name|hash
operator|==
name|hash
operator|&&
comment|/* fast signature check */
name|ncp
operator|->
name|dp
operator|==
name|dp
operator|&&
name|ncp
operator|->
name|namlen
operator|==
name|namlen
operator|&&
name|bcmp
argument_list|(
name|ncp
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Move this entry to the head of its hash chain 			 * if it's not already close. 			 */
if|if
condition|(
name|depth
operator|>
name|NC_MOVETOFRONT
condition|)
block|{
name|ncache_t
modifier|*
name|next
init|=
name|ncp
operator|->
name|hash_next
decl_stmt|;
name|ncache_t
modifier|*
name|prev
init|=
name|ncp
operator|->
name|hash_prev
decl_stmt|;
name|prev
operator|->
name|hash_next
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|hash_prev
operator|=
name|prev
expr_stmt|;
name|ncp
operator|->
name|hash_next
operator|=
name|next
operator|=
name|hp
operator|->
name|hash_next
expr_stmt|;
name|ncp
operator|->
name|hash_prev
operator|=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
expr_stmt|;
name|next
operator|->
name|hash_prev
operator|=
name|ncp
expr_stmt|;
name|hp
operator|->
name|hash_next
operator|=
name|ncp
expr_stmt|;
name|ncstats
operator|.
name|move_to_front
operator|++
expr_stmt|;
block|}
comment|/* 			 * Put a hold on the vnode now so its identity 			 * can't change before the caller has a chance to 			 * put a hold on it. 			 */
name|vp
operator|=
name|ncp
operator|->
name|vp
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|ncstats
operator|.
name|hits
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_hits
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|DNLC_NO_VNODE
condition|)
block|{
name|ncs
operator|.
name|ncs_neg_hits
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
block|}
name|TRACE_4
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_LOOKUP_END
argument_list|,
literal|"dnlc_lookup_end:%S %d vp %x name %s"
argument_list|,
literal|"hit"
argument_list|,
name|ncstats
operator|.
name|hits
argument_list|,
name|vp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
name|depth
operator|++
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|ncstats
operator|.
name|misses
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_misses
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|TRACE_4
argument_list|(
name|TR_FAC_NFS
argument_list|,
name|TR_DNLC_LOOKUP_END
argument_list|,
literal|"dnlc_lookup_end:%S %d vp %x name %s"
argument_list|,
literal|"miss"
argument_list|,
name|ncstats
operator|.
name|misses
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry in the directory name cache.  */
end_comment

begin_function
name|void
name|dnlc_remove
parameter_list|(
name|vnode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|uchar_t
name|namlen
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
operator|!
name|doingcache
condition|)
return|return;
name|DNLCHASH
argument_list|(
name|name
argument_list|,
name|dp
argument_list|,
name|hash
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|&
name|nc_hash
index|[
name|hash
operator|&
name|nc_hashmask
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp
operator|=
name|dnlc_search
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|,
name|hash
argument_list|)
condition|)
block|{
comment|/* 		 * Free up the entry 		 */
name|nc_rmhash
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ncp
operator|->
name|vp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ncp
operator|->
name|dp
argument_list|)
expr_stmt|;
name|dnlc_free
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Purge cache entries referencing a vfsp.  Caller supplies a count  * of entries to purge; up to that many will be freed.  A count of  * zero indicates that all such entries should be purged.  Returns  * the number of entries that were purged.  */
end_comment

begin_function
name|int
name|dnlc_purge_vfsp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|nc_hash_t
modifier|*
name|nch
decl_stmt|;
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vnode_t
modifier|*
name|nc_rele
index|[
name|DNLC_MAX_RELE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|doingcache
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ncstats
operator|.
name|purges
operator|++
expr_stmt|;
name|ncs
operator|.
name|ncs_purge_vfs
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
for|for
control|(
name|nch
operator|=
name|nc_hash
init|;
name|nch
operator|<
operator|&
name|nc_hash
index|[
name|nc_hashsz
index|]
condition|;
name|nch
operator|++
control|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|nch
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|ncp
operator|=
name|nch
operator|->
name|hash_next
expr_stmt|;
while|while
condition|(
name|ncp
operator|!=
operator|(
name|ncache_t
operator|*
operator|)
name|nch
condition|)
block|{
name|ncache_t
modifier|*
name|np
decl_stmt|;
name|np
operator|=
name|ncp
operator|->
name|hash_next
expr_stmt|;
name|ASSERT
argument_list|(
name|ncp
operator|->
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ncp
operator|->
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ncp
operator|->
name|dp
operator|->
name|v_vfsp
operator|==
name|vfsp
operator|)
operator|||
operator|(
name|ncp
operator|->
name|vp
operator|->
name|v_vfsp
operator|==
name|vfsp
operator|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|nc_rele
index|[
name|index
operator|++
index|]
operator|=
name|ncp
operator|->
name|vp
expr_stmt|;
name|nc_rele
index|[
name|index
operator|++
index|]
operator|=
name|ncp
operator|->
name|dp
expr_stmt|;
name|nc_rmhash
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
name|dnlc_free
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
name|ncs
operator|.
name|ncs_purge_total
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|DNLC_MAX_RELE
condition|)
block|{
name|ncp
operator|=
name|np
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
name|n
operator|>=
name|count
condition|)
block|{
break|break;
block|}
block|}
name|ncp
operator|=
name|np
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|nch
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
comment|/* Release holds on all the vnodes now that we have no locks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|VN_RELE
argument_list|(
name|nc_rele
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
name|n
operator|>=
name|count
condition|)
block|{
return|return
operator|(
name|n
operator|)
return|;
block|}
if|if
condition|(
name|ncp
operator|!=
operator|(
name|ncache_t
operator|*
operator|)
name|nch
condition|)
block|{
name|nch
operator|--
expr_stmt|;
comment|/* Do current hash chain again */
block|}
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility routine to search for a cache entry. Return the  * ncache entry if found, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|ncache_t
modifier|*
name|dnlc_search
parameter_list|(
name|vnode_t
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
name|namlen
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|nc_hash_t
modifier|*
name|hp
decl_stmt|;
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|hp
operator|=
operator|&
name|nc_hash
index|[
name|hash
operator|&
name|nc_hashmask
index|]
expr_stmt|;
for|for
control|(
name|ncp
operator|=
name|hp
operator|->
name|hash_next
init|;
name|ncp
operator|!=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|hash_next
control|)
block|{
if|if
condition|(
name|ncp
operator|->
name|hash
operator|==
name|hash
operator|&&
name|ncp
operator|->
name|dp
operator|==
name|dp
operator|&&
name|ncp
operator|->
name|namlen
operator|==
name|namlen
operator|&&
name|bcmp
argument_list|(
name|ncp
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ncp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
operator|(
literal|1
operator|<<
name|NBBY
operator|)
operator|-
literal|1
operator|)
operator|<
operator|(
name|MAXNAMELEN
operator|-
literal|1
operator|)
end_if

begin_error
error|#
directive|error
error|ncache_t name length representation is too small
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dnlc_reduce_cache
parameter_list|(
name|void
modifier|*
name|reduce_percent
parameter_list|)
block|{
if|if
condition|(
name|dnlc_reduce_idle
operator|&&
operator|(
name|dnlc_nentries
operator|>=
name|ncsize
operator|||
name|reduce_percent
operator|)
condition|)
block|{
name|dnlc_reduce_idle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|taskq_dispatch
argument_list|(
name|system_taskq
argument_list|,
name|do_dnlc_reduce_cache
argument_list|,
name|reduce_percent
argument_list|,
name|TQ_NOSLEEP
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|dnlc_reduce_idle
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a new name cache entry.  * If the dnlc_reduce_cache() taskq isn't keeping up with demand, or memory  * is short then just return NULL. If we're over ncsize then kick off a  * thread to free some in use entries down to dnlc_nentries_low_water.  * Caller must initialise all fields except namlen.  * Component names are defined to be less than MAXNAMELEN  * which includes a null.  */
end_comment

begin_function
specifier|static
name|ncache_t
modifier|*
name|dnlc_get
parameter_list|(
name|uchar_t
name|namlen
parameter_list|)
block|{
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
if|if
condition|(
name|dnlc_nentries
operator|>
name|dnlc_max_nentries
condition|)
block|{
name|dnlc_max_nentries_cnt
operator|++
expr_stmt|;
comment|/* keep a statistic */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ncp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ncache_t
argument_list|)
operator|+
name|namlen
argument_list|,
name|KM_NOSLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ncp
operator|->
name|namlen
operator|=
name|namlen
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|dnlc_nentries
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dnlc_reduce_cache
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ncp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Taskq routine to free up name cache entries to reduce the  * cache size to the low water mark if "reduce_percent" is not provided.  * If "reduce_percent" is provided, reduce cache size by  * (ncsize_onepercent * reduce_percent).  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|do_dnlc_reduce_cache
parameter_list|(
name|void
modifier|*
name|reduce_percent
parameter_list|)
block|{
name|nc_hash_t
modifier|*
name|hp
init|=
name|dnlc_free_rotor
decl_stmt|,
modifier|*
name|start_hp
init|=
name|hp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|ncache_t
modifier|*
name|ncp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|uint_t
name|low_water
init|=
name|dnlc_nentries_low_water
decl_stmt|;
if|if
condition|(
name|reduce_percent
condition|)
block|{
name|uint_t
name|reduce_cnt
decl_stmt|;
comment|/* 		 * Never try to reduce the current number 		 * of cache entries below 3% of ncsize. 		 */
if|if
condition|(
name|dnlc_nentries
operator|<=
name|ncsize_min_percent
condition|)
block|{
name|dnlc_reduce_idle
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|reduce_cnt
operator|=
name|ncsize_onepercent
operator|*
operator|(
name|uint_t
operator|)
operator|(
name|uintptr_t
operator|)
name|reduce_percent
expr_stmt|;
if|if
condition|(
name|reduce_cnt
operator|>
name|dnlc_nentries
operator|||
name|dnlc_nentries
operator|-
name|reduce_cnt
operator|<
name|ncsize_min_percent
condition|)
name|low_water
operator|=
name|ncsize_min_percent
expr_stmt|;
else|else
name|low_water
operator|=
name|dnlc_nentries
operator|-
name|reduce_cnt
expr_stmt|;
block|}
do|do
block|{
comment|/* 		 * Find the first non empty hash queue without locking. 		 * Only look at each hash queue once to avoid an infinite loop. 		 */
do|do
block|{
if|if
condition|(
operator|++
name|hp
operator|==
operator|&
name|nc_hash
index|[
name|nc_hashsz
index|]
condition|)
name|hp
operator|=
name|nc_hash
expr_stmt|;
block|}
do|while
condition|(
name|hp
operator|->
name|hash_next
operator|==
operator|(
name|ncache_t
operator|*
operator|)
name|hp
operator|&&
name|hp
operator|!=
name|start_hp
condition|)
do|;
comment|/* return if all hash queues are empty. */
if|if
condition|(
name|hp
operator|->
name|hash_next
operator|==
operator|(
name|ncache_t
operator|*
operator|)
name|hp
condition|)
block|{
name|dnlc_reduce_idle
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|ncp
operator|=
name|hp
operator|->
name|hash_prev
init|;
name|ncp
operator|!=
operator|(
name|ncache_t
operator|*
operator|)
name|hp
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|hash_prev
operator|,
name|cnt
operator|++
control|)
block|{
name|vp
operator|=
name|ncp
operator|->
name|vp
expr_stmt|;
comment|/* 			 * A name cache entry with a reference count 			 * of one is only referenced by the dnlc. 			 * Also negative cache entries are purged first. 			 */
if|if
condition|(
operator|!
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
operator|&&
operator|(
operator|(
name|vp
operator|->
name|v_count
operator|==
literal|1
operator|)
operator|||
operator|(
name|vp
operator|==
name|DNLC_NO_VNODE
operator|)
operator|)
condition|)
block|{
name|ncs
operator|.
name|ncs_pick_heur
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* 			 * Remove from the end of the chain if the 			 * chain is too long 			 */
if|if
condition|(
name|cnt
operator|>
name|dnlc_long_chain
condition|)
block|{
name|ncp
operator|=
name|hp
operator|->
name|hash_prev
expr_stmt|;
name|ncs
operator|.
name|ncs_pick_last
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|vp
operator|=
name|ncp
operator|->
name|vp
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* check for race and continue */
if|if
condition|(
name|hp
operator|->
name|hash_next
operator|==
operator|(
name|ncache_t
operator|*
operator|)
name|hp
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ncp
operator|=
name|hp
operator|->
name|hash_prev
expr_stmt|;
comment|/* pick the last one in the hash queue */
name|ncs
operator|.
name|ncs_pick_last
operator|.
name|value
operator|.
name|ui64
operator|++
expr_stmt|;
name|vp
operator|=
name|ncp
operator|->
name|vp
expr_stmt|;
name|found
label|:
comment|/* 		 * Remove from hash chain. 		 */
name|nc_rmhash
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hp
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ncp
operator|->
name|dp
argument_list|)
expr_stmt|;
name|dnlc_free
argument_list|(
name|ncp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dnlc_nentries
operator|>
name|low_water
condition|)
do|;
name|dnlc_free_rotor
operator|=
name|hp
expr_stmt|;
name|dnlc_reduce_idle
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnlc_lowvnodes
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|int
name|nvnodes
parameter_list|)
block|{
name|nvnodes
operator|/=
name|ncsize_onepercent
expr_stmt|;
comment|/* Free no less than 5%. */
name|nvnodes
operator|=
name|nvnodes
operator|<
literal|5
operator|*
name|ncsize_onepercent
condition|?
literal|5
operator|*
name|ncsize_onepercent
else|:
name|nvnodes
expr_stmt|;
name|dnlc_reduce_cache
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|nvnodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dnlc
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|dnlc_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|dnlc
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|dnlc_fini
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

