begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * DVA-based Adjustable Replacement Cache  *  * While much of the theory of operation used here is  * based on the self-tuning, low overhead replacement cache  * presented by Megiddo and Modha at FAST 2003, there are some  * significant differences:  *  * 1. The Megiddo and Modha model assumes any page is evictable.  * Pages in its cache cannot be "locked" into memory.  This makes  * the eviction algorithm simple: evict the last page in the list.  * This also make the performance characteristics easy to reason  * about.  Our cache is not so simple.  At any given moment, some  * subset of the blocks in the cache are un-evictable because we  * have handed out a reference to them.  Blocks are only evictable  * when there are no external references active.  This makes  * eviction far more problematic:  we choose to evict the evictable  * blocks that are the "lowest" in the list.  *  * There are times when it is not possible to evict the requested  * space.  In these circumstances we are unable to adjust the cache  * size.  To prevent the cache growing unbounded at these times we  * implement a "cache throttle" that slowes the flow of new data  * into the cache until we can make space avaiable.  *  * 2. The Megiddo and Modha model assumes a fixed cache size.  * Pages are evicted when the cache is full and there is a cache  * miss.  Our model has a variable sized cache.  It grows with  * high use, but also tries to react to memory preasure from the  * operating system: decreasing its size when system memory is  * tight.  *  * 3. The Megiddo and Modha model assumes a fixed page size. All  * elements of the cache are therefor exactly the same size.  So  * when adjusting the cache size following a cache miss, its simply  * a matter of choosing a single page to evict.  In our model, we  * have variable sized cache blocks (rangeing from 512 bytes to  * 128K bytes).  We therefor choose a set of blocks to evict to make  * space for a cache miss that approximates as closely as possible  * the space used by the new block.  *  * See also:  "ARC: A Self-Tuning, Low Overhead Replacement Cache"  * by N. Megiddo& D. Modha, FAST 2003  */
end_comment

begin_comment
comment|/*  * The locking model:  *  * A new reference to a cache buffer can be obtained in two  * ways: 1) via a hash table lookup using the DVA as a key,  * or 2) via one of the ARC lists.  The arc_read() inerface  * uses method 1, while the internal arc algorithms for  * adjusting the cache use method 2.  We therefor provide two  * types of locks: 1) the hash table lock array, and 2) the  * arc list locks.  *  * Buffers do not have their own mutexs, rather they rely on the  * hash table mutexs for the bulk of their protection (i.e. most  * fields in the arc_buf_hdr_t are protected by these mutexs).  *  * buf_hash_find() returns the appropriate mutex (held) when it  * locates the requested buffer in the hash table.  It returns  * NULL for the mutex if the buffer was not in the table.  *  * buf_hash_remove() expects the appropriate hash mutex to be  * already held before it is invoked.  *  * Each arc state also has a mutex which is used to protect the  * buffer list associated with the state.  When attempting to  * obtain a hash table lock while holding an arc list lock you  * must use: mutex_tryenter() to avoid deadlock.  Also note that  * the active state mutex must be held before the ghost state mutex.  *  * Arc buffers may have an associated eviction callback function.  * This function will be invoked prior to removing the buffer (e.g.  * in arc_do_user_evicts()).  Note however that the data associated  * with the buffer may be evicted prior to the callback.  The callback  * must be made with *no locks held* (to prevent deadlock).  Additionally,  * the users of callbacks must ensure that their private data is  * protected from simultaneous callbacks from arc_buf_evict()  * and arc_do_user_evicts().  *  * Note that the majority of the performance stats are manipulated  * with atomic operations.  */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_define
define|#
directive|define
name|ARC_FREE_AT_ONCE
value|4194304
end_define

begin_decl_stmt
specifier|static
name|kmutex_t
name|arc_reclaim_thr_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kcondvar_t
name|arc_reclaim_thr_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to signal reclaim thr */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|arc_thread_exit
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARC_REDUCE_DNLC_PERCENT
value|3
end_define

begin_decl_stmt
name|uint_t
name|arc_reduce_dnlc_percent
init|=
name|ARC_REDUCE_DNLC_PERCENT
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
name|arc_reclaim_strategy
block|{
name|ARC_RECLAIM_AGGR
block|,
comment|/* Aggressive reclaim strategy */
name|ARC_RECLAIM_CONS
comment|/* Conservative reclaim strategy */
block|}
name|arc_reclaim_strategy_t
typedef|;
end_typedef

begin_comment
comment|/* number of seconds before growing cache again */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_grow_retry
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * minimum lifespan of a prefetch block in clock ticks  * (initialized in arc_init())  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_min_prefetch_lifespan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arc_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These tunables are for performance analysis.  */
end_comment

begin_decl_stmt
name|u_long
name|zfs_arc_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|zfs_arc_min
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"vfs.zfs.arc_max"
argument_list|,
operator|&
name|zfs_arc_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"vfs.zfs.arc_min"
argument_list|,
operator|&
name|zfs_arc_min
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_max
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_arc_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum ARC size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_min
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_arc_min
argument_list|,
literal|0
argument_list|,
literal|"Minimum ARC size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Note that buffers can be on one of 5 states:  *	ARC_anon	- anonymous (discussed below)  *	ARC_mru		- recently used, currently cached  *	ARC_mru_ghost	- recentely used, no longer in cache  *	ARC_mfu		- frequently used, currently cached  *	ARC_mfu_ghost	- frequently used, no longer in cache  * When there are no active references to the buffer, they  * are linked onto one of the lists in arc.  These are the  * only buffers that can be evicted or deleted.  *  * Anonymous buffers are buffers that are not associated with  * a DVA.  These are buffers that hold dirty block copies  * before they are written to stable storage.  By definition,  * they are "ref'd" and are considered part of arc_mru  * that cannot be freed.  Generally, they will aquire a DVA  * as they are written and migrate onto the arc_mru list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arc_state
block|{
name|list_t
name|arcs_list
decl_stmt|;
comment|/* linked list of evictable buffer in state */
name|uint64_t
name|arcs_lsize
decl_stmt|;
comment|/* total size of buffers in the linked list */
name|uint64_t
name|arcs_size
decl_stmt|;
comment|/* total size of all buffers in this state */
name|kmutex_t
name|arcs_mtx
decl_stmt|;
block|}
name|arc_state_t
typedef|;
end_typedef

begin_comment
comment|/* The 5 states: */
end_comment

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_anon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mru_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mfu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mfu_ghost
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|arc_stats
block|{
name|kstat_named_t
name|arcstat_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_data_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_data_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_metadata_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_metadata_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_data_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_data_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_metadata_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_metadata_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_mru_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mru_ghost_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mfu_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mfu_ghost_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_deleted
decl_stmt|;
name|kstat_named_t
name|arcstat_recycle_miss
decl_stmt|;
name|kstat_named_t
name|arcstat_mutex_miss
decl_stmt|;
name|kstat_named_t
name|arcstat_evict_skip
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_elements
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_elements_max
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_collisions
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_chains
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_chain_max
decl_stmt|;
name|kstat_named_t
name|arcstat_p
decl_stmt|;
name|kstat_named_t
name|arcstat_c
decl_stmt|;
name|kstat_named_t
name|arcstat_c_min
decl_stmt|;
name|kstat_named_t
name|arcstat_c_max
decl_stmt|;
name|kstat_named_t
name|arcstat_size
decl_stmt|;
block|}
name|arc_stats_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arc_stats_t
name|arc_stats
init|=
block|{
block|{
literal|"hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_data_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_data_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_metadata_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_metadata_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_data_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_data_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_metadata_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_metadata_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mru_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mru_ghost_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mfu_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mfu_ghost_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"deleted"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"recycle_miss"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mutex_miss"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"evict_skip"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_elements"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_elements_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_collisions"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_chains"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_chain_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"p"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c_min"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARCSTAT
parameter_list|(
name|stat
parameter_list|)
value|(arc_stats.stat.value.ui64)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_INCR
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
define|\
value|atomic_add_64(&arc_stats.stat.value.ui64, (val));
end_define

begin_define
define|#
directive|define
name|ARCSTAT_BUMP
parameter_list|(
name|stat
parameter_list|)
value|ARCSTAT_INCR(stat, 1)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_BUMPDOWN
parameter_list|(
name|stat
parameter_list|)
value|ARCSTAT_INCR(stat, -1)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_MAX
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
value|{					\ 	uint64_t m;							\ 	while ((val)> (m = arc_stats.stat.value.ui64)&&		\ 	    (m != atomic_cas_64(&arc_stats.stat.value.ui64, m, (val))))	\ 		continue;						\ }
end_define

begin_define
define|#
directive|define
name|ARCSTAT_MAXSTAT
parameter_list|(
name|stat
parameter_list|)
define|\
value|ARCSTAT_MAX(stat##_max, arc_stats.stat.value.ui64)
end_define

begin_comment
comment|/*  * We define a macro to allow ARC hits/misses to be easily broken down by  * two separate conditions, giving a total of four different subtypes for  * each of hits and misses (so eight statistics total).  */
end_comment

begin_define
define|#
directive|define
name|ARCSTAT_CONDSTAT
parameter_list|(
name|cond1
parameter_list|,
name|stat1
parameter_list|,
name|notstat1
parameter_list|,
name|cond2
parameter_list|,
name|stat2
parameter_list|,
name|notstat2
parameter_list|,
name|stat
parameter_list|)
define|\
value|if (cond1) {							\ 		if (cond2) {						\ 			ARCSTAT_BUMP(arcstat_##stat1##_##stat2##_##stat); \ 		} else {						\ 			ARCSTAT_BUMP(arcstat_##stat1##_##notstat2##_##stat); \ 		}							\ 	} else {							\ 		if (cond2) {						\ 			ARCSTAT_BUMP(arcstat_##notstat1##_##stat2##_##stat); \ 		} else {						\ 			ARCSTAT_BUMP(arcstat_##notstat1##_##notstat2##_##stat);\ 		}							\ 	}
end_define

begin_decl_stmt
name|kstat_t
modifier|*
name|arc_ksp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_anon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mru_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mfu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mfu_ghost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * There are several ARC variables that are critical to export as kstats --  * but we don't want to have to grovel around in the kstat whenever we wish to  * manipulate them.  For these variables, we therefore define them to be in  * terms of the statistic variable.  This assures that we are not introducing  * the possibility of inconsistency by having shadow copies of the variables,  * while still allowing the code to be readable.  */
end_comment

begin_define
define|#
directive|define
name|arc_size
value|ARCSTAT(arcstat_size)
end_define

begin_comment
comment|/* actual total arc size */
end_comment

begin_define
define|#
directive|define
name|arc_p
value|ARCSTAT(arcstat_p)
end_define

begin_comment
comment|/* target size of MRU */
end_comment

begin_define
define|#
directive|define
name|arc_c
value|ARCSTAT(arcstat_c)
end_define

begin_comment
comment|/* target size of cache */
end_comment

begin_define
define|#
directive|define
name|arc_c_min
value|ARCSTAT(arcstat_c_min)
end_define

begin_comment
comment|/* min target cache size */
end_comment

begin_define
define|#
directive|define
name|arc_c_max
value|ARCSTAT(arcstat_c_max)
end_define

begin_comment
comment|/* max target cache size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_no_grow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't try to grow cache size */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|arc_tempreserve
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|arc_callback
name|arc_callback_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arc_callback
block|{
name|void
modifier|*
name|acb_private
decl_stmt|;
name|arc_done_func_t
modifier|*
name|acb_done
decl_stmt|;
name|arc_byteswap_func_t
modifier|*
name|acb_byteswap
decl_stmt|;
name|arc_buf_t
modifier|*
name|acb_buf
decl_stmt|;
name|zio_t
modifier|*
name|acb_zio_dummy
decl_stmt|;
name|arc_callback_t
modifier|*
name|acb_next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arc_write_callback
name|arc_write_callback_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arc_write_callback
block|{
name|void
modifier|*
name|awcb_private
decl_stmt|;
name|arc_done_func_t
modifier|*
name|awcb_ready
decl_stmt|;
name|arc_done_func_t
modifier|*
name|awcb_done
decl_stmt|;
name|arc_buf_t
modifier|*
name|awcb_buf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arc_buf_hdr
block|{
comment|/* protected by hash lock */
name|dva_t
name|b_dva
decl_stmt|;
name|uint64_t
name|b_birth
decl_stmt|;
name|uint64_t
name|b_cksum0
decl_stmt|;
name|kmutex_t
name|b_freeze_lock
decl_stmt|;
name|zio_cksum_t
modifier|*
name|b_freeze_cksum
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|b_hash_next
decl_stmt|;
name|arc_buf_t
modifier|*
name|b_buf
decl_stmt|;
name|uint32_t
name|b_flags
decl_stmt|;
name|uint32_t
name|b_datacnt
decl_stmt|;
name|arc_callback_t
modifier|*
name|b_acb
decl_stmt|;
name|kcondvar_t
name|b_cv
decl_stmt|;
comment|/* immutable */
name|arc_buf_contents_t
name|b_type
decl_stmt|;
name|uint64_t
name|b_size
decl_stmt|;
name|spa_t
modifier|*
name|b_spa
decl_stmt|;
comment|/* protected by arc state mutex */
name|arc_state_t
modifier|*
name|b_state
decl_stmt|;
name|list_node_t
name|b_arc_node
decl_stmt|;
comment|/* updated atomically */
name|clock_t
name|b_arc_access
decl_stmt|;
comment|/* self protecting */
name|refcount_t
name|b_refcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|arc_buf_t
modifier|*
name|arc_eviction_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|arc_eviction_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_buf_hdr_t
name|arc_eviction_hdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|arc_get_data_buf
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arc_access
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GHOST_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|((state) == arc_mru_ghost || (state) == arc_mfu_ghost)
end_define

begin_comment
comment|/*  * Private ARC flags.  These flags are private ARC only flags that will show up  * in b_flags in the arc_hdr_buf_t.  Some flags are publicly declared, and can  * be passed in as arc_flags in things like arc_read.  However, these flags  * should never be passed and should only be set by ARC code.  When adding new  * public flags, make sure not to smash the private ones.  */
end_comment

begin_define
define|#
directive|define
name|ARC_IN_HASH_TABLE
value|(1<< 9)
end_define

begin_comment
comment|/* this buffer is hashed */
end_comment

begin_define
define|#
directive|define
name|ARC_IO_IN_PROGRESS
value|(1<< 10)
end_define

begin_comment
comment|/* I/O in progress for buf */
end_comment

begin_define
define|#
directive|define
name|ARC_IO_ERROR
value|(1<< 11)
end_define

begin_comment
comment|/* I/O failed for buf */
end_comment

begin_define
define|#
directive|define
name|ARC_FREED_IN_READ
value|(1<< 12)
end_define

begin_comment
comment|/* buf freed while in read */
end_comment

begin_define
define|#
directive|define
name|ARC_BUF_AVAILABLE
value|(1<< 13)
end_define

begin_comment
comment|/* block not in active use */
end_comment

begin_define
define|#
directive|define
name|ARC_INDIRECT
value|(1<< 14)
end_define

begin_comment
comment|/* this is an indirect block */
end_comment

begin_define
define|#
directive|define
name|HDR_IN_HASH_TABLE
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IN_HASH_TABLE)
end_define

begin_define
define|#
directive|define
name|HDR_IO_IN_PROGRESS
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IO_IN_PROGRESS)
end_define

begin_define
define|#
directive|define
name|HDR_IO_ERROR
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IO_ERROR)
end_define

begin_define
define|#
directive|define
name|HDR_FREED_IN_READ
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_FREED_IN_READ)
end_define

begin_define
define|#
directive|define
name|HDR_BUF_AVAILABLE
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_BUF_AVAILABLE)
end_define

begin_comment
comment|/*  * Hash table routines  */
end_comment

begin_define
define|#
directive|define
name|HT_LOCK_PAD
value|128
end_define

begin_struct
struct|struct
name|ht_lock
block|{
name|kmutex_t
name|ht_lock
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|unsigned
name|char
name|pad
index|[
operator|(
name|HT_LOCK_PAD
operator|-
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
operator|)
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BUF_LOCKS
value|256
end_define

begin_typedef
typedef|typedef
struct|struct
name|buf_hash_table
block|{
name|uint64_t
name|ht_mask
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
modifier|*
name|ht_table
decl_stmt|;
name|struct
name|ht_lock
name|ht_locks
index|[
name|BUF_LOCKS
index|]
decl_stmt|;
block|}
name|buf_hash_table_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|buf_hash_table_t
name|buf_hash_table
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUF_HASH_INDEX
parameter_list|(
name|spa
parameter_list|,
name|dva
parameter_list|,
name|birth
parameter_list|)
define|\
value|(buf_hash(spa, dva, birth)& buf_hash_table.ht_mask)
end_define

begin_define
define|#
directive|define
name|BUF_HASH_LOCK_NTRY
parameter_list|(
name|idx
parameter_list|)
value|(buf_hash_table.ht_locks[idx& (BUF_LOCKS-1)])
end_define

begin_define
define|#
directive|define
name|BUF_HASH_LOCK
parameter_list|(
name|idx
parameter_list|)
value|(&(BUF_HASH_LOCK_NTRY(idx).ht_lock))
end_define

begin_define
define|#
directive|define
name|HDR_LOCK
parameter_list|(
name|buf
parameter_list|)
define|\
value|(BUF_HASH_LOCK(BUF_HASH_INDEX(buf->b_spa,&buf->b_dva, buf->b_birth)))
end_define

begin_decl_stmt
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint64_t
name|buf_hash
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|birth
parameter_list|)
block|{
name|uintptr_t
name|spav
init|=
operator|(
name|uintptr_t
operator|)
name|spa
decl_stmt|;
name|uint8_t
modifier|*
name|vdva
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dva
decl_stmt|;
name|uint64_t
name|crc
init|=
operator|-
literal|1ULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|zfs_crc64_table
index|[
literal|128
index|]
operator|==
name|ZFS_CRC64_POLY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
name|zfs_crc64_table
index|[
operator|(
name|crc
operator|^
name|vdva
index|[
name|i
index|]
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
name|crc
operator|^=
operator|(
name|spav
operator|>>
literal|8
operator|)
operator|^
name|birth
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_EMPTY
parameter_list|(
name|buf
parameter_list|)
define|\
value|((buf)->b_dva.dva_word[0] == 0&&			\ 	(buf)->b_dva.dva_word[1] == 0&&			\ 	(buf)->b_birth == 0)
end_define

begin_define
define|#
directive|define
name|BUF_EQUAL
parameter_list|(
name|spa
parameter_list|,
name|dva
parameter_list|,
name|birth
parameter_list|,
name|buf
parameter_list|)
define|\
value|((buf)->b_dva.dva_word[0] == (dva)->dva_word[0])&&	\ 	((buf)->b_dva.dva_word[1] == (dva)->dva_word[1])&&	\ 	((buf)->b_birth == birth)&& ((buf)->b_spa == spa)
end_define

begin_function
specifier|static
name|arc_buf_hdr_t
modifier|*
name|buf_hash_find
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|birth
parameter_list|,
name|kmutex_t
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|spa
argument_list|,
name|dva
argument_list|,
name|birth
argument_list|)
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|buf
decl_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|buf
operator|->
name|b_hash_next
control|)
block|{
if|if
condition|(
name|BUF_EQUAL
argument_list|(
name|spa
argument_list|,
name|dva
argument_list|,
name|birth
argument_list|,
name|buf
argument_list|)
condition|)
block|{
operator|*
name|lockp
operator|=
name|hash_lock
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
operator|*
name|lockp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert an entry into the hash table.  If there is already an element  * equal to elem in the hash table, then the already existing element  * will be returned and the new element will not be inserted.  * Otherwise returns NULL.  */
end_comment

begin_function
specifier|static
name|arc_buf_hdr_t
modifier|*
name|buf_hash_insert
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|)
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|fbuf
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lockp
operator|=
name|hash_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|fbuf
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|,
name|i
operator|=
literal|0
init|;
name|fbuf
operator|!=
name|NULL
condition|;
name|fbuf
operator|=
name|fbuf
operator|->
name|b_hash_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BUF_EQUAL
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|,
name|fbuf
argument_list|)
condition|)
return|return
operator|(
name|fbuf
operator|)
return|;
block|}
name|buf
operator|->
name|b_hash_next
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
expr_stmt|;
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|=
name|buf
expr_stmt|;
name|buf
operator|->
name|b_flags
operator||=
name|ARC_IN_HASH_TABLE
expr_stmt|;
comment|/* collect some hash table performance data */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_collisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_chains
argument_list|)
expr_stmt|;
name|ARCSTAT_MAX
argument_list|(
name|arcstat_hash_chain_max
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
name|ARCSTAT_MAXSTAT
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_hash_remove
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|fbuf
decl_stmt|,
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|fbuf
operator|=
operator|*
name|bufp
operator|)
operator|!=
name|buf
condition|)
block|{
name|ASSERT
argument_list|(
name|fbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|fbuf
operator|->
name|b_hash_next
expr_stmt|;
block|}
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_hash_next
expr_stmt|;
name|buf
operator|->
name|b_hash_next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IN_HASH_TABLE
expr_stmt|;
comment|/* collect some hash table performance data */
name|ARCSTAT_BUMPDOWN
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|&&
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|->
name|b_hash_next
operator|==
name|NULL
condition|)
name|ARCSTAT_BUMPDOWN
argument_list|(
name|arcstat_hash_chains
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Global data structures and functions for the buf kmem cache.  */
end_comment

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|hdr_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|buf_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|buf_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|kmem_free
argument_list|(
name|buf_hash_table
operator|.
name|ht_table
argument_list|,
operator|(
name|buf_hash_table
operator|.
name|ht_mask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF_LOCKS
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|buf_hash_table
operator|.
name|ht_locks
index|[
name|i
index|]
operator|.
name|ht_lock
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|hdr_cache
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|buf_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Constructor callback - called when the cache is empty  * and a new buf is requested.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|hdr_cons
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|buf
operator|->
name|b_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destructor callback - called when a cached buf is  * no longer required.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|hdr_dest
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim callback -- invoked when memory is low.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|hdr_recl
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dprintf
argument_list|(
literal|"hdr_recl called\n"
argument_list|)
expr_stmt|;
comment|/* 	 * umem calls the reclaim func when we destroy the buf cache, 	 * which is after we do arc_fini(). 	 */
if|if
condition|(
operator|!
name|arc_dead
condition|)
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
modifier|*
name|ct
decl_stmt|;
name|uint64_t
name|hsize
init|=
literal|1ULL
operator|<<
literal|12
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * The hash table is big enough to fill all of physical memory 	 * with an average 64K block size.  The table will take up 	 * totalmem*sizeof(void*)/64K (eg. 128KB/GB with 8-byte pointers). 	 */
while|while
condition|(
name|hsize
operator|*
literal|65536
operator|<
name|physmem
operator|*
name|PAGESIZE
condition|)
name|hsize
operator|<<=
literal|1
expr_stmt|;
name|retry
label|:
name|buf_hash_table
operator|.
name|ht_mask
operator|=
name|hsize
operator|-
literal|1
expr_stmt|;
name|buf_hash_table
operator|.
name|ht_table
operator|=
name|kmem_zalloc
argument_list|(
name|hsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_NOSLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_hash_table
operator|.
name|ht_table
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|hsize
operator|>
operator|(
literal|1ULL
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hsize
operator|>>=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|hdr_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"arc_buf_hdr_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|hdr_cons
argument_list|,
name|hdr_dest
argument_list|,
name|hdr_recl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"arc_buf_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ct
operator|=
name|zfs_crc64_table
operator|+
name|i
operator|,
operator|*
name|ct
operator|=
name|i
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ct
operator|=
operator|(
operator|*
name|ct
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|-
operator|(
operator|*
name|ct
operator|&
literal|1
operator|)
operator|&
name|ZFS_CRC64_POLY
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|buf_hash_table
operator|.
name|ht_locks
index|[
name|i
index|]
operator|.
name|ht_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ARC_MINTIME
value|(hz>>4)
end_define

begin_comment
comment|/* 62 ms */
end_comment

begin_function
specifier|static
name|void
name|arc_cksum_verify
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|zio_cksum_t
name|zc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|==
name|NULL
operator|||
operator|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_ERROR
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|fletcher_2_native
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
operator|*
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|,
name|zc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"buffer modified while frozen!"
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_cksum_compute
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|fletcher_2_native
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_thaw
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|panic
argument_list|(
literal|"modifying non-anon buffer!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_IN_PROGRESS
condition|)
name|panic
argument_list|(
literal|"modifying buffer while i/o in progress!"
argument_list|)
expr_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_freeze
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
operator|||
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|==
name|arc_anon
argument_list|)
expr_stmt|;
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_reference
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|refcount_add
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ab
operator|->
name|b_state
operator|!=
name|arc_anon
operator|)
condition|)
block|{
name|uint64_t
name|delta
init|=
name|ab
operator|->
name|b_size
operator|*
name|ab
operator|->
name|b_datacnt
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|ab
operator|->
name|b_state
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|ab
operator|->
name|b_datacnt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ab
operator|->
name|b_buf
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|delta
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ab
operator|->
name|b_state
operator|->
name|arcs_lsize
argument_list|,
operator|>=
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_lsize
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
comment|/* remove the prefetch flag is we get a reference */
if|if
condition|(
name|ab
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
name|ab
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|remove_reference
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|arc_state_t
modifier|*
name|state
init|=
name|ab
operator|->
name|b_state
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|==
name|arc_anon
operator|||
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|GHOST_STATE
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cnt
operator|=
name|refcount_remove
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|state
operator|!=
name|arc_anon
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|state
operator|->
name|arcs_lsize
argument_list|,
name|ab
operator|->
name|b_size
operator|*
name|ab
operator|->
name|b_datacnt
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|state
operator|->
name|arcs_lsize
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the supplied buffer to the indicated state.  The mutex  * for the buffer must be held by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|arc_change_state
parameter_list|(
name|arc_state_t
modifier|*
name|new_state
parameter_list|,
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|old_state
init|=
name|ab
operator|->
name|b_state
decl_stmt|;
name|int64_t
name|refcnt
init|=
name|refcount_count
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
decl_stmt|;
name|uint64_t
name|from_delta
decl_stmt|,
name|to_delta
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_state
operator|!=
name|old_state
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcnt
operator|==
literal|0
operator|||
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
operator|||
operator|!
name|GHOST_STATE
argument_list|(
name|new_state
argument_list|)
argument_list|)
expr_stmt|;
name|from_delta
operator|=
name|to_delta
operator|=
name|ab
operator|->
name|b_datacnt
operator|*
name|ab
operator|->
name|b_size
expr_stmt|;
comment|/* 	 * If this buffer is evictable, transfer it from the 	 * old state list to the new state list. 	 */
if|if
condition|(
name|refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|old_state
operator|!=
name|arc_anon
condition|)
block|{
name|int
name|use_mutex
init|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_enter
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* 			 * If prefetching out of the ghost cache, 			 * we will have a non-null datacnt. 			 */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|old_state
argument_list|)
operator|&&
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
condition|)
block|{
comment|/* ghost elements have a ghost size */
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|from_delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|old_state
operator|->
name|arcs_lsize
argument_list|,
operator|>=
argument_list|,
name|from_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_lsize
argument_list|,
operator|-
name|from_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_exit
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_state
operator|!=
name|arc_anon
condition|)
block|{
name|int
name|use_mutex
init|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_enter
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* ghost elements have a ghost size */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|new_state
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|to_delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_lsize
argument_list|,
name|to_delta
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|new_state
operator|->
name|arcs_size
operator|+
name|to_delta
argument_list|,
operator|>=
argument_list|,
name|new_state
operator|->
name|arcs_lsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_exit
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
operator|!
name|BUF_EMPTY
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|==
name|arc_anon
operator|&&
name|old_state
operator|!=
name|arc_anon
condition|)
block|{
name|buf_hash_remove
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* adjust state sizes */
if|if
condition|(
name|to_delta
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_size
argument_list|,
name|to_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_delta
condition|)
block|{
name|ASSERT3U
argument_list|(
name|old_state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|from_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_size
argument_list|,
operator|-
name|from_delta
argument_list|)
expr_stmt|;
block|}
name|ab
operator|->
name|b_state
operator|=
name|new_state
expr_stmt|;
block|}
end_function

begin_function
name|arc_buf_t
modifier|*
name|arc_buf_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|arc_buf_contents_t
name|type
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|kmem_cache_alloc
argument_list|(
name|hdr_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_size
operator|=
name|size
expr_stmt|;
name|hdr
operator|->
name|b_type
operator|=
name|type
expr_stmt|;
name|hdr
operator|->
name|b_spa
operator|=
name|spa
expr_stmt|;
name|hdr
operator|->
name|b_state
operator|=
name|arc_anon
expr_stmt|;
name|hdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|hdr
operator|->
name|b_freeze_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arc_buf_t
modifier|*
name|arc_buf_clone
parameter_list|(
name|arc_buf_t
modifier|*
name|from
parameter_list|)
block|{
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|from
operator|->
name|b_hdr
decl_stmt|;
name|uint64_t
name|size
init|=
name|hdr
operator|->
name|b_size
decl_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|hdr
operator|->
name|b_buf
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|from
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_buf_add_ref
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
comment|/* 	 * Check to see if this buffer is currently being evicted via 	 * arc_do_user_evicts(). 	 */
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This buffer is evicted. 		 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|==
name|hdr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hits
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|hits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_buf_destroy
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|boolean_t
name|recycle
parameter_list|,
name|boolean_t
name|all
parameter_list|)
block|{
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
comment|/* free up data associated with the buf */
if|if
condition|(
name|buf
operator|->
name|b_data
condition|)
block|{
name|arc_state_t
modifier|*
name|state
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
decl_stmt|;
name|uint64_t
name|size
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_type
decl_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recycle
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|zio_buf_free
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|zio_data_buf_free
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_arc_node
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|state
operator|->
name|arcs_lsize
argument_list|,
operator|>=
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|state
operator|->
name|arcs_lsize
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|state
operator|->
name|arcs_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|->
name|b_datacnt
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* only remove the buf if requested */
if|if
condition|(
operator|!
name|all
condition|)
return|return;
comment|/* remove the buf from the hdr list */
for|for
control|(
name|bufp
operator|=
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_buf
init|;
operator|*
name|bufp
operator|!=
name|buf
condition|;
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
control|)
continue|continue;
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* clean up the buf */
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_hdr_destroy
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|hdr
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|hdr
operator|->
name|b_buf
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|hdr
operator|->
name|b_buf
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_efunc
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|hdr
operator|->
name|b_buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
operator|&
name|arc_eviction_hdr
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|arc_eviction_list
expr_stmt|;
name|arc_eviction_list
operator|=
name|buf
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_buf_destroy
argument_list|(
name|hdr
operator|->
name|b_buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|hdr
operator|->
name|b_freeze_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_destroy
argument_list|(
operator|&
name|hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_hash_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_acb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|hdr_cache
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_free
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|int
name|hashed
init|=
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
decl_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashed
condition|)
block|{
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
condition|)
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|int
name|destroy_hdr
decl_stmt|;
comment|/* 		 * We are in the middle of an async write.  Don't destroy 		 * this buffer unless the write completes before we finish 		 * decrementing the reference count. 		 */
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_hdr
operator|=
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_hdr
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|HDR_IO_ERROR
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|arc_buf_remove_ref
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|int
name|no_callback
init|=
operator|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
name|arc_buf_free
argument_list|(
name|buf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_callback
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|no_callback
condition|)
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|no_callback
condition|)
block|{
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_buf
operator|==
name|buf
operator|&&
name|buf
operator|->
name|b_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|no_callback
operator|||
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
operator|||
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_callback
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_buf_size
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evict buffers from list until we've removed the specified number of  * bytes.  Move the removed buffers to the appropriate evict state.  * If the recycle flag is set, then attempt to "recycle" a buffer:  * - look for a buffer to evict that is `bytes' long.  * - return the data block from this buffer rather than freeing it.  * This flag is used by callers that are trying to make space for a  * new buffer in a full arc cache.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arc_evict
parameter_list|(
name|arc_state_t
modifier|*
name|state
parameter_list|,
name|int64_t
name|bytes
parameter_list|,
name|boolean_t
name|recycle
parameter_list|,
name|arc_buf_contents_t
name|type
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|evicted_state
decl_stmt|;
name|uint64_t
name|bytes_evicted
init|=
literal|0
decl_stmt|,
name|skipped
init|=
literal|0
decl_stmt|,
name|missed
init|=
literal|0
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
init|=
name|NULL
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|boolean_t
name|have_lock
decl_stmt|;
name|void
modifier|*
name|stolen
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|==
name|arc_mru
operator|||
name|state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
name|evicted_state
operator|=
operator|(
name|state
operator|==
name|arc_mru
operator|)
condition|?
name|arc_mru_ghost
else|:
name|arc_mfu_ghost
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|ab
operator|=
name|list_tail
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* prefetch buffers have a minimum lifespan */
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
operator|||
operator|(
name|ab
operator|->
name|b_flags
operator|&
operator|(
name|ARC_PREFETCH
operator||
name|ARC_INDIRECT
operator|)
operator|&&
name|lbolt
operator|-
name|ab
operator|->
name|b_arc_access
operator|<
name|arc_min_prefetch_lifespan
operator|)
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* "lookahead" for better eviction candidate */
if|if
condition|(
name|recycle
operator|&&
name|ab
operator|->
name|b_size
operator|!=
name|bytes
operator|&&
name|ab_prev
operator|&&
name|ab_prev
operator|->
name|b_size
operator|==
name|bytes
condition|)
continue|continue;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_lock
operator|||
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ab
operator|->
name|b_buf
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|ab
operator|->
name|b_buf
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_data
condition|)
block|{
name|bytes_evicted
operator|+=
name|ab
operator|->
name|b_size
expr_stmt|;
if|if
condition|(
name|recycle
operator|&&
name|ab
operator|->
name|b_type
operator|==
name|type
operator|&&
name|ab
operator|->
name|b_size
operator|==
name|bytes
condition|)
block|{
name|stolen
operator|=
name|buf
operator|->
name|b_data
expr_stmt|;
name|recycle
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|->
name|b_efunc
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|b_data
operator|==
name|stolen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
operator|&
name|arc_eviction_hdr
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|arc_eviction_list
expr_stmt|;
name|arc_eviction_list
operator|=
name|buf
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|b_data
operator|==
name|stolen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|evicted_state
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_flags
operator|=
name|ARC_IN_HASH_TABLE
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|arc__evict
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
condition|)
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
operator|&&
name|bytes_evicted
operator|>=
name|bytes
condition|)
break|break;
block|}
else|else
block|{
name|missed
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_evicted
operator|<
name|bytes
condition|)
name|dprintf
argument_list|(
literal|"only evicted %lld bytes from %x"
argument_list|,
operator|(
name|longlong_t
operator|)
name|bytes_evicted
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped
condition|)
name|ARCSTAT_INCR
argument_list|(
name|arcstat_evict_skip
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|missed
condition|)
name|ARCSTAT_INCR
argument_list|(
name|arcstat_mutex_miss
argument_list|,
name|missed
argument_list|)
expr_stmt|;
return|return
operator|(
name|stolen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove buffers from list until we've removed the specified number of  * bytes.  Destroy the buffers that are removed.  */
end_comment

begin_function
specifier|static
name|void
name|arc_evict_ghost
parameter_list|(
name|arc_state_t
modifier|*
name|state
parameter_list|,
name|int64_t
name|bytes
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|uint64_t
name|bytes_deleted
init|=
literal|0
decl_stmt|;
name|uint64_t
name|bufs_skipped
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|GHOST_STATE
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|top
label|:
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|ab
operator|=
name|list_tail
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_deleted
argument_list|)
expr_stmt|;
name|bytes_deleted
operator|+=
name|ab
operator|->
name|b_size
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|arc__delete
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
operator|&&
name|bytes_deleted
operator|>=
name|bytes
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bufs_skipped
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufs_skipped
condition|)
block|{
name|ARCSTAT_INCR
argument_list|(
name|arcstat_mutex_miss
argument_list|,
name|bufs_skipped
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes_deleted
operator|<
name|bytes
condition|)
name|dprintf
argument_list|(
literal|"only deleted %lld bytes from %p"
argument_list|,
operator|(
name|longlong_t
operator|)
name|bytes_deleted
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_adjust
parameter_list|(
name|void
parameter_list|)
block|{
name|int64_t
name|top_sz
decl_stmt|,
name|mru_over
decl_stmt|,
name|arc_over
decl_stmt|,
name|todelete
decl_stmt|;
name|top_sz
operator|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
expr_stmt|;
if|if
condition|(
name|top_sz
operator|>
name|arc_p
operator|&&
name|arc_mru
operator|->
name|arcs_lsize
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mru
operator|->
name|arcs_lsize
argument_list|,
name|top_sz
operator|-
name|arc_p
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_UNDEF
argument_list|)
expr_stmt|;
name|top_sz
operator|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
expr_stmt|;
block|}
name|mru_over
operator|=
name|top_sz
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|-
name|arc_c
expr_stmt|;
if|if
condition|(
name|mru_over
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|arc_mru_ghost
operator|->
name|arcs_lsize
operator|>
literal|0
condition|)
block|{
name|todelete
operator|=
name|MIN
argument_list|(
name|arc_mru_ghost
operator|->
name|arcs_lsize
argument_list|,
name|mru_over
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mru_ghost
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arc_over
operator|=
name|arc_size
operator|-
name|arc_c
operator|)
operator|>
literal|0
condition|)
block|{
name|int64_t
name|tbl_over
decl_stmt|;
if|if
condition|(
name|arc_mfu
operator|->
name|arcs_lsize
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mfu
operator|->
name|arcs_lsize
argument_list|,
name|arc_over
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_UNDEF
argument_list|)
expr_stmt|;
block|}
name|tbl_over
operator|=
name|arc_size
operator|+
name|arc_mru_ghost
operator|->
name|arcs_lsize
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_lsize
operator|-
name|arc_c
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|tbl_over
operator|>
literal|0
operator|&&
name|arc_mfu_ghost
operator|->
name|arcs_lsize
operator|>
literal|0
condition|)
block|{
name|todelete
operator|=
name|MIN
argument_list|(
name|arc_mfu_ghost
operator|->
name|arcs_lsize
argument_list|,
name|tbl_over
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mfu_ghost
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_do_user_evicts
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|arc_eviction_list
operator|!=
name|NULL
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|arc_eviction_list
decl_stmt|;
name|arc_eviction_list
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_efunc
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|buf
operator|->
name|b_efunc
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush all *evictable* data from the cache.  * NOTE: this will not touch "active" (i.e. referenced) data.  */
end_comment

begin_function
name|void
name|arc_flush
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
argument_list|)
condition|)
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_UNDEF
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
argument_list|)
condition|)
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_UNDEF
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mru_ghost
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mfu_ghost
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_do_user_evicts
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_eviction_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|arc_shrink_shift
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2(fraction of arc to reclaim) */
end_comment

begin_function
name|void
name|arc_shrink
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|arc_c
operator|>
name|arc_c_min
condition|)
block|{
name|uint64_t
name|to_free
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|to_free
operator|=
name|arc_c
operator|>>
name|arc_shrink_shift
expr_stmt|;
else|#
directive|else
name|to_free
operator|=
name|arc_c
operator|>>
name|arc_shrink_shift
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arc_c
operator|>
name|arc_c_min
operator|+
name|to_free
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|arc_c
argument_list|,
operator|-
name|to_free
argument_list|)
expr_stmt|;
else|else
name|arc_c
operator|=
name|arc_c_min
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_p
argument_list|,
operator|-
operator|(
name|arc_p
operator|>>
name|arc_shrink_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_c
operator|>
name|arc_size
condition|)
name|arc_c
operator|=
name|MAX
argument_list|(
name|arc_size
argument_list|,
name|arc_c_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_p
operator|>
name|arc_c
condition|)
name|arc_p
operator|=
operator|(
name|arc_c
operator|>>
literal|1
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_c
operator|>=
name|arc_c_min
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc_size
operator|>
name|arc_c
condition|)
name|arc_adjust
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|zfs_needfree
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|arc_reclaim_needed
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|uint64_t extra;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|zfs_needfree
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
literal|0
comment|/* 	 * check to make sure that swapfs has enough space so that anon 	 * reservations can still succeeed. anon_resvmem() checks that the 	 * availrmem is greater than swapfs_minfree, and the number of reserved 	 * swap pages.  We also add a bit of extra here just to prevent 	 * circumstances from getting really dire. 	 */
block|if (availrmem< swapfs_minfree + swapfs_reserve + extra) 		return (1);
comment|/* 	 * If zio data pages are being allocated out of a separate heap segment, 	 * then check that the size of available vmem for this area remains 	 * above 1/4th free.  This needs to be done when the size of the 	 * non-default segment is smaller than physical memory, so we could 	 * conceivably run out of VA in that segment before running out of 	 * physical memory. 	 */
block|if (zio_arena != NULL) { 		size_t arc_ziosize = 		    btop(vmem_size(zio_arena, VMEM_FREE | VMEM_ALLOC));  		if ((physmem> arc_ziosize)&& 		    (btop(vmem_size(zio_arena, VMEM_FREE))< arc_ziosize>> 2)) 			return (1); 	}
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
comment|/* 	 * If we're on an i386 platform, it's possible that we'll exhaust the 	 * kernel heap space before we ever run out of available physical 	 * memory.  Most checks of the size of the heap_area compare against 	 * tune.t_minarmem, which is the minimum available real memory that we 	 * can have in the system.  However, this is generally fixed at 25 pages 	 * which is so low that it's useless.  In this comparison, we seek to 	 * calculate the total heap-size, and reclaim if more than 3/4ths of the 	 * heap is allocated.  (Or, in the caclulation, if less than 1/4th is 	 * free) 	 */
block|if (btop(vmem_size(heap_arena, VMEM_FREE))< 	    (btop(vmem_size(heap_arena, VMEM_FREE | VMEM_ALLOC))>> 2)) 		return (1);
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|kmem_map
operator|->
name|size
operator|>
operator|(
name|vm_kmem_size
operator|*
literal|3
operator|)
operator|/
literal|4
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|spa_get_random
argument_list|(
literal|100
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_kmem_reap_now
parameter_list|(
name|arc_reclaim_strategy_t
name|strat
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|i
decl_stmt|;
name|kmem_cache_t
modifier|*
name|prev_cache
init|=
name|NULL
decl_stmt|;
name|kmem_cache_t
modifier|*
name|prev_data_cache
init|=
name|NULL
decl_stmt|;
specifier|extern
name|kmem_cache_t
modifier|*
name|zio_buf_cache
index|[]
decl_stmt|;
specifier|extern
name|kmem_cache_t
modifier|*
name|zio_data_buf_cache
index|[]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * First purge some DNLC entries, in case the DNLC is using 	 * up too much memory. 	 */
name|dnlc_reduce_cache
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|arc_reduce_dnlc_percent
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
comment|/* 	 * Reclaim unused memory from all kmem caches. 	 */
name|kmem_reap
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * An agressive reclamation will shrink the cache size as well as 	 * reap free buffers from the arc kmem caches. 	 */
if|if
condition|(
name|strat
operator|==
name|ARC_RECLAIM_AGGR
condition|)
name|arc_shrink
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zio_buf_cache
index|[
name|i
index|]
operator|!=
name|prev_cache
condition|)
block|{
name|prev_cache
operator|=
name|zio_buf_cache
index|[
name|i
index|]
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|zio_buf_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_data_buf_cache
index|[
name|i
index|]
operator|!=
name|prev_data_cache
condition|)
block|{
name|prev_data_cache
operator|=
name|zio_data_buf_cache
index|[
name|i
index|]
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|zio_data_buf_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|kmem_cache_reap_now
argument_list|(
name|buf_cache
argument_list|)
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|hdr_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_reclaim_thread
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|clock_t
name|growtime
init|=
literal|0
decl_stmt|;
name|arc_reclaim_strategy_t
name|last_reclaim
init|=
name|ARC_RECLAIM_CONS
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|arc_thread_exit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
if|if
condition|(
name|arc_no_grow
condition|)
block|{
if|if
condition|(
name|last_reclaim
operator|==
name|ARC_RECLAIM_CONS
condition|)
block|{
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
block|}
else|else
block|{
name|last_reclaim
operator|=
name|ARC_RECLAIM_CONS
expr_stmt|;
block|}
block|}
else|else
block|{
name|arc_no_grow
operator|=
name|TRUE
expr_stmt|;
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
comment|/* reset the growth delay for every reclaim */
name|growtime
operator|=
name|lbolt
operator|+
operator|(
name|arc_grow_retry
operator|*
name|hz
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|growtime
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_needfree
operator|&&
name|last_reclaim
operator|==
name|ARC_RECLAIM_CONS
condition|)
block|{
comment|/* 				 * If zfs_needfree is TRUE our vm_lowmem hook 				 * was called and in that case we must free some 				 * memory, so switch to aggressive mode. 				 */
name|arc_no_grow
operator|=
name|TRUE
expr_stmt|;
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
block|}
name|arc_kmem_reap_now
argument_list|(
name|last_reclaim
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|growtime
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|growtime
operator|-
name|lbolt
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|arc_no_grow
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|zfs_needfree
operator|||
operator|(
literal|2
operator|*
name|arc_c
operator|<
name|arc_size
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
condition|)
name|arc_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc_eviction_list
operator|!=
name|NULL
condition|)
name|arc_do_user_evicts
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
name|zfs_needfree
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|wakeup
argument_list|(
operator|&
name|zfs_needfree
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* block until needed, or one second, whichever is shorter */
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
block|}
name|arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
comment|/* drops arc_reclaim_thr_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adapt arc info given the number of bytes we are trying to add and  * the state that we are comming from.  This function is only called  * when we are adding new content to the cache.  */
end_comment

begin_function
specifier|static
name|void
name|arc_adapt
parameter_list|(
name|int
name|bytes
parameter_list|,
name|arc_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|mult
decl_stmt|;
name|ASSERT
argument_list|(
name|bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Adapt the target size of the MRU list: 	 *	- if we just hit in the MRU ghost list, then increase 	 *	  the target size of the MRU list. 	 *	- if we just hit in the MFU ghost list, then increase 	 *	  the target size of the MFU list by decreasing the 	 *	  target size of the MRU list. 	 */
if|if
condition|(
name|state
operator|==
name|arc_mru_ghost
condition|)
block|{
name|mult
operator|=
operator|(
operator|(
name|arc_mru_ghost
operator|->
name|arcs_size
operator|>=
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
condition|?
literal|1
else|:
operator|(
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|/
name|arc_mru_ghost
operator|->
name|arcs_size
operator|)
operator|)
expr_stmt|;
name|arc_p
operator|=
name|MIN
argument_list|(
name|arc_c
argument_list|,
name|arc_p
operator|+
name|bytes
operator|*
name|mult
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_mfu_ghost
condition|)
block|{
name|mult
operator|=
operator|(
operator|(
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|>=
name|arc_mru_ghost
operator|->
name|arcs_size
operator|)
condition|?
literal|1
else|:
operator|(
name|arc_mru_ghost
operator|->
name|arcs_size
operator|/
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
operator|)
expr_stmt|;
name|arc_p
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
operator|(
name|int64_t
operator|)
name|arc_p
operator|-
name|bytes
operator|*
name|mult
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arc_no_grow
condition|)
return|return;
if|if
condition|(
name|arc_c
operator|>=
name|arc_c_max
condition|)
return|return;
comment|/* 	 * If we're within (2 * maxblocksize) bytes of the target 	 * cache size, increment the target cache size 	 */
if|if
condition|(
name|arc_size
operator|>
name|arc_c
operator|-
operator|(
literal|2ULL
operator|<<
name|SPA_MAXBLOCKSHIFT
operator|)
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|arc_c
argument_list|,
operator|(
name|int64_t
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_c
operator|>
name|arc_c_max
condition|)
name|arc_c
operator|=
name|arc_c_max
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_anon
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|arc_p
argument_list|,
operator|(
name|int64_t
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_p
operator|>
name|arc_c
condition|)
name|arc_p
operator|=
name|arc_c
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the cache has reached its limits and eviction is required  * prior to insert.  */
end_comment

begin_function
specifier|static
name|int
name|arc_evict_needed
parameter_list|()
block|{
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|arc_size
operator|>
name|arc_c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The buffer, supplied as the first argument, needs a data block.  * So, if we are at cache max, determine which cache should be victimized.  * We have the following cases:  *  * 1. Insert for MRU, p> sizeof(arc_anon + arc_mru) ->  * In this situation if we're out of space, but the resident size of the MFU is  * under the limit, victimize the MFU cache to satisfy this insertion request.  *  * 2. Insert for MRU, p<= sizeof(arc_anon + arc_mru) ->  * Here, we've used up all of the available space for the MRU, so we need to  * evict from our own cache instead.  Evict from the set of resident MRU  * entries.  *  * 3. Insert for MFU (c - p)> sizeof(arc_mfu) ->  * c minus p represents the MFU space in the cache, since p is the size of the  * cache that is dedicated to the MRU.  In this situation there's still space on  * the MFU side, so the MRU side needs to be victimized.  *  * 4. Insert for MFU (c - p)< sizeof(arc_mfu) ->  * MFU's resident set is consuming more space than it has been allotted.  In  * this situation, we must victimize our own cache, the MFU, for this insertion.  */
end_comment

begin_function
specifier|static
name|void
name|arc_get_data_buf
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|state
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
decl_stmt|;
name|uint64_t
name|size
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_type
decl_stmt|;
name|arc_adapt
argument_list|(
name|size
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * We have not yet reached cache maximum size, 	 * just allocate a new buffer. 	 */
if|if
condition|(
operator|!
name|arc_evict_needed
argument_list|()
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|buf
operator|->
name|b_data
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we are prefetching from the mfu ghost list, this buffer 	 * will end up on the mru list; so steal space from there. 	 */
if|if
condition|(
name|state
operator|==
name|arc_mfu_ghost
condition|)
name|state
operator|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|?
name|arc_mru
else|:
name|arc_mfu
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_mru_ghost
condition|)
name|state
operator|=
name|arc_mru
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|arc_mru
operator|||
name|state
operator|==
name|arc_anon
condition|)
block|{
name|uint64_t
name|mru_used
init|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
decl_stmt|;
name|state
operator|=
operator|(
name|arc_p
operator|>
name|mru_used
operator|)
condition|?
name|arc_mfu
else|:
name|arc_mru
expr_stmt|;
block|}
else|else
block|{
comment|/* MFU cases */
name|uint64_t
name|mfu_space
init|=
name|arc_c
operator|-
name|arc_p
decl_stmt|;
name|state
operator|=
operator|(
name|mfu_space
operator|>
name|arc_mfu
operator|->
name|arcs_size
operator|)
condition|?
name|arc_mru
else|:
name|arc_mfu
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|buf
operator|->
name|b_data
operator|=
name|arc_evict
argument_list|(
name|state
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|buf
operator|->
name|b_data
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_recycle_miss
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Update the state size.  Note that ghost states have a 	 * "ghost size" and so don't need to be updated. 	 */
if|if
condition|(
operator|!
name|GHOST_STATE
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
argument_list|)
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_lsize
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we are growing the cache, and we are adding anonymous 		 * data, and we have outgrown arc_p, update arc_p 		 */
if|if
condition|(
name|arc_size
operator|<
name|arc_c
operator|&&
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
operator|&&
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
operator|>
name|arc_p
condition|)
name|arc_p
operator|=
name|MIN
argument_list|(
name|arc_c
argument_list|,
name|arc_p
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is called whenever a buffer is accessed.  * NOTE: the hash lock is dropped in this function.  */
end_comment

begin_function
specifier|static
name|void
name|arc_access
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
comment|/* 		 * This buffer is not in the cache, and does not 		 * appear in our "ghost" list.  Add the new buffer 		 * to the MRU state. 		 */
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_arc_access
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mru
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_mru
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mru
condition|)
block|{
comment|/* 		 * If this buffer is here because of a prefetch, then either: 		 * - clear the flag if this is a "referencing" read 		 *   (any subsequent access will bump this into the MFU state). 		 * or 		 * - move the buffer to the head of the list if this is 		 *   another prefetch (to make it less likely to be evicted). 		 */
if|if
condition|(
operator|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_hits
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
return|return;
block|}
comment|/* 		 * This buffer has been "accessed" only once so far, 		 * but it is still in the cache. Move it to the MFU 		 * state. 		 */
if|if
condition|(
name|lbolt
operator|>
name|buf
operator|->
name|b_arc_access
operator|+
name|ARC_MINTIME
condition|)
block|{
comment|/* 			 * More than 125ms have passed since we 			 * instantiated this buffer.  Move it to the 			 * most frequently used state. 			 */
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_mfu
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_hits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mru_ghost
condition|)
block|{
name|arc_state_t
modifier|*
name|new_state
decl_stmt|;
comment|/* 		 * This buffer has been "accessed" recently, but 		 * was evicted from the cache.  Move it to the 		 * MFU state. 		 */
if|if
condition|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
name|new_state
operator|=
name|arc_mru
expr_stmt|;
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|>
literal|0
condition|)
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mru
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_state
operator|=
name|arc_mfu
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
name|arc_change_state
argument_list|(
name|new_state
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_ghost_hits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mfu
condition|)
block|{
comment|/* 		 * This buffer has been accessed more than once and is 		 * still in the cache.  Keep it in the MFU state. 		 * 		 * NOTE: an add_reference() that occurred when we did 		 * the arc_read() will have kicked this off the list. 		 * If it was a prefetch, we will explicitly move it to 		 * the head of the list now. 		 */
if|if
condition|(
operator|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mfu_hits
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mfu_ghost
condition|)
block|{
name|arc_state_t
modifier|*
name|new_state
init|=
name|arc_mfu
decl_stmt|;
comment|/* 		 * This buffer has been accessed more than once but has 		 * been evicted from the cache.  Move it back to the 		 * MFU state. 		 */
if|if
condition|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
comment|/* 			 * This is a prefetch access... 			 * move this block back to the MRU state. 			 */
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_state
operator|=
name|arc_mru
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|lbolt
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|new_state
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mfu_ghost_hits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
literal|"invalid arc state"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* a generic arc_done_func_t which you can use */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|arc_bcopy_func
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bcopy
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|arg
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a generic arc_done_func_t which you can use */
end_comment

begin_function
name|void
name|arc_getbuf_func
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|arc_buf_t
modifier|*
modifier|*
name|bufp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|zio
operator|&&
name|zio
operator|->
name|io_error
condition|)
block|{
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
comment|/* buffer we're assigning to callback */
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_callback_t
modifier|*
name|callback_list
decl_stmt|,
modifier|*
name|acb
decl_stmt|;
name|int
name|freeable
init|=
name|FALSE
decl_stmt|;
name|buf
operator|=
name|zio
operator|->
name|io_private
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
comment|/* 	 * The hdr was inserted into hash-table and removed from lists 	 * prior to starting I/O.  We should find this header, since 	 * it's in the hash table, and it should be legit since it's 	 * not possible to evict it during the I/O.  The only possible 	 * reason for it not to be found is if we were freed during the 	 * read. 	 */
name|found
operator|=
name|buf_hash_find
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
name|hdr
operator|->
name|b_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|found
operator|==
name|NULL
operator|&&
name|HDR_FREED_IN_READ
argument_list|(
name|hdr
argument_list|)
operator|&&
name|hash_lock
operator|==
name|NULL
operator|)
operator|||
operator|(
name|found
operator|==
name|hdr
operator|&&
name|DVA_EQUAL
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* byteswap if necessary */
name|callback_list
operator|=
name|hdr
operator|->
name|b_acb
expr_stmt|;
name|ASSERT
argument_list|(
name|callback_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_SHOULD_BYTESWAP
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|&&
name|callback_list
operator|->
name|acb_byteswap
condition|)
name|callback_list
operator|->
name|acb_byteswap
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* create copies of the data buffer for the callers */
name|abuf
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|callback_list
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|acb_next
control|)
block|{
if|if
condition|(
name|acb
operator|->
name|acb_done
condition|)
block|{
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
name|abuf
operator|=
name|arc_buf_clone
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_buf
operator|=
name|abuf
expr_stmt|;
name|abuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|hdr
operator|->
name|b_acb
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_BUF_AVAILABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|==
name|buf
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|||
name|callback_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
block|{
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_ERROR
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
condition|)
name|buf_hash_remove
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|freeable
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|ECKSUM
condition|)
name|zio
operator|->
name|io_error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 	 * Broadcast before we drop the hash_lock to avoid the possibility 	 * that the hdr (and hence the cv) might be freed before we get to 	 * the cv_broadcast(). 	 */
name|cv_broadcast
argument_list|(
operator|&
name|hdr
operator|->
name|b_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_lock
condition|)
block|{
comment|/* 		 * Only call arc_access on anonymous buffers.  This is because 		 * if we've issued an I/O for an evicted buffer, we've already 		 * called arc_access (to prevent any simultaneous readers from 		 * getting confused). 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This block was freed while we waited for the read to 		 * complete.  It has been removed from the hash table and 		 * moved to the anonymous state (so that it won't show up 		 * in the cache). 		 */
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|freeable
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
block|}
comment|/* execute each callback and free its structure */
while|while
condition|(
operator|(
name|acb
operator|=
name|callback_list
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|acb_done
condition|)
name|acb
operator|->
name|acb_done
argument_list|(
name|zio
argument_list|,
name|acb
operator|->
name|acb_buf
argument_list|,
name|acb
operator|->
name|acb_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_zio_dummy
operator|!=
name|NULL
condition|)
block|{
name|acb
operator|->
name|acb_zio_dummy
operator|->
name|io_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|zio_nowait
argument_list|(
name|acb
operator|->
name|acb_zio_dummy
argument_list|)
expr_stmt|;
block|}
name|callback_list
operator|=
name|acb
operator|->
name|acb_next
expr_stmt|;
name|kmem_free
argument_list|(
name|acb
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freeable
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "Read" the block block at the specified DVA (in bp) via the  * cache.  If the block is found in the cache, invoke the provided  * callback immediately and return.  Note that the `zio' parameter  * in the callback will be NULL in this case, since no IO was  * required.  If the block is not in the cache pass the read request  * on to the spa with a substitute callback function, so that the  * requested block will be added to the cache.  *  * If a read request arrives for a block that has a read in-progress,  * either wait for the in-progress read to complete (and return the  * results); or, if this is a read with a "done" func, add a record  * to the read to invoke the "done" func when the read completes,  * and return; or just return.  *  * arc_read_done() will invoke all the requested "done" functions  * for readers of this block.  */
end_comment

begin_function
name|int
name|arc_read
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_byteswap_func_t
modifier|*
name|swap
parameter_list|,
name|arc_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint32_t
modifier|*
name|arc_flags
parameter_list|,
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|zio_t
modifier|*
name|rzio
decl_stmt|;
name|top
label|:
name|hdr
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|&&
name|hdr
operator|->
name|b_datacnt
operator|>
literal|0
condition|)
block|{
operator|*
name|arc_flags
operator||=
name|ARC_CACHED
expr_stmt|;
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|hdr
operator|->
name|b_cv
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|ASSERT
argument_list|(
operator|*
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|arc_callback_t
modifier|*
name|acb
init|=
name|NULL
decl_stmt|;
name|acb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_done
operator|=
name|done
expr_stmt|;
name|acb
operator|->
name|acb_private
operator|=
name|private
expr_stmt|;
name|acb
operator|->
name|acb_byteswap
operator|=
name|swap
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
name|acb
operator|->
name|acb_zio_dummy
operator|=
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|acb
operator|->
name|acb_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_next
operator|=
name|hdr
operator|->
name|b_acb
expr_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|acb
expr_stmt|;
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
comment|/* 			 * If this block is already in use, create a new 			 * copy of the data so that we will be guaranteed 			 * that arc_release() will always succeed. 			 */
name|buf
operator|=
name|hdr
operator|->
name|b_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_BUF_AVAILABLE
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_BUF_AVAILABLE
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|arc_buf_clone
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
operator|&&
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|arc__hit
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hits
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|hits
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|done
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
name|private
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|arc_callback_t
modifier|*
name|acb
decl_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
comment|/* this block is not in the cache */
name|arc_buf_hdr_t
modifier|*
name|exists
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|BP_GET_BUFC_TYPE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|buf
operator|=
name|arc_buf_alloc
argument_list|(
name|spa
argument_list|,
name|size
argument_list|,
name|private
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
name|hdr
operator|->
name|b_dva
operator|=
operator|*
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
name|bp
operator|->
name|blk_birth
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* somebody beat us to the hash insert */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|private
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
comment|/* restart the IO request */
block|}
comment|/* if this is a prefetch, we don't have a reference */
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_INDIRECT
expr_stmt|;
block|}
else|else
block|{
comment|/* this block is in the ghost cache */
name|ASSERT
argument_list|(
name|GHOST_STATE
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* if this is a prefetch, we don't have a reference */
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
else|else
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_datacnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
block|}
name|acb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_done
operator|=
name|done
expr_stmt|;
name|acb
operator|->
name|acb_private
operator|=
name|private
expr_stmt|;
name|acb
operator|->
name|acb_byteswap
operator|=
name|swap
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_acb
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|acb
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_IN_PROGRESS
expr_stmt|;
comment|/* 		 * If the buffer has been evicted, migrate it to a present state 		 * before issuing the I/O.  Once we drop the hash-table lock, 		 * the header will be marked as I/O in progress and have an 		 * attached buffer.  At this point, anybody who finds this 		 * buffer ought to notice that it's legit but has a pending I/O. 		 */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|)
condition|)
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|hdr
operator|->
name|b_size
argument_list|,
operator|==
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|arc__miss
argument_list|,
name|blkptr_t
operator|*
argument_list|,
name|bp
argument_list|,
name|uint64_t
argument_list|,
name|size
argument_list|,
name|zbookmark_t
operator|*
argument_list|,
name|zb
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_misses
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|misses
argument_list|)
expr_stmt|;
name|rzio
operator|=
name|zio_read
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|,
name|arc_read_done
argument_list|,
name|buf
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
return|return
operator|(
name|zio_wait
argument_list|(
name|rzio
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
operator|*
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|rzio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * arc_read() variant to support pool traversal.  If the block is already  * in the ARC, make a copy of it; otherwise, the caller will do the I/O.  * The idea is that we don't want pool traversal filling up memory, but  * if the ARC already has the data anyway, we shouldn't pay for the I/O.  */
end_comment

begin_function
name|int
name|arc_tryread
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_mtx
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|hdr
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|&&
name|hdr
operator|->
name|b_datacnt
operator|>
literal|0
operator|&&
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|hdr
operator|->
name|b_buf
decl_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|hash_mtx
condition|)
name|mutex_exit
argument_list|(
name|hash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_set_callback
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|arc_evict_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
operator|||
name|func
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|func
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|private
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used by the DMU to let the ARC know that a buffer is  * being evicted, so the ARC should clean up.  If this arc buf  * is not yet in the evicted state, it will be put there.  */
end_comment

begin_function
name|int
name|arc_buf_evict
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We are in arc_do_user_evicts(). 		 */
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We are on the eviction list. 		 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We are already in arc_do_user_evicts(). 			 */
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|arc_buf_t
name|copy
init|=
operator|*
name|buf
decl_stmt|;
comment|/* structure assignment */
comment|/* 			 * Process this buffer now 			 * but let arc_do_user_evicts() do the reaping. 			 */
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|copy
operator|.
name|b_efunc
argument_list|(
operator|&
name|copy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|==
name|hdr
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|<
argument_list|,
name|hdr
operator|->
name|b_datacnt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
comment|/* 	 * Pull this buffer off of the hdr 	 */
name|bufp
operator|=
operator|&
name|hdr
operator|->
name|b_buf
expr_stmt|;
while|while
condition|(
operator|*
name|bufp
operator|!=
name|buf
condition|)
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|==
literal|0
condition|)
block|{
name|arc_state_t
modifier|*
name|old_state
init|=
name|hdr
operator|->
name|b_state
decl_stmt|;
name|arc_state_t
modifier|*
name|evicted_state
decl_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|evicted_state
operator|=
operator|(
name|old_state
operator|==
name|arc_mru
operator|)
condition|?
name|arc_mru_ghost
else|:
name|arc_mfu_ghost
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|evicted_state
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|=
name|ARC_IN_HASH_TABLE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|buf
operator|->
name|b_efunc
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release this buffer from the cache.  This must be done  * after a read and prior to modifying the buffer contents.  * If the buffer has more than one reference, we must make  * make a new hdr for the buffer.  */
end_comment

begin_function
name|void
name|arc_release
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
comment|/* this buffer is not on any list */
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
comment|/* this buffer is already released */
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_thaw
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Do we have more than one buf? 	 */
if|if
condition|(
name|hdr
operator|->
name|b_buf
operator|!=
name|buf
operator|||
name|buf
operator|->
name|b_next
operator|!=
name|NULL
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|nhdr
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|uint64_t
name|blksz
init|=
name|hdr
operator|->
name|b_size
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|hdr
operator|->
name|b_spa
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|hdr
operator|->
name|b_type
decl_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Pull the data off of this buf and attach it to 		 * a new anonymous buf. 		 */
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|hdr
operator|->
name|b_buf
expr_stmt|;
while|while
condition|(
operator|*
name|bufp
operator|!=
name|buf
condition|)
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
operator|*
name|bufp
operator|=
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|ASSERT3U
argument_list|(
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
operator|-
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|hdr
operator|->
name|b_state
operator|->
name|arcs_lsize
argument_list|,
operator|>=
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_lsize
argument_list|,
operator|-
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|b_datacnt
operator|-=
literal|1
expr_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|nhdr
operator|=
name|kmem_cache_alloc
argument_list|(
name|hdr_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|nhdr
operator|->
name|b_size
operator|=
name|blksz
expr_stmt|;
name|nhdr
operator|->
name|b_spa
operator|=
name|spa
expr_stmt|;
name|nhdr
operator|->
name|b_type
operator|=
name|type
expr_stmt|;
name|nhdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|nhdr
operator|->
name|b_state
operator|=
name|arc_anon
expr_stmt|;
name|nhdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|nhdr
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|nhdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
name|nhdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|nhdr
operator|->
name|b_freeze_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|nhdr
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|nhdr
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_size
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|nhdr
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|arc_buf_thaw
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_released
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
operator|&&
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|==
name|arc_anon
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_has_callback
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|b_efunc
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
name|int
name|arc_referenced
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arc_write_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_write_callback_t
modifier|*
name|callback
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
init|=
name|callback
operator|->
name|awcb_buf
decl_stmt|;
if|if
condition|(
name|callback
operator|->
name|awcb_ready
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_ready
argument_list|(
name|zio
argument_list|,
name|buf
argument_list|,
name|callback
operator|->
name|awcb_private
argument_list|)
expr_stmt|;
block|}
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_write_callback_t
modifier|*
name|callback
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
init|=
name|callback
operator|->
name|awcb_buf
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|NULL
expr_stmt|;
comment|/* this buffer is on no lists and is not in the hash table */
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_dva
operator|=
operator|*
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * If the block to be written was all-zero, we may have 	 * compressed it away.  In this case no write was performed 	 * so there will be no dva/birth-date/checksum.  The buffer 	 * must therefor remain anonymous (and uncached). 	 */
if|if
condition|(
operator|!
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|exists
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* 			 * This can only happen if we overwrite for 			 * sync-to-convergence, because we remove 			 * buffers from the hash table when we arc_free(). 			 */
name|ASSERT
argument_list|(
name|DVA_EQUAL
argument_list|(
name|BP_IDENTITY
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|,
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_bp_orig
operator|.
name|blk_birth
argument_list|,
operator|==
argument_list|,
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|exists
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|exists
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|exists
argument_list|)
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|exists
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callback
operator|->
name|awcb_done
operator|==
name|NULL
condition|)
block|{
name|int
name|destroy_hdr
decl_stmt|;
comment|/* 		 * This is an anonymous buffer with no user callback, 		 * destroy it if there are no active references. 		 */
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|destroy_hdr
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_hdr
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
block|}
if|if
condition|(
name|callback
operator|->
name|awcb_done
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_done
argument_list|(
name|zio
argument_list|,
name|buf
argument_list|,
name|callback
operator|->
name|awcb_private
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|callback
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_write_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|arc_write
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|checksum
parameter_list|,
name|int
name|compress
parameter_list|,
name|int
name|ncopies
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|arc_done_func_t
modifier|*
name|ready
parameter_list|,
name|arc_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|arc_write_callback_t
modifier|*
name|callback
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
comment|/* this is a private buffer - no locking required */
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_ERROR
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_IN_PROGRESS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_acb
operator|==
literal|0
argument_list|)
expr_stmt|;
name|callback
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_write_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_ready
operator|=
name|ready
expr_stmt|;
name|callback
operator|->
name|awcb_done
operator|=
name|done
expr_stmt|;
name|callback
operator|->
name|awcb_private
operator|=
name|private
expr_stmt|;
name|callback
operator|->
name|awcb_buf
operator|=
name|buf
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|zio
operator|=
name|zio_write
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|checksum
argument_list|,
name|compress
argument_list|,
name|ncopies
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|,
name|arc_write_ready
argument_list|,
name|arc_write_done
argument_list|,
name|callback
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_free
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|uint32_t
name|arc_flags
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
comment|/* 	 * If this buffer is in the cache, release it, so it 	 * can be re-used. 	 */
name|ab
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The checksum of blocks to free is not always 		 * preserved (eg. on the deadlist).  However, if it is 		 * nonzero, it should match what we have in the cache. 		 */
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|ab
operator|->
name|b_cksum0
operator|==
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
condition|)
block|{
comment|/* 			 * This should only happen when we prefetch. 			 */
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ab
operator|->
name|b_datacnt
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_flags
operator||=
name|ARC_FREED_IN_READ
expr_stmt|;
if|if
condition|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
condition|)
name|buf_hash_remove
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ab
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_deleted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We still have an active reference on this 			 * buffer.  This can happen, e.g., from 			 * dbuf_unoverride(). 			 */
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ab
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|zio
operator|=
name|zio_free
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|done
argument_list|,
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
return|return
operator|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_tempreserve_clear
parameter_list|(
name|uint64_t
name|tempreserve
parameter_list|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|arc_tempreserve
argument_list|,
operator|-
name|tempreserve
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_tempreserve
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_tempreserve_space
parameter_list|(
name|uint64_t
name|tempreserve
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/* 	 * Once in a while, fail for no reason.  Everything should cope. 	 */
if|if
condition|(
name|spa_get_random
argument_list|(
literal|10000
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"forcing random failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tempreserve
operator|>
name|arc_c
operator|/
literal|4
operator|&&
operator|!
name|arc_no_grow
condition|)
name|arc_c
operator|=
name|MIN
argument_list|(
name|arc_c_max
argument_list|,
name|tempreserve
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempreserve
operator|>
name|arc_c
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Throttle writes when the amount of dirty data in the cache 	 * gets too large.  We try to keep the cache less than half full 	 * of dirty blocks so that our sync times don't grow too large. 	 * Note: if two requests come in concurrently, we might let them 	 * both succeed, when one of them should fail.  Not a huge deal. 	 * 	 * XXX The limit should be adjusted dynamically to keep the time 	 * to sync a dataset fixed (around 1-5 seconds?). 	 */
if|if
condition|(
name|tempreserve
operator|+
name|arc_tempreserve
operator|+
name|arc_anon
operator|->
name|arcs_size
operator|>
name|arc_c
operator|/
literal|2
operator|&&
name|arc_tempreserve
operator|+
name|arc_anon
operator|->
name|arcs_size
operator|>
name|arc_c
operator|/
literal|4
condition|)
block|{
name|dprintf
argument_list|(
literal|"failing, arc_tempreserve=%lluK anon=%lluK "
literal|"tempreserve=%lluK arc_c=%lluK\n"
argument_list|,
name|arc_tempreserve
operator|>>
literal|10
argument_list|,
name|arc_anon
operator|->
name|arcs_lsize
operator|>>
literal|10
argument_list|,
name|tempreserve
operator|>>
literal|10
argument_list|,
name|arc_c
operator|>>
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|arc_tempreserve
argument_list|,
name|tempreserve
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|zfs_event_lowmem
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zfs_lowmem
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|int
name|howto
name|__unused
parameter_list|)
block|{
name|zfs_needfree
operator|=
literal|1
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|zfs_needfree
condition|)
name|tsleep
argument_list|(
operator|&
name|zfs_needfree
argument_list|,
literal|0
argument_list|,
literal|"zfs:lowmem"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|arc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Convert seconds to clock ticks */
name|arc_min_prefetch_lifespan
operator|=
literal|1
operator|*
name|hz
expr_stmt|;
comment|/* Start out with 1/8 of all memory */
name|arc_c
operator|=
name|physmem
operator|*
name|PAGESIZE
operator|/
literal|8
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * On architectures where the physical memory can be larger 	 * than the addressable space (intel in 32-bit mode), we may 	 * need to limit the cache to 1/8 of VM size. 	 */
block|arc_c = MIN(arc_c, vmem_size(heap_arena, VMEM_ALLOC | VMEM_FREE) / 8);
endif|#
directive|endif
endif|#
directive|endif
comment|/* set min cache to 1/32 of all memory, or 64MB, whichever is more */
name|arc_c_min
operator|=
name|MAX
argument_list|(
name|arc_c
operator|/
literal|4
argument_list|,
literal|64
operator|<<
literal|20
argument_list|)
expr_stmt|;
comment|/* set max to 3/4 of all memory, or all but 1GB, whichever is more */
if|if
condition|(
name|arc_c
operator|*
literal|8
operator|>=
literal|1
operator|<<
literal|30
condition|)
name|arc_c_max
operator|=
operator|(
name|arc_c
operator|*
literal|8
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
else|else
name|arc_c_max
operator|=
name|arc_c_min
expr_stmt|;
name|arc_c_max
operator|=
name|MAX
argument_list|(
name|arc_c
operator|*
literal|6
argument_list|,
name|arc_c_max
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * Allow the tunables to override our calculations if they are 	 * reasonable (ie. over 64MB) 	 */
if|if
condition|(
name|zfs_arc_max
operator|>
literal|64
operator|<<
literal|20
operator|&&
name|zfs_arc_max
operator|<
name|vm_kmem_size
condition|)
name|arc_c_max
operator|=
name|zfs_arc_max
expr_stmt|;
if|if
condition|(
name|zfs_arc_min
operator|>
literal|64
operator|<<
literal|20
operator|&&
name|zfs_arc_min
operator|<=
name|arc_c_max
condition|)
name|arc_c_min
operator|=
name|zfs_arc_min
expr_stmt|;
endif|#
directive|endif
name|arc_c
operator|=
name|arc_c_max
expr_stmt|;
name|arc_p
operator|=
operator|(
name|arc_c
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* if kmem_flags are set, lets try to use less memory */
if|if
condition|(
name|kmem_debugging
argument_list|()
condition|)
name|arc_c
operator|=
name|arc_c
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|arc_c
operator|<
name|arc_c_min
condition|)
name|arc_c
operator|=
name|arc_c_min
expr_stmt|;
name|zfs_arc_min
operator|=
name|arc_c_min
expr_stmt|;
name|zfs_arc_max
operator|=
name|arc_c_max
expr_stmt|;
name|arc_anon
operator|=
operator|&
name|ARC_anon
expr_stmt|;
name|arc_mru
operator|=
operator|&
name|ARC_mru
expr_stmt|;
name|arc_mru_ghost
operator|=
operator|&
name|ARC_mru_ghost
expr_stmt|;
name|arc_mfu
operator|=
operator|&
name|ARC_mfu
expr_stmt|;
name|arc_mfu_ghost
operator|=
operator|&
name|ARC_mfu_ghost
expr_stmt|;
name|arc_size
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|buf_init
argument_list|()
expr_stmt|;
name|arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|arc_eviction_list
operator|=
name|NULL
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|arc_eviction_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|arc_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"arcstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_ksp
operator|!=
name|NULL
condition|)
block|{
name|arc_ksp
operator|->
name|ks_data
operator|=
operator|&
name|arc_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|arc_ksp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|arc_reclaim_thread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_event_lowmem
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|zfs_lowmem
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arc_dead
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_thread_exit
operator|=
literal|1
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|arc_thread_exit
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_flush
argument_list|()
expr_stmt|;
name|arc_dead
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|arc_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|arc_ksp
argument_list|)
expr_stmt|;
name|arc_ksp
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_destroy
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|buf_fini
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|zfs_event_lowmem
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|zfs_event_lowmem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

