begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * ZFS volume emulation driver.  *  * Makes a DMU object look like a volume of arbitrary size, up to 2^64 bytes.  * Volumes are accessed through the symbolic links named:  *  * /dev/zvol/dsk/<pool_name>/<dataset_name>  * /dev/zvol/rdsk/<pool_name>/<dataset_name>  *  * These links are created by the ZFS-specific devfsadm link generator.  * Volumes are persistent through reboot.  No user command needs to be  * run before opening and using a device.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_decl_stmt
name|struct
name|g_class
name|zfs_zvol_class
init|=
block|{
operator|.
name|name
operator|=
literal|"ZFS::ZVOL"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|zfs_zvol_class
argument_list|,
name|zfs_zvol
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ZVOL_OBJ
value|1ULL
end_define

begin_define
define|#
directive|define
name|ZVOL_ZAP_OBJ
value|2ULL
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|zvol_minors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The in-core state of each volume.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zvol_state
block|{
name|char
name|zv_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* pool/dd name */
name|uint64_t
name|zv_volsize
decl_stmt|;
comment|/* amount of space we advertise */
name|uint64_t
name|zv_volblocksize
decl_stmt|;
comment|/* volume block size */
name|struct
name|g_provider
modifier|*
name|zv_provider
decl_stmt|;
comment|/* GEOM provider */
name|uint8_t
name|zv_min_bs
decl_stmt|;
comment|/* minimum addressable block shift */
name|uint8_t
name|zv_readonly
decl_stmt|;
comment|/* hard readonly; like write-protect */
name|objset_t
modifier|*
name|zv_objset
decl_stmt|;
comment|/* objset handle */
name|uint32_t
name|zv_mode
decl_stmt|;
comment|/* DS_MODE_* flags at open time */
name|uint32_t
name|zv_total_opens
decl_stmt|;
comment|/* total open count */
name|zilog_t
modifier|*
name|zv_zilog
decl_stmt|;
comment|/* ZIL handle */
name|uint64_t
name|zv_txg_assign
decl_stmt|;
comment|/* txg to assign during ZIL replay */
name|znode_t
name|zv_znode
decl_stmt|;
comment|/* for range locking */
name|int
name|zv_state
decl_stmt|;
name|struct
name|bio_queue_head
name|zv_queue
decl_stmt|;
name|struct
name|mtx
name|zv_queue_mtx
decl_stmt|;
comment|/* zv_queue mutex */
block|}
name|zvol_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * zvol maximum transfer in one DMU tx.  */
end_comment

begin_decl_stmt
name|int
name|zvol_maxphys
init|=
name|DMU_MAX_ACCESS
operator|/
literal|2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|zvol_check_volsize
parameter_list|(
name|uint64_t
name|volsize
parameter_list|,
name|uint64_t
name|blocksize
parameter_list|)
block|{
if|if
condition|(
name|volsize
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|volsize
operator|%
name|blocksize
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|volsize
operator|-
literal|1
operator|>
name|SPEC_MAXOFFSET_T
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_check_volblocksize
parameter_list|(
name|uint64_t
name|volblocksize
parameter_list|)
block|{
if|if
condition|(
name|volblocksize
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|volblocksize
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|volblocksize
argument_list|)
condition|)
return|return
operator|(
name|EDOM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_readonly_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
name|zv
operator|->
name|zv_readonly
operator|=
operator|(
name|uint8_t
operator|)
name|newval
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_get_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zvol_state_t
modifier|*
name|zvol_minor_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&zfs_zvol_class.geom
argument_list|,
argument|geom
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&gp->provider
argument_list|,
argument|provider
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|name
operator|+
sizeof|sizeof
argument_list|(
name|ZVOL_DEV_DIR
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pp
operator|->
name|private
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|zv
operator|=
name|pp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pp
operator|->
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acw
operator|>
literal|0
operator|&&
operator|(
name|zv
operator|->
name|zv_readonly
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|zv
operator|->
name|zv_total_opens
operator|+=
name|acr
operator|+
name|acw
operator|+
name|ace
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zvol_log_write() handles synchronous writes using TX_WRITE ZIL transactions.  *  * We store data in the log buffers if it's small enough.  * Otherwise we will later flush the data out via dmu_sync().  */
end_comment

begin_decl_stmt
name|ssize_t
name|zvol_immediate_write_sz
init|=
literal|32768
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zvol_log_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|zv
operator|->
name|zv_volblocksize
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|ssize_t
name|nbytes
init|=
name|MIN
argument_list|(
name|len
argument_list|,
name|blocksize
operator|-
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|)
argument_list|)
decl_stmt|;
name|itx_t
modifier|*
name|itx
init|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
decl_stmt|;
name|itx
operator|->
name|itx_wr_state
operator|=
name|len
operator|>
name|zvol_immediate_write_sz
condition|?
name|WR_INDIRECT
else|:
name|WR_NEED_COPY
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zv
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|nbytes
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
name|off
operator|-
name|P2ALIGN_TYPED
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_itx_assign
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|len
operator|-=
name|nbytes
expr_stmt|;
name|off
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_FLUSH
case|:
name|zv
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|ASSERT
argument_list|(
name|zv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_GETATTR
case|:
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_serve_one
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|,
name|volsize
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|resid
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|reading
decl_stmt|;
name|off
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
name|ASSERT
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There must be no buffer changes when doing a dmu_sync() because 	 * we can't change the data whilst calculating the checksum. 	 * A better approach than a per zvol rwlock would be to lock ranges. 	 */
name|reading
operator|=
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|reading
condition|?
name|RL_READER
else|:
name|RL_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
operator|&&
name|off
operator|<
name|volsize
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|zvol_maxphys
argument_list|)
expr_stmt|;
comment|/* zvol_maxphys per tx */
if|if
condition|(
name|size
operator|>
name|volsize
operator|-
name|off
condition|)
comment|/* don't write past the end */
name|size
operator|=
name|volsize
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|reading
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|off
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_completed
operator|<
name|bp
operator|->
name|bio_length
condition|)
name|bp
operator|->
name|bio_error
operator|=
operator|(
name|off
operator|>
name|volsize
condition|?
name|EINVAL
else|:
name|error
operator|)
expr_stmt|;
comment|/* 	 * XXX: We are devilering here? 	 * Looks like I don't understand something here, but I was sure it was 	 * an async request. 	 */
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|zv
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_state
operator|==
literal|1
condition|)
block|{
name|zv
operator|->
name|zv_state
operator|=
literal|2
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"zvol:io"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
condition|)
block|{
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|UINT64_MAX
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zvol_serve_one
argument_list|(
name|zv
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|zvol_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfs_create_data_t
modifier|*
name|zc
init|=
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|volblocksize
decl_stmt|,
name|volsize
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zc
operator|->
name|zc_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|volsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|zc
operator|->
name|zc_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|volblocksize
argument_list|)
operator|!=
literal|0
condition|)
name|volblocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * These properites must be removed from the list so the generic 	 * property setting step won't apply to them. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove_all
argument_list|(
name|zc
operator|->
name|zc_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|zc
operator|->
name|zc_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|DMU_OT_ZVOL
argument_list|,
name|volblocksize
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|DMU_OT_ZVOL_PROP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replay a TX_WRITE ZIL transaction that didn't get committed  * after a system failure  */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* data follows lr_write_t */
name|uint64_t
name|off
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|len
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zv
operator|->
name|zv_txg_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_err
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback vectors for replaying records.  * Only TX_WRITE is needed for zvol.  */
end_comment

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|zvol_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|zvol_replay_err
block|,
comment|/* 0 no such transaction type */
name|zvol_replay_err
block|,
comment|/* TX_CREATE */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR */
name|zvol_replay_err
block|,
comment|/* TX_MKXATTR */
name|zvol_replay_err
block|,
comment|/* TX_SYMLINK */
name|zvol_replay_err
block|,
comment|/* TX_REMOVE */
name|zvol_replay_err
block|,
comment|/* TX_RMDIR */
name|zvol_replay_err
block|,
comment|/* TX_LINK */
name|zvol_replay_err
block|,
comment|/* TX_RENAME */
name|zvol_replay_write
block|,
comment|/* TX_WRITE */
name|zvol_replay_err
block|,
comment|/* TX_TRUNCATE */
name|zvol_replay_err
block|,
comment|/* TX_SETATTR */
name|zvol_replay_err
block|,
comment|/* TX_ACL */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create a minor node for the specified volume.  */
end_comment

begin_function
name|int
name|zvol_create_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|ds_mode
init|=
name|DS_MODE_PRIMARY
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|!=
literal|0
condition|)
name|ds_mode
operator||=
name|DS_MODE_READONLY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|ds_mode
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|end
goto|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|zfs_zvol_class
argument_list|,
literal|"zfs::zvol::%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|zvol_start
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|zvol_access
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DEV_DIR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|volsize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|zv
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_min_bs
operator|=
name|DEV_BSHIFT
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|pp
expr_stmt|;
name|zv
operator|->
name|zv_volsize
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
name|zv
operator|->
name|zv_mode
operator|=
name|ds_mode
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|zvol_get_data
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|,
name|zfs_range_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|rl_t
argument_list|,
name|r_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get and cache the blocksize */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_volblocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zv
argument_list|,
operator|&
name|zv
operator|->
name|zv_txg_assign
argument_list|,
name|zvol_replay_vector
argument_list|)
expr_stmt|;
comment|/* XXX this should handle the possible i/o error */
name|VERIFY
argument_list|(
name|dsl_prop_register
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|"readonly"
argument_list|,
name|zvol_readonly_changed_cb
argument_list|,
name|zv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|zv
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|"zvol"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|0
expr_stmt|;
name|kthread_create
argument_list|(
name|zvol_worker
argument_list|,
name|zv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"zvol:worker %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|zvol_minors
operator|++
expr_stmt|;
name|end
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove minor node for the specified volume.  */
end_comment

begin_function
name|int
name|zvol_remove_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|"readonly"
argument_list|,
name|zvol_readonly_changed_cb
argument_list|,
name|zv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|zv
operator|->
name|zv_state
operator|!=
literal|2
condition|)
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|0
argument_list|,
literal|"zvol:w"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|pp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|zil_close
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|NULL
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
name|zvol_minors
operator|--
expr_stmt|;
name|end
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_set_volsize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|zvol_check_volsize
argument_list|(
name|volsize
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_readonly
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volsize
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_free_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volsize
argument_list|,
name|DMU_OBJECT_END
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|->
name|mediasize
operator|=
name|volsize
expr_stmt|;
comment|/* XXX: Not supported. */
block|}
name|end
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_set_volblocksize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|volblocksize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_readonly
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_object_set_blocksize
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volblocksize
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOTSUP
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* XXX: Not supported. */
if|#
directive|if
literal|0
block|if (error == 0) 			zv->zv_provider->sectorsize = zc->zc_volblocksize;
endif|#
directive|endif
block|}
name|end
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_get_done
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|vzgd
parameter_list|)
block|{
name|zgd_t
modifier|*
name|zgd
init|=
operator|(
name|zgd_t
operator|*
operator|)
name|vzgd
decl_stmt|;
name|rl_t
modifier|*
name|rl
init|=
name|zgd
operator|->
name|zgd_rl
decl_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|vzgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|zil_add_vdev
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
name|zgd
operator|->
name|zgd_bp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|uint64_t
name|boff
decl_stmt|;
comment|/* block starting offset */
name|int
name|dlen
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
comment|/* length of user data */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
comment|/* immediate write */
return|return
operator|(
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|dlen
argument_list|,
name|buf
argument_list|)
operator|)
return|;
name|zgd
operator|=
operator|(
name|zgd_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
operator|&
name|lr
operator|->
name|lr_blkptr
expr_stmt|;
comment|/* 	 * Lock the range of the block to ensure that when the data is 	 * written out and it's checksum is being calculated that no other 	 * thread can change the block. 	 */
name|boff
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|lr
operator|->
name|lr_offset
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|boff
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|rl
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|db
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zvol_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_add_vdev
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we get EINPROGRESS, then we need to wait for a 	 * write IO initiated by dmu_sync() to complete before 	 * we can release this dbuf.  We will finish everything 	 * up in the zvol_get_done() callback. 	 */
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zvol_minors
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Initialized."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zvol_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Deinitialized."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

