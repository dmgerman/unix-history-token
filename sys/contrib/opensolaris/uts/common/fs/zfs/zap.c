begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file contains the top half of the zfs directory structure  * implementation. The bottom half is in zap_leaf.c.  *  * The zdir is an extendable hash data structure. There is a table of  * pointers to buckets (zap_t->zd_data->zd_leafs). The buckets are  * each a constant size and hold a variable number of directory entries.  * The buckets (aka "leaf nodes") are implemented in zap_leaf.c.  *  * The pointer table holds a power of 2 number of pointers.  * (1<<zap_t->zd_data->zd_phys->zd_prefix_len).  The bucket pointed to  * by the pointer at index i in the table holds entries whose hash value  * has a zd_prefix_len - bit prefix  */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap_leaf.h>
end_include

begin_decl_stmt
name|int
name|fzap_default_block_shift
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 16k blocksize */
end_comment

begin_function_decl
specifier|static
name|void
name|zap_leaf_pageout
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|vl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|zap_allocate_blocks
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|int
name|nblocks
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|fzap_byteswap
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
name|block_type
decl_stmt|;
name|block_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|vbuf
expr_stmt|;
if|if
condition|(
name|block_type
operator|==
name|ZBT_LEAF
operator|||
name|block_type
operator|==
name|BSWAP_64
argument_list|(
name|ZBT_LEAF
argument_list|)
condition|)
name|zap_leaf_byteswap
argument_list|(
name|vbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* it's a ptrtbl block */
name|byteswap_uint64_array
argument_list|(
name|vbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|fzap_upgrade
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zap_phys_t
modifier|*
name|zp
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|zap
operator|->
name|zap_ismicro
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_buf_update_user
argument_list|(
name|zap
operator|->
name|zap_dbuf
argument_list|,
name|zap
argument_list|,
name|zap
argument_list|,
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
argument_list|,
name|zap_evict
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_num_entries_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_block_shift
operator|=
name|highbit
argument_list|(
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|zp
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
expr_stmt|;
comment|/* 	 * explicitly zero it since it might be coming from an 	 * initialized microzap 	 */
name|bzero
argument_list|(
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_data
argument_list|,
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|zp
operator|->
name|zap_block_type
operator|=
name|ZBT_HEADER
expr_stmt|;
name|zp
operator|->
name|zap_magic
operator|=
name|ZAP_MAGIC
expr_stmt|;
name|zp
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|=
name|ZAP_EMBEDDED_PTRTBL_SHIFT
argument_list|(
name|zap
argument_list|)
expr_stmt|;
name|zp
operator|->
name|zap_freeblk
operator|=
literal|2
expr_stmt|;
comment|/* block 1 will be the first leaf */
name|zp
operator|->
name|zap_num_leafs
operator|=
literal|1
expr_stmt|;
name|zp
operator|->
name|zap_num_entries
operator|=
literal|0
expr_stmt|;
name|zp
operator|->
name|zap_salt
operator|=
name|zap
operator|->
name|zap_salt
expr_stmt|;
comment|/* block 1 will be the first leaf */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|zp
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|)
condition|;
name|i
operator|++
control|)
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
name|zap
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* 	 * set up block 1 - the first leaf 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
literal|1
operator|<<
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|l
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_leaf_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_dbuf
operator|=
name|db
expr_stmt|;
name|l
operator|->
name|l_phys
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|zap_leaf_init
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_leaf_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_tryupgradedir
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rw_tryupgrade
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|zap
operator|->
name|zap_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic routines for dealing with the pointer& cookie tables.  */
end_comment

begin_function
specifier|static
name|int
name|zap_table_grow
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_table_phys_t
modifier|*
name|tbl
parameter_list|,
name|void
function_decl|(
modifier|*
name|transfer_func
function_decl|)
parameter_list|(
specifier|const
name|uint64_t
modifier|*
name|src
parameter_list|,
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|int
name|n
parameter_list|)
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|b
decl_stmt|,
name|newblk
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db_old
decl_stmt|,
modifier|*
name|db_new
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|bs
init|=
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
decl_stmt|;
name|int
name|hepb
init|=
literal|1
operator|<<
operator|(
name|bs
operator|-
literal|4
operator|)
decl_stmt|;
comment|/* hepb = half the number of entries in a block */
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tbl
operator|->
name|zt_blk
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tbl
operator|->
name|zt_numblks
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|->
name|zt_nextblk
operator|!=
literal|0
condition|)
block|{
name|newblk
operator|=
name|tbl
operator|->
name|zt_nextblk
expr_stmt|;
block|}
else|else
block|{
name|newblk
operator|=
name|zap_allocate_blocks
argument_list|(
name|zap
argument_list|,
name|tbl
operator|->
name|zt_numblks
operator|*
literal|2
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|zt_nextblk
operator|=
name|newblk
expr_stmt|;
name|ASSERT3U
argument_list|(
name|tbl
operator|->
name|zt_blks_copied
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_prefetch
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|tbl
operator|->
name|zt_blk
operator|<<
name|bs
argument_list|,
name|tbl
operator|->
name|zt_numblks
operator|<<
name|bs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy the ptrtbl from the old to new location. 	 */
name|b
operator|=
name|tbl
operator|->
name|zt_blks_copied
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|tbl
operator|->
name|zt_blk
operator|+
name|b
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db_old
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* first half of entries in old[b] go to new[2*b+0] */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|newblk
operator|+
literal|2
operator|*
name|b
operator|+
literal|0
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db_new
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db_new
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|transfer_func
argument_list|(
name|db_old
operator|->
name|db_data
argument_list|,
name|db_new
operator|->
name|db_data
argument_list|,
name|hepb
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db_new
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* second half of entries in old[b] go to new[2*b+1] */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|newblk
operator|+
literal|2
operator|*
name|b
operator|+
literal|1
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db_new
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db_new
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|transfer_func
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|db_old
operator|->
name|db_data
operator|+
name|hepb
argument_list|,
name|db_new
operator|->
name|db_data
argument_list|,
name|hepb
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db_new
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db_old
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|zt_blks_copied
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|"copied block %llu of %llu\n"
argument_list|,
name|tbl
operator|->
name|zt_blks_copied
argument_list|,
name|tbl
operator|->
name|zt_numblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|->
name|zt_blks_copied
operator|==
name|tbl
operator|->
name|zt_numblks
condition|)
block|{
operator|(
name|void
operator|)
name|dmu_free_range
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|tbl
operator|->
name|zt_blk
operator|<<
name|bs
argument_list|,
name|tbl
operator|->
name|zt_numblks
operator|<<
name|bs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|zt_blk
operator|=
name|newblk
expr_stmt|;
name|tbl
operator|->
name|zt_numblks
operator|*=
literal|2
expr_stmt|;
name|tbl
operator|->
name|zt_shift
operator|++
expr_stmt|;
name|tbl
operator|->
name|zt_nextblk
operator|=
literal|0
expr_stmt|;
name|tbl
operator|->
name|zt_blks_copied
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
literal|"finished; numblocks now %llu (%lluk entries)\n"
argument_list|,
name|tbl
operator|->
name|zt_numblks
argument_list|,
literal|1
operator|<<
operator|(
name|tbl
operator|->
name|zt_shift
operator|-
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_table_store
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_table_phys_t
modifier|*
name|tbl
parameter_list|,
name|uint64_t
name|idx
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|off
decl_stmt|;
name|int
name|bs
init|=
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tbl
operator|->
name|zt_blk
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"storing %llx at index %llx\n"
argument_list|,
name|val
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|blk
operator|=
name|idx
operator|>>
operator|(
name|bs
operator|-
literal|3
operator|)
expr_stmt|;
name|off
operator|=
name|idx
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bs
operator|-
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|tbl
operator|->
name|zt_blk
operator|+
name|blk
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|->
name|zt_nextblk
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|idx2
init|=
name|idx
operator|*
literal|2
decl_stmt|;
name|uint64_t
name|blk2
init|=
name|idx2
operator|>>
operator|(
name|bs
operator|-
literal|3
operator|)
decl_stmt|;
name|uint64_t
name|off2
init|=
name|idx2
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bs
operator|-
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db2
decl_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|tbl
operator|->
name|zt_nextblk
operator|+
name|blk2
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|db2
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|db2
operator|->
name|db_data
operator|)
index|[
name|off2
index|]
operator|=
name|val
expr_stmt|;
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|db2
operator|->
name|db_data
operator|)
index|[
name|off2
operator|+
literal|1
index|]
operator|=
name|val
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db2
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|)
index|[
name|off
index|]
operator|=
name|val
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_table_load
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_table_phys_t
modifier|*
name|tbl
parameter_list|,
name|uint64_t
name|idx
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|)
block|{
name|uint64_t
name|blk
decl_stmt|,
name|off
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|bs
init|=
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|=
name|idx
operator|>>
operator|(
name|bs
operator|-
literal|3
operator|)
expr_stmt|;
name|off
operator|=
name|idx
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bs
operator|-
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|tbl
operator|->
name|zt_blk
operator|+
name|blk
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|*
name|valp
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|)
index|[
name|off
index|]
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|->
name|zt_nextblk
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * read the nextblk for the sake of i/o error checking, 		 * so that zap_table_load() will catch errors for 		 * zap_table_store. 		 */
name|blk
operator|=
operator|(
name|idx
operator|*
literal|2
operator|)
operator|>>
operator|(
name|bs
operator|-
literal|3
operator|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|tbl
operator|->
name|zt_nextblk
operator|+
name|blk
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for growing the ptrtbl.  */
end_comment

begin_function
specifier|static
name|void
name|zap_ptrtbl_transfer
parameter_list|(
specifier|const
name|uint64_t
modifier|*
name|src
parameter_list|,
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|lb
init|=
name|src
index|[
name|i
index|]
decl_stmt|;
name|dst
index|[
literal|2
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|lb
expr_stmt|;
name|dst
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|lb
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zap_grow_ptrtbl
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
comment|/* In case things go horribly wrong. */
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|>=
name|ZAP_HASHBITS
operator|-
literal|2
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We are outgrowing the "embedded" ptrtbl (the one 		 * stored in the header block).  Give it its own entire 		 * block, which will double the size of the ptrtbl. 		 */
name|uint64_t
name|newblk
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db_new
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
argument_list|,
operator|==
argument_list|,
name|ZAP_EMBEDDED_PTRTBL_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newblk
operator|=
name|zap_allocate_blocks
argument_list|(
name|zap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|newblk
operator|<<
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dmu_buf_will_dirty
argument_list|(
name|db_new
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zap_ptrtbl_transfer
argument_list|(
operator|&
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
name|zap
argument_list|,
literal|0
argument_list|)
argument_list|,
name|db_new
operator|->
name|db_data
argument_list|,
literal|1
operator|<<
name|ZAP_EMBEDDED_PTRTBL_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db_new
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
operator|=
name|newblk
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|=
literal|1
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|++
expr_stmt|;
name|ASSERT3U
argument_list|(
literal|1ULL
operator|<<
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
argument_list|,
operator|==
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|<<
operator|(
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
operator|-
literal|3
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|zap_table_grow
argument_list|(
name|zap
argument_list|,
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
argument_list|,
name|zap_ptrtbl_transfer
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zap_increment_num_entries
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|int
name|delta
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|zap
operator|->
name|zap_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_num_entries_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|delta
operator|>
literal|0
operator|||
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_entries
operator|>=
operator|-
name|delta
argument_list|)
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_entries
operator|+=
name|delta
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_num_entries_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zap_allocate_blocks
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|int
name|nblocks
parameter_list|)
block|{
name|uint64_t
name|newblk
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|newblk
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_freeblk
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_freeblk
operator|+=
name|nblocks
expr_stmt|;
return|return
operator|(
name|newblk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zap_leaf_t
modifier|*
name|zap_create_leaf
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|void
modifier|*
name|winner
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_leaf_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_blkid
operator|=
name|zap_allocate_blocks
argument_list|(
name|zap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_dbuf
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|l_phys
operator|=
name|NULL
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|l
operator|->
name|l_blkid
operator|<<
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
operator|->
name|l_dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|winner
operator|=
name|dmu_buf_set_user
argument_list|(
name|l
operator|->
name|l_dbuf
argument_list|,
name|l
argument_list|,
operator|&
name|l
operator|->
name|l_phys
argument_list|,
name|zap_leaf_pageout
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|winner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|l
operator|->
name|l_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zap_leaf_init
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_leafs
operator|++
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_count
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
modifier|*
name|count
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|zap
operator|->
name|zap_ismicro
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_num_entries_mtx
argument_list|)
expr_stmt|;
comment|/* unnecessary */
operator|*
name|count
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_entries
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_num_entries_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for obtaining zap_leaf_t's  */
end_comment

begin_function
name|void
name|zap_put_leaf
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|)
block|{
name|rw_exit
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|l
operator|->
name|l_dbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|_NOTE
argument_list|(
argument|ARGSUSED(
literal|0
argument|)
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|zap_leaf_pageout
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|vl
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
init|=
name|vl
decl_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_leaf_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|zap_leaf_t
modifier|*
name|zap_open_leaf
parameter_list|(
name|uint64_t
name|blkid
parameter_list|,
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|,
modifier|*
name|winner
decl_stmt|;
name|ASSERT
argument_list|(
name|blkid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|l
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_leaf_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_blkid
operator|=
name|blkid
expr_stmt|;
name|l
operator|->
name|l_bs
operator|=
name|highbit
argument_list|(
name|db
operator|->
name|db_size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|l
operator|->
name|l_dbuf
operator|=
name|db
expr_stmt|;
name|l
operator|->
name|l_phys
operator|=
name|NULL
expr_stmt|;
name|winner
operator|=
name|dmu_buf_set_user
argument_list|(
name|db
argument_list|,
name|l
argument_list|,
operator|&
name|l
operator|->
name|l_phys
argument_list|,
name|zap_leaf_pageout
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
operator|!=
name|NULL
condition|)
block|{
comment|/* someone else set it first */
name|zap_leaf_pageout
argument_list|(
name|NULL
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|winner
expr_stmt|;
block|}
comment|/* 	 * lhr_pad was previously used for the next leaf in the leaf 	 * chain.  There should be no chained leafs (as we have removed 	 * support for them). 	 */
name|ASSERT3U
argument_list|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_pad1
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * There should be more hash entries than there can be 	 * chunks to put in the hash table 	 */
name|ASSERT3U
argument_list|(
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
argument_list|,
operator|>
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
operator|/
literal|3
argument_list|)
expr_stmt|;
comment|/* The chunks should begin at the end of the hash table */
name|ASSERT3P
argument_list|(
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|&
name|l
operator|->
name|l_phys
operator|->
name|l_hash
index|[
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* The chunks should end at the end of the block */
name|ASSERT3U
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|l
operator|->
name|l_phys
argument_list|,
operator|==
argument_list|,
name|l
operator|->
name|l_dbuf
operator|->
name|db_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_get_leaf_byblk
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|krw_t
name|lt
parameter_list|,
name|zap_leaf_t
modifier|*
modifier|*
name|lp
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|int
name|bs
init|=
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|blkid
operator|<<
name|bs
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_object
argument_list|,
operator|==
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_offset
argument_list|,
operator|==
argument_list|,
name|blkid
operator|<<
name|bs
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|==
argument_list|,
literal|1
operator|<<
name|bs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|blkid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|l
operator|=
name|dmu_buf_get_user
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|l
operator|=
name|zap_open_leaf
argument_list|(
name|blkid
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|l
operator|->
name|l_rwlock
argument_list|,
name|lt
argument_list|)
expr_stmt|;
comment|/* 	 * Must lock before dirtying, otherwise l->l_phys could change, 	 * causing ASSERT below to fail. 	 */
if|if
condition|(
name|lt
operator|==
name|RW_WRITER
condition|)
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|l
operator|->
name|l_blkid
argument_list|,
operator|==
argument_list|,
name|blkid
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|l
operator|->
name|l_dbuf
argument_list|,
operator|==
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|l
operator|->
name|l_phys
argument_list|,
operator|==
argument_list|,
name|l
operator|->
name|l_dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_block_type
argument_list|,
operator|==
argument_list|,
name|ZBT_LEAF
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_magic
argument_list|,
operator|==
argument_list|,
name|ZAP_LEAF_MAGIC
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_idx_to_blk
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
name|idx
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|idx
argument_list|,
operator|<
argument_list|,
operator|(
literal|1ULL
operator|<<
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|)
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
name|zap
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|zap_table_load
argument_list|(
name|zap
argument_list|,
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
argument_list|,
name|idx
argument_list|,
name|valp
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zap_set_idx_to_blk
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
name|idx
parameter_list|,
name|uint64_t
name|blk
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|tx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
operator|==
literal|0
condition|)
block|{
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
name|zap
argument_list|,
name|idx
argument_list|)
operator|=
name|blk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|zap_table_store
argument_list|(
name|zap
argument_list|,
operator|&
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
argument_list|,
name|idx
argument_list|,
name|blk
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zap_deref_leaf
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
name|h
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|krw_t
name|lt
parameter_list|,
name|zap_leaf_t
modifier|*
modifier|*
name|lp
parameter_list|)
block|{
name|uint64_t
name|idx
decl_stmt|,
name|blk
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|zap
operator|->
name|zap_dbuf
operator|==
name|NULL
operator|||
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|==
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_magic
argument_list|,
operator|==
argument_list|,
name|ZAP_MAGIC
argument_list|)
expr_stmt|;
name|idx
operator|=
name|ZAP_HASH_IDX
argument_list|(
name|h
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_idx_to_blk
argument_list|(
name|zap
argument_list|,
name|idx
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|zap_get_leaf_byblk
argument_list|(
name|zap
argument_list|,
name|blk
argument_list|,
name|tx
argument_list|,
name|lt
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|||
name|ZAP_HASH_IDX
argument_list|(
name|h
argument_list|,
operator|(
operator|*
name|lp
operator|)
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
argument_list|)
operator|==
operator|(
operator|*
name|lp
operator|)
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_expand_leaf
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|hash
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|zap_leaf_t
modifier|*
modifier|*
name|lp
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|nl
decl_stmt|;
name|int
name|prefix_diff
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
name|uint64_t
name|sibling
decl_stmt|;
name|int
name|old_prefix_len
init|=
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
decl_stmt|;
name|ASSERT3U
argument_list|(
name|old_prefix_len
argument_list|,
operator|<=
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ZAP_HASH_IDX
argument_list|(
name|hash
argument_list|,
name|old_prefix_len
argument_list|)
argument_list|,
operator|==
argument_list|,
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_tryupgradedir
argument_list|(
name|zap
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
operator|||
name|old_prefix_len
operator|==
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
condition|)
block|{
comment|/* We failed to upgrade, or need to grow the pointer table */
name|objset_t
modifier|*
name|os
init|=
name|zap
operator|->
name|zap_objset
decl_stmt|;
name|uint64_t
name|object
init|=
name|zap
operator|->
name|zap_object
decl_stmt|;
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|zap_unlockdir
argument_list|(
name|zap
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lockdir
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
name|FALSE
argument_list|,
operator|&
name|zap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT
argument_list|(
operator|!
name|zap
operator|->
name|zap_ismicro
argument_list|)
expr_stmt|;
while|while
condition|(
name|old_prefix_len
operator|==
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
condition|)
block|{
name|err
operator|=
name|zap_grow_ptrtbl
argument_list|(
name|zap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|!=
name|old_prefix_len
condition|)
block|{
comment|/* it split while our locks were down */
operator|*
name|lp
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|old_prefix_len
argument_list|,
operator|<
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ZAP_HASH_IDX
argument_list|(
name|hash
argument_list|,
name|old_prefix_len
argument_list|)
argument_list|,
operator|==
argument_list|,
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix
argument_list|)
expr_stmt|;
name|prefix_diff
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|-
operator|(
name|old_prefix_len
operator|+
literal|1
operator|)
expr_stmt|;
name|sibling
operator|=
operator|(
name|ZAP_HASH_IDX
argument_list|(
name|hash
argument_list|,
name|old_prefix_len
operator|+
literal|1
argument_list|)
operator||
literal|1
operator|)
operator|<<
name|prefix_diff
expr_stmt|;
comment|/* check for i/o errors before doing zap_leaf_split */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1ULL
operator|<<
name|prefix_diff
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|blk
decl_stmt|;
name|err
operator|=
name|zap_idx_to_blk
argument_list|(
name|zap
argument_list|,
name|sibling
operator|+
name|i
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT3U
argument_list|(
name|blk
argument_list|,
operator|==
argument_list|,
name|l
operator|->
name|l_blkid
argument_list|)
expr_stmt|;
block|}
name|nl
operator|=
name|zap_create_leaf
argument_list|(
name|zap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zap_leaf_split
argument_list|(
name|l
argument_list|,
name|nl
argument_list|)
expr_stmt|;
comment|/* set sibling pointers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1ULL
operator|<<
name|prefix_diff
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|zap_set_idx_to_blk
argument_list|(
name|zap
argument_list|,
name|sibling
operator|+
name|i
argument_list|,
name|nl
operator|->
name|l_blkid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we checked for i/o errors above */
block|}
if|if
condition|(
name|hash
operator|&
operator|(
literal|1ULL
operator|<<
operator|(
literal|64
operator|-
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|)
operator|)
condition|)
block|{
comment|/* we want the sibling */
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|nl
expr_stmt|;
block|}
else|else
block|{
name|zap_put_leaf
argument_list|(
name|nl
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|l
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zap_put_leaf_maybe_grow_ptrtbl
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|shift
init|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
decl_stmt|;
name|int
name|leaffull
init|=
operator|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|==
name|shift
operator|&&
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|<
name|ZAP_LEAF_LOW_WATER
operator|)
decl_stmt|;
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaffull
operator|||
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_nextblk
condition|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 		 * We are in the middle of growing the pointer table, or 		 * this leaf will soon make us grow it. 		 */
if|if
condition|(
name|zap_tryupgradedir
argument_list|(
name|zap
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zap
operator|->
name|zap_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|zap
operator|->
name|zap_object
decl_stmt|;
name|zap_unlockdir
argument_list|(
name|zap
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lockdir
argument_list|(
name|os
argument_list|,
name|zapobj
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
name|FALSE
argument_list|,
operator|&
name|zap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return;
block|}
comment|/* could have finished growing while our locks were down */
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|==
name|shift
condition|)
operator|(
name|void
operator|)
name|zap_grow_ptrtbl
argument_list|(
name|zap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fzap_checksize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|)
block|{
if|if
condition|(
name|name
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
name|ZAP_MAXNAMELEN
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
comment|/* Only integer sizes supported by C */
switch|switch
condition|(
name|integer_size
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|integer_size
operator|*
name|num_integers
operator|>
name|ZAP_MAXVALUELEN
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for maniplulating attributes.  */
end_comment

begin_function
name|int
name|fzap_lookup
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|err
operator|=
name|fzap_checksize
argument_list|(
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|hash
operator|=
name|zap_hash
argument_list|(
name|zap
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|NULL
argument_list|,
name|RW_READER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|zap_leaf_lookup
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|zap_entry_read
argument_list|(
operator|&
name|zeh
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_add_cd
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|uint32_t
name|cd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|zap
operator|->
name|zap_ismicro
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fzap_checksize
argument_list|(
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hash
operator|=
name|zap_hash
argument_list|(
name|zap
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry
label|:
name|err
operator|=
name|zap_leaf_lookup
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_entry_create
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|cd
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|val
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|zap_increment_num_entries
argument_list|(
name|zap
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
block|{
name|err
operator|=
name|zap_expand_leaf
argument_list|(
name|zap
argument_list|,
name|l
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
name|out
label|:
name|zap_put_leaf_maybe_grow_ptrtbl
argument_list|(
name|zap
argument_list|,
name|l
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_add
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
init|=
name|fzap_checksize
argument_list|(
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|fzap_add_cd
argument_list|(
name|zap
argument_list|,
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|val
argument_list|,
name|ZAP_MAXCD
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_update
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|int
name|err
decl_stmt|,
name|create
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zap
operator|->
name|zap_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fzap_checksize
argument_list|(
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|hash
operator|=
name|zap_hash
argument_list|(
name|zap
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry
label|:
name|err
operator|=
name|zap_leaf_lookup
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
name|create
operator|=
operator|(
name|err
operator|==
name|ENOENT
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* XXX If this leaf is chained, split it if we can. */
if|if
condition|(
name|create
condition|)
block|{
name|err
operator|=
name|zap_entry_create
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|ZAP_MAXCD
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|val
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|zap_increment_num_entries
argument_list|(
name|zap
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|zap_entry_update
argument_list|(
operator|&
name|zeh
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
block|{
name|err
operator|=
name|zap_expand_leaf
argument_list|(
name|zap
argument_list|,
name|l
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
block|}
name|zap_put_leaf_maybe_grow_ptrtbl
argument_list|(
name|zap
argument_list|,
name|l
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_length
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|integer_size
parameter_list|,
name|uint64_t
modifier|*
name|num_integers
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|hash
operator|=
name|zap_hash
argument_list|(
name|zap
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|NULL
argument_list|,
name|RW_READER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|zap_leaf_lookup
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|integer_size
condition|)
operator|*
name|integer_size
operator|=
name|zeh
operator|.
name|zeh_integer_size
expr_stmt|;
if|if
condition|(
name|num_integers
condition|)
operator|*
name|num_integers
operator|=
name|zeh
operator|.
name|zeh_num_integers
expr_stmt|;
name|out
label|:
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fzap_remove
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|hash
operator|=
name|zap_hash
argument_list|(
name|zap
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|hash
argument_list|,
name|tx
argument_list|,
name|RW_WRITER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|zap_leaf_lookup
argument_list|(
name|l
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|zap_entry_remove
argument_list|(
operator|&
name|zeh
argument_list|)
expr_stmt|;
name|zap_increment_num_entries
argument_list|(
name|zap
argument_list|,
operator|-
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"fzap_remove: ds=%p obj=%llu name=%s err=%d\n"
argument_list|,
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|name
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zap_value_search
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
modifier|*
name|za
decl_stmt|;
name|int
name|err
decl_stmt|;
name|za
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zapobj
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
if|if
condition|(
name|za
operator|->
name|za_first_integer
operator|==
name|value
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|za
operator|->
name|za_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|za
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for iterating over the attributes.  */
end_comment

begin_function
name|int
name|fzap_cursor_retrieve
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|zap_attribute_t
modifier|*
name|za
parameter_list|)
block|{
name|int
name|err
init|=
name|ENOENT
decl_stmt|;
name|zap_entry_handle_t
name|zeh
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
comment|/* retrieve the next entry at or after zc_hash/zc_cd */
comment|/* if no entry, return ENOENT */
if|if
condition|(
name|zc
operator|->
name|zc_leaf
operator|&&
operator|(
name|ZAP_HASH_IDX
argument_list|(
name|zc
operator|->
name|zc_hash
argument_list|,
name|zc
operator|->
name|zc_leaf
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
argument_list|)
operator|!=
name|zc
operator|->
name|zc_leaf
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|zc
operator|->
name|zc_leaf
operator|->
name|l_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|zap_put_leaf
argument_list|(
name|zc
operator|->
name|zc_leaf
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_leaf
operator|=
name|NULL
expr_stmt|;
block|}
name|again
label|:
if|if
condition|(
name|zc
operator|->
name|zc_leaf
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|zap_deref_leaf
argument_list|(
name|zap
argument_list|,
name|zc
operator|->
name|zc_hash
argument_list|,
name|NULL
argument_list|,
name|RW_READER
argument_list|,
operator|&
name|zc
operator|->
name|zc_leaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
name|rw_enter
argument_list|(
operator|&
name|zc
operator|->
name|zc_leaf
operator|->
name|l_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|zc
operator|->
name|zc_leaf
expr_stmt|;
name|err
operator|=
name|zap_leaf_lookup_closest
argument_list|(
name|l
argument_list|,
name|zc
operator|->
name|zc_hash
argument_list|,
name|zc
operator|->
name|zc_cd
argument_list|,
operator|&
name|zeh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
name|uint64_t
name|nocare
init|=
operator|(
literal|1ULL
operator|<<
operator|(
literal|64
operator|-
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|zc
operator|->
name|zc_hash
operator|=
operator|(
name|zc
operator|->
name|zc_hash
operator|&
operator|~
name|nocare
operator|)
operator|+
name|nocare
operator|+
literal|1
expr_stmt|;
name|zc
operator|->
name|zc_cd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|==
literal|0
operator|||
name|zc
operator|->
name|zc_hash
operator|==
literal|0
condition|)
block|{
name|zc
operator|->
name|zc_hash
operator|=
operator|-
literal|1ULL
expr_stmt|;
block|}
else|else
block|{
name|zap_put_leaf
argument_list|(
name|zc
operator|->
name|zc_leaf
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_leaf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|zc
operator|->
name|zc_hash
operator|=
name|zeh
operator|.
name|zeh_hash
expr_stmt|;
name|zc
operator|->
name|zc_cd
operator|=
name|zeh
operator|.
name|zeh_cd
expr_stmt|;
name|za
operator|->
name|za_integer_length
operator|=
name|zeh
operator|.
name|zeh_integer_size
expr_stmt|;
name|za
operator|->
name|za_num_integers
operator|=
name|zeh
operator|.
name|zeh_num_integers
expr_stmt|;
if|if
condition|(
name|zeh
operator|.
name|zeh_num_integers
operator|==
literal|0
condition|)
block|{
name|za
operator|->
name|za_first_integer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|zap_entry_read
argument_list|(
operator|&
name|zeh
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|za
operator|->
name|za_first_integer
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|EOVERFLOW
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|zap_entry_read_name
argument_list|(
operator|&
name|zeh
argument_list|,
sizeof|sizeof
argument_list|(
name|za
operator|->
name|za_name
argument_list|)
argument_list|,
name|za
operator|->
name|za_name
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|zc
operator|->
name|zc_leaf
operator|->
name|l_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zap_stats_ptrtbl
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
modifier|*
name|tbl
parameter_list|,
name|int
name|len
parameter_list|,
name|zap_stats_t
modifier|*
name|zs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|uint64_t
name|lastblk
init|=
literal|0
decl_stmt|;
comment|/* 	 * NB: if a leaf has more pointers than an entire ptrtbl block 	 * can hold, then it'll be accounted for more than once, since 	 * we won't have lastblk. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|zap_leaf_t
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|==
name|lastblk
condition|)
continue|continue;
name|lastblk
operator|=
name|tbl
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|zap_get_leaf_byblk
argument_list|(
name|zap
argument_list|,
name|tbl
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|RW_READER
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|zap_leaf_stats
argument_list|(
name|zap
argument_list|,
name|l
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|zap_put_leaf
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|fzap_get_stats
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_stats_t
modifier|*
name|zs
parameter_list|)
block|{
name|int
name|bs
init|=
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
decl_stmt|;
name|zs
operator|->
name|zs_blocksize
operator|=
literal|1ULL
operator|<<
name|bs
expr_stmt|;
comment|/* 	 * Set zap_phys_t fields 	 */
name|zs
operator|->
name|zs_num_leafs
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_leafs
expr_stmt|;
name|zs
operator|->
name|zs_num_entries
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_num_entries
expr_stmt|;
name|zs
operator|->
name|zs_num_blocks
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_freeblk
expr_stmt|;
name|zs
operator|->
name|zs_block_type
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_block_type
expr_stmt|;
name|zs
operator|->
name|zs_magic
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_magic
expr_stmt|;
name|zs
operator|->
name|zs_salt
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_salt
expr_stmt|;
comment|/* 	 * Set zap_ptrtbl fields 	 */
name|zs
operator|->
name|zs_ptrtbl_len
operator|=
literal|1ULL
operator|<<
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
expr_stmt|;
name|zs
operator|->
name|zs_ptrtbl_nextblk
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_nextblk
expr_stmt|;
name|zs
operator|->
name|zs_ptrtbl_blks_copied
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blks_copied
expr_stmt|;
name|zs
operator|->
name|zs_ptrtbl_zt_blk
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
expr_stmt|;
name|zs
operator|->
name|zs_ptrtbl_zt_numblks
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
expr_stmt|;
name|zs
operator|->
name|zs_ptrtbl_zt_shift
operator|=
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
expr_stmt|;
if|if
condition|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|==
literal|0
condition|)
block|{
comment|/* the ptrtbl is entirely in the header block. */
name|zap_stats_ptrtbl
argument_list|(
name|zap
argument_list|,
operator|&
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
name|zap
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
operator|<<
name|ZAP_EMBEDDED_PTRTBL_SHIFT
argument_list|(
name|zap
argument_list|)
argument_list|,
name|zs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|b
decl_stmt|;
name|dmu_prefetch
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
operator|<<
name|bs
argument_list|,
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
operator|<<
name|bs
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_numblks
condition|;
name|b
operator|++
control|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|zap
operator|->
name|zap_objset
argument_list|,
name|zap
operator|->
name|zap_object
argument_list|,
operator|(
name|zap
operator|->
name|zap_f
operator|.
name|zap_phys
operator|->
name|zap_ptrtbl
operator|.
name|zt_blk
operator|+
name|b
operator|)
operator|<<
name|bs
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|zap_stats_ptrtbl
argument_list|(
name|zap
argument_list|,
name|db
operator|->
name|db_data
argument_list|,
literal|1
operator|<<
operator|(
name|bs
operator|-
literal|3
operator|)
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

