begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_comment
comment|/*  * The zfs intent log (ZIL) saves transaction records of system calls  * that change the file system in memory with enough information  * to be able to replay them. These are stored in memory until  * either the DMU transaction group (txg) commits them to the stable pool  * and they can be discarded, or they are flushed to the stable log  * (also in the pool) due to a fsync, O_DSYNC or other synchronous  * requirement. In the event of a panic or power fail then those log  * records (transactions) are replayed.  *  * There is one ZIL per file system. Its on-disk (pool) format consists  * of 3 parts:  *  * 	- ZIL header  * 	- ZIL blocks  * 	- ZIL records  *  * A log record holds a system call transaction. Log blocks can  * hold many log records and the blocks are chained together.  * Each ZIL block contains a block pointer (blkptr_t) to the next  * ZIL block in the chain. The ZIL header points to the first  * block in the chain. Note there is not a fixed place in the pool  * to hold blocks. They are dynamically allocated and freed as  * needed from the blocks available. Figure X shows the ZIL structure:  */
end_comment

begin_comment
comment|/*  * This global ZIL switch affects all pools  */
end_comment

begin_decl_stmt
name|int
name|zil_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* disable intent logging */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.zil_disable"
argument_list|,
operator|&
name|zil_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zil_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zil_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable ZFS Intent Log (ZIL)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunable parameter for debugging or performance analysis.  Setting  * zfs_nocacheflush will cause corruption on power loss if a volatile  * out-of-order write cache is enabled.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_nocacheflush
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.cache_flush_disable"
argument_list|,
operator|&
name|zfs_nocacheflush
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cache_flush_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_nocacheflush
argument_list|,
literal|0
argument_list|,
literal|"Disable cache flush"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|zil_lwb_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zil_dva_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva1
init|=
name|x1
decl_stmt|;
specifier|const
name|dva_t
modifier|*
name|dva2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_dva_tree_init
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|)
block|{
name|avl_create
argument_list|(
name|t
argument_list|,
name|zil_dva_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_dva_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_dva_node_t
argument_list|,
name|zn_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_dva_tree_fini
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|)
block|{
name|zil_dva_node_t
modifier|*
name|zn
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|zn
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|zn
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_dva_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_dva_tree_add
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|)
block|{
name|zil_dva_node_t
modifier|*
name|zn
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|t
argument_list|,
name|dva
argument_list|,
operator|&
name|where
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|zn
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zil_dva_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zn
operator|->
name|zn_dva
operator|=
operator|*
name|dva
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|zn
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zil_header_t
modifier|*
name|zil_header_in_syncing_context
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
return|return
operator|(
operator|(
name|zil_header_t
operator|*
operator|)
name|zilog
operator|->
name|zl_header
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_init_log_chain
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zc
init|=
operator|&
name|bp
operator|->
name|blk_cksum
decl_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_0
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_1
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
operator|=
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|=
literal|1ULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a log block, make sure it's valid, and byteswap it if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|zil_read_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_buf_t
modifier|*
modifier|*
name|abufpp
parameter_list|)
block|{
name|blkptr_t
name|blk
init|=
operator|*
name|bp
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
name|uint32_t
name|aflags
init|=
name|ARC_WAIT
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zb
operator|.
name|zb_objset
operator|=
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
expr_stmt|;
operator|*
name|abufpp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
operator|&
name|blk
argument_list|,
name|byteswap_uint64_array
argument_list|,
name|arc_getbuf_func
argument_list|,
name|abufpp
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|data
init|=
operator|(
operator|*
name|abufpp
operator|)
operator|->
name|b_data
decl_stmt|;
name|uint64_t
name|blksz
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|zil_trailer_t
modifier|*
name|ztp
init|=
operator|(
name|zil_trailer_t
operator|*
operator|)
operator|(
name|data
operator|+
name|blksz
operator|)
operator|-
literal|1
decl_stmt|;
name|zio_cksum_t
name|cksum
init|=
name|bp
operator|->
name|blk_cksum
decl_stmt|;
comment|/* 		 * Sequence numbers should be... sequential.  The checksum 		 * verifier for the next block should be bp's checksum plus 1. 		 */
name|cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cksum
argument_list|,
operator|&
name|ztp
operator|->
name|zit_next_blk
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|ESTALE
expr_stmt|;
elseif|else
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|ztp
operator|->
name|zit_next_blk
argument_list|)
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|ztp
operator|->
name|zit_nused
operator|>
operator|(
name|blksz
operator|-
sizeof|sizeof
argument_list|(
name|zil_trailer_t
argument_list|)
operator|)
condition|)
name|error
operator|=
name|EOVERFLOW
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
operator|*
name|abufpp
argument_list|,
name|abufpp
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|abufpp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|dprintf
argument_list|(
literal|"error %d on %llu:%llu\n"
argument_list|,
name|error
argument_list|,
name|zb
operator|.
name|zb_objset
argument_list|,
name|zb
operator|.
name|zb_blkid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the intent log, and call parse_func for each valid record within.  * Return the highest sequence number.  */
end_comment

begin_function
name|uint64_t
name|zil_parse
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_parse_blk_func_t
modifier|*
name|parse_blk_func
parameter_list|,
name|zil_parse_lr_func_t
modifier|*
name|parse_lr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|uint64_t
name|claim_seq
init|=
name|zh
operator|->
name|zh_claim_seq
decl_stmt|;
name|uint64_t
name|seq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|max_seq
init|=
literal|0
decl_stmt|;
name|blkptr_t
name|blk
init|=
name|zh
operator|->
name|zh_log
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
name|char
modifier|*
name|lrbuf
decl_stmt|,
modifier|*
name|lrp
decl_stmt|;
name|zil_trailer_t
modifier|*
name|ztp
decl_stmt|;
name|int
name|reclen
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
return|return
operator|(
name|max_seq
operator|)
return|;
comment|/* 	 * Starting at the block pointed to by zh_log we read the log chain. 	 * For each block in the chain we strongly check that block to 	 * ensure its validity.  We stop when an invalid block is found. 	 * For each block pointer in the chain we call parse_blk_func(). 	 * For each record in each valid block we call parse_lr_func(). 	 * If the log has been claimed, stop if we encounter a sequence 	 * number greater than the highest claimed sequence number. 	 */
name|zil_dva_tree_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_dva_tree
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|seq
operator|=
name|blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
expr_stmt|;
if|if
condition|(
name|claim_seq
operator|!=
literal|0
operator|&&
name|seq
operator|>
name|claim_seq
condition|)
break|break;
name|ASSERT
argument_list|(
name|max_seq
operator|<
name|seq
argument_list|)
expr_stmt|;
name|max_seq
operator|=
name|seq
expr_stmt|;
name|error
operator|=
name|zil_read_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|abuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_blk_func
operator|!=
name|NULL
condition|)
name|parse_blk_func
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|lrbuf
operator|=
name|abuf
operator|->
name|b_data
expr_stmt|;
name|ztp
operator|=
operator|(
name|zil_trailer_t
operator|*
operator|)
operator|(
name|lrbuf
operator|+
name|BP_GET_LSIZE
argument_list|(
operator|&
name|blk
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|blk
operator|=
name|ztp
operator|->
name|zit_next_blk
expr_stmt|;
if|if
condition|(
name|parse_lr_func
operator|==
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|lrp
operator|=
name|lrbuf
init|;
name|lrp
operator|<
name|lrbuf
operator|+
name|ztp
operator|->
name|zit_nused
condition|;
name|lrp
operator|+=
name|reclen
control|)
block|{
name|lr_t
modifier|*
name|lr
init|=
operator|(
name|lr_t
operator|*
operator|)
name|lrp
decl_stmt|;
name|reclen
operator|=
name|lr
operator|->
name|lrc_reclen
expr_stmt|;
name|ASSERT3U
argument_list|(
name|reclen
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
name|parse_lr_func
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|zil_dva_tree_fini
argument_list|(
operator|&
name|zilog
operator|->
name|zl_dva_tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|max_seq
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zil_claim_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Claim log block if not already committed and not already claimed. 	 */
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>=
name|first_txg
operator|&&
name|zil_dva_tree_add
argument_list|(
operator|&
name|zilog
operator|->
name|zl_dva_tree
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zio_wait
argument_list|(
name|zio_claim
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|first_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zil_claim_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|zil_claim_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zil_free_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zio_free_blk
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|bp
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_free_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
comment|/* 	 * If we previously claimed it, we need to free it. 	 */
if|if
condition|(
name|claim_txg
operator|!=
literal|0
operator|&&
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>=
name|claim_txg
operator|&&
operator|!
name|zil_dva_tree_add
argument_list|(
operator|&
name|zilog
operator|->
name|zl_dva_tree
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|arc_free
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_WAIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create an on-disk intent log.  */
end_comment

begin_function
specifier|static
name|void
name|zil_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|NULL
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_replay_seq
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blk
operator|=
name|zh
operator|->
name|zh_log
expr_stmt|;
comment|/* 	 * If we don't already have an initial log block, allocate one now. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_alloc_blk
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
operator|&
name|blk
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a log write buffer (lwb) for the first log block. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|lwb
operator|=
name|kmem_cache_alloc
argument_list|(
name|zil_lwb_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_zilog
operator|=
name|zilog
expr_stmt|;
name|lwb
operator|->
name|lwb_blk
operator|=
name|blk
expr_stmt|;
name|lwb
operator|->
name|lwb_nused
operator|=
literal|0
expr_stmt|;
name|lwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_buf
operator|=
name|zio_buf_alloc
argument_list|(
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|txg
expr_stmt|;
name|lwb
operator|->
name|lwb_zio
operator|=
name|NULL
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we just allocated the first log block, commit our transaction 	 * and wait for zil_sync() to stuff the block poiner into zh_log. 	 * (zh is part of the MOS, so we cannot modify it in open context.) 	 */
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
operator|&
name|blk
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|,
sizeof|sizeof
argument_list|(
name|blk
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In one tx, free all log blocks and clear the log header.  * If keep_first is set, then we're replaying a log with no content.  * We want to keep the first block, however, so that the first  * synchronous transaction doesn't require a txg_wait_synced()  * in zil_create().  We don't need to txg_wait_synced() here either  * when keep_first is set, because both zil_create() and zil_destroy()  * will wait for any in-progress destroys to complete.  */
end_comment

begin_function
name|void
name|zil_destroy
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|boolean_t
name|keep_first
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zilog
operator|->
name|zl_destroy_txg
argument_list|,
operator|<
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|txg
expr_stmt|;
name|zilog
operator|->
name|zl_keep_first
operator|=
name|keep_first
expr_stmt|;
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|keep_first
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zio_free_blk
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|keep_first
condition|)
block|{
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_free_log_block
argument_list|,
name|zil_free_log_record
argument_list|,
name|tx
argument_list|,
name|zh
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_first
condition|)
comment|/* no need to wait in this case */
return|return;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zil_claim
parameter_list|(
name|char
modifier|*
name|osname
parameter_list|,
name|void
modifier|*
name|txarg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|txarg
decl_stmt|;
name|uint64_t
name|first_txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zil_header_t
modifier|*
name|zh
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_STANDARD
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"can't process intent log for %s"
argument_list|,
name|osname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zh
operator|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
comment|/* 	 * Claim all log blocks if we haven't already done so, and remember 	 * the highest claimed sequence number.  This ensures that if we can 	 * read only part of the log now (e.g. due to a missing device), 	 * but we can read the entire log later, we will not try to replay 	 * or destroy beyond the last block we successfully claimed. 	 */
name|ASSERT3U
argument_list|(
name|zh
operator|->
name|zh_claim_txg
argument_list|,
operator|<=
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
block|{
name|zh
operator|->
name|zh_claim_txg
operator|=
name|first_txg
expr_stmt|;
name|zh
operator|->
name|zh_claim_seq
operator|=
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_claim_log_block
argument_list|,
name|zil_claim_log_record
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|first_txg
argument_list|,
operator|==
argument_list|,
operator|(
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_add_vdev
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|vdev
parameter_list|)
block|{
name|zil_vdev_t
modifier|*
name|zv
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|uint64_t
name|bmap_sz
init|=
sizeof|sizeof
argument_list|(
name|zilog
operator|->
name|zl_vdev_bmap
argument_list|)
operator|<<
literal|3
decl_stmt|;
name|uchar_t
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|zfs_nocacheflush
condition|)
return|return;
if|if
condition|(
name|vdev
operator|<
name|bmap_sz
condition|)
block|{
name|cp
operator|=
name|zilog
operator|->
name|zl_vdev_bmap
operator|+
operator|(
name|vdev
operator|/
literal|8
operator|)
expr_stmt|;
name|atomic_or_8
argument_list|(
name|cp
argument_list|,
literal|1
operator|<<
operator|(
name|vdev
operator|%
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * insert into ordered list 		 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zv
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|)
init|;
name|zv
operator|!=
name|NULL
condition|;
name|zv
operator|=
name|list_next
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
name|zv
argument_list|)
control|)
block|{
if|if
condition|(
name|zv
operator|->
name|vdev
operator|==
name|vdev
condition|)
block|{
comment|/* duplicate found - just return */
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zv
operator|->
name|vdev
operator|>
name|vdev
condition|)
block|{
comment|/* insert before this entry */
name|new
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zil_vdev_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|vdev
operator|=
name|vdev
expr_stmt|;
name|list_insert_before
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
name|zv
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* ran off end of list, insert at the end */
name|ASSERT
argument_list|(
name|zv
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zil_vdev_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|vdev
operator|=
name|vdev
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* start an async flush of the write cache for this vdev */
end_comment

begin_function
name|void
name|zil_flush_vdev
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|vdev
parameter_list|,
name|zio_t
modifier|*
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
if|if
condition|(
operator|*
name|zio
operator|==
name|NULL
condition|)
operator|*
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
operator|*
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_flush_vdevs
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|zil_vdev_t
modifier|*
name|zv
decl_stmt|;
name|zio_t
modifier|*
name|zio
init|=
name|NULL
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|uint64_t
name|vdev
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_writer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zilog
operator|->
name|zl_vdev_bmap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|zilog
operator|->
name|zl_vdev_bmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|vdev
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator|+
name|j
expr_stmt|;
name|zil_flush_vdev
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|,
operator|&
name|zio
argument_list|)
expr_stmt|;
block|}
block|}
name|zilog
operator|->
name|zl_vdev_bmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|zv
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zil_flush_vdev
argument_list|(
name|spa
argument_list|,
name|zv
operator|->
name|vdev
argument_list|,
operator|&
name|zio
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
name|zv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_vdev_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for all the flushes to complete.  Not all devices actually 	 * support the DKIOCFLUSHWRITECACHE ioctl, so it's OK if it fails. 	 */
if|if
condition|(
name|zio
condition|)
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function called when a log block write completes  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|lwb
operator|->
name|lwb_zilog
decl_stmt|;
comment|/* 	 * Now that we've written this log block, we have a stable pointer 	 * to the next block in the chain, so it's OK to let the txg in 	 * which we allocated the next block sync. 	 */
name|txg_rele_to_sync
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_txgh
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
block|{
name|zilog
operator|->
name|zl_log_error
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the io for a log block.  *  * Note, we should not initialize the IO until we are about  * to use it, since zio_rewrite() does a spa_config_enter().  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_init
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|zbookmark_t
name|zb
decl_stmt|;
name|zb
operator|.
name|zb_objset
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_root_zio
operator|==
name|NULL
condition|)
block|{
name|zilog
operator|->
name|zl_root_zio
operator|=
name|zio_root
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lwb
operator|->
name|lwb_zio
operator|==
name|NULL
condition|)
block|{
name|lwb
operator|->
name|lwb_zio
operator|=
name|zio_rewrite
argument_list|(
name|zilog
operator|->
name|zl_root_zio
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|ZIO_CHECKSUM_ZILOG
argument_list|,
literal|0
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|,
name|zil_lwb_write_done
argument_list|,
name|lwb
argument_list|,
name|ZIO_PRIORITY_LOG_WRITE
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a log block write and advance to the next log block.  * Calls are serialized.  */
end_comment

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_write_start
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lwb_t
modifier|*
name|nlwb
decl_stmt|;
name|zil_trailer_t
modifier|*
name|ztp
init|=
operator|(
name|zil_trailer_t
operator|*
operator|)
operator|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_sz
operator|)
operator|-
literal|1
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|ztp
operator|->
name|zit_next_blk
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|uint64_t
name|zil_blksz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_nused
operator|<=
name|ZIL_BLK_DATA_SZ
argument_list|(
name|lwb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the next block and save its address in this block 	 * before writing it in order to establish the log chain. 	 * Note that if the allocation of nlwb synced before we wrote 	 * the block that points at it (lwb), we'd leak it if we crashed. 	 * Therefore, we don't do txg_rele_to_sync() until zil_lwb_write_done(). 	 */
name|txg
operator|=
name|txg_hold_open
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_txgh
argument_list|)
expr_stmt|;
name|txg_rele_to_quiesce
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_txgh
argument_list|)
expr_stmt|;
comment|/* 	 * Pick a ZIL blocksize. We request a size that is the 	 * maximum of the previous used size, the current used size and 	 * the amount waiting in the queue. 	 */
name|zil_blksz
operator|=
name|MAX
argument_list|(
name|zilog
operator|->
name|zl_prev_used
argument_list|,
name|zilog
operator|->
name|zl_cur_used
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ztp
argument_list|)
argument_list|)
expr_stmt|;
name|zil_blksz
operator|=
name|MAX
argument_list|(
name|zil_blksz
argument_list|,
name|zilog
operator|->
name|zl_itx_list_sz
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ztp
argument_list|)
argument_list|)
expr_stmt|;
name|zil_blksz
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|zil_blksz
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|zil_blksz
operator|>
name|ZIL_MAX_BLKSZ
condition|)
name|zil_blksz
operator|=
name|ZIL_MAX_BLKSZ
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* pass the old blkptr in order to spread log blocks across devs */
name|error
operator|=
name|zio_alloc_blk
argument_list|(
name|spa
argument_list|,
name|zil_blksz
argument_list|,
name|bp
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create_assigned
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
decl_stmt|;
comment|/* 		 * We dirty the dataset to ensure that zil_sync() will 		 * be called to remove this lwb from our zl_lwb_list. 		 * Failing to do so, may leave an lwb with a NULL lwb_buf 		 * hanging around on the zl_lwb_list. 		 */
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Since we've just experienced an allocation failure so we 		 * terminate the current lwb and send it on its way. 		 */
name|ztp
operator|->
name|zit_pad
operator|=
literal|0
expr_stmt|;
name|ztp
operator|->
name|zit_nused
operator|=
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|ztp
operator|->
name|zit_bt
operator|.
name|zbt_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
name|zio_nowait
argument_list|(
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
comment|/* 		 * By returning NULL the caller will call tx_wait_synced() 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|==
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ztp
operator|->
name|zit_pad
operator|=
literal|0
expr_stmt|;
name|ztp
operator|->
name|zit_nused
operator|=
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|ztp
operator|->
name|zit_bt
operator|.
name|zbt_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
comment|/* 	 * Allocate a new log write buffer (lwb). 	 */
name|nlwb
operator|=
name|kmem_cache_alloc
argument_list|(
name|zil_lwb_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|nlwb
operator|->
name|lwb_zilog
operator|=
name|zilog
expr_stmt|;
name|nlwb
operator|->
name|lwb_blk
operator|=
operator|*
name|bp
expr_stmt|;
name|nlwb
operator|->
name|lwb_nused
operator|=
literal|0
expr_stmt|;
name|nlwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
operator|&
name|nlwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|nlwb
operator|->
name|lwb_buf
operator|=
name|zio_buf_alloc
argument_list|(
name|nlwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|nlwb
operator|->
name|lwb_max_txg
operator|=
name|txg
expr_stmt|;
name|nlwb
operator|->
name|lwb_zio
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Put new lwb at the end of the log chain 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|nlwb
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* Record the vdev for later flushing */
name|zil_add_vdev
argument_list|(
name|zilog
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
operator|&
operator|(
name|lwb
operator|->
name|lwb_blk
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * kick off the write for the old log block 	 */
name|dprintf_bp
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
literal|"lwb %p txg %llu: "
argument_list|,
name|lwb
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|nlwb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lr_t
modifier|*
name|lrc
init|=
operator|&
name|itx
operator|->
name|itx_lr
decl_stmt|;
comment|/* common log record */
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|uint64_t
name|txg
init|=
name|lrc
operator|->
name|lrc_txg
decl_stmt|;
name|uint64_t
name|reclen
init|=
name|lrc
operator|->
name|lrc_reclen
decl_stmt|;
name|uint64_t
name|dlen
decl_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
operator|&&
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
condition|)
name|dlen
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lr
operator|->
name|lr_length
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
else|else
name|dlen
operator|=
literal|0
expr_stmt|;
name|zilog
operator|->
name|zl_cur_used
operator|+=
operator|(
name|reclen
operator|+
name|dlen
operator|)
expr_stmt|;
name|zil_lwb_write_init
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
comment|/* 	 * If this record won't fit in the current log block, start a new one. 	 */
if|if
condition|(
name|lwb
operator|->
name|lwb_nused
operator|+
name|reclen
operator|+
name|dlen
operator|>
name|ZIL_BLK_DATA_SZ
argument_list|(
name|lwb
argument_list|)
condition|)
block|{
name|lwb
operator|=
name|zil_lwb_write_start
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zil_lwb_write_init
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_nused
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|+
name|dlen
operator|>
name|ZIL_BLK_DATA_SZ
argument_list|(
name|lwb
argument_list|)
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
block|}
comment|/* 	 * Update the lrc_seq, to be log record sequence number. See zil.h 	 * Then copy the record to the log buffer. 	 */
name|lrc
operator|->
name|lrc_seq
operator|=
operator|++
name|zilog
operator|->
name|zl_lr_seq
expr_stmt|;
comment|/* we are single threaded */
name|bcopy
argument_list|(
name|lrc
argument_list|,
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * If it's a write, fetch the data or get its blkptr as appropriate. 	 */
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|itx
operator|->
name|itx_wr_state
operator|!=
name|WR_COPIED
condition|)
block|{
name|char
modifier|*
name|dbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* alignment is guaranteed */
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
operator|)
expr_stmt|;
if|if
condition|(
name|dlen
condition|)
block|{
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
operator|+
name|reclen
expr_stmt|;
name|lr
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|+=
name|dlen
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_INDIRECT
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|zilog
operator|->
name|zl_get_data
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
name|lr
argument_list|,
name|dbuf
argument_list|,
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EEXIST
operator|||
name|error
operator|==
name|EALREADY
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
block|}
block|}
name|lwb
operator|->
name|lwb_nused
operator|+=
name|reclen
operator|+
name|dlen
expr_stmt|;
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|MAX
argument_list|(
name|lwb
operator|->
name|lwb_max_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
operator|<=
argument_list|,
name|ZIL_BLK_DATA_SZ
argument_list|(
name|lwb
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|P2PHASE
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_function
name|itx_t
modifier|*
name|zil_itx_create
parameter_list|(
name|int
name|txtype
parameter_list|,
name|size_t
name|lrsize
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lrsize
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|itx
operator|=
name|kmem_alloc
argument_list|(
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|lrsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|=
name|txtype
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
operator|=
name|lrsize
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|=
literal|0
expr_stmt|;
comment|/* defensive */
return|return
operator|(
name|itx
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|zil_itx_assign
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|seq
decl_stmt|;
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_itx_list_sz
operator|+=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|=
name|seq
operator|=
operator|++
name|zilog
operator|->
name|zl_itx_seq
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|seq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up all in-memory intent log transactions that have now been synced.  */
end_comment

begin_function
specifier|static
name|void
name|zil_itx_clean
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|uint64_t
name|synced_txg
init|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
decl_stmt|;
name|uint64_t
name|freeze_txg
init|=
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
decl_stmt|;
name|list_t
name|clean_list
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|list_create
argument_list|(
operator|&
name|clean_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* wait for a log writer to finish walking list */
while|while
condition|(
name|zilog
operator|->
name|zl_writer
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Move the sync'd log transactions to a separate list so we can call 	 * kmem_free without holding the zl_lock. 	 * 	 * There is no need to set zl_writer as we don't drop zl_lock here 	 */
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
operator|<=
name|MIN
argument_list|(
name|synced_txg
argument_list|,
name|freeze_txg
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_itx_list_sz
operator|-=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|clean_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* destroy sync'd log transactions */
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|clean_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|clean_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|clean_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there are any in-memory intent log transactions which have now been  * synced then start up a taskq to free them.  */
end_comment

begin_function
name|void
name|zil_clean
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|itx
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
operator|<=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|zil_itx_clean
argument_list|,
name|zilog
argument_list|,
name|TQ_NOSLEEP
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_commit_writer
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|seq
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|uint64_t
name|reclen
decl_stmt|;
name|uint64_t
name|commit_seq
init|=
literal|0
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|,
modifier|*
name|itx_next
init|=
operator|(
name|itx_t
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|zilog
operator|->
name|zl_writer
operator|=
name|B_TRUE
expr_stmt|;
name|zilog
operator|->
name|zl_root_zio
operator|=
name|NULL
expr_stmt|;
name|spa
operator|=
name|zilog
operator|->
name|zl_spa
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
condition|)
block|{
name|lwb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Return if there's nothing to flush before we 			 * dirty the fs by calling zil_create() 			 */
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
condition|)
block|{
name|zilog
operator|->
name|zl_writer
operator|=
name|B_FALSE
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_create
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Loop through in-memory log transactions filling log blocks. */
name|DTRACE_PROBE1
argument_list|(
name|zil__cw1
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Find the next itx to push: 		 * Push all transactions related to specified foid and all 		 * other transactions except TX_WRITE, TX_TRUNCATE, 		 * TX_SETATTR and TX_ACL for all other files. 		 */
if|if
condition|(
name|itx_next
operator|!=
operator|(
name|itx_t
operator|*
operator|)
operator|-
literal|1
condition|)
name|itx
operator|=
name|itx_next
expr_stmt|;
else|else
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|itx
operator|!=
name|NULL
condition|;
name|itx
operator|=
name|list_next
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
name|itx
argument_list|)
control|)
block|{
if|if
condition|(
name|foid
operator|==
literal|0
condition|)
comment|/* push all foids? */
break|break;
if|if
condition|(
name|itx
operator|->
name|itx_sync
condition|)
comment|/* push all O_[D]SYNC */
break|break;
switch|switch
condition|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
condition|)
block|{
case|case
name|TX_SETATTR
case|:
case|case
name|TX_WRITE
case|:
case|case
name|TX_TRUNCATE
case|:
case|case
name|TX_ACL
case|:
comment|/* lr_foid is same offset for these records */
if|if
condition|(
operator|(
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
operator|)
operator|->
name|lr_foid
operator|!=
name|foid
condition|)
block|{
continue|continue;
comment|/* skip this record */
block|}
block|}
break|break;
block|}
if|if
condition|(
name|itx
operator|==
name|NULL
condition|)
break|break;
name|reclen
operator|=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
expr_stmt|;
if|if
condition|(
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|>
name|seq
operator|)
operator|&&
operator|(
operator|(
name|lwb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|lwb
operator|->
name|lwb_nused
operator|==
literal|0
operator|)
operator|||
operator|(
name|lwb
operator|->
name|lwb_nused
operator|+
name|reclen
operator|>
name|ZIL_BLK_DATA_SZ
argument_list|(
name|lwb
argument_list|)
operator|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* 		 * Save the next pointer.  Even though we soon drop 		 * zl_lock all threads that may change the list 		 * (another writer or zil_itx_clean) can't do so until 		 * they have zl_writer. 		 */
name|itx_next
operator|=
name|list_next
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|txg
operator|=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|||
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
name|lwb
operator|=
name|zil_lwb_commit
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_itx_list_sz
operator|-=
name|reclen
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|zil__cw2
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
comment|/* determine commit sequence number */
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|itx
condition|)
name|commit_seq
operator|=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
expr_stmt|;
else|else
name|commit_seq
operator|=
name|zilog
operator|->
name|zl_itx_seq
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* write the last block out */
if|if
condition|(
name|lwb
operator|!=
name|NULL
operator|&&
name|lwb
operator|->
name|lwb_zio
operator|!=
name|NULL
condition|)
name|lwb
operator|=
name|zil_lwb_write_start
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_prev_used
operator|=
name|zilog
operator|->
name|zl_cur_used
expr_stmt|;
name|zilog
operator|->
name|zl_cur_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait if necessary for the log blocks to be on stable storage. 	 */
if|if
condition|(
name|zilog
operator|->
name|zl_root_zio
condition|)
block|{
name|DTRACE_PROBE1
argument_list|(
name|zil__cw3
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zilog
operator|->
name|zl_root_zio
argument_list|)
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|zil__cw4
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_nocacheflush
condition|)
name|zil_flush_vdevs
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_log_error
operator|||
name|lwb
operator|==
name|NULL
condition|)
block|{
name|zilog
operator|->
name|zl_log_error
operator|=
literal|0
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_writer
operator|=
name|B_FALSE
expr_stmt|;
name|ASSERT3U
argument_list|(
name|commit_seq
argument_list|,
operator|>=
argument_list|,
name|zilog
operator|->
name|zl_commit_seq
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_commit_seq
operator|=
name|commit_seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push zfs transactions to stable storage up to the supplied sequence number.  * If foid is 0 push out all transactions, otherwise push only those  * for that file or might have been used to create that file.  */
end_comment

begin_function
name|void
name|zil_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|seq
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
if|if
condition|(
name|zilog
operator|==
name|NULL
operator|||
name|seq
operator|==
literal|0
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|seq
operator|=
name|MIN
argument_list|(
name|seq
argument_list|,
name|zilog
operator|->
name|zl_itx_seq
argument_list|)
expr_stmt|;
comment|/* cap seq at largest itx seq */
while|while
condition|(
name|zilog
operator|->
name|zl_writer
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|<
name|zilog
operator|->
name|zl_commit_seq
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|zil_commit_writer
argument_list|(
name|zilog
argument_list|,
name|seq
argument_list|,
name|foid
argument_list|)
expr_stmt|;
comment|/* drops zl_lock */
comment|/* wake up others waiting on the commit */
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called in syncing context to free committed log blocks and update log header.  */
end_comment

begin_function
name|void
name|zil_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zil_header_t
modifier|*
name|zh
init|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_stop_sync
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_replay_seq
operator|=
name|zilog
operator|->
name|zl_replay_seq
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_destroy_txg
operator|==
name|txg
condition|)
block|{
name|blkptr_t
name|blk
init|=
name|zh
operator|->
name|zh_log
decl_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zh
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zilog
operator|->
name|zl_replay_seq
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog
operator|->
name|zl_replay_seq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_keep_first
condition|)
block|{
comment|/* 			 * If this block was part of log chain that couldn't 			 * be claimed because a device was missing during 			 * zil_claim(), but that device later returns, 			 * then this block could erroneously appear valid. 			 * To guard against this, assign a new GUID to the new 			 * log chain so it doesn't matter what blk points to. 			 */
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_log
operator|=
name|blk
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|zh
operator|->
name|zh_log
operator|=
name|lwb
operator|->
name|lwb_blk
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
operator|||
name|lwb
operator|->
name|lwb_max_txg
operator|>
name|txg
condition|)
break|break;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_free_blk
argument_list|(
name|spa
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
comment|/* 		 * If we don't have anything left in the lwb list then 		 * we've had an allocation failure and we need to zero 		 * out the zil_header blkptr so that we don't end 		 * up freeing the same block twice. 		 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
condition|)
name|BP_ZERO
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_init
parameter_list|(
name|void
parameter_list|)
block|{
name|zil_lwb_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zil_lwb_cache"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lwb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|zil_lwb_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|zilog_t
modifier|*
name|zil_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_header_t
modifier|*
name|zh_phys
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zilog
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_header
operator|=
name|zh_phys
expr_stmt|;
name|zilog
operator|->
name|zl_os
operator|=
name|os
expr_stmt|;
name|zilog
operator|->
name|zl_spa
operator|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_dmu_pool
operator|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|TXG_INITIAL
operator|-
literal|1
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|lwb_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|lwb_t
argument_list|,
name|lwb_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_vdev_t
argument_list|,
name|vdev_seq_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_free
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|zil_vdev_t
modifier|*
name|zv
decl_stmt|;
name|zilog
operator|->
name|zl_stop_sync
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zv
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|,
name|zv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_vdev_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_list
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zilog
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return true if the initial log block is not valid  */
end_comment

begin_function
specifier|static
name|int
name|zil_empty
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|zil_read_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|,
operator|&
name|abuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open an intent log.  */
end_comment

begin_function
name|zilog_t
modifier|*
name|zil_open
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_get_data_t
modifier|*
name|get_data
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|get_data
expr_stmt|;
name|zilog
operator|->
name|zl_clean_taskq
operator|=
name|taskq_create
argument_list|(
literal|"zil_clean"
argument_list|,
literal|1
argument_list|,
name|minclsyspri
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an intent log.  */
end_comment

begin_function
name|void
name|zil_close
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
comment|/* 	 * If the log isn't already committed, mark the objset dirty 	 * (so zil_sync() will be called) and wait for that txg to sync. 	 */
if|if
condition|(
operator|!
name|zil_is_committed
argument_list|(
name|zilog
argument_list|)
condition|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|taskq_destroy
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_clean_taskq
operator|=
name|NULL
expr_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|NULL
expr_stmt|;
name|zil_itx_clean
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suspend an intent log.  While in suspended mode, we still honor  * synchronous semantics, but we rely on txg_wait_synced() to do it.  * We suspend the log briefly when taking a snapshot so that the snapshot  * contains all the data it's supposed to, and has an empty intent log.  */
end_comment

begin_function
name|int
name|zil_suspend
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_claim_txg
operator|!=
literal|0
condition|)
block|{
comment|/* unplayed log */
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
operator|++
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Someone else already began a suspend. 		 * Just wait for them to finish. 		 */
while|while
condition|(
name|zilog
operator|->
name|zl_suspending
condition|)
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for any in-flight log writes to complete. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|zilog
operator|->
name|zl_writer
condition|)
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_FALSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_resume
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_suspend
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspend
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zil_replay_arg
block|{
name|objset_t
modifier|*
name|zr_os
decl_stmt|;
name|zil_replay_func_t
modifier|*
modifier|*
name|zr_replay
decl_stmt|;
name|void
modifier|*
name|zr_arg
decl_stmt|;
name|uint64_t
modifier|*
name|zr_txgp
decl_stmt|;
name|boolean_t
name|zr_byteswap
decl_stmt|;
name|char
modifier|*
name|zr_lrbuf
decl_stmt|;
block|}
name|zil_replay_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|zil_replay_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|void
modifier|*
name|zra
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zil_replay_arg_t
modifier|*
name|zr
init|=
name|zra
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|uint64_t
name|reclen
init|=
name|lr
operator|->
name|lrc_reclen
decl_stmt|;
name|uint64_t
name|txtype
init|=
name|lr
operator|->
name|lrc_txtype
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|error
decl_stmt|,
name|sunk
decl_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_stop_replay
condition|)
return|return;
if|if
condition|(
name|lr
operator|->
name|lrc_txg
operator|<
name|claim_txg
condition|)
comment|/* already committed */
return|return;
if|if
condition|(
name|lr
operator|->
name|lrc_seq
operator|<=
name|zh
operator|->
name|zh_replay_seq
condition|)
comment|/* already replayed */
return|return;
comment|/* 	 * Make a copy of the data so we can revise and extend it. 	 */
name|bcopy
argument_list|(
name|lr
argument_list|,
name|zr
operator|->
name|zr_lrbuf
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * The log block containing this lr may have been byteswapped 	 * so that we can easily examine common fields like lrc_txtype. 	 * However, the log is a mix of different data types, and only the 	 * replay vectors know how to byteswap their records.  Therefore, if 	 * the lr was byteswapped, undo it before invoking the replay vector. 	 */
if|if
condition|(
name|zr
operator|->
name|zr_byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|zr
operator|->
name|zr_lrbuf
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a TX_WRITE with a blkptr, suck in the data. 	 */
if|if
condition|(
name|txtype
operator|==
name|TX_WRITE
operator|&&
name|reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|lr_write_t
modifier|*
name|lrw
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lr
decl_stmt|;
name|blkptr_t
modifier|*
name|wbp
init|=
operator|&
name|lrw
operator|->
name|lr_blkptr
decl_stmt|;
name|uint64_t
name|wlen
init|=
name|lrw
operator|->
name|lr_length
decl_stmt|;
name|char
modifier|*
name|wbuf
init|=
name|zr
operator|->
name|zr_lrbuf
operator|+
name|reclen
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|wbp
argument_list|)
condition|)
block|{
comment|/* compressed to a hole */
name|bzero
argument_list|(
name|wbuf
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * A subsequent write may have overwritten this block, 			 * in which case wbp may have been been freed and 			 * reallocated, and our read of wbp may fail with a 			 * checksum error.  We can safely ignore this because 			 * the later write will provide the correct data. 			 */
name|zbookmark_t
name|zb
decl_stmt|;
name|zb
operator|.
name|zb_objset
operator|=
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
name|lrw
operator|->
name|lr_foid
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|lrw
operator|->
name|lr_offset
operator|/
name|BP_GET_LSIZE
argument_list|(
name|wbp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|wbp
argument_list|,
name|wbuf
argument_list|,
name|BP_GET_LSIZE
argument_list|(
name|wbp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|,
operator|&
name|zb
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|wbuf
argument_list|,
name|wbuf
operator|+
name|lrw
operator|->
name|lr_blkoff
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We must now do two things atomically: replay this log record, 	 * and update the log header to reflect the fact that we did so. 	 * We use the DMU's ability to assign into a specific txg to do this. 	 */
for|for
control|(
name|pass
operator|=
literal|1
operator|,
name|sunk
operator|=
name|B_FALSE
init|;
comment|/* CONSTANTCONDITION */
condition|;
name|pass
operator|++
control|)
block|{
name|uint64_t
name|replay_txg
decl_stmt|;
name|dmu_tx_t
modifier|*
name|replay_tx
decl_stmt|;
name|replay_tx
operator|=
name|dmu_tx_create
argument_list|(
name|zr
operator|->
name|zr_os
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|replay_tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|replay_tx
argument_list|)
expr_stmt|;
break|break;
block|}
name|replay_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|replay_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
literal|0
operator|||
name|txtype
operator|>=
name|TX_MAX_TYPE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * On the first pass, arrange for the replay vector 			 * to fail its dmu_tx_assign().  That's the only way 			 * to ensure that those code paths remain well tested. 			 */
operator|*
name|zr
operator|->
name|zr_txgp
operator|=
name|replay_txg
operator|-
operator|(
name|pass
operator|==
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|zr
operator|->
name|zr_replay
index|[
name|txtype
index|]
operator|(
name|zr
operator|->
name|zr_arg
operator|,
name|zr
operator|->
name|zr_lrbuf
operator|,
name|zr
operator|->
name|zr_byteswap
operator|)
expr_stmt|;
operator|*
name|zr
operator|->
name|zr_txgp
operator|=
name|TXG_NOWAIT
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zr
operator|->
name|zr_os
argument_list|)
argument_list|,
name|replay_tx
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replay_seq
index|[
name|replay_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|lr
operator|->
name|lrc_seq
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|replay_tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return;
comment|/* 		 * The DMU's dnode layer doesn't see removes until the txg 		 * commits, so a subsequent claim can spuriously fail with 		 * EEXIST. So if we receive any error other than ERESTART 		 * we try syncing out any removes then retrying the 		 * transaction. 		 */
if|if
condition|(
name|error
operator|!=
name|ERESTART
operator|&&
operator|!
name|sunk
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sunk
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
comment|/* retry */
block|}
if|if
condition|(
name|error
operator|!=
name|ERESTART
condition|)
break|break;
if|if
condition|(
name|pass
operator|!=
literal|1
condition|)
name|txg_wait_open
argument_list|(
name|spa_get_dsl
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|,
name|replay_txg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pass %d, retrying\n"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|error
operator|&&
name|error
operator|!=
name|ERESTART
argument_list|)
expr_stmt|;
name|name
operator|=
name|kmem_alloc
argument_list|(
name|MAXNAMELEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|zr
operator|->
name|zr_os
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"ZFS replay transaction error %d, "
literal|"dataset %s, seq 0x%llx, txtype %llu\n"
argument_list|,
name|error
argument_list|,
name|name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|lr
operator|->
name|lrc_seq
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txtype
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_stop_replay
operator|=
literal|1
expr_stmt|;
name|kmem_free
argument_list|(
name|name
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zil_incr_blks
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zilog
operator|->
name|zl_replay_blks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If this dataset has a non-empty intent log, replay it and destroy it.  */
end_comment

begin_function
name|void
name|zil_replay
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
modifier|*
name|txgp
parameter_list|,
name|zil_replay_func_t
modifier|*
name|replay_func
index|[
name|TX_MAX_TYPE
index|]
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|zil_replay_arg_t
name|zr
decl_stmt|;
if|if
condition|(
name|zil_empty
argument_list|(
name|zilog
argument_list|)
condition|)
block|{
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//printf("ZFS: Replaying ZIL on %s...\n", os->os->os_spa->spa_name);
name|zr
operator|.
name|zr_os
operator|=
name|os
expr_stmt|;
name|zr
operator|.
name|zr_replay
operator|=
name|replay_func
expr_stmt|;
name|zr
operator|.
name|zr_arg
operator|=
name|arg
expr_stmt|;
name|zr
operator|.
name|zr_txgp
operator|=
name|txgp
expr_stmt|;
name|zr
operator|.
name|zr_byteswap
operator|=
name|BP_SHOULD_BYTESWAP
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|zr
operator|.
name|zr_lrbuf
operator|=
name|kmem_alloc
argument_list|(
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for in-progress removes to sync before starting replay. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_stop_replay
operator|=
literal|0
expr_stmt|;
name|zilog
operator|->
name|zl_replay_time
operator|=
name|lbolt
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_replay_blks
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_incr_blks
argument_list|,
name|zil_replay_log_record
argument_list|,
operator|&
name|zr
argument_list|,
name|zh
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zr
operator|.
name|zr_lrbuf
argument_list|,
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|//printf("ZFS: Replay of ZIL on %s finished.\n", os->os->os_spa->spa_name);
block|}
end_function

begin_comment
comment|/*  * Report whether all transactions are committed  */
end_comment

begin_function
name|int
name|zil_is_committed
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|zilog
operator|->
name|zl_writer
condition|)
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* recent unpushed intent log transactions? */
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list
argument_list|)
condition|)
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* intent log never used? */
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|B_TRUE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * more than 1 log buffer means zil_sync() hasn't yet freed 	 * entries after a txg has committed 	 */
if|if
condition|(
name|list_next
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
condition|)
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|zil_empty
argument_list|(
name|zilog
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|B_TRUE
expr_stmt|;
name|out
label|:
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

