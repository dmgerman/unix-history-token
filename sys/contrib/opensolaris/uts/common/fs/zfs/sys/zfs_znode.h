begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_FS_ZFS_ZNODE_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_FS_ZFS_ZNODE_H
end_define

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/list.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Define special zfs pflags  */
define|#
directive|define
name|ZFS_XATTR
value|0x1
comment|/* is an extended attribute */
define|#
directive|define
name|ZFS_INHERIT_ACE
value|0x2
comment|/* ace has inheritable ACEs */
define|#
directive|define
name|ZFS_ACL_TRIVIAL
value|0x4
comment|/* files ACL is trivial */
define|#
directive|define
name|MASTER_NODE_OBJ
value|1
comment|/*  * special attributes for master node.  */
define|#
directive|define
name|ZFS_FSID
value|"FSID"
define|#
directive|define
name|ZFS_UNLINKED_SET
value|"DELETE_QUEUE"
define|#
directive|define
name|ZFS_ROOT_OBJ
value|"ROOT"
define|#
directive|define
name|ZPL_VERSION_OBJ
value|"VERSION"
define|#
directive|define
name|ZFS_PROP_BLOCKPERPAGE
value|"BLOCKPERPAGE"
define|#
directive|define
name|ZFS_PROP_NOGROWBLOCKS
value|"NOGROWBLOCKS"
define|#
directive|define
name|ZFS_FLAG_BLOCKPERPAGE
value|0x1
define|#
directive|define
name|ZFS_FLAG_NOGROWBLOCKS
value|0x2
comment|/*  * ZPL version - rev'd whenever an incompatible on-disk format change  * occurs.  Independent of SPA/DMU/ZAP versioning.  */
define|#
directive|define
name|ZPL_VERSION
value|1ULL
define|#
directive|define
name|ZFS_MAX_BLOCKSIZE
value|(SPA_MAXBLOCKSIZE)
comment|/* Path component length */
comment|/*  * The generic fs code uses MAXNAMELEN to represent  * what the largest component length is.  Unfortunately,  * this length includes the terminating NULL.  ZFS needs  * to tell the users via pathconf() and statvfs() what the  * true maximum length of a component is, excluding the NULL.  */
define|#
directive|define
name|ZFS_MAXNAMELEN
value|(MAXNAMELEN - 1)
comment|/*  * The directory entry has the type (currently unused on Solaris) in the  * top 4 bits, and the object number in the low 48 bits.  The "middle"  * 12 bits are unused.  */
define|#
directive|define
name|ZFS_DIRENT_TYPE
parameter_list|(
name|de
parameter_list|)
value|BF64_GET(de, 60, 4)
define|#
directive|define
name|ZFS_DIRENT_OBJ
parameter_list|(
name|de
parameter_list|)
value|BF64_GET(de, 0, 48)
define|#
directive|define
name|ZFS_DIRENT_MAKE
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
value|(((uint64_t)type<< 60) | obj)
comment|/*  * This is the persistent portion of the znode.  It is stored  * in the "bonus buffer" of the file.  Short symbolic links  * are also stored in the bonus buffer.  */
typedef|typedef
struct|struct
name|znode_phys
block|{
name|uint64_t
name|zp_atime
index|[
literal|2
index|]
decl_stmt|;
comment|/*  0 - last file access time */
name|uint64_t
name|zp_mtime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 16 - last file modification time */
name|uint64_t
name|zp_ctime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 32 - last file change time */
name|uint64_t
name|zp_crtime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 48 - creation time */
name|uint64_t
name|zp_gen
decl_stmt|;
comment|/* 64 - generation (txg of creation) */
name|uint64_t
name|zp_mode
decl_stmt|;
comment|/* 72 - file mode bits */
name|uint64_t
name|zp_size
decl_stmt|;
comment|/* 80 - size of file */
name|uint64_t
name|zp_parent
decl_stmt|;
comment|/* 88 - directory parent (`..') */
name|uint64_t
name|zp_links
decl_stmt|;
comment|/* 96 - number of links to file */
name|uint64_t
name|zp_xattr
decl_stmt|;
comment|/* 104 - DMU object for xattrs */
name|uint64_t
name|zp_rdev
decl_stmt|;
comment|/* 112 - dev_t for VBLK& VCHR files */
name|uint64_t
name|zp_flags
decl_stmt|;
comment|/* 120 - persistent flags */
name|uint64_t
name|zp_uid
decl_stmt|;
comment|/* 128 - file owner */
name|uint64_t
name|zp_gid
decl_stmt|;
comment|/* 136 - owning group */
name|uint64_t
name|zp_pad
index|[
literal|4
index|]
decl_stmt|;
comment|/* 144 - future */
name|zfs_znode_acl_t
name|zp_acl
decl_stmt|;
comment|/* 176 - 263 ACL */
comment|/* 	 * Data may pad out any remaining bytes in the znode buffer, eg: 	 * 	 * |<---------------------- dnode_phys (512) ------------------------>| 	 * |<-- dnode (192) --->|<----------- "bonus" buffer (320) ---------->| 	 *			|<---- znode (264) ---->|<---- data (56) ---->| 	 * 	 * At present, we only use this space to store symbolic links. 	 */
block|}
name|znode_phys_t
typedef|;
comment|/*  * Directory entry locks control access to directory entries.  * They are used to protect creates, deletes, and renames.  * Each directory znode has a mutex and a list of locked names.  */
ifdef|#
directive|ifdef
name|_KERNEL
typedef|typedef
struct|struct
name|zfs_dirlock
block|{
name|char
modifier|*
name|dl_name
decl_stmt|;
comment|/* directory entry being locked */
name|uint32_t
name|dl_sharecnt
decl_stmt|;
comment|/* 0 if exclusive,> 0 if shared */
name|uint16_t
name|dl_namesize
decl_stmt|;
comment|/* set if dl_name was allocated */
name|kcondvar_t
name|dl_cv
decl_stmt|;
comment|/* wait for entry to be unlocked */
name|struct
name|znode
modifier|*
name|dl_dzp
decl_stmt|;
comment|/* directory znode */
name|struct
name|zfs_dirlock
modifier|*
name|dl_next
decl_stmt|;
comment|/* next in z_dirlocks list */
block|}
name|zfs_dirlock_t
typedef|;
typedef|typedef
struct|struct
name|znode
block|{
name|struct
name|zfsvfs
modifier|*
name|z_zfsvfs
decl_stmt|;
name|vnode_t
modifier|*
name|z_vnode
decl_stmt|;
name|uint64_t
name|z_id
decl_stmt|;
comment|/* object ID for this znode */
name|kmutex_t
name|z_lock
decl_stmt|;
comment|/* znode modification lock */
name|krwlock_t
name|z_map_lock
decl_stmt|;
comment|/* page map lock */
name|krwlock_t
name|z_parent_lock
decl_stmt|;
comment|/* parent lock for directories */
name|krwlock_t
name|z_name_lock
decl_stmt|;
comment|/* "master" lock for dirent locks */
name|zfs_dirlock_t
modifier|*
name|z_dirlocks
decl_stmt|;
comment|/* directory entry lock list */
name|kmutex_t
name|z_range_lock
decl_stmt|;
comment|/* protects changes to z_range_avl */
name|avl_tree_t
name|z_range_avl
decl_stmt|;
comment|/* avl tree of file range locks */
name|uint8_t
name|z_unlinked
decl_stmt|;
comment|/* file has been unlinked */
name|uint8_t
name|z_atime_dirty
decl_stmt|;
comment|/* atime needs to be synced */
name|uint8_t
name|z_dbuf_held
decl_stmt|;
comment|/* Is z_dbuf already held? */
name|uint8_t
name|z_zn_prefetch
decl_stmt|;
comment|/* Prefetch znodes? */
name|uint_t
name|z_blksz
decl_stmt|;
comment|/* block size in bytes */
name|uint_t
name|z_seq
decl_stmt|;
comment|/* modification sequence number */
name|uint64_t
name|z_mapcnt
decl_stmt|;
comment|/* number of pages mapped to file */
name|uint64_t
name|z_last_itx
decl_stmt|;
comment|/* last ZIL itx on this znode */
name|uint32_t
name|z_sync_cnt
decl_stmt|;
comment|/* synchronous open count */
name|kmutex_t
name|z_acl_lock
decl_stmt|;
comment|/* acl data lock */
name|list_node_t
name|z_link_node
decl_stmt|;
comment|/* all znodes in fs link */
name|struct
name|lockf
modifier|*
name|z_lockf
decl_stmt|;
comment|/* Head of byte-level lock list. */
comment|/* 	 * These are dmu managed fields. 	 */
name|znode_phys_t
modifier|*
name|z_phys
decl_stmt|;
comment|/* pointer to persistent znode */
name|dmu_buf_t
modifier|*
name|z_dbuf
decl_stmt|;
comment|/* buffer containing the z_phys */
block|}
name|znode_t
typedef|;
comment|/*  * Range locking rules  * --------------------  * 1. When truncating a file (zfs_create, zfs_setattr, zfs_space) the whole  *    file range needs to be locked as RL_WRITER. Only then can the pages be  *    freed etc and zp_size reset. zp_size must be set within range lock.  * 2. For writes and punching holes (zfs_write& zfs_space) just the range  *    being written or freed needs to be locked as RL_WRITER.  *    Multiple writes at the end of the file must coordinate zp_size updates  *    to ensure data isn't lost. A compare and swap loop is currently used  *    to ensure the file size is at least the offset last written.  * 3. For reads (zfs_read, zfs_get_data& zfs_putapage) just the range being  *    read needs to be locked as RL_READER. A check against zp_size can then  *    be made for reading beyond end of file.  */
comment|/*  * Convert between znode pointers and vnode pointers  */
define|#
directive|define
name|ZTOV
parameter_list|(
name|ZP
parameter_list|)
value|((ZP)->z_vnode)
define|#
directive|define
name|VTOZ
parameter_list|(
name|VP
parameter_list|)
value|((znode_t *)(VP)->v_data)
comment|/*  * ZFS_ENTER() is called on entry to each ZFS vnode and vfs operation.  * ZFS_EXIT() must be called before exitting the vop.  */
define|#
directive|define
name|ZFS_ENTER
parameter_list|(
name|zfsvfs
parameter_list|)
define|\
value|{ \ 		atomic_add_32(&(zfsvfs)->z_op_cnt, 1); \ 		if ((zfsvfs)->z_unmounted1) { \ 			ZFS_EXIT(zfsvfs); \ 			return (EIO); \ 		} \ 	}
define|#
directive|define
name|ZFS_EXIT
parameter_list|(
name|zfsvfs
parameter_list|)
value|atomic_add_32(&(zfsvfs)->z_op_cnt, -1)
comment|/*  * Macros for dealing with dmu_buf_hold  */
define|#
directive|define
name|ZFS_OBJ_HASH
parameter_list|(
name|obj_num
parameter_list|)
value|(obj_num& (ZFS_OBJ_MTX_SZ - 1))
define|#
directive|define
name|ZFS_OBJ_MUTEX
parameter_list|(
name|zp
parameter_list|)
define|\
value|(&zp->z_zfsvfs->z_hold_mtx[ZFS_OBJ_HASH(zp->z_id)])
define|#
directive|define
name|ZFS_OBJ_HOLD_ENTER
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|mutex_enter(&zfsvfs->z_hold_mtx[ZFS_OBJ_HASH(obj_num)]);
define|#
directive|define
name|ZFS_OBJ_HOLD_EXIT
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|mutex_exit(&zfsvfs->z_hold_mtx[ZFS_OBJ_HASH(obj_num)])
comment|/*  * Macros to encode/decode ZFS stored time values from/to struct timespec  */
define|#
directive|define
name|ZFS_TIME_ENCODE
parameter_list|(
name|tp
parameter_list|,
name|stmp
parameter_list|)
define|\
value|{						\ 	stmp[0] = (uint64_t)(tp)->tv_sec; 	\ 	stmp[1] = (uint64_t)(tp)->tv_nsec;	\ }
define|#
directive|define
name|ZFS_TIME_DECODE
parameter_list|(
name|tp
parameter_list|,
name|stmp
parameter_list|)
define|\
value|{						\ 	(tp)->tv_sec = (time_t)stmp[0];		\ 	(tp)->tv_nsec = (long)stmp[1];		\ }
comment|/*  * Timestamp defines  */
define|#
directive|define
name|ACCESSED
value|(AT_ATIME)
define|#
directive|define
name|STATE_CHANGED
value|(AT_CTIME)
define|#
directive|define
name|CONTENT_MODIFIED
value|(AT_MTIME | AT_CTIME)
define|#
directive|define
name|ZFS_ACCESSTIME_STAMP
parameter_list|(
name|zfsvfs
parameter_list|,
name|zp
parameter_list|)
define|\
value|if ((zfsvfs)->z_atime&& !((zfsvfs)->z_vfs->vfs_flag& VFS_RDONLY)) \ 		zfs_time_stamper(zp, ACCESSED, NULL)
specifier|extern
name|int
name|zfs_init_fs
parameter_list|(
name|zfsvfs_t
modifier|*
parameter_list|,
name|znode_t
modifier|*
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_set_dataprop
parameter_list|(
name|objset_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_create_fs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_time_stamper
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_time_stamper_locked
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_grow_blocksize
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_freesp
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_zget
parameter_list|(
name|zfsvfs_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|znode_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_zinactive
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_delete
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_free
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_remove_op_tables
parameter_list|()
function_decl|;
specifier|extern
name|int
name|zfs_create_op_tables
parameter_list|()
function_decl|;
specifier|extern
name|dev_t
name|zfs_cmpldev
parameter_list|(
name|uint64_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_remove
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_link
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_symlink
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|link
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_rename
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|char
modifier|*
name|sname
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_write
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_truncate
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_setattr
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|uint_t
name|mask_applied
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|ZFS_NO_ACL
specifier|extern
name|void
name|zfs_log_acl
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|ace_t
modifier|*
name|z_ace
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|extern
name|zil_get_data_t
name|zfs_get_data
decl_stmt|;
specifier|extern
name|zil_replay_func_t
modifier|*
name|zfs_replay_vector
index|[
name|TX_MAX_TYPE
index|]
decl_stmt|;
specifier|extern
name|int
name|zfsfstype
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
specifier|extern
name|int
name|zfs_obj_to_path
parameter_list|(
name|objset_t
modifier|*
name|osp
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_FS_ZFS_ZNODE_H */
end_comment

end_unit

