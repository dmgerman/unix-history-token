begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_function
name|spa_t
modifier|*
name|dmu_objset_spa
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os
operator|->
name|os_spa
operator|)
return|;
block|}
end_function

begin_function
name|zilog_t
modifier|*
name|dmu_objset_zil
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os
operator|->
name|os_zil
operator|)
return|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|dmu_objset_pool
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|)
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|)
return|;
else|else
return|return
operator|(
name|spa_get_dsl
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_spa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dsl_dataset_t
modifier|*
name|dmu_objset_ds
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|)
return|;
block|}
end_function

begin_function
name|dmu_objset_type_t
name|dmu_objset_type
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_name
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|dsl_dataset_name
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dmu_objset_id
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
return|return
operator|(
name|ds
condition|?
name|ds
operator|->
name|ds_object
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|!=
name|ZIO_CHECKSUM_INHERIT
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_checksum
operator|=
name|zio_checksum_select
argument_list|(
name|newval
argument_list|,
name|ZIO_CHECKSUM_ON_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compression_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|!=
name|ZIO_COMPRESS_INHERIT
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_compress
operator|=
name|zio_compress_select
argument_list|(
name|newval
argument_list|,
name|ZIO_COMPRESS_ON_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copies_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|newval
operator|<=
name|spa_max_replication
argument_list|(
name|osi
operator|->
name|os_spa
argument_list|)
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_copies
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|objset_phys_t
modifier|*
name|osp
init|=
name|buf
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_byteswap
argument_list|(
operator|&
name|osp
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|byteswap_uint64_array
argument_list|(
operator|&
name|osp
operator|->
name|os_zil_header
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|osp
operator|->
name|os_type
operator|=
name|BSWAP_64
argument_list|(
name|osp
operator|->
name|os_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_open_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|objset_impl_t
modifier|*
modifier|*
name|osip
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|winner
decl_stmt|,
modifier|*
name|osi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|checksum
decl_stmt|;
name|osi
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|objset_impl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os
operator|.
name|os
operator|=
name|osi
expr_stmt|;
name|osi
operator|->
name|os_dsl_dataset
operator|=
name|ds
expr_stmt|;
name|osi
operator|->
name|os_spa
operator|=
name|spa
expr_stmt|;
name|osi
operator|->
name|os_rootbp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|osi
operator|->
name|os_rootbp
argument_list|)
condition|)
block|{
name|uint32_t
name|aflags
init|=
name|ARC_WAIT
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
name|zb
operator|.
name|zb_objset
operator|=
name|ds
condition|?
name|ds
operator|->
name|ds_object
else|:
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
literal|0
expr_stmt|;
name|dprintf_bp
argument_list|(
name|osi
operator|->
name|os_rootbp
argument_list|,
literal|"reading %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|err
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|osi
operator|->
name|os_rootbp
argument_list|,
name|dmu_ot
index|[
name|DMU_OT_OBJSET
index|]
operator|.
name|ot_byteswap
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|osi
operator|->
name|os_phys_buf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|osi
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_impl_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|osi
operator|->
name|os_phys
operator|=
name|osi
operator|->
name|os_phys_buf
operator|->
name|b_data
expr_stmt|;
name|arc_release
argument_list|(
name|osi
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|osi
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osi
operator|->
name|os_phys_buf
operator|=
name|arc_buf_alloc
argument_list|(
name|spa
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|,
operator|&
name|osi
operator|->
name|os_phys_buf
argument_list|,
name|ARC_BUFC_METADATA
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_phys
operator|=
name|osi
operator|->
name|os_phys_buf
operator|->
name|b_data
expr_stmt|;
name|bzero
argument_list|(
name|osi
operator|->
name|os_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note: the changed_cb will be called once before the register 	 * func returns, thus changing the checksum/compression from the 	 * default (fletcher2/off).  Snapshots don't need to know, and 	 * registering would complicate clone promotion. 	 */
if|if
condition|(
name|ds
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"checksum"
argument_list|,
name|checksum_changed_cb
argument_list|,
name|osi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"compression"
argument_list|,
name|compression_changed_cb
argument_list|,
name|osi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"copies"
argument_list|,
name|copies_changed_cb
argument_list|,
name|osi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|osi
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|osi
operator|->
name|os_phys_buf
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|osi
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_impl_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
comment|/* It's the meta-objset. */
name|osi
operator|->
name|os_checksum
operator|=
name|ZIO_CHECKSUM_FLETCHER_4
expr_stmt|;
name|osi
operator|->
name|os_compress
operator|=
name|ZIO_COMPRESS_LZJB
expr_stmt|;
name|osi
operator|->
name|os_copies
operator|=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|osi
operator|->
name|os_zil
operator|=
name|zil_alloc
argument_list|(
operator|&
name|osi
operator|->
name|os
argument_list|,
operator|&
name|osi
operator|->
name|os_phys
operator|->
name|os_zil_header
argument_list|)
expr_stmt|;
comment|/* 	 * Metadata always gets compressed and checksummed. 	 * If the data checksum is multi-bit correctable, and it's not 	 * a ZBT-style checksum, then it's suitable for metadata as well. 	 * Otherwise, the metadata checksum defaults to fletcher4. 	 */
name|checksum
operator|=
name|osi
operator|->
name|os_checksum
expr_stmt|;
if|if
condition|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_correctable
operator|&&
operator|!
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_zbt
condition|)
name|osi
operator|->
name|os_md_checksum
operator|=
name|checksum
expr_stmt|;
else|else
name|osi
operator|->
name|os_md_checksum
operator|=
name|ZIO_CHECKSUM_FLETCHER_4
expr_stmt|;
name|osi
operator|->
name|os_md_compress
operator|=
name|ZIO_COMPRESS_LZJB
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|list_create
argument_list|(
operator|&
name|osi
operator|->
name|os_dirty_dnodes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|osi
operator|->
name|os_free_dnodes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_link
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|osi
operator|->
name|os_downgraded_dbufs
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_impl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_buf_impl_t
argument_list|,
name|db_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|osi
operator|->
name|os_obj_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_meta_dnode
operator|=
name|dnode_special_open
argument_list|(
name|osi
argument_list|,
operator|&
name|osi
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
block|{
name|winner
operator|=
name|dsl_dataset_set_user_ptr
argument_list|(
name|ds
argument_list|,
name|osi
argument_list|,
name|dmu_objset_evict
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
argument_list|,
name|osi
argument_list|)
expr_stmt|;
name|osi
operator|=
name|winner
expr_stmt|;
block|}
block|}
operator|*
name|osip
operator|=
name|osi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called from zpl */
end_comment

begin_function
name|int
name|dmu_objset_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|int
name|mode
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|objset_impl_t
modifier|*
name|osi
decl_stmt|;
name|os
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
name|os
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|osi
operator|=
name|dsl_dataset_get_user_ptr
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|osi
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|dmu_objset_open_impl
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|,
operator|&
name|osi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|mode
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|os
operator|->
name|os
operator|=
name|osi
expr_stmt|;
name|os
operator|->
name|os_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|DMU_OST_ANY
operator|&&
name|type
operator|!=
name|os
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
condition|)
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|osp
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_close
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_close
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|os
operator|->
name|os_mode
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_evict_dbufs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
init|=
name|os
operator|->
name|os
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* process the mdn last, since the other dnodes have holds on it */
name|list_remove
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|,
name|osi
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|,
name|osi
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
comment|/* 	 * Find the first dnode with holds.  We have to do this dance 	 * because dnode_add_ref() only works if you already have a 	 * hold.  If there are no holds then it has no dbufs so OK to 	 * skip. 	 */
for|for
control|(
name|dn
operator|=
name|list_head
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|)
init|;
name|dn
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
condition|;
name|dn
operator|=
name|list_next
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|dn
condition|)
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
while|while
condition|(
name|dn
condition|)
block|{
name|dnode_t
modifier|*
name|next_dn
init|=
name|dn
decl_stmt|;
do|do
block|{
name|next_dn
operator|=
name|list_next
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|,
name|next_dn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next_dn
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|next_dn
operator|->
name|dn_holds
argument_list|)
condition|)
do|;
if|if
condition|(
name|next_dn
condition|)
name|dnode_add_ref
argument_list|(
name|next_dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|,
name|try
argument_list|)
condition|)
block|{
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_dn
condition|)
name|dnode_rele
argument_list|(
name|next_dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dn
operator|=
name|next_dn
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_evict
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
init|=
name|arg
decl_stmt|;
name|objset_t
name|os
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|osi
operator|->
name|os_dirty_dnodes
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|osi
operator|->
name|os_free_dnodes
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"checksum"
argument_list|,
name|checksum_changed_cb
argument_list|,
name|osi
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"compression"
argument_list|,
name|compression_changed_cb
argument_list|,
name|osi
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"copies"
argument_list|,
name|copies_changed_cb
argument_list|,
name|osi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We should need only a single pass over the dnode list, since 	 * nothing can be added to the list at this point. 	 */
name|os
operator|.
name|os
operator|=
name|osi
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_evict_dbufs
argument_list|(
operator|&
name|os
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|)
argument_list|,
operator|==
argument_list|,
name|osi
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_tail
argument_list|(
operator|&
name|osi
operator|->
name|os_dnodes
argument_list|)
argument_list|,
operator|==
argument_list|,
name|osi
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|osi
operator|->
name|os_meta_dnode
operator|->
name|dn_dbufs
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnode_special_close
argument_list|(
name|osi
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|zil_free
argument_list|(
name|osi
operator|->
name|os_zil
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|osi
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|osi
operator|->
name|os_phys_buf
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|osi
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|osi
operator|->
name|os_obj_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|osi
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_impl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from dsl for meta-objset */
end_comment

begin_function
name|objset_impl_t
modifier|*
name|dmu_objset_create_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|osi
decl_stmt|;
name|dnode_t
modifier|*
name|mdn
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_objset_open_impl
argument_list|(
name|spa
argument_list|,
name|ds
argument_list|,
name|bp
argument_list|,
operator|&
name|osi
argument_list|)
argument_list|)
expr_stmt|;
name|mdn
operator|=
name|osi
operator|->
name|os_meta_dnode
expr_stmt|;
name|dnode_allocate
argument_list|(
name|mdn
argument_list|,
name|DMU_OT_DNODE
argument_list|,
literal|1
operator|<<
name|DNODE_BLOCK_SHIFT
argument_list|,
name|DN_MAX_INDBLKSHIFT
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * We don't want to have to increase the meta-dnode's nlevels 	 * later, because then we could do it in quescing context while 	 * we are also accessing it in open context. 	 * 	 * This precaution is not necessary for the MOS (ds == NULL), 	 * because the MOS is only updated in syncing context. 	 * This is most fortunate: the MOS is the only objset that 	 * needs to be synced multiple times as spa_sync() iterates 	 * to convergence, so minimizing its dn_nlevels matters. 	 */
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
block|{
name|int
name|levels
init|=
literal|1
decl_stmt|;
comment|/* 		 * Determine the number of levels necessary for the meta-dnode 		 * to contain DN_MAX_OBJECT dnodes. 		 */
while|while
condition|(
operator|(
name|uint64_t
operator|)
name|mdn
operator|->
name|dn_nblkptr
operator|<<
operator|(
name|mdn
operator|->
name|dn_datablkshift
operator|+
operator|(
name|levels
operator|-
literal|1
operator|)
operator|*
operator|(
name|mdn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
operator|)
operator|)
operator|<
name|DN_MAX_OBJECT
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
condition|)
name|levels
operator|++
expr_stmt|;
name|mdn
operator|->
name|dn_next_nlevels
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|mdn
operator|->
name|dn_nlevels
operator|=
name|levels
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|type
operator|!=
name|DMU_OST_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
operator|!=
name|DMU_OST_ANY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
operator|<
name|DMU_OST_NUMTYPES
argument_list|)
expr_stmt|;
name|osi
operator|->
name|os_phys
operator|->
name|os_type
operator|=
name|type
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|osi
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|oscarg
block|{
name|void
function_decl|(
modifier|*
name|userfunc
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
modifier|*
name|userarg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|clone_parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|lastname
decl_stmt|;
name|dmu_objset_type_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dmu_objset_create_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|arg1
decl_stmt|;
name|struct
name|oscarg
modifier|*
name|oa
init|=
name|arg2
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|ddobj
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|oa
operator|->
name|lastname
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ddobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
condition|?
name|err
else|:
name|EEXIST
operator|)
return|;
if|if
condition|(
name|oa
operator|->
name|clone_parent
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * You can't clone across pools. 		 */
if|if
condition|(
name|oa
operator|->
name|clone_parent
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|!=
name|dd
operator|->
name|dd_pool
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
comment|/* 		 * You can only clone snapshots, not the head datasets. 		 */
if|if
condition|(
name|oa
operator|->
name|clone_parent
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_create_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|arg1
decl_stmt|;
name|struct
name|oscarg
modifier|*
name|oa
init|=
name|arg2
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|dd
argument_list|,
name|oa
operator|->
name|lastname
argument_list|,
name|oa
operator|->
name|clone_parent
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dsobj
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_STANDARD
operator||
name|DS_MODE_READONLY
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|objset_impl_t
modifier|*
name|osi
decl_stmt|;
comment|/* This is an empty dmu_objset; not a clone. */
name|osi
operator|=
name|dmu_objset_create_impl
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ds
argument_list|,
name|bp
argument_list|,
name|oa
operator|->
name|type
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|oa
operator|->
name|userfunc
condition|)
name|oa
operator|->
name|userfunc
argument_list|(
operator|&
name|osi
operator|->
name|os
argument_list|,
name|oa
operator|->
name|userarg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_STANDARD
operator||
name|DS_MODE_READONLY
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|objset_t
modifier|*
name|clone_parent
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|pdd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|oscarg
name|oa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ASSERT
argument_list|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|"name=%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oa
operator|.
name|userfunc
operator|=
name|func
expr_stmt|;
name|oa
operator|.
name|userarg
operator|=
name|arg
expr_stmt|;
name|oa
operator|.
name|lastname
operator|=
name|tail
expr_stmt|;
name|oa
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|clone_parent
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * You can't clone to a different type. 		 */
if|if
condition|(
name|clone_parent
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|!=
name|type
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oa
operator|.
name|clone_parent
operator|=
name|clone_parent
operator|->
name|os
operator|->
name|os_dsl_dataset
expr_stmt|;
block|}
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|pdd
operator|->
name|dd_pool
argument_list|,
name|dmu_objset_create_check
argument_list|,
name|dmu_objset_create_sync
argument_list|,
name|pdd
argument_list|,
operator|&
name|oa
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_destroy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If it looks like we'll be able to destroy it, and there's 	 * an unplayed replay log sitting around, destroy the log. 	 * It would be nicer to do this in dsl_dataset_destroy_sync(), 	 * but the replay log objset is modified in open context. 	 */
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_EXCLUSIVE
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zil_destroy
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dsl_dataset_destroy
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_rollback
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|err
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_EXCLUSIVE
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zil_suspend
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|zil_resume
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* XXX uncache everything? */
name|err
operator|=
name|dsl_dataset_rollback
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|snaparg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|char
name|failed
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dmu_objset_snapshot_one
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|snaparg
modifier|*
name|sn
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_objset_stats_t
name|stat
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sn
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_STANDARD
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * If the objset is in an inconsistent state, return busy. 	 */
name|dmu_objset_fast_stat
argument_list|(
name|os
argument_list|,
operator|&
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|dds_inconsistent
condition|)
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 * NB: we need to wait for all in-flight changes to get to disk, 	 * so that we snapshot those changes.  zil_suspend does this as 	 * a side effect. 	 */
name|err
operator|=
name|zil_suspend
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_sync_task_create
argument_list|(
name|sn
operator|->
name|dstg
argument_list|,
name|dsl_dataset_snapshot_check
argument_list|,
name|dsl_dataset_snapshot_sync
argument_list|,
name|os
argument_list|,
name|sn
operator|->
name|snapname
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_snapshot
parameter_list|(
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|struct
name|snaparg
name|sn
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sn
operator|.
name|failed
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sn
operator|.
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|sn
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dmu_objset_snapshot_one
argument_list|,
operator|&
name|sn
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|fsname
argument_list|,
operator|&
name|sn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|sn
operator|.
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|sn
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|sn
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|sn
operator|.
name|failed
argument_list|)
expr_stmt|;
name|zil_resume
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|err
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fsname
argument_list|,
name|sn
operator|.
name|failed
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|sn
operator|.
name|dstg
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_sync_dnodes
parameter_list|(
name|list_t
modifier|*
name|list
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
while|while
condition|(
name|dn
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_data_pending
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize dn_zio outside dnode_sync() 		 * to accomodate meta-dnode 		 */
name|dn
operator|->
name|dn_zio
operator|=
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_data_pending
operator|->
name|dr_zio
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_LEVELS
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|dnode_sync
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|abuf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|os
operator|->
name|os_rootbp
decl_stmt|;
name|dnode_phys_t
modifier|*
name|dnp
init|=
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Update rootbp fill count. 	 */
name|bp
operator|->
name|blk_fill
operator|=
literal|1
expr_stmt|;
comment|/* count the meta-dnode */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|blk_fill
operator|+=
name|dnp
operator|->
name|dn_blkptr
index|[
name|i
index|]
operator|.
name|blk_fill
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|killer
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|abuf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|,
name|DMU_OT_OBJSET
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DVA_EQUAL
argument_list|(
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
name|BP_IDENTITY
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_bp_orig
operator|.
name|blk_birth
operator|==
name|os
operator|->
name|os_synctx
operator|->
name|tx_txg
condition|)
name|dsl_dataset_block_kill
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|,
name|NULL
argument_list|,
name|os
operator|->
name|os_synctx
argument_list|)
expr_stmt|;
name|dsl_dataset_block_born
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|os
operator|->
name|os_synctx
argument_list|)
expr_stmt|;
block|}
name|arc_release
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from dsl */
end_comment

begin_function
name|void
name|dmu_objset_sync
parameter_list|(
name|objset_impl_t
modifier|*
name|os
parameter_list|,
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|int
name|zio_flags
decl_stmt|;
name|dprintf_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
literal|"txg=%llu\n"
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX the write_done callback should really give us the tx... */
name|os
operator|->
name|os_synctx
operator|=
name|tx
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is the MOS.  If we have upgraded, 		 * spa_max_replication() could change, so reset 		 * os_copies here. 		 */
name|os
operator|->
name|os_copies
operator|=
name|spa_max_replication
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the root block IO 	 */
name|zb
operator|.
name|zb_objset
operator|=
name|os
operator|->
name|os_dsl_dataset
condition|?
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
else|:
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
literal|0
expr_stmt|;
name|zio_flags
operator|=
name|ZIO_FLAG_MUSTSUCCEED
expr_stmt|;
if|if
condition|(
name|dmu_ot
index|[
name|DMU_OT_OBJSET
index|]
operator|.
name|ot_metadata
operator|||
name|zb
operator|.
name|zb_level
operator|!=
literal|0
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_METADATA
expr_stmt|;
if|if
condition|(
name|BP_IS_OLDER
argument_list|(
name|os
operator|->
name|os_rootbp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
condition|)
name|dsl_dataset_block_kill
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|os
operator|->
name|os_rootbp
argument_list|,
name|pio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zio
operator|=
name|arc_write
argument_list|(
name|pio
argument_list|,
name|os
operator|->
name|os_spa
argument_list|,
name|os
operator|->
name|os_md_checksum
argument_list|,
name|os
operator|->
name|os_md_compress
argument_list|,
name|dmu_get_replication_level
argument_list|(
name|os
argument_list|,
operator|&
name|zb
argument_list|,
name|DMU_OT_OBJSET
argument_list|)
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|os
operator|->
name|os_rootbp
argument_list|,
name|os
operator|->
name|os_phys_buf
argument_list|,
name|ready
argument_list|,
name|killer
argument_list|,
name|os
argument_list|,
name|ZIO_PRIORITY_ASYNC_WRITE
argument_list|,
name|zio_flags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
comment|/* 	 * Sync meta-dnode - the parent IO for the sync is the root block 	 */
name|os
operator|->
name|os_meta_dnode
operator|->
name|dn_zio
operator|=
name|zio
expr_stmt|;
name|dnode_sync
argument_list|(
name|os
operator|->
name|os_meta_dnode
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txgoff
operator|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
expr_stmt|;
name|dmu_objset_sync_dnodes
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_sync_dnodes
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|os
operator|->
name|os_meta_dnode
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
expr_stmt|;
while|while
condition|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
operator|==
literal|0
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_zio
condition|)
name|zio_nowait
argument_list|(
name|dr
operator|->
name|dr_zio
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free intent log blocks up to this tx. 	 */
name|zil_sync
argument_list|(
name|os
operator|->
name|os_zil
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_space
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
name|dsl_dataset_space
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|refdbytesp
argument_list|,
name|availbytesp
argument_list|,
name|usedobjsp
argument_list|,
name|availobjsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dmu_objset_fsid_guid
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|dsl_dataset_fsid_guid
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_fast_stat
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|stat
operator|->
name|dds_type
operator|=
name|os
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
condition|)
name|dsl_dataset_fast_stat
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|||
name|os
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|==
name|DMU_OST_META
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
name|dsl_dataset_stats
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_TYPE
argument_list|,
name|os
operator|->
name|os
operator|->
name|os_phys
operator|->
name|os_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_is_snapshot
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dsl_dataset_is_snapshot
argument_list|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_snapshot_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|zap_cursor_t
name|cursor
decl_stmt|;
name|zap_attribute_t
name|attr
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|cursor
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_cursor_retrieve
argument_list|(
operator|&
name|cursor
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attr
operator|.
name|za_name
argument_list|)
operator|+
literal|1
operator|>
name|namelen
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
condition|)
operator|*
name|idp
operator|=
name|attr
operator|.
name|za_first_integer
expr_stmt|;
name|zap_cursor_advance
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|offp
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_dir_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_dir
decl_stmt|;
name|zap_cursor_t
name|cursor
decl_stmt|;
name|zap_attribute_t
name|attr
decl_stmt|;
comment|/* there is no next dir on a snapshot! */
if|if
condition|(
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
operator|!=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|cursor
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_cursor_retrieve
argument_list|(
operator|&
name|cursor
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attr
operator|.
name|za_name
argument_list|)
operator|+
literal|1
operator|>
name|namelen
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
condition|)
operator|*
name|idp
operator|=
name|attr
operator|.
name|za_first_integer
expr_stmt|;
name|zap_cursor_advance
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|offp
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find all objsets under name, and for each, call 'func(child_name, arg)'.  */
end_comment

begin_function
name|int
name|dmu_objset_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|func
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|snapobj
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|attr
decl_stmt|;
name|char
modifier|*
name|child
decl_stmt|;
name|int
name|do_self
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* NB: the $MOS dir doesn't have a head dataset */
name|do_self
operator|=
operator|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Iterate over all children. 	 */
if|if
condition|(
name|flags
operator|&
name|DS_FIND_CHILDREN
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|attr
operator|.
name|za_integer_length
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|attr
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * No separating '/' because parent's name ends in /. 			 */
name|child
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* XXX could probably just use name here */
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|child
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|child
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|child
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|child
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|child
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 	 * Iterate over all snapshots. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DS_FIND_SNAPSHOTS
operator|)
operator|&&
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|DS_MODE_STANDARD
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|os
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snapobj
operator|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|snapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|attr
operator|.
name|za_integer_length
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|attr
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|child
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* XXX could probably just use name here */
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|child
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|child
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|child
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|func
argument_list|(
name|child
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|child
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Apply to self if appropriate. 	 */
if|if
condition|(
name|do_self
condition|)
name|err
operator|=
name|func
argument_list|(
name|name
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

