begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunldi.h>
end_include

begin_comment
comment|/*  * Virtual device vector for disks.  */
end_comment

begin_decl_stmt
specifier|extern
name|ldi_ident_t
name|zfs_li
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|vdev_disk_buf
block|{
name|buf_t
name|vdb_buf
decl_stmt|;
name|zio_t
modifier|*
name|vdb_io
decl_stmt|;
block|}
name|vdev_disk_buf_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|vdev_disk_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|psize
parameter_list|,
name|uint64_t
modifier|*
name|ashift
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
decl_stmt|;
name|struct
name|dk_minfo
name|dkm
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * We must have a pathname, and it must be absolute. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|==
name|NULL
operator|||
name|vd
operator|->
name|vdev_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_disk_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * When opening a disk device, we want to preserve the user's original 	 * intent.  We always want to open the device by the path the user gave 	 * us, even if it is one of multiple paths to the save device.  But we 	 * also want to be able to survive disks being removed/recabled. 	 * Therefore the sequence of opening devices is: 	 * 	 * 1. Try opening the device by path.  For legacy pools without the 	 *    'whole_disk' property, attempt to fix the path by appending 's0'. 	 * 	 * 2. If the devid of the device matches the stored value, return 	 *    success. 	 * 	 * 3. Otherwise, the device may have moved.  Try opening the device 	 *    by the devid instead. 	 * 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ddi_devid_str_decode
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|,
operator|&
name|dvd
operator|->
name|vd_devid
argument_list|,
operator|&
name|dvd
operator|->
name|vd_minor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* presume failure */
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
block|{
name|ddi_devid_t
name|devid
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|==
operator|-
literal|1ULL
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|kmem_alloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|ldi_handle_t
name|lh
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%ss0"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldi_open_by_name
argument_list|(
name|buf
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|,
operator|&
name|lh
argument_list|,
name|zfs_li
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_path
operator|=
name|buf
expr_stmt|;
name|vd
operator|->
name|vdev_wholedisk
operator|=
literal|1ULL
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|lh
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|ldi_open_by_name
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
comment|/* 		 * Compare the devid to the stored value. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
operator|&&
name|ldi_get_devid
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ddi_devid_compare
argument_list|(
name|devid
argument_list|,
name|dvd
operator|->
name|vd_devid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|dvd
operator|->
name|vd_lh
operator|=
name|NULL
expr_stmt|;
block|}
name|ddi_devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we succeeded in opening the device, but 'vdev_wholedisk' 		 * is not yet set, then this must be a slice. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_wholedisk
operator|==
operator|-
literal|1ULL
condition|)
name|vd
operator|->
name|vdev_wholedisk
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we were unable to open by path, or the devid check fails, open by 	 * devid instead. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
name|error
operator|=
name|ldi_open_by_devid
argument_list|(
name|dvd
operator|->
name|vd_devid
argument_list|,
name|dvd
operator|->
name|vd_minor
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_OPEN_FAILED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Determine the actual size of the device. 	 */
if|if
condition|(
name|ldi_get_size
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|psize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_OPEN_FAILED
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If we own the whole disk, try to enable disk write caching. 	 * We ignore errors because it's OK if we can't do it. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|==
literal|1
condition|)
block|{
name|int
name|wce
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCSETWCE
argument_list|,
operator|(
name|intptr_t
operator|)
operator|&
name|wce
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine the device's minimum transfer size. 	 * If the ioctl isn't supported, assume DEV_BSIZE. 	 */
if|if
condition|(
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCGMEDIAINFO
argument_list|,
operator|(
name|intptr_t
operator|)
operator|&
name|dkm
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|dkm
operator|.
name|dki_lbsize
operator|=
name|DEV_BSIZE
expr_stmt|;
operator|*
name|ashift
operator|=
name|highbit
argument_list|(
name|MAX
argument_list|(
name|dkm
operator|.
name|dki_lbsize
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Clear the nowritecache bit, so that on a vdev_reopen() we will 	 * try again. 	 */
name|vd
operator|->
name|vdev_nowritecache
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
if|if
condition|(
name|dvd
operator|==
name|NULL
condition|)
return|return;
name|dprintf
argument_list|(
literal|"removing disk %s, devid %s\n"
argument_list|,
name|vd
operator|->
name|vdev_path
condition|?
name|vd
operator|->
name|vdev_path
else|:
literal|"<none>"
argument_list|,
name|vd
operator|->
name|vdev_devid
condition|?
name|vd
operator|->
name|vdev_devid
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvd
operator|->
name|vd_minor
operator|!=
name|NULL
condition|)
name|ddi_devid_str_free
argument_list|(
name|dvd
operator|->
name|vd_minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvd
operator|->
name|vd_devid
operator|!=
name|NULL
condition|)
name|ddi_devid_free
argument_list|(
name|dvd
operator|->
name|vd_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvd
operator|->
name|vd_lh
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|spa_mode
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dvd
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_disk_t
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_tsd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_intr
parameter_list|(
name|buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|vdev_disk_buf_t
modifier|*
name|vdb
init|=
operator|(
name|vdev_disk_buf_t
operator|*
operator|)
name|bp
decl_stmt|;
name|zio_t
modifier|*
name|zio
init|=
name|vdb
operator|->
name|vdb_io
decl_stmt|;
if|if
condition|(
operator|(
name|zio
operator|->
name|io_error
operator|=
name|geterror
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|EIO
expr_stmt|;
name|kmem_free
argument_list|(
name|vdb
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_disk_buf_t
argument_list|)
argument_list|)
expr_stmt|;
name|zio_next_stage_async
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_ioctl_done
parameter_list|(
name|void
modifier|*
name|zio_arg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|zio_arg
decl_stmt|;
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
name|zio_next_stage_async
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|vdev_disk_buf_t
modifier|*
name|vdb
decl_stmt|;
name|buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_IOCTL
condition|)
block|{
name|zio_vdev_io_bypass
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* XXPOLICY */
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|ENXIO
expr_stmt|;
name|zio_next_stage_async
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|zio
operator|->
name|io_cmd
condition|)
block|{
case|case
name|DKIOCFLUSHWRITECACHE
case|:
if|if
condition|(
name|zfs_nocacheflush
condition|)
break|break;
if|if
condition|(
name|vd
operator|->
name|vdev_nowritecache
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
name|zio
operator|->
name|io_dk_callback
operator|.
name|dkc_callback
operator|=
name|vdev_disk_ioctl_done
expr_stmt|;
name|zio
operator|->
name|io_dk_callback
operator|.
name|dkc_cookie
operator|=
name|zio
expr_stmt|;
name|error
operator|=
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zio
operator|->
name|io_cmd
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|zio
operator|->
name|io_dk_callback
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The ioctl will be done asychronously, 				 * and will call vdev_disk_ioctl_done() 				 * upon completion. 				 */
return|return;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOTSUP
condition|)
block|{
comment|/* 				 * If we get ENOTSUP, we know that no future 				 * attempts will ever succeed.  In this case we 				 * set a persistent bit so that we don't bother 				 * with the ioctl in the future. 				 */
name|vd
operator|->
name|vdev_nowritecache
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
break|break;
default|default:
name|zio
operator|->
name|io_error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
name|zio_next_stage_async
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|vdev_cache_read
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|zio
operator|=
name|vdev_queue_io
argument_list|(
name|zio
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|flags
operator|=
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|?
name|B_READ
else|:
name|B_WRITE
operator|)
expr_stmt|;
name|flags
operator||=
name|B_BUSY
operator||
name|B_NOCACHE
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_FAILFAST
condition|)
name|flags
operator||=
name|B_FAILFAST
expr_stmt|;
name|vdb
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_disk_buf_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vdb
operator|->
name|vdb_io
operator|=
name|zio
expr_stmt|;
name|bp
operator|=
operator|&
name|vdb
operator|->
name|vdb_buf
expr_stmt|;
name|bioinit
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|flags
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|lbtodb
argument_list|(
name|zio
operator|->
name|io_offset
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|vdev_disk_io_intr
expr_stmt|;
comment|/* XXPOLICY */
name|error
operator|=
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|?
name|ENXIO
else|:
name|vdev_error_inject
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
name|bioerror
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|ldi_strategy
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* ldi_strategy() will return non-zero only on programming errors */
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
name|vdev_cache_write
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_device_injection
argument_list|(
name|zio
operator|->
name|io_vd
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|zio_next_stage
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_disk_ops
init|=
block|{
name|vdev_disk_open
block|,
name|vdev_disk_close
block|,
name|vdev_default_asize
block|,
name|vdev_disk_io_start
block|,
name|vdev_disk_io_done
block|,
name|NULL
block|,
name|VDEV_TYPE_DISK
block|,
comment|/* name of this vdev type */
name|B_TRUE
comment|/* leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

end_unit

