begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_function
specifier|static
name|void
name|dnode_increase_indirection
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|nblkptr
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
decl_stmt|;
name|int
name|old_toplvl
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|-
literal|1
decl_stmt|;
name|int
name|new_level
init|=
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* this dnode can't be paged out because it's dirty */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_level
operator|>
literal|1
operator|&&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|=
name|new_level
expr_stmt|;
name|dprintf
argument_list|(
literal|"os=%p obj=%llu, increase to %d\n"
argument_list|,
name|dn
operator|->
name|dn_objset
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
comment|/* check for existing blkptrs in the dnode */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblkptr
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|nblkptr
condition|)
block|{
comment|/* transfer dnode's block pointers to new indirect block */
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
operator||
name|DB_RF_HAVESTRUCT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_released
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|)
expr_stmt|;
name|arc_buf_freeze
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
block|}
comment|/* set dbuf's parent pointers to new indirect buf */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblkptr
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|child
init|=
name|dbuf_find
argument_list|(
name|dn
argument_list|,
name|old_toplvl
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
continue|continue;
name|ASSERT3P
argument_list|(
name|child
operator|->
name|db_dnode
argument_list|,
operator|==
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|db_parent
operator|&&
name|child
operator|->
name|db_parent
operator|!=
name|dn
operator|->
name|dn_dbuf
condition|)
block|{
name|ASSERT
argument_list|(
name|child
operator|->
name|db_parent
operator|->
name|db_level
operator|==
name|db
operator|->
name|db_level
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|child
operator|->
name|db_blkptr
operator|!=
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
name|child
operator|->
name|db_blkid
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|child
operator|->
name|db_parent
operator|==
name|NULL
operator|||
name|child
operator|->
name|db_parent
operator|==
name|dn
operator|->
name|dn_dbuf
argument_list|)
expr_stmt|;
name|child
operator|->
name|db_parent
operator|=
name|db
expr_stmt|;
name|dbuf_add_ref
argument_list|(
name|db
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db
operator|.
name|db_data
condition|)
name|child
operator|->
name|db_blkptr
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
name|db
operator|->
name|db
operator|.
name|db_data
operator|+
name|i
expr_stmt|;
else|else
name|child
operator|->
name|db_blkptr
operator|=
name|NULL
expr_stmt|;
name|dprintf_dbuf_bp
argument_list|(
name|child
argument_list|,
name|child
operator|->
name|db_blkptr
argument_list|,
literal|"changed db_blkptr to new indirect %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
name|nblkptr
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_blocks
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|num
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|uint64_t
name|bytesfreed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dprintf
argument_list|(
literal|"os=%p obj=%llx num=%d\n"
argument_list|,
name|os
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|bytesfreed
operator|+=
name|bp_get_dasize
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bytesfreed
argument_list|,
operator|<=
argument_list|,
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_block_kill
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|bp
argument_list|,
name|dn
operator|->
name|dn_zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnode_diduse_space
argument_list|(
name|dn
argument_list|,
operator|-
name|bytesfreed
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|free_verify
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|off
decl_stmt|,
name|num
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|epbs
decl_stmt|;
name|uint64_t
name|txg
init|=
name|tx
operator|->
name|tx_txg
decl_stmt|;
name|epbs
operator|=
name|db
operator|->
name|db_dnode
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|off
operator|=
name|start
operator|-
operator|(
name|db
operator|->
name|db_blkid
operator|*
literal|1
operator|<<
name|epbs
operator|)
expr_stmt|;
name|num
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|num
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_level
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|,
operator|==
argument_list|,
literal|1
operator|<<
name|db
operator|->
name|db_dnode
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
operator|+
name|num
argument_list|,
operator|<=
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_size
operator|>>
name|SPA_BLKPTRSHIFT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_blkptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
init|;
name|i
operator|<
name|off
operator|+
name|num
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
modifier|*
name|buf
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|child
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_level
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|db
operator|->
name|db_dnode
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbuf_hold_impl
argument_list|(
name|db
operator|->
name|db_dnode
argument_list|,
name|db
operator|->
name|db_level
operator|-
literal|1
argument_list|,
operator|(
name|db
operator|->
name|db_blkid
operator|<<
name|epbs
operator|)
operator|+
name|i
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|child
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|db
operator|->
name|db_dnode
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|child
operator|->
name|db_level
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dr
operator|=
name|child
operator|->
name|db_last_dirty
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|dr
operator|->
name|dr_txg
operator|>
name|txg
condition|)
name|dr
operator|=
name|dr
operator|->
name|dr_next
expr_stmt|;
name|ASSERT
argument_list|(
name|dr
operator|==
name|NULL
operator|||
name|dr
operator|->
name|dr_txg
operator|==
name|txg
argument_list|)
expr_stmt|;
comment|/* data_old better be zeroed */
if|if
condition|(
name|dr
condition|)
block|{
name|buf
operator|=
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child
operator|->
name|db
operator|.
name|db_size
operator|>>
literal|3
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"freed data not zero: "
literal|"child=%p i=%d off=%d num=%d\n"
argument_list|,
name|child
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * db_data better be zeroed unless it's dirty in a 		 * future txg. 		 */
name|mutex_enter
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|buf
operator|=
name|child
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|child
operator|->
name|db_state
operator|!=
name|DB_FILL
operator|&&
name|child
operator|->
name|db_last_dirty
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child
operator|->
name|db
operator|.
name|db_size
operator|>>
literal|3
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"freed data not zero: "
literal|"child=%p i=%d off=%d num=%d\n"
argument_list|,
name|child
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|child
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|child
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|free_children
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|int
name|trunc
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|db
operator|->
name|db_dnode
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|subdb
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|dbstart
decl_stmt|,
name|dbend
decl_stmt|,
name|i
decl_stmt|;
name|int
name|epbs
decl_stmt|,
name|shift
decl_stmt|,
name|err
decl_stmt|;
name|int
name|all
init|=
name|TRUE
decl_stmt|;
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
argument_list|)
expr_stmt|;
name|arc_release
argument_list|(
name|db
operator|->
name|db_buf
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
name|epbs
operator|=
name|db
operator|->
name|db_dnode
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|shift
operator|=
operator|(
name|db
operator|->
name|db_level
operator|-
literal|1
operator|)
operator|*
name|epbs
expr_stmt|;
name|dbstart
operator|=
name|db
operator|->
name|db_blkid
operator|<<
name|epbs
expr_stmt|;
name|start
operator|=
name|blkid
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
name|dbstart
operator|<
name|start
condition|)
block|{
name|bp
operator|+=
name|start
operator|-
name|dbstart
expr_stmt|;
name|all
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|dbstart
expr_stmt|;
block|}
name|dbend
operator|=
operator|(
operator|(
name|db
operator|->
name|db_blkid
operator|+
literal|1
operator|)
operator|<<
name|epbs
operator|)
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|(
name|blkid
operator|+
name|nblks
operator|-
literal|1
operator|)
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
name|dbend
operator|<=
name|end
condition|)
name|end
operator|=
name|dbend
expr_stmt|;
elseif|else
if|if
condition|(
name|all
condition|)
name|all
operator|=
name|trunc
expr_stmt|;
name|ASSERT3U
argument_list|(
name|start
argument_list|,
operator|<=
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_level
operator|==
literal|1
condition|)
block|{
name|FREE_VERIFY
argument_list|(
name|db
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|arc_buf_freeze
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|all
operator|||
name|db
operator|->
name|db_last_dirty
argument_list|)
expr_stmt|;
return|return
operator|(
name|all
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|db
operator|->
name|db_level
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|subdb
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_children
argument_list|(
name|subdb
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|trunc
argument_list|,
name|tx
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|subdb
operator|->
name|db_blkptr
argument_list|,
operator|==
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|all
operator|=
name|FALSE
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|subdb
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|arc_buf_freeze
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|bp
operator|-=
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|start
operator|&&
name|blkid
operator|!=
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|==
name|end
operator|&&
operator|!
name|trunc
condition|)
continue|continue;
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ASSERT
argument_list|(
name|all
operator|||
name|db
operator|->
name|db_last_dirty
argument_list|)
expr_stmt|;
return|return
operator|(
name|all
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free_range: Traverse the indicated range of the provided file  * and "free" all the blocks contained there.  */
end_comment

begin_function
specifier|static
name|void
name|dnode_sync_free_range
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|trunc
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|shift
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
name|int
name|dnlevel
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
decl_stmt|;
if|if
condition|(
name|blkid
operator|>
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
condition|)
return|return;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|<
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|trunc
operator|=
name|blkid
operator|+
name|nblks
operator|>
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
name|nblks
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|-
name|blkid
operator|+
literal|1
expr_stmt|;
comment|/* There are no indirect blocks in the object */
if|if
condition|(
name|dnlevel
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|blkid
operator|>=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
condition|)
block|{
comment|/* this range was never made persistent */
return|return;
block|}
name|ASSERT3U
argument_list|(
name|blkid
operator|+
name|nblks
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
operator|+
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
block|{
name|uint64_t
name|off
init|=
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|*
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
operator|)
decl_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|=
operator|(
name|blkid
condition|?
name|blkid
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|off
operator|<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|||
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|==
literal|0
operator|||
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|FALSE
argument_list|,
operator|&
name|off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|shift
operator|=
operator|(
name|dnlevel
operator|-
literal|1
operator|)
operator|*
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
operator|)
expr_stmt|;
name|start
operator|=
name|blkid
operator|>>
name|shift
expr_stmt|;
name|ASSERT
argument_list|(
name|start
operator|<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
argument_list|)
expr_stmt|;
name|end
operator|=
operator|(
name|blkid
operator|+
name|nblks
operator|-
literal|1
operator|)
operator|>>
name|shift
expr_stmt|;
name|bp
operator|+=
name|start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
continue|continue;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|dnlevel
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_children
argument_list|(
name|db
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|trunc
argument_list|,
name|tx
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|,
operator|==
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|free_blocks
argument_list|(
name|dn
argument_list|,
name|bp
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trunc
condition|)
block|{
name|uint64_t
name|off
init|=
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|*
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
operator|)
decl_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|=
operator|(
name|blkid
condition|?
name|blkid
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|off
operator|<
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|||
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|==
literal|0
operator|||
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|FALSE
argument_list|,
operator|&
name|off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to kick all the dnodes dbufs out of the cache...  */
end_comment

begin_function
name|int
name|dnode_evict_dbufs
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|int
name|progress
decl_stmt|;
name|int
name|pass
init|=
literal|0
decl_stmt|;
do|do
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|,
name|marker
decl_stmt|;
name|int
name|evicting
init|=
name|FALSE
decl_stmt|;
name|progress
operator|=
name|FALSE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
name|db
operator|=
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|db
operator|!=
operator|&
name|marker
condition|;
name|db
operator|=
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
control|)
block|{
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_state
operator|==
name|DB_EVICTING
condition|)
block|{
name|progress
operator|=
name|TRUE
expr_stmt|;
name|evicting
operator|=
name|TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|db
operator|->
name|db_holds
argument_list|)
condition|)
block|{
name|progress
operator|=
name|TRUE
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|arc_released
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dbuf_clear
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* exits db_mtx for us */
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
comment|/* 		 * NB: we need to drop dn_dbufs_mtx between passes so 		 * that any DB_EVICTING dbufs can make progress. 		 * Ideally, we would have some cv we could wait on, but 		 * since we don't, just wait a bit to give the other 		 * thread a chance to run. 		 */
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|evicting
condition|)
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pass
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|pass
operator|<
literal|100
argument_list|)
expr_stmt|;
comment|/* sanity check */
block|}
do|while
condition|(
name|progress
condition|)
do|;
comment|/* 	 * This function works fine even if it can't evict everything. 	 * If were only asked to try to evict everything then 	 * return an error if we can't. Otherwise panic as the caller 	 * expects total eviction. 	 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|try
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"dangling dbufs (dn=%p, dbuf=%p)\n"
argument_list|,
name|dn
argument_list|,
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_holds
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_evict
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_undirty_dbufs
parameter_list|(
name|list_t
modifier|*
name|list
parameter_list|)
block|{
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
while|while
condition|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dr
operator|->
name|dr_dbuf
decl_stmt|;
name|uint64_t
name|txg
init|=
name|dr
operator|->
name|dr_txg
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
comment|/* XXX - use dbuf_undirty()? */
name|list_remove
argument_list|(
name|list
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_last_dirty
operator|==
name|dr
argument_list|)
expr_stmt|;
name|db
operator|->
name|db_last_dirty
operator|=
name|NULL
expr_stmt|;
name|db
operator|->
name|db_dirtycnt
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_level
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|db
operator|->
name|db_blkid
operator|==
name|DB_BONUS_BLKID
operator|||
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
operator|==
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
name|dbuf_unoverride
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dnode_undirty_dbufs
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_children
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|dr
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf_dirty_record_t
argument_list|)
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_sync_free
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_undirty_dbufs
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - It would be nice to assert this, but we may still 	 * have residual holds from async evictions from the arc... 	 * 	 * zfs_obj_to_path() also depends on this being 	 * commented out. 	 * 	 * ASSERT3U(refcount_count(&dn->dn_holds), ==, 1); 	 */
comment|/* Undirty next bits */
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
comment|/* free up all the blocks in the file. */
name|dnode_sync_free_range
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|+
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ASSERT(blkptrs are zero); */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_allocated_txg
operator|!=
name|dn
operator|->
name|dn_free_txg
condition|)
name|dbuf_will_dirty
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_type
operator|=
name|DMU_OT_NONE
expr_stmt|;
name|dn
operator|->
name|dn_maxblkid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_allocated_txg
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've released our hold, the dnode may 	 * be evicted, so we musn't access it. 	 */
block|}
end_function

begin_comment
comment|/*  * Write out the dnode's dirty buffers.  *  * NOTE: The dnode is kept in memory by being dirty.  Once the  * dirty bit is cleared, it may be evicted.  Beware of this!  */
end_comment

begin_function
name|void
name|dnode_sync
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|free_range_t
modifier|*
name|rp
decl_stmt|;
name|dnode_phys_t
modifier|*
name|dnp
init|=
name|dn
operator|->
name|dn_phys
decl_stmt|;
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|==
name|NULL
operator|||
name|arc_released
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_buf
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_allocated_txg
operator|==
name|tx
operator|->
name|tx_txg
condition|)
block|{
comment|/* The dnode is newly allocated or reallocated */
if|if
condition|(
name|dnp
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
condition|)
block|{
comment|/* this is a first alloc, not a realloc */
comment|/* XXX shouldn't the phys already be zeroed? */
name|bzero
argument_list|(
name|dnp
argument_list|,
name|DNODE_CORE_SIZE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_nlevels
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_nblkptr
operator|>
name|dnp
operator|->
name|dn_nblkptr
condition|)
block|{
comment|/* zero the new blkptrs we are gaining */
name|bzero
argument_list|(
name|dnp
operator|->
name|dn_blkptr
operator|+
name|dnp
operator|->
name|dn_nblkptr
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|*
operator|(
name|dn
operator|->
name|dn_nblkptr
operator|-
name|dnp
operator|->
name|dn_nblkptr
operator|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
name|dnp
operator|->
name|dn_bonustype
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|dnp
operator|->
name|dn_bonuslen
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
name|dnp
operator|->
name|dn_nblkptr
operator|=
name|dn
operator|->
name|dn_nblkptr
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nlevels
operator|>
literal|1
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|BP_GET_LSIZE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|==
name|dnp
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
condition|)
block|{
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|list_head
argument_list|(
name|list
argument_list|)
operator|!=
name|NULL
operator|||
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|>>
name|SPA_MINBLOCKSHIFT
operator|==
name|dnp
operator|->
name|dn_datablkszsec
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_datablkszsec
operator|=
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
condition|)
block|{
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nlevels
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_indblkshift
operator|=
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Just take the live (open-context) values for checksum and compress. 	 * Strictly speaking it's a future leak, but nothing bad happens if we 	 * start using the new checksum or compress algorithm a little early. 	 */
name|dnp
operator|->
name|dn_checksum
operator|=
name|dn
operator|->
name|dn_checksum
expr_stmt|;
name|dnp
operator|->
name|dn_compress
operator|=
name|dn
operator|->
name|dn_compress
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
comment|/* process all the "freed" ranges in the file */
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|==
literal|0
operator|||
name|dn
operator|->
name|dn_free_txg
operator|>
name|tx
operator|->
name|tx_txg
condition|)
block|{
for|for
control|(
name|rp
operator|=
name|avl_last
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|txgoff
index|]
argument_list|)
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|AVL_PREV
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|txgoff
index|]
argument_list|,
name|rp
argument_list|)
control|)
name|dnode_sync_free_range
argument_list|(
name|dn
argument_list|,
name|rp
operator|->
name|fr_blkid
argument_list|,
name|rp
operator|->
name|fr_nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|avl_first
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|txgoff
index|]
argument_list|)
init|;
name|rp
condition|;
control|)
block|{
name|free_range_t
modifier|*
name|last
init|=
name|rp
decl_stmt|;
name|rp
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|txgoff
index|]
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|txgoff
index|]
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|free_range_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
operator|&&
name|dn
operator|->
name|dn_free_txg
operator|<=
name|tx
operator|->
name|tx_txg
condition|)
block|{
name|dnode_sync_free
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
condition|)
block|{
name|dnode_increase_indirection
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dbuf_sync_list
argument_list|(
name|list
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
condition|)
block|{
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
name|list
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Although we have dropped our reference to the dnode, it 	 * can't be evicted until its written, and we haven't yet 	 * initiated the IO for the dnode's dbuf. 	 */
block|}
end_function

end_unit

