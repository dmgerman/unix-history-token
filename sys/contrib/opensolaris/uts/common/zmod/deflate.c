begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/* deflate.c -- compress data using the deflation algorithm  * Copyright (C) 1995-2005 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  *  ALGORITHM  *  *      The "deflation" process depends on being able to identify portions  *      of the input text which are identical to earlier input (within a  *      sliding window trailing behind the input currently being processed).  *  *      The most straightforward technique turns out to be the fastest for  *      most input files: try all possible matches and select the longest.  *      The key feature of this algorithm is that insertions into the string  *      dictionary are very simple and thus fast, and deletions are avoided  *      completely. Insertions are performed at each input character, whereas  *      string matches are performed only when the previous match ends. So it  *      is preferable to spend more time in matches to allow very fast string  *      insertions and avoid deletions. The matching algorithm for small  *      strings is inspired from that of Rabin& Karp. A brute force approach  *      is used to find longer strings when a small match has been found.  *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze  *      (by Leonid Broukhis).  *         A previous version of this file used a more sophisticated algorithm  *      (by Fiala and Greene) which is guaranteed to run in linear amortized  *      time, but has a larger average cost, uses more memory and is patented.  *      However the F&G algorithm may be faster for some highly redundant  *      files if the parameter max_chain_length (described below) is too large.  *  *  ACKNOWLEDGEMENTS  *  *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and  *      I found it in 'freeze' written by Leonid Broukhis.  *      Thanks to many people for bug reports and testing.  *  *  REFERENCES  *  *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".  *      Available in http://www.ietf.org/rfc/rfc1951.txt  *  *      A description of the Rabin and Karp algorithm is given in the book  *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.  *  *      Fiala,E.R., and Greene,D.H.  *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595  *  */
end_comment

begin_include
include|#
directive|include
file|"deflate.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|deflate_copyright
index|[]
init|=
literal|" deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   If you use the zlib library in a product, an acknowledgment is welcome   in the documentation of your product. If for some reason you cannot   include such an acknowledgment, I would appreciate that you keep this   copyright string in the executable of your product.  */
end_comment

begin_comment
comment|/* ===========================================================================  *  Function prototypes.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|need_more
block|,
comment|/* block not completed, need more input or more output */
name|block_done
block|,
comment|/* block flush performed */
name|finish_started
block|,
comment|/* finish started, need only more output at next deflate */
name|finish_done
comment|/* finish done, accept no more input or output */
block|}
name|block_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|block_state
argument_list|(
argument|*compress_func
argument_list|)
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* Compression function. Returns the block state after the call. */
end_comment

begin_decl_stmt
name|local
name|void
name|fill_window
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|block_state
name|deflate_stored
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|block_state
name|deflate_fast
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FASTEST
end_ifndef

begin_decl_stmt
name|local
name|block_state
name|deflate_slow
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|local
name|void
name|lm_init
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|putShortMSB
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|uInt
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|flush_pending
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|read_buf
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|Bytef
operator|*
name|buf
operator|,
name|unsigned
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FASTEST
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ASMV
end_ifdef

begin_decl_stmt
name|void
name|match_init
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* asm code initialization */
end_comment

begin_decl_stmt
name|uInt
name|longest_match
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|cur_match
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|local
name|uInt
name|longest_match
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|cur_match
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|local
name|uInt
name|longest_match_fast
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|cur_match
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|local
name|void
name|check_match
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|start
operator|,
name|IPos
name|match
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Local data  */
end_comment

begin_define
define|#
directive|define
name|NIL
value|0
end_define

begin_comment
comment|/* Tail of hash chains */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TOO_FAR
end_ifndef

begin_define
define|#
directive|define
name|TOO_FAR
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
end_comment

begin_define
define|#
directive|define
name|MIN_LOOKAHEAD
value|(MAX_MATCH+MIN_MATCH+1)
end_define

begin_comment
comment|/* Minimum amount of lookahead, except at the end of the input file.  * See deflate.c for comments about the MIN_MATCH+1.  */
end_comment

begin_comment
comment|/* Values for max_lazy_match, good_match and max_chain_length, depending on  * the desired pack level (0..9). The values given below have been tuned to  * exclude worst case performance for pathological files. Better values may be  * found for specific files.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|config_s
block|{
name|ush
name|good_length
decl_stmt|;
comment|/* reduce lazy search above this match length */
name|ush
name|max_lazy
decl_stmt|;
comment|/* do not perform lazy search above this match length */
name|ush
name|nice_length
decl_stmt|;
comment|/* quit search above this match length */
name|ush
name|max_chain
decl_stmt|;
name|compress_func
name|func
decl_stmt|;
block|}
name|config
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|FASTEST
end_ifdef

begin_decl_stmt
name|local
specifier|const
name|config
name|configuration_table
index|[
literal|2
index|]
init|=
block|{
comment|/*      good lazy nice chain */
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|deflate_stored
block|}
block|,
comment|/* store only */
comment|/* 1 */
block|{
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|deflate_fast
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max speed, no lazy matches */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|local
specifier|const
name|config
name|configuration_table
index|[
literal|10
index|]
init|=
block|{
comment|/*      good lazy nice chain */
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|deflate_stored
block|}
block|,
comment|/* store only */
comment|/* 1 */
block|{
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|deflate_fast
block|}
block|,
comment|/* max speed, no lazy matches */
comment|/* 2 */
block|{
literal|4
block|,
literal|5
block|,
literal|16
block|,
literal|8
block|,
name|deflate_fast
block|}
block|,
comment|/* 3 */
block|{
literal|4
block|,
literal|6
block|,
literal|32
block|,
literal|32
block|,
name|deflate_fast
block|}
block|,
comment|/* 4 */
block|{
literal|4
block|,
literal|4
block|,
literal|16
block|,
literal|16
block|,
name|deflate_slow
block|}
block|,
comment|/* lazy matches */
comment|/* 5 */
block|{
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|32
block|,
name|deflate_slow
block|}
block|,
comment|/* 6 */
block|{
literal|8
block|,
literal|16
block|,
literal|128
block|,
literal|128
block|,
name|deflate_slow
block|}
block|,
comment|/* 7 */
block|{
literal|8
block|,
literal|32
block|,
literal|128
block|,
literal|256
block|,
name|deflate_slow
block|}
block|,
comment|/* 8 */
block|{
literal|32
block|,
literal|128
block|,
literal|258
block|,
literal|1024
block|,
name|deflate_slow
block|}
block|,
comment|/* 9 */
block|{
literal|32
block|,
literal|258
block|,
literal|258
block|,
literal|4096
block|,
name|deflate_slow
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max compression */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Note: the deflate() code requires max_lazy>= MIN_MATCH and max_chain>= 4  * For deflate_fast() (levels<= 3) good is ignored and lazy has a different  * meaning.  */
end_comment

begin_define
define|#
directive|define
name|EQUAL
value|0
end_define

begin_comment
comment|/* result of memcmp for equal strings */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DUMMY_DECL
end_ifndef

begin_struct
struct|struct
name|static_tree_desc_s
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Update a hash value with the given input byte  * IN  assertion: all calls to to UPDATE_HASH are made with consecutive  *    input characters, so that a running hash key can be computed from the  *    previous key instead of complete recalculation each time.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_HASH
parameter_list|(
name|s
parameter_list|,
name|h
parameter_list|,
name|c
parameter_list|)
value|(h = (((h)<<s->hash_shift) ^ (c))& s->hash_mask)
end_define

begin_comment
comment|/* ===========================================================================  * Insert string str in the dictionary and set match_head to the previous head  * of the hash chain (the most recent string with same hash key). Return  * the previous length of the hash chain.  * If this file is compiled with -DFASTEST, the compression level is forced  * to 1, and no hash chains are maintained.  * IN  assertion: all calls to to INSERT_STRING are made with consecutive  *    input characters and the first MIN_MATCH bytes of str are valid  *    (except for the last MIN_MATCH-1 bytes of the input file).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FASTEST
end_ifdef

begin_define
define|#
directive|define
name|INSERT_STRING
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|,
name|match_head
parameter_list|)
define|\
value|(UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \     match_head = s->head[s->ins_h], \     s->head[s->ins_h] = (Pos)(str))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INSERT_STRING
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|,
name|match_head
parameter_list|)
define|\
value|(UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \     match_head = s->prev[(str)& s->w_mask] = s->head[s->ins_h], \     s->head[s->ins_h] = (Pos)(str))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Initialize the hash table (avoiding 64K overflow for 16 bit systems).  * prev[] will be initialized on the fly.  */
end_comment

begin_define
define|#
directive|define
name|CLEAR_HASH
parameter_list|(
name|s
parameter_list|)
define|\
value|s->head[s->hash_size-1] = NIL; \     (void) zmemzero((Bytef *)s->head, \     (unsigned)(s->hash_size-1)*sizeof(*s->head));
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateInit_
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|level
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
return|return
name|deflateInit2_
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|,
name|version
argument_list|,
name|stream_size
argument_list|)
return|;
comment|/* To do: ignore strm->next_in if we use it as window */
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateInit2_
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|,
name|method
parameter_list|,
name|windowBits
parameter_list|,
name|memLevel
parameter_list|,
name|strategy
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|method
decl_stmt|;
name|int
name|windowBits
decl_stmt|;
name|int
name|memLevel
decl_stmt|;
name|int
name|strategy
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|wrap
init|=
literal|1
decl_stmt|;
specifier|static
specifier|const
name|char
name|my_version
index|[]
init|=
name|ZLIB_VERSION
decl_stmt|;
name|ushf
modifier|*
name|overlay
decl_stmt|;
comment|/* We overlay pending_buf and d_buf+l_buf. This works since the average      * output size for (length,distance) codes is<= 24 bits.      */
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|my_version
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
condition|)
block|{
return|return
name|Z_VERSION_ERROR
return|;
block|}
if|if
condition|(
name|strm
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
condition|)
block|{
name|strm
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
name|strm
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
ifdef|#
directive|ifdef
name|FASTEST
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|level
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|level
operator|==
name|Z_DEFAULT_COMPRESSION
condition|)
name|level
operator|=
literal|6
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|windowBits
operator|<
literal|0
condition|)
block|{
comment|/* suppress zlib wrapper */
name|wrap
operator|=
literal|0
expr_stmt|;
name|windowBits
operator|=
operator|-
name|windowBits
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GZIP
elseif|else
if|if
condition|(
name|windowBits
operator|>
literal|15
condition|)
block|{
name|wrap
operator|=
literal|2
expr_stmt|;
comment|/* write gzip wrapper instead */
name|windowBits
operator|-=
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|memLevel
operator|<
literal|1
operator|||
name|memLevel
operator|>
name|MAX_MEM_LEVEL
operator|||
name|method
operator|!=
name|Z_DEFLATED
operator|||
name|windowBits
operator|<
literal|8
operator|||
name|windowBits
operator|>
literal|15
operator|||
name|level
operator|<
literal|0
operator|||
name|level
operator|>
literal|9
operator|||
name|strategy
operator|<
literal|0
operator|||
name|strategy
operator|>
name|Z_FIXED
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
if|if
condition|(
name|windowBits
operator|==
literal|8
condition|)
name|windowBits
operator|=
literal|9
expr_stmt|;
comment|/* until 256-byte window bug fixed */
name|s
operator|=
operator|(
name|deflate_state
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|deflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|strm
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|strm
operator|=
name|strm
expr_stmt|;
name|s
operator|->
name|wrap
operator|=
name|wrap
expr_stmt|;
name|s
operator|->
name|gzhead
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|w_bits
operator|=
name|windowBits
expr_stmt|;
name|s
operator|->
name|w_size
operator|=
literal|1
operator|<<
name|s
operator|->
name|w_bits
expr_stmt|;
name|s
operator|->
name|w_mask
operator|=
name|s
operator|->
name|w_size
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|hash_bits
operator|=
name|memLevel
operator|+
literal|7
expr_stmt|;
name|s
operator|->
name|hash_size
operator|=
literal|1
operator|<<
name|s
operator|->
name|hash_bits
expr_stmt|;
name|s
operator|->
name|hash_mask
operator|=
name|s
operator|->
name|hash_size
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|hash_shift
operator|=
operator|(
operator|(
name|s
operator|->
name|hash_bits
operator|+
name|MIN_MATCH
operator|-
literal|1
operator|)
operator|/
name|MIN_MATCH
operator|)
expr_stmt|;
name|s
operator|->
name|window
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|w_size
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|prev
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|w_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|head
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|hash_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|lit_bufsize
operator|=
literal|1
operator|<<
operator|(
name|memLevel
operator|+
literal|6
operator|)
expr_stmt|;
comment|/* 16K elements by default */
name|overlay
operator|=
operator|(
name|ushf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|lit_bufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|s
operator|->
name|pending_buf
operator|=
operator|(
name|uchf
operator|*
operator|)
name|overlay
expr_stmt|;
name|s
operator|->
name|pending_buf_size
operator|=
operator|(
name|ulg
operator|)
name|s
operator|->
name|lit_bufsize
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
operator|+
literal|2L
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|window
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|prev
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|head
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|pending_buf
operator|==
name|Z_NULL
condition|)
block|{
name|s
operator|->
name|status
operator|=
name|FINISH_STATE
expr_stmt|;
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|ERR_MSG
argument_list|(
name|Z_MEM_ERROR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|s
operator|->
name|d_buf
operator|=
name|overlay
operator|+
name|s
operator|->
name|lit_bufsize
operator|/
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
expr_stmt|;
name|s
operator|->
name|l_buf
operator|=
name|s
operator|->
name|pending_buf
operator|+
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
operator|)
operator|*
name|s
operator|->
name|lit_bufsize
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|s
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
name|s
operator|->
name|method
operator|=
operator|(
name|Byte
operator|)
name|method
expr_stmt|;
return|return
name|deflateReset
argument_list|(
name|strm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateSetDictionary
parameter_list|(
name|strm
parameter_list|,
name|dictionary
parameter_list|,
name|dictLength
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|dictionary
decl_stmt|;
name|uInt
name|dictLength
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|uInt
name|length
init|=
name|dictLength
decl_stmt|;
name|uInt
name|n
decl_stmt|;
name|IPos
name|hash_head
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|dictionary
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|->
name|wrap
operator|==
literal|2
operator|||
operator|(
name|strm
operator|->
name|state
operator|->
name|wrap
operator|==
literal|1
operator|&&
name|strm
operator|->
name|state
operator|->
name|status
operator|!=
name|INIT_STATE
operator|)
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|=
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|wrap
condition|)
name|strm
operator|->
name|adler
operator|=
name|adler32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|dictionary
argument_list|,
name|dictLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|MIN_MATCH
condition|)
return|return
name|Z_OK
return|;
if|if
condition|(
name|length
operator|>
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|length
operator|=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dictionary
operator|+=
name|dictLength
operator|-
name|length
expr_stmt|;
comment|/* use the tail of the dictionary */
block|}
operator|(
name|void
operator|)
name|zmemcpy
argument_list|(
name|s
operator|->
name|window
argument_list|,
name|dictionary
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|s
operator|->
name|strstart
operator|=
name|length
expr_stmt|;
name|s
operator|->
name|block_start
operator|=
operator|(
name|long
operator|)
name|length
expr_stmt|;
comment|/* Insert all strings in the hash table (except for the last two bytes).      * s->lookahead stays null, so s->ins_h will be recomputed at the next      * call of fill_window.      */
name|s
operator|->
name|ins_h
operator|=
name|s
operator|->
name|window
index|[
literal|0
index|]
expr_stmt|;
name|UPDATE_HASH
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ins_h
argument_list|,
name|s
operator|->
name|window
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|length
operator|-
name|MIN_MATCH
condition|;
name|n
operator|++
control|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hash_head
condition|)
name|hash_head
operator|=
literal|0
expr_stmt|;
comment|/* to make compiler happy */
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateReset
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
operator|||
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|strm
operator|->
name|total_in
operator|=
name|strm
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/* use zfree if we ever allocate msg dynamically */
name|strm
operator|->
name|data_type
operator|=
name|Z_UNKNOWN
expr_stmt|;
name|s
operator|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pending_out
operator|=
name|s
operator|->
name|pending_buf
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|wrap
operator|<
literal|0
condition|)
block|{
name|s
operator|->
name|wrap
operator|=
operator|-
name|s
operator|->
name|wrap
expr_stmt|;
comment|/* was made negative by deflate(..., Z_FINISH); */
block|}
name|s
operator|->
name|status
operator|=
name|s
operator|->
name|wrap
condition|?
name|INIT_STATE
else|:
name|BUSY_STATE
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
ifdef|#
directive|ifdef
name|GZIP
name|s
operator|->
name|wrap
operator|==
literal|2
condition|?
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
else|:
endif|#
directive|endif
name|adler32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|last_flush
operator|=
name|Z_NO_FLUSH
expr_stmt|;
name|_tr_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lm_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateSetHeader
parameter_list|(
name|strm
parameter_list|,
name|head
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|gz_headerp
name|head
decl_stmt|;
block|{
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|strm
operator|->
name|state
operator|->
name|wrap
operator|!=
literal|2
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|state
operator|->
name|gzhead
operator|=
name|head
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflatePrime
parameter_list|(
name|strm
parameter_list|,
name|bits
parameter_list|,
name|value
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|state
operator|->
name|bi_valid
operator|=
name|bits
expr_stmt|;
name|strm
operator|->
name|state
operator|->
name|bi_buf
operator|=
call|(
name|ush
call|)
argument_list|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateParams
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|,
name|strategy
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|strategy
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|compress_func
name|func
decl_stmt|;
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|=
name|strm
operator|->
name|state
expr_stmt|;
ifdef|#
directive|ifdef
name|FASTEST
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|level
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|level
operator|==
name|Z_DEFAULT_COMPRESSION
condition|)
name|level
operator|=
literal|6
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
literal|9
operator|||
name|strategy
operator|<
literal|0
operator|||
name|strategy
operator|>
name|Z_FIXED
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|func
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|func
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|configuration_table
index|[
name|level
index|]
operator|.
name|func
operator|&&
name|strm
operator|->
name|total_in
operator|!=
literal|0
condition|)
block|{
comment|/* Flush the last buffer: */
name|err
operator|=
name|deflate
argument_list|(
name|strm
argument_list|,
name|Z_PARTIAL_FLUSH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|level
operator|!=
name|level
condition|)
block|{
name|s
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|s
operator|->
name|max_lazy_match
operator|=
name|configuration_table
index|[
name|level
index|]
operator|.
name|max_lazy
expr_stmt|;
name|s
operator|->
name|good_match
operator|=
name|configuration_table
index|[
name|level
index|]
operator|.
name|good_length
expr_stmt|;
name|s
operator|->
name|nice_match
operator|=
name|configuration_table
index|[
name|level
index|]
operator|.
name|nice_length
expr_stmt|;
name|s
operator|->
name|max_chain_length
operator|=
name|configuration_table
index|[
name|level
index|]
operator|.
name|max_chain
expr_stmt|;
block|}
name|s
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateTune
parameter_list|(
name|strm
parameter_list|,
name|good_length
parameter_list|,
name|max_lazy
parameter_list|,
name|nice_length
parameter_list|,
name|max_chain
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|good_length
decl_stmt|;
name|int
name|max_lazy
decl_stmt|;
name|int
name|nice_length
decl_stmt|;
name|int
name|max_chain
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|=
name|strm
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|good_match
operator|=
name|good_length
expr_stmt|;
name|s
operator|->
name|max_lazy_match
operator|=
name|max_lazy
expr_stmt|;
name|s
operator|->
name|nice_match
operator|=
name|nice_length
expr_stmt|;
name|s
operator|->
name|max_chain_length
operator|=
name|max_chain
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * For the default windowBits of 15 and memLevel of 8, this function returns  * a close to exact, as well as small, upper bound on the compressed size.  * They are coded as constants here for a reason--if the #define's are  * changed, then this function needs to be changed as well.  The return  * value for 15 and 8 only works for those exact settings.  *  * For any setting other than those defaults for windowBits and memLevel,  * the value returned is a conservative worst case for the maximum expansion  * resulting from using fixed blocks instead of stored blocks, which deflate  * can emit on compressed data for some combinations of the parameters.  *  * This function could be more sophisticated to provide closer upper bounds  * for every combination of windowBits and memLevel, as well as wrap.  * But even the conservative upper bound of about 14% expansion does not  * seem onerous for output buffer allocation.  */
end_comment

begin_function
name|uLong
name|ZEXPORT
name|deflateBound
parameter_list|(
name|strm
parameter_list|,
name|sourceLen
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|uLong
name|sourceLen
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|uLong
name|destLen
decl_stmt|;
comment|/* conservative upper bound */
name|destLen
operator|=
name|sourceLen
operator|+
operator|(
operator|(
name|sourceLen
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|+
operator|(
operator|(
name|sourceLen
operator|+
literal|63
operator|)
operator|>>
literal|6
operator|)
operator|+
literal|11
expr_stmt|;
comment|/* if can't get parameters, return conservative bound */
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|destLen
return|;
comment|/* if not default parameters, return conservative bound */
name|s
operator|=
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|w_bits
operator|!=
literal|15
operator|||
name|s
operator|->
name|hash_bits
operator|!=
literal|8
operator|+
literal|7
condition|)
return|return
name|destLen
return|;
comment|/* default settings: return tight bound for that case */
return|return
name|compressBound
argument_list|(
name|sourceLen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * Put a short in the pending buffer. The 16-bit value is put in MSB order.  * IN assertion: the stream state is correct and there is enough room in  * pending_buf.  */
end_comment

begin_function
name|local
name|void
name|putShortMSB
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|uInt
name|b
decl_stmt|;
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|b
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|b
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * Flush as much pending output as possible. All deflate() output goes  * through this function so some applications may wish to modify it  * to avoid allocating a large strm->next_out buffer and copying into it.  * (See also read_buf()).  */
end_comment

begin_function
name|local
name|void
name|flush_pending
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|unsigned
name|len
init|=
name|strm
operator|->
name|state
operator|->
name|pending
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|strm
operator|->
name|avail_out
condition|)
name|len
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|zmemcpy
argument_list|(
name|strm
operator|->
name|next_out
argument_list|,
name|strm
operator|->
name|state
operator|->
name|pending_out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_out
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|state
operator|->
name|pending_out
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|-=
name|len
expr_stmt|;
name|strm
operator|->
name|state
operator|->
name|pending
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|state
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|state
operator|->
name|pending_out
operator|=
name|strm
operator|->
name|state
operator|->
name|pending_buf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflate
parameter_list|(
name|strm
parameter_list|,
name|flush
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|int
name|old_flush
decl_stmt|;
comment|/* value of flush param for previous deflate call */
name|deflate_state
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|flush
operator|>
name|Z_FINISH
operator|||
name|flush
operator|<
literal|0
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|s
operator|=
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|next_out
operator|==
name|Z_NULL
operator|||
operator|(
name|strm
operator|->
name|next_in
operator|==
name|Z_NULL
operator|&&
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|)
operator|||
operator|(
name|s
operator|->
name|status
operator|==
name|FINISH_STATE
operator|&&
name|flush
operator|!=
name|Z_FINISH
operator|)
condition|)
block|{
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|strm
operator|=
name|strm
expr_stmt|;
comment|/* just in case */
name|old_flush
operator|=
name|s
operator|->
name|last_flush
expr_stmt|;
name|s
operator|->
name|last_flush
operator|=
name|flush
expr_stmt|;
comment|/* Write the header */
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|INIT_STATE
condition|)
block|{
ifdef|#
directive|ifdef
name|GZIP
if|if
condition|(
name|s
operator|->
name|wrap
operator|==
literal|2
condition|)
block|{
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|139
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|gzhead
operator|==
name|NULL
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|level
operator|==
literal|9
condition|?
literal|2
else|:
operator|(
name|s
operator|->
name|strategy
operator|>=
name|Z_HUFFMAN_ONLY
operator|||
name|s
operator|->
name|level
operator|<
literal|2
condition|?
literal|4
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|OS_CODE
argument_list|)
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
block|}
else|else
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
operator|(
name|s
operator|->
name|gzhead
operator|->
name|text
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|s
operator|->
name|gzhead
operator|->
name|extra
operator|==
name|Z_NULL
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|s
operator|->
name|gzhead
operator|->
name|name
operator|==
name|Z_NULL
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
name|s
operator|->
name|gzhead
operator|->
name|comment
operator|==
name|Z_NULL
condition|?
literal|0
else|:
literal|16
operator|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|s
operator|->
name|gzhead
operator|->
name|time
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|s
operator|->
name|gzhead
operator|->
name|time
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|s
operator|->
name|gzhead
operator|->
name|time
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|s
operator|->
name|gzhead
operator|->
name|time
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|level
operator|==
literal|9
condition|?
literal|2
else|:
operator|(
name|s
operator|->
name|strategy
operator|>=
name|Z_HUFFMAN_ONLY
operator|||
name|s
operator|->
name|level
operator|<
literal|2
condition|?
literal|4
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|gzhead
operator|->
name|os
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|extra
operator|!=
name|NULL
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|gzhead
operator|->
name|extra_len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
operator|(
name|s
operator|->
name|gzhead
operator|->
name|extra_len
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
argument_list|,
name|s
operator|->
name|pending
argument_list|)
expr_stmt|;
name|s
operator|->
name|gzindex
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|EXTRA_STATE
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|uInt
name|header
init|=
operator|(
name|Z_DEFLATED
operator|+
operator|(
operator|(
name|s
operator|->
name|w_bits
operator|-
literal|8
operator|)
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|8
decl_stmt|;
name|uInt
name|level_flags
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|strategy
operator|>=
name|Z_HUFFMAN_ONLY
operator|||
name|s
operator|->
name|level
operator|<
literal|2
condition|)
name|level_flags
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|level
operator|<
literal|6
condition|)
name|level_flags
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|level
operator|==
literal|6
condition|)
name|level_flags
operator|=
literal|2
expr_stmt|;
else|else
name|level_flags
operator|=
literal|3
expr_stmt|;
name|header
operator||=
operator|(
name|level_flags
operator|<<
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|strstart
operator|!=
literal|0
condition|)
name|header
operator||=
name|PRESET_DICT
expr_stmt|;
name|header
operator|+=
literal|31
operator|-
operator|(
name|header
operator|%
literal|31
operator|)
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
name|putShortMSB
argument_list|(
name|s
argument_list|,
name|header
argument_list|)
expr_stmt|;
comment|/* Save the adler32 of the preset dictionary: */
if|if
condition|(
name|s
operator|->
name|strstart
operator|!=
literal|0
condition|)
block|{
name|putShortMSB
argument_list|(
name|s
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|putShortMSB
argument_list|(
name|s
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strm
operator|->
name|adler
operator|=
name|adler32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|GZIP
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|EXTRA_STATE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|extra
operator|!=
name|NULL
condition|)
block|{
name|uInt
name|beg
init|=
name|s
operator|->
name|pending
decl_stmt|;
comment|/* start of bytes to update crc */
while|while
condition|(
name|s
operator|->
name|gzindex
operator|<
operator|(
name|s
operator|->
name|gzhead
operator|->
name|extra_len
operator|&
literal|0xffff
operator|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|beg
operator|=
name|s
operator|->
name|pending
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
break|break;
block|}
name|put_byte
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|gzhead
operator|->
name|extra
index|[
name|s
operator|->
name|gzindex
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|gzindex
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|gzindex
operator|==
name|s
operator|->
name|gzhead
operator|->
name|extra_len
condition|)
block|{
name|s
operator|->
name|gzindex
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|NAME_STATE
expr_stmt|;
block|}
block|}
else|else
name|s
operator|->
name|status
operator|=
name|NAME_STATE
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|NAME_STATE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|uInt
name|beg
init|=
name|s
operator|->
name|pending
decl_stmt|;
comment|/* start of bytes to update crc */
name|int
name|val
decl_stmt|;
do|do
block|{
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|beg
operator|=
name|s
operator|->
name|pending
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|val
operator|=
name|s
operator|->
name|gzhead
operator|->
name|name
index|[
name|s
operator|->
name|gzindex
operator|++
index|]
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|gzindex
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|COMMENT_STATE
expr_stmt|;
block|}
block|}
else|else
name|s
operator|->
name|status
operator|=
name|COMMENT_STATE
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|COMMENT_STATE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|comment
operator|!=
name|NULL
condition|)
block|{
name|uInt
name|beg
init|=
name|s
operator|->
name|pending
decl_stmt|;
comment|/* start of bytes to update crc */
name|int
name|val
decl_stmt|;
do|do
block|{
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|beg
operator|=
name|s
operator|->
name|pending
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pending
operator|==
name|s
operator|->
name|pending_buf_size
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|val
operator|=
name|s
operator|->
name|gzhead
operator|->
name|comment
index|[
name|s
operator|->
name|gzindex
operator|++
index|]
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
operator|&&
name|s
operator|->
name|pending
operator|>
name|beg
condition|)
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|s
operator|->
name|pending_buf
operator|+
name|beg
argument_list|,
name|s
operator|->
name|pending
operator|-
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|s
operator|->
name|status
operator|=
name|HCRC_STATE
expr_stmt|;
block|}
else|else
name|s
operator|->
name|status
operator|=
name|HCRC_STATE
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|HCRC_STATE
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|gzhead
operator|->
name|hcrc
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|pending
operator|+
literal|2
operator|>
name|s
operator|->
name|pending_buf_size
condition|)
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|pending
operator|+
literal|2
operator|<=
name|s
operator|->
name|pending_buf_size
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|adler
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
block|}
block|}
else|else
name|s
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Flush as much pending output as possible */
if|if
condition|(
name|s
operator|->
name|pending
operator|!=
literal|0
condition|)
block|{
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
block|{
comment|/* Since avail_out is 0, deflate will be called again with              * more output space, but possibly with both pending and              * avail_in equal to zero. There won't be anything to do,              * but this is not an error situation so make sure we              * return OK instead of BUF_ERROR at next call of deflate:              */
name|s
operator|->
name|last_flush
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
comment|/* Make sure there is something to do and avoid duplicate consecutive      * flushes. For repeated and useless calls with Z_FINISH, we keep      * returning Z_STREAM_END instead of Z_BUF_ERROR.      */
block|}
elseif|else
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|flush
operator|<=
name|old_flush
operator|&&
name|flush
operator|!=
name|Z_FINISH
condition|)
block|{
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/* User must not provide more input after the first FINISH: */
if|if
condition|(
name|s
operator|->
name|status
operator|==
name|FINISH_STATE
operator|&&
name|strm
operator|->
name|avail_in
operator|!=
literal|0
condition|)
block|{
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new block or continue the current one.      */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|||
name|s
operator|->
name|lookahead
operator|!=
literal|0
operator|||
operator|(
name|flush
operator|!=
name|Z_NO_FLUSH
operator|&&
name|s
operator|->
name|status
operator|!=
name|FINISH_STATE
operator|)
condition|)
block|{
name|block_state
name|bstate
decl_stmt|;
name|bstate
operator|=
operator|(
operator|*
operator|(
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|func
operator|)
operator|)
operator|(
name|s
operator|,
name|flush
operator|)
expr_stmt|;
if|if
condition|(
name|bstate
operator|==
name|finish_started
operator|||
name|bstate
operator|==
name|finish_done
condition|)
block|{
name|s
operator|->
name|status
operator|=
name|FINISH_STATE
expr_stmt|;
block|}
if|if
condition|(
name|bstate
operator|==
name|need_more
operator|||
name|bstate
operator|==
name|finish_started
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|last_flush
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* avoid BUF_ERROR next call, see above */
block|}
return|return
name|Z_OK
return|;
comment|/* If flush != Z_NO_FLUSH&& avail_out == 0, the next call              * of deflate should use the same flush parameter to make sure              * that the flush is complete. So we don't have to output an              * empty block here, this will be done at next call. This also              * ensures that for a very small output buffer, we emit at most              * one empty block.              */
block|}
if|if
condition|(
name|bstate
operator|==
name|block_done
condition|)
block|{
if|if
condition|(
name|flush
operator|==
name|Z_PARTIAL_FLUSH
condition|)
block|{
name|_tr_align
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FULL_FLUSH or SYNC_FLUSH */
name|_tr_stored_block
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a full flush, this empty block will be recognized                  * as a special marker by inflate_sync().                  */
if|if
condition|(
name|flush
operator|==
name|Z_FULL_FLUSH
condition|)
block|{
name|CLEAR_HASH
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* forget history */
block|}
block|}
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|last_flush
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* avoid BUF_ERROR at next call, see above */
return|return
name|Z_OK
return|;
block|}
block|}
block|}
name|Assert
argument_list|(
name|strm
operator|->
name|avail_out
operator|>
literal|0
argument_list|,
literal|"bug2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|!=
name|Z_FINISH
condition|)
return|return
name|Z_OK
return|;
if|if
condition|(
name|s
operator|->
name|wrap
operator|<=
literal|0
condition|)
return|return
name|Z_STREAM_END
return|;
comment|/* Write the trailer */
ifdef|#
directive|ifdef
name|GZIP
if|if
condition|(
name|s
operator|->
name|wrap
operator|==
literal|2
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|adler
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|adler
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|adler
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|strm
operator|->
name|total_in
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|total_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|total_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|strm
operator|->
name|total_in
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|putShortMSB
argument_list|(
name|s
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|putShortMSB
argument_list|(
name|s
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|strm
operator|->
name|adler
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
comment|/* If avail_out is zero, the application will call deflate again      * to flush the rest.      */
if|if
condition|(
name|s
operator|->
name|wrap
operator|>
literal|0
condition|)
name|s
operator|->
name|wrap
operator|=
operator|-
name|s
operator|->
name|wrap
expr_stmt|;
comment|/* write the trailer only once! */
return|return
name|s
operator|->
name|pending
operator|!=
literal|0
condition|?
name|Z_OK
else|:
name|Z_STREAM_END
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateEnd
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|status
operator|=
name|strm
operator|->
name|state
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|INIT_STATE
operator|&&
name|status
operator|!=
name|EXTRA_STATE
operator|&&
name|status
operator|!=
name|NAME_STATE
operator|&&
name|status
operator|!=
name|COMMENT_STATE
operator|&&
name|status
operator|!=
name|HCRC_STATE
operator|&&
name|status
operator|!=
name|BUSY_STATE
operator|&&
name|status
operator|!=
name|FINISH_STATE
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
comment|/* Deallocate in reverse order of allocations: */
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
operator|->
name|pending_buf
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
operator|->
name|head
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
operator|->
name|prev
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
operator|->
name|window
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
return|return
name|status
operator|==
name|BUSY_STATE
condition|?
name|Z_DATA_ERROR
else|:
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * Copy the source state to the destination state.  * To simplify the source, this is not supported for 16-bit MSDOS (which  * doesn't have enough memory anyway to duplicate compression states).  */
end_comment

begin_function
name|int
name|ZEXPORT
name|deflateCopy
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|z_streamp
name|dest
decl_stmt|;
name|z_streamp
name|source
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MAXSEG_64K
return|return
name|Z_STREAM_ERROR
return|;
else|#
directive|else
name|deflate_state
modifier|*
name|ds
decl_stmt|;
name|deflate_state
modifier|*
name|ss
decl_stmt|;
name|ushf
modifier|*
name|overlay
decl_stmt|;
if|if
condition|(
name|source
operator|==
name|Z_NULL
operator|||
name|dest
operator|==
name|Z_NULL
operator|||
name|source
operator|->
name|state
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|ss
operator|=
name|source
operator|->
name|state
expr_stmt|;
name|zmemcpy
argument_list|(
name|dest
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|=
operator|(
name|deflate_state
operator|*
operator|)
name|ZALLOC
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|deflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|dest
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|ds
expr_stmt|;
name|zmemcpy
argument_list|(
name|ds
argument_list|,
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|deflate_state
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|strm
operator|=
name|dest
expr_stmt|;
name|ds
operator|->
name|window
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|dest
argument_list|,
name|ds
operator|->
name|w_size
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|prev
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|dest
argument_list|,
name|ds
operator|->
name|w_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|head
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|dest
argument_list|,
name|ds
operator|->
name|hash_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|overlay
operator|=
operator|(
name|ushf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|dest
argument_list|,
name|ds
operator|->
name|lit_bufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pending_buf
operator|=
operator|(
name|uchf
operator|*
operator|)
name|overlay
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|window
operator|==
name|Z_NULL
operator|||
name|ds
operator|->
name|prev
operator|==
name|Z_NULL
operator|||
name|ds
operator|->
name|head
operator|==
name|Z_NULL
operator|||
name|ds
operator|->
name|pending_buf
operator|==
name|Z_NULL
condition|)
block|{
name|deflateEnd
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
comment|/* following zmemcpy do not work for 16-bit MSDOS */
name|zmemcpy
argument_list|(
name|ds
operator|->
name|window
argument_list|,
name|ss
operator|->
name|window
argument_list|,
name|ds
operator|->
name|w_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
name|zmemcpy
argument_list|(
name|ds
operator|->
name|prev
argument_list|,
name|ss
operator|->
name|prev
argument_list|,
name|ds
operator|->
name|w_size
operator|*
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|zmemcpy
argument_list|(
name|ds
operator|->
name|head
argument_list|,
name|ss
operator|->
name|head
argument_list|,
name|ds
operator|->
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|zmemcpy
argument_list|(
name|ds
operator|->
name|pending_buf
argument_list|,
name|ss
operator|->
name|pending_buf
argument_list|,
operator|(
name|uInt
operator|)
name|ds
operator|->
name|pending_buf_size
argument_list|)
expr_stmt|;
name|ds
operator|->
name|pending_out
operator|=
name|ds
operator|->
name|pending_buf
operator|+
operator|(
name|ss
operator|->
name|pending_out
operator|-
name|ss
operator|->
name|pending_buf
operator|)
expr_stmt|;
name|ds
operator|->
name|d_buf
operator|=
name|overlay
operator|+
name|ds
operator|->
name|lit_bufsize
operator|/
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
expr_stmt|;
name|ds
operator|->
name|l_buf
operator|=
name|ds
operator|->
name|pending_buf
operator|+
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
operator|)
operator|*
name|ds
operator|->
name|lit_bufsize
expr_stmt|;
name|ds
operator|->
name|l_desc
operator|.
name|dyn_tree
operator|=
name|ds
operator|->
name|dyn_ltree
expr_stmt|;
name|ds
operator|->
name|d_desc
operator|.
name|dyn_tree
operator|=
name|ds
operator|->
name|dyn_dtree
expr_stmt|;
name|ds
operator|->
name|bl_desc
operator|.
name|dyn_tree
operator|=
name|ds
operator|->
name|bl_tree
expr_stmt|;
return|return
name|Z_OK
return|;
endif|#
directive|endif
comment|/* MAXSEG_64K */
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Read a new buffer from the current input stream, update the adler32  * and total number of bytes read.  All deflate() input goes through  * this function so some applications may wish to modify it to avoid  * allocating a large strm->next_in buffer and copying from it.  * (See also flush_pending()).  */
end_comment

begin_function
name|local
name|int
name|read_buf
parameter_list|(
name|strm
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|Bytef
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|unsigned
name|len
init|=
name|strm
operator|->
name|avail_in
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|size
condition|)
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strm
operator|->
name|avail_in
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|state
operator|->
name|wrap
operator|==
literal|1
condition|)
block|{
name|strm
operator|->
name|adler
operator|=
name|adler32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GZIP
elseif|else
if|if
condition|(
name|strm
operator|->
name|state
operator|->
name|wrap
operator|==
literal|2
condition|)
block|{
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zmemcpy
argument_list|(
name|buf
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|total_in
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Initialize the "longest match" routines for a new zlib stream  */
end_comment

begin_function
name|local
name|void
name|lm_init
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|window_size
operator|=
operator|(
name|ulg
operator|)
literal|2L
operator|*
name|s
operator|->
name|w_size
expr_stmt|;
name|CLEAR_HASH
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Set the default configuration parameters:      */
name|s
operator|->
name|max_lazy_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|max_lazy
expr_stmt|;
name|s
operator|->
name|good_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|good_length
expr_stmt|;
name|s
operator|->
name|nice_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|nice_length
expr_stmt|;
name|s
operator|->
name|max_chain_length
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|max_chain
expr_stmt|;
name|s
operator|->
name|strstart
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|block_start
operator|=
literal|0L
expr_stmt|;
name|s
operator|->
name|lookahead
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|s
operator|->
name|prev_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ins_h
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTEST
ifdef|#
directive|ifdef
name|ASMV
name|match_init
argument_list|()
expr_stmt|;
comment|/* initialize the asm code */
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FASTEST
end_ifndef

begin_comment
comment|/* ===========================================================================  * Set match_start to the longest match starting at the given string and  * return its length. Matches shorter or equal to prev_length are discarded,  * in which case the result is equal to prev_length and match_start is  * garbage.  * IN assertions: cur_match is the head of the hash chain for the current  *   string (strstart) and its distance is<= MAX_DIST, and prev_length>= 1  * OUT assertion: the match length is not greater than s->lookahead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASMV
end_ifndef

begin_comment
comment|/* For 80x86 and 680x0, an optimized version will be provided in match.asm or  * match.S. The code will be functionally equivalent.  */
end_comment

begin_function
name|local
name|uInt
name|longest_match
parameter_list|(
name|s
parameter_list|,
name|cur_match
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|IPos
name|cur_match
decl_stmt|;
comment|/* current match */
block|{
name|unsigned
name|chain_length
init|=
name|s
operator|->
name|max_chain_length
decl_stmt|;
comment|/* max hash chain length */
specifier|register
name|Bytef
modifier|*
name|scan
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
decl_stmt|;
comment|/* current string */
specifier|register
name|Bytef
modifier|*
name|match
decl_stmt|;
comment|/* matched string */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of current match */
name|int
name|best_len
init|=
name|s
operator|->
name|prev_length
decl_stmt|;
comment|/* best match length so far */
name|int
name|nice_match
init|=
name|s
operator|->
name|nice_match
decl_stmt|;
comment|/* stop if match long enough */
name|IPos
name|limit
init|=
name|s
operator|->
name|strstart
operator|>
operator|(
name|IPos
operator|)
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|?
name|s
operator|->
name|strstart
operator|-
operator|(
name|IPos
operator|)
name|MAX_DIST
argument_list|(
name|s
argument_list|)
else|:
name|NIL
decl_stmt|;
comment|/* Stop when cur_match becomes<= limit. To simplify the code,      * we prevent matches with the string of window index 0.      */
name|Posf
modifier|*
name|prev
init|=
name|s
operator|->
name|prev
decl_stmt|;
name|uInt
name|wmask
init|=
name|s
operator|->
name|w_mask
decl_stmt|;
ifdef|#
directive|ifdef
name|UNALIGNED_OK
comment|/* Compare two bytes at a time. Note: this is not always beneficial.      * Try with and without -DUNALIGNED_OK to check.      */
specifier|register
name|Bytef
modifier|*
name|strend
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|MAX_MATCH
operator|-
literal|1
decl_stmt|;
specifier|register
name|ush
name|scan_start
init|=
operator|*
operator|(
name|ushf
operator|*
operator|)
name|scan
decl_stmt|;
specifier|register
name|ush
name|scan_end
init|=
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+
name|best_len
operator|-
literal|1
operator|)
decl_stmt|;
else|#
directive|else
specifier|register
name|Bytef
modifier|*
name|strend
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|MAX_MATCH
decl_stmt|;
specifier|register
name|Byte
name|scan_end1
init|=
name|scan
index|[
name|best_len
operator|-
literal|1
index|]
decl_stmt|;
specifier|register
name|Byte
name|scan_end
init|=
name|scan
index|[
name|best_len
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* The code is optimized for HASH_BITS>= 8 and MAX_MATCH-2 multiple of 16.      * It is easy to get rid of this optimization if necessary.      */
name|Assert
argument_list|(
name|s
operator|->
name|hash_bits
operator|>=
literal|8
operator|&&
name|MAX_MATCH
operator|==
literal|258
argument_list|,
literal|"Code too clever"
argument_list|)
expr_stmt|;
comment|/* Do not waste too much time if we already have a good match: */
if|if
condition|(
name|s
operator|->
name|prev_length
operator|>=
name|s
operator|->
name|good_match
condition|)
block|{
name|chain_length
operator|>>=
literal|2
expr_stmt|;
block|}
comment|/* Do not look for matches beyond the end of the input. This is necessary      * to make deflate deterministic.      */
if|if
condition|(
operator|(
name|uInt
operator|)
name|nice_match
operator|>
name|s
operator|->
name|lookahead
condition|)
name|nice_match
operator|=
name|s
operator|->
name|lookahead
expr_stmt|;
name|Assert
argument_list|(
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
operator|<=
name|s
operator|->
name|window_size
operator|-
name|MIN_LOOKAHEAD
argument_list|,
literal|"need lookahead"
argument_list|)
expr_stmt|;
do|do
block|{
name|Assert
argument_list|(
name|cur_match
operator|<
name|s
operator|->
name|strstart
argument_list|,
literal|"no future"
argument_list|)
expr_stmt|;
name|match
operator|=
name|s
operator|->
name|window
operator|+
name|cur_match
expr_stmt|;
comment|/* Skip to next match if the match length cannot increase          * or if the match length is less than 2.  Note that the checks below          * for insufficient lookahead only occur occasionally for performance          * reasons.  Therefore uninitialized memory will be accessed, and          * conditional jumps will be made that depend on those values.          * However the length of the match is limited to the lookahead, so          * the output of deflate is not affected by the uninitialized values.          */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNALIGNED_OK
argument_list|)
operator|&&
name|MAX_MATCH
operator|==
literal|258
operator|)
comment|/* This code assumes sizeof(unsigned short) == 2. Do not use          * UNALIGNED_OK if your compiler uses a different size.          */
if|if
condition|(
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+
name|best_len
operator|-
literal|1
operator|)
operator|!=
name|scan_end
operator|||
operator|*
operator|(
name|ushf
operator|*
operator|)
name|match
operator|!=
name|scan_start
condition|)
continue|continue;
comment|/* It is not necessary to compare scan[2] and match[2] since they are          * always equal when the other bytes match, given that the hash keys          * are equal and that HASH_BITS>= 8. Compare 2 bytes at a time at          * strstart+3, +5, ... up to strstart+257. We check for insufficient          * lookahead only every 4th comparison; the 128th check will be made          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is          * necessary to put more guard bytes at the end of the window, or          * to check more often for insufficient lookahead.          */
name|Assert
argument_list|(
name|scan
index|[
literal|2
index|]
operator|==
name|match
index|[
literal|2
index|]
argument_list|,
literal|"scan[2]?"
argument_list|)
expr_stmt|;
name|scan
operator|++
operator|,
name|match
operator|++
expr_stmt|;
do|do
block|{         }
do|while
condition|(
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
name|scan
operator|<
name|strend
condition|)
do|;
comment|/* The funny "do {}" generates better code on most compilers */
comment|/* Here, scan<= window+strstart+257 */
name|Assert
argument_list|(
name|scan
operator|<=
name|s
operator|->
name|window
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|"wild scan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|==
operator|*
name|match
condition|)
name|scan
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|MAX_MATCH
operator|-
literal|1
operator|)
operator|-
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|strend
operator|-
operator|(
name|MAX_MATCH
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
comment|/* UNALIGNED_OK */
if|if
condition|(
name|match
index|[
name|best_len
index|]
operator|!=
name|scan_end
operator|||
name|match
index|[
name|best_len
operator|-
literal|1
index|]
operator|!=
name|scan_end1
operator|||
operator|*
name|match
operator|!=
operator|*
name|scan
operator|||
operator|*
operator|++
name|match
operator|!=
name|scan
index|[
literal|1
index|]
condition|)
continue|continue;
comment|/* The check at best_len-1 can be removed because it will be made          * again later. (This heuristic is not always a win.)          * It is not necessary to compare scan[2] and match[2] since they          * are always equal when the other bytes match, given that          * the hash keys are equal and that HASH_BITS>= 8.          */
name|scan
operator|+=
literal|2
operator|,
name|match
operator|++
expr_stmt|;
name|Assert
argument_list|(
operator|*
name|scan
operator|==
operator|*
name|match
argument_list|,
literal|"match[2]?"
argument_list|)
expr_stmt|;
comment|/* We check for insufficient lookahead only every 8th comparison;          * the 256th check will be made at strstart+258.          */
do|do
block|{         }
do|while
condition|(
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
name|scan
operator|<
name|strend
condition|)
do|;
name|Assert
argument_list|(
name|scan
operator|<=
name|s
operator|->
name|window
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|"wild scan"
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAX_MATCH
operator|-
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|strend
operator|-
name|MAX_MATCH
expr_stmt|;
endif|#
directive|endif
comment|/* UNALIGNED_OK */
if|if
condition|(
name|len
operator|>
name|best_len
condition|)
block|{
name|s
operator|->
name|match_start
operator|=
name|cur_match
expr_stmt|;
name|best_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|nice_match
condition|)
break|break;
ifdef|#
directive|ifdef
name|UNALIGNED_OK
name|scan_end
operator|=
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+
name|best_len
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|scan_end1
operator|=
name|scan
index|[
name|best_len
operator|-
literal|1
index|]
expr_stmt|;
name|scan_end
operator|=
name|scan
index|[
name|best_len
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
do|while
condition|(
operator|(
name|cur_match
operator|=
name|prev
index|[
name|cur_match
operator|&
name|wmask
index|]
operator|)
operator|>
name|limit
operator|&&
operator|--
name|chain_length
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|uInt
operator|)
name|best_len
operator|<=
name|s
operator|->
name|lookahead
condition|)
return|return
operator|(
name|uInt
operator|)
name|best_len
return|;
return|return
name|s
operator|->
name|lookahead
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASMV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FASTEST */
end_comment

begin_comment
comment|/* ---------------------------------------------------------------------------  * Optimized version for level == 1 or strategy == Z_RLE only  */
end_comment

begin_function
name|local
name|uInt
name|longest_match_fast
parameter_list|(
name|s
parameter_list|,
name|cur_match
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|IPos
name|cur_match
decl_stmt|;
comment|/* current match */
block|{
specifier|register
name|Bytef
modifier|*
name|scan
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
decl_stmt|;
comment|/* current string */
specifier|register
name|Bytef
modifier|*
name|match
decl_stmt|;
comment|/* matched string */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of current match */
specifier|register
name|Bytef
modifier|*
name|strend
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|MAX_MATCH
decl_stmt|;
comment|/* The code is optimized for HASH_BITS>= 8 and MAX_MATCH-2 multiple of 16.      * It is easy to get rid of this optimization if necessary.      */
name|Assert
argument_list|(
name|s
operator|->
name|hash_bits
operator|>=
literal|8
operator|&&
name|MAX_MATCH
operator|==
literal|258
argument_list|,
literal|"Code too clever"
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
operator|<=
name|s
operator|->
name|window_size
operator|-
name|MIN_LOOKAHEAD
argument_list|,
literal|"need lookahead"
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|cur_match
operator|<
name|s
operator|->
name|strstart
argument_list|,
literal|"no future"
argument_list|)
expr_stmt|;
name|match
operator|=
name|s
operator|->
name|window
operator|+
name|cur_match
expr_stmt|;
comment|/* Return failure if the match length is less than 2:      */
if|if
condition|(
name|match
index|[
literal|0
index|]
operator|!=
name|scan
index|[
literal|0
index|]
operator|||
name|match
index|[
literal|1
index|]
operator|!=
name|scan
index|[
literal|1
index|]
condition|)
return|return
name|MIN_MATCH
operator|-
literal|1
return|;
comment|/* The check at best_len-1 can be removed because it will be made      * again later. (This heuristic is not always a win.)      * It is not necessary to compare scan[2] and match[2] since they      * are always equal when the other bytes match, given that      * the hash keys are equal and that HASH_BITS>= 8.      */
name|scan
operator|+=
literal|2
operator|,
name|match
operator|+=
literal|2
expr_stmt|;
name|Assert
argument_list|(
operator|*
name|scan
operator|==
operator|*
name|match
argument_list|,
literal|"match[2]?"
argument_list|)
expr_stmt|;
comment|/* We check for insufficient lookahead only every 8th comparison;      * the 256th check will be made at strstart+258.      */
do|do
block|{     }
do|while
condition|(
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
name|scan
operator|<
name|strend
condition|)
do|;
name|Assert
argument_list|(
name|scan
operator|<=
name|s
operator|->
name|window
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|"wild scan"
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAX_MATCH
operator|-
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|MIN_MATCH
condition|)
return|return
name|MIN_MATCH
operator|-
literal|1
return|;
name|s
operator|->
name|match_start
operator|=
name|cur_match
expr_stmt|;
return|return
operator|(
name|uInt
operator|)
name|len
operator|<=
name|s
operator|->
name|lookahead
condition|?
operator|(
name|uInt
operator|)
name|len
else|:
name|s
operator|->
name|lookahead
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* ===========================================================================  * Check that the match at match_start is indeed a match.  */
end_comment

begin_function
name|local
name|void
name|check_match
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|match
parameter_list|,
name|length
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|IPos
name|start
decl_stmt|,
name|match
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
comment|/* check that the match is indeed a match */
if|if
condition|(
name|zmemcmp
argument_list|(
name|s
operator|->
name|window
operator|+
name|match
argument_list|,
name|s
operator|->
name|window
operator|+
name|start
argument_list|,
name|length
argument_list|)
operator|!=
name|EQUAL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" start %u, match %u, length %d\n"
argument_list|,
name|start
argument_list|,
name|match
argument_list|,
name|length
argument_list|)
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%c"
argument_list|,
name|s
operator|->
name|window
index|[
name|match
operator|++
index|]
argument_list|,
name|s
operator|->
name|window
index|[
name|start
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|!=
literal|0
condition|)
do|;
name|z_error
argument_list|(
literal|"invalid match"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z_verbose
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\\[%d,%d]"
argument_list|,
name|start
operator|-
name|match
argument_list|,
name|length
argument_list|)
expr_stmt|;
do|do
block|{
name|putc
argument_list|(
name|s
operator|->
name|window
index|[
name|start
operator|++
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|check_match
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|match
parameter_list|,
name|length
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* ===========================================================================  * Fill the window when the lookahead becomes insufficient.  * Updates strstart and lookahead.  *  * IN assertion: lookahead< MIN_LOOKAHEAD  * OUT assertions: strstart<= window_size-MIN_LOOKAHEAD  *    At least one byte has been read, or avail_in == 0; reads are  *    performed for at least two bytes (required for the zip translate_eol  *    option -- not supported here).  */
end_comment

begin_function
name|local
name|void
name|fill_window
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|n
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|Posf
modifier|*
name|p
decl_stmt|;
name|unsigned
name|more
decl_stmt|;
comment|/* Amount of free space at the end of the window. */
name|uInt
name|wsize
init|=
name|s
operator|->
name|w_size
decl_stmt|;
do|do
block|{
name|more
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
operator|(
name|ulg
operator|)
name|s
operator|->
name|lookahead
operator|-
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
argument_list|)
expr_stmt|;
comment|/* Deal with !@#$% 64K limit: */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|more
operator|==
literal|0
operator|&&
name|s
operator|->
name|strstart
operator|==
literal|0
operator|&&
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
block|{
name|more
operator|=
name|wsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|more
operator|==
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Very unlikely, but possible on 16 bit machine if                  * strstart == 0&& lookahead == 1 (input done a byte at time)                  */
name|more
operator|--
expr_stmt|;
block|}
block|}
comment|/* If the window is almost full and there is insufficient lookahead,          * move the upper half to the lower one to make room in the upper half.          */
if|if
condition|(
name|s
operator|->
name|strstart
operator|>=
name|wsize
operator|+
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|zmemcpy
argument_list|(
name|s
operator|->
name|window
argument_list|,
name|s
operator|->
name|window
operator|+
name|wsize
argument_list|,
operator|(
name|unsigned
operator|)
name|wsize
argument_list|)
expr_stmt|;
name|s
operator|->
name|match_start
operator|-=
name|wsize
expr_stmt|;
name|s
operator|->
name|strstart
operator|-=
name|wsize
expr_stmt|;
comment|/* we now have strstart>= MAX_DIST */
name|s
operator|->
name|block_start
operator|-=
operator|(
name|long
operator|)
name|wsize
expr_stmt|;
comment|/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage). We slide even when level == 0                to keep the hash table consistent if we switch back to level> 0                later. (Using level 0 permanently is not an optimal usage of                zlib, so we don't care about this pathological case.)              */
comment|/* %%% avoid this when Z_RLE */
name|n
operator|=
name|s
operator|->
name|hash_size
expr_stmt|;
name|p
operator|=
operator|&
name|s
operator|->
name|head
index|[
name|n
index|]
expr_stmt|;
do|do
block|{
name|m
operator|=
operator|*
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
call|(
name|Pos
call|)
argument_list|(
name|m
operator|>=
name|wsize
condition|?
name|m
operator|-
name|wsize
else|:
name|NIL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|n
operator|=
name|wsize
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTEST
name|p
operator|=
operator|&
name|s
operator|->
name|prev
index|[
name|n
index|]
expr_stmt|;
do|do
block|{
name|m
operator|=
operator|*
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
call|(
name|Pos
call|)
argument_list|(
name|m
operator|>=
name|wsize
condition|?
name|m
operator|-
name|wsize
else|:
name|NIL
argument_list|)
expr_stmt|;
comment|/* If n is not on any hash chain, prev[n] is garbage but                  * its value will never be used.                  */
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
endif|#
directive|endif
name|more
operator|+=
name|wsize
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
return|return;
comment|/* If there was no sliding:          *    strstart<= WSIZE+MAX_DIST-1&& lookahead<= MIN_LOOKAHEAD - 1&&          *    more == window_size - lookahead - strstart          * => more>= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more>= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported),          *   window_size == input_size + MIN_LOOKAHEAD&&          *   strstart + s->lookahead<= input_size => more>= MIN_LOOKAHEAD.          * Otherwise, window_size == 2*WSIZE so more>= 2.          * If there was sliding, more>= WSIZE. So in all cases, more>= 2.          */
name|Assert
argument_list|(
name|more
operator|>=
literal|2
argument_list|,
literal|"more< 2"
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_buf
argument_list|(
name|s
operator|->
name|strm
argument_list|,
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|s
operator|->
name|lookahead
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|+=
name|n
expr_stmt|;
comment|/* Initialize the hash value now that we have some input: */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|s
operator|->
name|ins_h
operator|=
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
expr_stmt|;
name|UPDATE_HASH
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ins_h
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|MIN_MATCH
operator|!=
literal|3
name|Call
name|UPDATE_HASH
argument_list|()
name|MIN_MATCH
operator|-
literal|3
name|more
name|times
endif|#
directive|endif
block|}
comment|/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,          * but this is not important since only literal bytes will be emitted.          */
block|}
do|while
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|s
operator|->
name|strm
operator|->
name|avail_in
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Flush the current block, with given end-of-file flag.  * IN assertion: strstart is set to the end of the current match.  */
end_comment

begin_define
define|#
directive|define
name|FLUSH_BLOCK_ONLY
parameter_list|(
name|s
parameter_list|,
name|eof
parameter_list|)
value|{ \    _tr_flush_block(s, (s->block_start>= 0L ? \                    (charf *)&s->window[(unsigned)s->block_start] : \                    (charf *)Z_NULL), \                 (ulg)((long)s->strstart - s->block_start), \                 (eof)); \    s->block_start = s->strstart; \    flush_pending(s->strm); \    Tracev((stderr,"[FLUSH]")); \ }
end_define

begin_comment
comment|/* Same but force premature exit if necessary. */
end_comment

begin_define
define|#
directive|define
name|FLUSH_BLOCK
parameter_list|(
name|s
parameter_list|,
name|eof
parameter_list|)
value|{ \    FLUSH_BLOCK_ONLY(s, eof); \    if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \ }
end_define

begin_comment
comment|/* ===========================================================================  * Copy without compression as much as possible from the input stream, return  * the current block state.  * This function does not insert new strings in the dictionary since  * uncompressible data is probably not useful. This function is used  * only for the level=0 compression option.  * NOTE: this function should be optimized to avoid extra copying from  * window to pending_buf.  */
end_comment

begin_function
name|local
name|block_state
name|deflate_stored
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
comment|/* Stored blocks are limited to 0xffff bytes, pending_buf is limited      * to pending_buf_size, and each stored block has a 5 byte header:      */
name|ulg
name|max_block_size
init|=
literal|0xffff
decl_stmt|;
name|ulg
name|max_start
decl_stmt|;
if|if
condition|(
name|max_block_size
operator|>
name|s
operator|->
name|pending_buf_size
operator|-
literal|5
condition|)
block|{
name|max_block_size
operator|=
name|s
operator|->
name|pending_buf_size
operator|-
literal|5
expr_stmt|;
block|}
comment|/* Copy as much as possible from input to output: */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Fill the window as much as possible: */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<=
literal|1
condition|)
block|{
name|Assert
argument_list|(
name|s
operator|->
name|strstart
operator|<
name|s
operator|->
name|w_size
operator|+
name|MAX_DIST
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|block_start
operator|>=
operator|(
name|long
operator|)
name|s
operator|->
name|w_size
argument_list|,
literal|"slide too late"
argument_list|)
expr_stmt|;
name|fill_window
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
return|return
name|need_more
return|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
break|break;
comment|/* flush the current block */
block|}
name|Assert
argument_list|(
name|s
operator|->
name|block_start
operator|>=
literal|0L
argument_list|,
literal|"block gone"
argument_list|)
expr_stmt|;
name|s
operator|->
name|strstart
operator|+=
name|s
operator|->
name|lookahead
expr_stmt|;
name|s
operator|->
name|lookahead
operator|=
literal|0
expr_stmt|;
comment|/* Emit a stored block if pending_buf will be full: */
name|max_start
operator|=
name|s
operator|->
name|block_start
operator|+
name|max_block_size
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|strstart
operator|==
literal|0
operator|||
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
operator|>=
name|max_start
condition|)
block|{
comment|/* strstart == 0 is possible when wraparound on 16-bit machine */
name|s
operator|->
name|lookahead
operator|=
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|strstart
operator|-
name|max_start
argument_list|)
expr_stmt|;
name|s
operator|->
name|strstart
operator|=
operator|(
name|uInt
operator|)
name|max_start
expr_stmt|;
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Flush if we may have to slide, otherwise block_start may become          * negative and the data will be gone:          */
if|if
condition|(
name|s
operator|->
name|strstart
operator|-
operator|(
name|uInt
operator|)
name|s
operator|->
name|block_start
operator|>=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|flush
operator|==
name|Z_FINISH
argument_list|)
expr_stmt|;
return|return
name|flush
operator|==
name|Z_FINISH
condition|?
name|finish_done
else|:
name|block_done
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Compress as much as possible from the input stream, return the current  * block state.  * This function does not perform lazy evaluation of matches and inserts  * new strings in the dictionary only for unmatched strings or for short  * matches. It is used only for the fast compression options.  */
end_comment

begin_function
name|local
name|block_state
name|deflate_fast
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|IPos
name|hash_head
init|=
name|NIL
decl_stmt|;
comment|/* head of the hash chain */
name|int
name|bflush
decl_stmt|;
comment|/* set if current block must be flushed */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Make sure that we always have enough lookahead, except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match, plus MIN_MATCH bytes to insert the          * string following the next match.          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
condition|)
block|{
name|fill_window
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
block|{
return|return
name|need_more
return|;
block|}
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
break|break;
comment|/* flush the current block */
block|}
comment|/* Insert the string window[strstart .. strstart+2] in the          * dictionary, and set hash_head to the head of the hash chain:          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* Find the longest match, discarding those<= prev_length.          * At this point we have always match_length< MIN_MATCH          */
if|if
condition|(
name|hash_head
operator|!=
name|NIL
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|<=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* To simplify the code, we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */
ifdef|#
directive|ifdef
name|FASTEST
if|if
condition|(
operator|(
name|s
operator|->
name|strategy
operator|!=
name|Z_HUFFMAN_ONLY
operator|&&
name|s
operator|->
name|strategy
operator|!=
name|Z_RLE
operator|)
operator|||
operator|(
name|s
operator|->
name|strategy
operator|==
name|Z_RLE
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|==
literal|1
operator|)
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match_fast
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|s
operator|->
name|strategy
operator|!=
name|Z_HUFFMAN_ONLY
operator|&&
name|s
operator|->
name|strategy
operator|!=
name|Z_RLE
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|strategy
operator|==
name|Z_RLE
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|==
literal|1
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match_fast
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* longest_match() or longest_match_fast() sets match_start */
block|}
if|if
condition|(
name|s
operator|->
name|match_length
operator|>=
name|MIN_MATCH
condition|)
block|{
name|check_match
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|s
operator|->
name|match_start
argument_list|,
name|s
operator|->
name|match_length
argument_list|)
expr_stmt|;
name|_tr_tally_dist
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
name|s
operator|->
name|match_start
argument_list|,
name|s
operator|->
name|match_length
operator|-
name|MIN_MATCH
argument_list|,
name|bflush
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|-=
name|s
operator|->
name|match_length
expr_stmt|;
comment|/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */
ifndef|#
directive|ifndef
name|FASTEST
if|if
condition|(
name|s
operator|->
name|match_length
operator|<=
name|s
operator|->
name|max_insert_length
operator|&&
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|s
operator|->
name|match_length
operator|--
expr_stmt|;
comment|/* string at strstart already in table */
do|do
block|{
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
comment|/* strstart never exceeds WSIZE-MAX_MATCH, so there are                      * always MIN_MATCH bytes ahead.                      */
block|}
do|while
condition|(
operator|--
name|s
operator|->
name|match_length
operator|!=
literal|0
condition|)
do|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|s
operator|->
name|strstart
operator|+=
name|s
operator|->
name|match_length
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ins_h
operator|=
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
expr_stmt|;
name|UPDATE_HASH
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ins_h
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|MIN_MATCH
operator|!=
literal|3
name|Call
name|UPDATE_HASH
argument_list|()
name|MIN_MATCH
operator|-
literal|3
name|more
name|times
endif|#
directive|endif
comment|/* If lookahead< MIN_MATCH, ins_h is garbage, but it does not                  * matter since it will be recomputed at next deflate call.                  */
block|}
block|}
else|else
block|{
comment|/* No match, output a literal byte */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
operator|)
argument_list|)
expr_stmt|;
name|_tr_tally_lit
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
argument_list|,
name|bflush
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bflush
condition|)
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|flush
operator|==
name|Z_FINISH
argument_list|)
expr_stmt|;
return|return
name|flush
operator|==
name|Z_FINISH
condition|?
name|finish_done
else|:
name|block_done
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FASTEST
end_ifndef

begin_comment
comment|/* ===========================================================================  * Same as above, but achieves better compression. We use a lazy  * evaluation for matches: a match is finally adopted only if there is  * no better match at the next window position.  */
end_comment

begin_function
name|local
name|block_state
name|deflate_slow
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|IPos
name|hash_head
init|=
name|NIL
decl_stmt|;
comment|/* head of hash chain */
name|int
name|bflush
decl_stmt|;
comment|/* set if current block must be flushed */
comment|/* Process the input block. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Make sure that we always have enough lookahead, except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match, plus MIN_MATCH bytes to insert the          * string following the next match.          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
condition|)
block|{
name|fill_window
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
block|{
return|return
name|need_more
return|;
block|}
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
break|break;
comment|/* flush the current block */
block|}
comment|/* Insert the string window[strstart .. strstart+2] in the          * dictionary, and set hash_head to the head of the hash chain:          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* Find the longest match, discarding those<= prev_length.          */
name|s
operator|->
name|prev_length
operator|=
name|s
operator|->
name|match_length
operator|,
name|s
operator|->
name|prev_match
operator|=
name|s
operator|->
name|match_start
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hash_head
operator|!=
name|NIL
operator|&&
name|s
operator|->
name|prev_length
operator|<
name|s
operator|->
name|max_lazy_match
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|<=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* To simplify the code, we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */
if|if
condition|(
name|s
operator|->
name|strategy
operator|!=
name|Z_HUFFMAN_ONLY
operator|&&
name|s
operator|->
name|strategy
operator|!=
name|Z_RLE
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|strategy
operator|==
name|Z_RLE
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|==
literal|1
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match_fast
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* longest_match() or longest_match_fast() sets match_start */
if|if
condition|(
name|s
operator|->
name|match_length
operator|<=
literal|5
operator|&&
operator|(
name|s
operator|->
name|strategy
operator|==
name|Z_FILTERED
if|#
directive|if
name|TOO_FAR
operator|<=
literal|32767
operator|||
operator|(
name|s
operator|->
name|match_length
operator|==
name|MIN_MATCH
operator|&&
name|s
operator|->
name|strstart
operator|-
name|s
operator|->
name|match_start
operator|>
name|TOO_FAR
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* If prev_match is also MIN_MATCH, match_start is garbage                  * but we will ignore the current match anyway.                  */
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* If there was a match at the previous step and the current          * match is not better, output the previous match:          */
if|if
condition|(
name|s
operator|->
name|prev_length
operator|>=
name|MIN_MATCH
operator|&&
name|s
operator|->
name|match_length
operator|<=
name|s
operator|->
name|prev_length
condition|)
block|{
name|uInt
name|max_insert
init|=
name|s
operator|->
name|strstart
operator|+
name|s
operator|->
name|lookahead
operator|-
name|MIN_MATCH
decl_stmt|;
comment|/* Do not insert strings in hash table beyond this. */
name|check_match
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
literal|1
argument_list|,
name|s
operator|->
name|prev_match
argument_list|,
name|s
operator|->
name|prev_length
argument_list|)
expr_stmt|;
name|_tr_tally_dist
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
literal|1
operator|-
name|s
operator|->
name|prev_match
argument_list|,
name|s
operator|->
name|prev_length
operator|-
name|MIN_MATCH
argument_list|,
name|bflush
argument_list|)
expr_stmt|;
comment|/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead, the last two strings are not inserted in              * the hash table.              */
name|s
operator|->
name|lookahead
operator|-=
name|s
operator|->
name|prev_length
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|prev_length
operator|-=
literal|2
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|s
operator|->
name|strstart
operator|<=
name|max_insert
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|s
operator|->
name|prev_length
operator|!=
literal|0
condition|)
do|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
if|if
condition|(
name|bflush
condition|)
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|match_available
condition|)
block|{
comment|/* If there was no match at the previous position, output a              * single literal. If there was a match but the current match              * is longer, truncate the previous match to a single literal.              */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|_tr_tally_lit
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
argument_list|,
name|bflush
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflush
condition|)
block|{
name|FLUSH_BLOCK_ONLY
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
return|return
name|need_more
return|;
block|}
else|else
block|{
comment|/* There is no previous match to compare with, wait for              * the next step to decide.              */
name|s
operator|->
name|match_available
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|flush
operator|!=
name|Z_NO_FLUSH
argument_list|,
literal|"no flush?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|match_available
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|_tr_tally_lit
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
argument_list|,
name|bflush
argument_list|)
expr_stmt|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
block|}
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|flush
operator|==
name|Z_FINISH
argument_list|)
expr_stmt|;
return|return
name|flush
operator|==
name|Z_FINISH
condition|?
name|finish_done
else|:
name|block_done
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FASTEST */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ===========================================================================  * For Z_RLE, simply look for runs of bytes, generate matches only of distance  * one.  Do not maintain a hash table.  (It will be regenerated if this run of  * deflate switches away from Z_RLE.)  */
end_comment

begin_comment
unit|local block_state deflate_rle(s, flush)     deflate_state *s;     int flush; {     int bflush;
comment|/* set if current block must be flushed */
end_comment

begin_comment
unit|uInt run;
comment|/* length of run */
end_comment

begin_comment
unit|uInt max;
comment|/* maximum length of run */
end_comment

begin_comment
unit|uInt prev;
comment|/* byte at distance one to match */
end_comment

begin_comment
unit|Bytef *scan;
comment|/* scan for end of run */
end_comment

begin_comment
unit|for (;;) {
comment|/* Make sure that we always have enough lookahead, except          * at the end of the input file. We need MAX_MATCH bytes          * for the longest encodable run.          */
end_comment

begin_comment
unit|if (s->lookahead< MAX_MATCH) {             fill_window(s);             if (s->lookahead< MAX_MATCH&& flush == Z_NO_FLUSH) {                 return need_more;             }             if (s->lookahead == 0) break;
comment|/* flush the current block */
end_comment

begin_comment
unit|}
comment|/* See how many times the previous byte repeats */
end_comment

begin_comment
unit|run = 0;         if (s->strstart> 0) {
comment|/* if there is a previous byte, that is */
end_comment

begin_comment
unit|max = s->lookahead< MAX_MATCH ? s->lookahead : MAX_MATCH;             scan = s->window + s->strstart - 1;             prev = *scan++;             do {                 if (*scan++ != prev)                     break;             } while (++run< max);         }
comment|/* Emit match if have run of MIN_MATCH or longer, else emit literal */
end_comment

begin_comment
unit|if (run>= MIN_MATCH) {             check_match(s, s->strstart, s->strstart - 1, run);             _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);             s->lookahead -= run;             s->strstart += run;         } else {
comment|/* No match, output a literal byte */
end_comment

begin_endif
unit|Tracevv((stderr,"%c", s->window[s->strstart]));             _tr_tally_lit (s, s->window[s->strstart], bflush);             s->lookahead--;             s->strstart++;         }         if (bflush) FLUSH_BLOCK(s, 0);     }     FLUSH_BLOCK(s, flush == Z_FINISH);     return flush == Z_FINISH ? finish_done : block_done; }
endif|#
directive|endif
end_endif

end_unit

