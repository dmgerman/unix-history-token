begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * $FreeBSD$  * Id: ip_log.c,v 2.75.2.19 2007/09/09 11:32:06 darrenr Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOLARIS
end_ifndef

begin_define
define|#
directive|define
name|SOLARIS
value|(defined(sun)&& (defined(__svr4__) || defined(__SVR4)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|220000
operator|)
operator|)
operator|&&
expr|\
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|__NetBSD_Version__
operator|>=
literal|104000000
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_if
if|#
directive|if
operator|!
name|SOLARIS
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|>
literal|199609
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|OpenBSD
argument_list|)
operator|&&
operator|(
name|OpenBSD
operator|>
literal|199603
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/ksynch.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOLARIS&& !__hpux */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|300000
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__sgi
end_ifdef

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IFF_DRVRLOCK
end_ifdef

begin_comment
comment|/* IRIX6 */
end_comment

begin_include
include|#
directive|include
file|<sys/hashing.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
expr|\
operator|!
operator|(
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IFF_DRVRLOCK
argument_list|)
operator|)
end_if

begin_comment
comment|/*IRIX<6*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_auth.h"
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPL_SELECT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread_iface.h>
end_include

begin_define
define|#
directive|define
name|READ_COLLISION
value|0x001
end_define

begin_decl_stmt
specifier|extern
name|int
name|selwait
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPL_SELECT */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ipf_log_softc_s
block|{
name|ipfmutex_t
name|ipl_mutex
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|kcondvar_t
name|ipl_wait
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|wait_queue_head_t
name|iplh_linux
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|iplog_select_t
name|ipl_ss
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|iplog_t
modifier|*
modifier|*
name|iplh
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|iplog_t
modifier|*
name|iplt
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|iplog_t
modifier|*
name|ipll
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|u_long
name|ipl_logfail
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|u_long
name|ipl_logok
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|fr_info_t
name|ipl_crc
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|u_32_t
name|ipl_counter
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|int
name|ipl_suppress
decl_stmt|;
name|int
name|ipl_logall
decl_stmt|;
name|int
name|ipl_log_init
decl_stmt|;
name|int
name|ipl_logsize
decl_stmt|;
name|int
name|ipl_used
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|int
name|ipl_magic
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
name|ipftuneable_t
modifier|*
name|ipf_log_tune
decl_stmt|;
name|int
name|ipl_readers
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
block|}
name|ipf_log_softc_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|magic
index|[
name|IPL_LOGSIZE
index|]
init|=
block|{
name|IPL_MAGIC
block|,
name|IPL_MAGIC_NAT
block|,
name|IPL_MAGIC_STATE
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
name|ipf_log_tuneables
index|[]
init|=
block|{
comment|/* log */
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_log_softc_t
argument_list|,
argument|ipl_suppress
argument_list|)
block|}
block|,
literal|"log_suppress"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_log_softc_t
argument_list|,
name|ipl_suppress
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_log_softc_t
argument_list|,
argument|ipl_logall
argument_list|)
block|}
block|,
literal|"log_all"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_log_softc_t
argument_list|,
name|ipl_logall
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_log_softc_t
argument_list|,
argument|ipl_logsize
argument_list|)
block|}
block|,
literal|"log_size"
block|,
literal|0
block|,
literal|0x80000
block|,
name|stsizeof
argument_list|(
name|ipf_log_softc_t
argument_list|,
name|ipl_logsize
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
name|NULL
block|}
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ipf_log_main_load
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ipf_log_main_unload
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_soft_create                                         */
end_comment

begin_comment
comment|/* Returns:     void * - NULL = failure, else pointer to log context data   */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise log buffers& pointers.  Also iniialised the CRC to a local   */
end_comment

begin_comment
comment|/* secret for use in calculating the "last log checksum".                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_log_soft_create
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
decl_stmt|;
name|KMALLOC
argument_list|(
name|softl
argument_list|,
name|ipf_log_softc_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|softl
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softl
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|magic
argument_list|,
operator|(
name|char
operator|*
operator|)
name|softl
operator|->
name|ipl_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|softl
operator|->
name|ipf_log_tune
operator|=
name|ipf_tune_array_copy
argument_list|(
name|softl
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_log_tuneables
argument_list|)
argument_list|,
name|ipf_log_tuneables
argument_list|)
expr_stmt|;
if|if
condition|(
name|softl
operator|->
name|ipf_log_tune
operator|==
name|NULL
condition|)
block|{
name|ipf_log_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ipf_tune_array_link
argument_list|(
name|softc
argument_list|,
name|softl
operator|->
name|ipf_log_tune
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_log_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|softl
operator|->
name|ipl_suppress
operator|=
literal|1
expr_stmt|;
name|softl
operator|->
name|ipl_logall
operator|=
literal|0
expr_stmt|;
name|softl
operator|->
name|ipl_log_init
operator|=
literal|0
expr_stmt|;
name|softl
operator|->
name|ipl_logsize
operator|=
name|IPFILTER_LOGSIZE
expr_stmt|;
return|return
name|softl
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_soft_init                                           */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success (always returned)                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise log buffers& pointers.  Also iniialised the CRC to a local   */
end_comment

begin_comment
comment|/* secret for use in calculating the "last log checksum".                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_soft_init
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|softl
operator|->
name|iplt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|softl
operator|->
name|ipll
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|softl
operator|->
name|iplh
index|[
name|i
index|]
operator|=
operator|&
name|softl
operator|->
name|iplt
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|softl
operator|->
name|ipl_crc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|softl
operator|->
name|ipl_crc
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
name|softl
operator|->
name|iplog_ss
index|[
name|i
index|]
operator|.
name|read_waiter
operator|=
literal|0
expr_stmt|;
name|softl
operator|->
name|iplog_ss
index|[
name|i
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|init_waitqueue_head
argument_list|(
name|softl
operator|->
name|iplh_linux
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_init
argument_list|(
operator|&
name|softl
operator|->
name|ipl_wait
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|CV_DRIVER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_INIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|,
literal|"ipf log mutex"
argument_list|)
expr_stmt|;
block|}
name|softl
operator|->
name|ipl_log_init
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_soft_fini                                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              arg(I)   - pointer to log context structure                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Clean up any log data that has accumulated without being read.           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_soft_fini
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|softl
operator|->
name|ipl_log_init
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|softl
operator|->
name|ipl_log_init
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|ipf_log_clear
argument_list|(
name|softc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * This is a busy-wait loop so as to avoid yet another lock 		 * to wait on. 		 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|softl
operator|->
name|ipl_readers
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_broadcast
argument_list|(
operator|&
name|softl
operator|->
name|ipl_wait
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|pollwakeup
argument_list|(
operator|&
name|softc
operator|->
name|ipf_poll_head
index|[
name|i
index|]
argument_list|,
name|POLLRDNORM
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WAKEUP
argument_list|(
name|softl
operator|->
name|iplh
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|POLLWAKEUP
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_soft_destroy                                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              arg(I)   - pointer to log context structure                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When this function is called, it is expected that there are no longer    */
end_comment

begin_comment
comment|/* any threads active in the reading code path or the logging code path.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_log_soft_destroy
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_destroy
argument_list|(
operator|&
name|softl
operator|->
name|ipl_wait
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softl
operator|->
name|ipf_log_tune
operator|!=
name|NULL
condition|)
block|{
name|ipf_tune_array_unlink
argument_list|(
name|softc
argument_list|,
name|softl
operator|->
name|ipf_log_tune
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|softl
operator|->
name|ipf_log_tune
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_log_tuneables
argument_list|)
argument_list|)
expr_stmt|;
name|softl
operator|->
name|ipf_log_tune
operator|=
name|NULL
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|softl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_pkt                                                 */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == success, -1 == failure                      */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              flags(I) - flags from filter rules                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create a log record for a packet given that it has been triggered by a   */
end_comment

begin_comment
comment|/* rule (or the default setting).  Calculate the transport protocol header  */
end_comment

begin_comment
comment|/* size using predetermined size of a couple of popular protocols and thus  */
end_comment

begin_comment
comment|/* how much data to copy into the log, including part of the data body if   */
end_comment

begin_comment
comment|/* requested.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_pkt
parameter_list|(
name|fin
parameter_list|,
name|flags
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
specifier|register
name|size_t
name|hlen
decl_stmt|;
name|int
name|types
index|[
literal|2
index|]
decl_stmt|,
name|mlen
decl_stmt|;
name|size_t
name|sizes
index|[
literal|2
index|]
decl_stmt|;
name|void
modifier|*
name|ptrs
index|[
literal|2
index|]
decl_stmt|;
name|ipflog_t
name|ipfl
decl_stmt|;
name|u_char
name|p
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
if|#
directive|if
operator|(
name|SOLARIS
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FW_HOOKS
argument_list|)
name|qif_t
modifier|*
name|ifp
decl_stmt|;
else|#
directive|else
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
endif|#
directive|endif
comment|/* SOLARIS || __hpux */
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ipfl
operator|.
name|fl_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|hlen
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
expr_stmt|;
comment|/* 	 * calculate header size. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|IPPROTO_TCP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_UDP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|struct
name|icmp
modifier|*
name|icmp
decl_stmt|;
name|icmp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
comment|/* 			 * For ICMP, if the packet is an error packet, also 			 * include the information about the packet which 			 * caused the error. 			 */
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_REDIRECT
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|+
literal|8
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
default|default :
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icmp
decl_stmt|;
name|icmp
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
comment|/* 			 * For ICMPV6, if the packet is an error packet, also 			 * include the information about the packet which 			 * caused the error. 			 */
if|if
condition|(
name|icmp
operator|->
name|icmp6_type
operator|<
literal|128
condition|)
block|{
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
literal|8
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Get the interface number and name to which this packet is 	 * currently associated. 	 */
if|#
directive|if
operator|(
name|SOLARIS
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FW_HOOKS
argument_list|)
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_int
operator|)
name|ifp
operator|->
name|qf_ppa
expr_stmt|;
endif|#
directive|endif
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_v
argument_list|,
name|ifp
argument_list|,
name|ipfl
operator|.
name|fl_ifname
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|<=
literal|1991011
operator|)
operator|&&
operator|(
name|NetBSD
operator|>=
literal|199603
operator|)
operator|)
operator|||
expr|\
name|OPENBSD_GE_REV
argument_list|(
literal|199603
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
name|FREEBSD_GE_REV
argument_list|(
literal|501113
argument_list|)
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_v
argument_list|,
name|ifp
argument_list|,
name|ipfl
operator|.
name|fl_ifname
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_int
operator|)
name|ifp
operator|->
name|if_unit
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|0
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|0
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|1
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|1
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|2
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|2
index|]
operator|)
condition|)
name|ipfl
operator|.
name|fl_ifname
index|[
literal|3
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|,
name|IFNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|ipfl
operator|.
name|fl_ifname
index|[
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* __hpux || SOLARIS */
name|mlen
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
operator|!
name|softl
operator|->
name|ipl_logall
condition|)
block|{
name|mlen
operator|=
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
condition|?
name|MIN
argument_list|(
name|mlen
argument_list|,
literal|128
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
operator|==
literal|0
condition|)
block|{
name|mlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mlen
operator|<
literal|0
condition|)
name|mlen
operator|=
literal|0
expr_stmt|;
name|ipfl
operator|.
name|fl_plen
operator|=
operator|(
name|u_char
operator|)
name|mlen
expr_stmt|;
name|ipfl
operator|.
name|fl_hlen
operator|=
operator|(
name|u_char
operator|)
name|hlen
expr_stmt|;
name|ipfl
operator|.
name|fl_rule
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipfl
operator|.
name|fl_group
argument_list|,
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|!=
name|NULL
condition|)
block|{
name|ipfl
operator|.
name|fl_loglevel
operator|=
name|fin
operator|->
name|fin_fr
operator|->
name|fr_loglevel
expr_stmt|;
name|ipfl
operator|.
name|fl_logtag
operator|=
name|fin
operator|->
name|fin_fr
operator|->
name|fr_logtag
expr_stmt|;
block|}
else|else
block|{
name|ipfl
operator|.
name|fl_loglevel
operator|=
literal|0xffff
expr_stmt|;
name|ipfl
operator|.
name|fl_logtag
operator|=
name|FR_NOLOGTAG
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|fin
operator|->
name|fin_nattag
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ipfl
operator|.
name|fl_nattag
argument_list|,
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_nattag
argument_list|)
argument_list|)
expr_stmt|;
name|ipfl
operator|.
name|fl_flags
operator|=
name|flags
expr_stmt|;
name|ipfl
operator|.
name|fl_breason
operator|=
operator|(
name|fin
operator|->
name|fin_reason
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ipfl
operator|.
name|fl_dir
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|ipfl
operator|.
name|fl_lflags
operator|=
name|fin
operator|->
name|fin_flx
expr_stmt|;
name|ipfl
operator|.
name|fl_family
operator|=
name|fin
operator|->
name|fin_family
expr_stmt|;
name|ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ipfl
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ipfl
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
comment|/* 	 * Are we copied from the mblk or an aligned array ? 	 */
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|m
operator|->
name|b_rptr
condition|)
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* MENTAT */
return|return
name|ipf_log_items
argument_list|(
name|softc
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|fin
argument_list|,
name|ptrs
argument_list|,
name|sizes
argument_list|,
name|types
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_items                                               */
end_comment

begin_comment
comment|/* Returns:     int       - 0 == success, -1 == failure                     */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to main soft context                    */
end_comment

begin_comment
comment|/*              unit(I)   - device we are reading from                      */
end_comment

begin_comment
comment|/*              fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              items(I)  - array of pointers to log data                   */
end_comment

begin_comment
comment|/*              itemsz(I) - array of size of valid memory pointed to        */
end_comment

begin_comment
comment|/*              types(I)  - type of data pointed to by items pointers       */
end_comment

begin_comment
comment|/*              cnt(I)    - number of elements in arrays items/itemsz/types */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Takes an array of parameters and constructs one record to include the    */
end_comment

begin_comment
comment|/* miscellaneous packet information, as well as packet data, for reading    */
end_comment

begin_comment
comment|/* from the log device.                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_items
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|fin
parameter_list|,
name|items
parameter_list|,
name|itemsz
parameter_list|,
name|types
parameter_list|,
name|cnt
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|void
modifier|*
modifier|*
name|items
decl_stmt|;
name|size_t
modifier|*
name|itemsz
decl_stmt|;
name|int
modifier|*
name|types
decl_stmt|,
name|cnt
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|,
name|ptr
decl_stmt|;
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Get the total amount of data to be logged. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|=
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|softl
operator|->
name|ipl_counter
index|[
name|unit
index|]
operator|++
expr_stmt|;
comment|/* 	 * check that we have space to record this information and can 	 * allocate that much. 	 */
if|if
condition|(
operator|(
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|+
name|len
operator|)
operator|>
name|softl
operator|->
name|ipl_logsize
condition|)
block|{
name|softl
operator|->
name|ipl_logfail
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|KMALLOCS
argument_list|(
name|buf
argument_list|,
name|caddr_t
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|softl
operator|->
name|ipl_logfail
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ipl
operator|=
operator|(
name|iplog_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ipl
operator|->
name|ipl_magic
operator|=
name|softl
operator|->
name|ipl_magic
index|[
name|unit
index|]
expr_stmt|;
name|ipl
operator|->
name|ipl_count
operator|=
literal|1
expr_stmt|;
name|ipl
operator|->
name|ipl_seqnum
operator|=
name|softl
operator|->
name|ipl_counter
index|[
name|unit
index|]
expr_stmt|;
name|ipl
operator|->
name|ipl_next
operator|=
name|NULL
expr_stmt|;
name|ipl
operator|->
name|ipl_dsize
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|GETKTIME
argument_list|(
operator|&
name|ipl
operator|->
name|ipl_sec
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipl
operator|->
name|ipl_sec
operator|=
literal|0
expr_stmt|;
name|ipl
operator|->
name|ipl_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Loop through all the items to be logged, copying each one to the 	 * buffer.  Use bcopy for normal data or the mb_t copyout routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptr
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ipl
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|COPYDATA
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Check to see if this log record has a CRC which matches the last 	 * record logged.  If it does, just up the count on the previous one 	 * rather than create a new one. 	 */
if|if
condition|(
name|softl
operator|->
name|ipl_suppress
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|softl
operator|->
name|ipll
index|[
name|unit
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_crc
operator|==
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
operator|.
name|fin_crc
operator|)
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
argument_list|,
name|FI_LCSIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|softl
operator|->
name|ipll
index|[
name|unit
index|]
operator|->
name|ipl_count
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
argument_list|,
name|FI_LCSIZE
argument_list|)
expr_stmt|;
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
operator|.
name|fin_crc
operator|=
name|fin
operator|->
name|fin_crc
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
argument_list|,
name|FI_CSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * advance the log pointer to the next empty record and deduct the 	 * amount of space we're going to use. 	 */
name|softl
operator|->
name|ipl_logok
index|[
name|unit
index|]
operator|++
expr_stmt|;
name|softl
operator|->
name|ipll
index|[
name|unit
index|]
operator|=
name|ipl
expr_stmt|;
operator|*
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
operator|=
name|ipl
expr_stmt|;
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Now that the log record has been completed and added to the queue, 	 * wake up any listeners who may want to read it. 	 */
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_signal
argument_list|(
operator|&
name|softl
operator|->
name|ipl_wait
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|pollwakeup
argument_list|(
operator|&
name|softc
operator|->
name|ipf_poll_head
index|[
name|unit
index|]
argument_list|,
name|POLLRDNORM
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|WAKEUP
argument_list|(
name|softl
operator|->
name|iplh
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|POLLWAKEUP
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
name|iplog_input_ready
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_read                                                */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == success, else error value.                  */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*              uio(O)   - pointer to information about where to store data */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called to handle a read on an IPFilter device.  Returns only complete    */
end_comment

begin_comment
comment|/* log messages - will not partially copy a log record out to userland.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: This function will block and wait for a signal to return data if   */
end_comment

begin_comment
comment|/* there is none present.  Asynchronous I/O is not implemented.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_read
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|,
name|uio
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|copied
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|softl
operator|->
name|ipl_log_init
operator|==
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|40007
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Sanity checks.  Make sure the minor # is valid and we're copying 	 * a valid chunk of data. 	 */
if|if
condition|(
name|IPL_LOGMAX
operator|<
name|unit
condition|)
block|{
name|IPFERROR
argument_list|(
literal|40001
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|40002
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|softl
operator|->
name|ipl_logsize
condition|)
block|{
name|IPFERROR
argument_list|(
literal|40005
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Lock the log so we can snapshot the variables.  Wait for a signal 	 * if the log is empty. 	 */
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|softl
operator|->
name|ipl_log_init
operator|==
literal|1
operator|&&
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|cv_wait_sig
argument_list|(
operator|&
name|softl
operator|->
name|ipl_wait
index|[
name|unit
index|]
argument_list|,
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
operator|.
name|ipf_lk
argument_list|)
condition|)
block|{
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|40003
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|lock_t
modifier|*
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
if|if
condition|(
name|uio
operator|->
name|uio_fpflags
operator|&
operator|(
name|FNBLOCK
operator||
name|FNDELAY
operator|)
condition|)
block|{
comment|/* this is no blocking system call */
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|l
operator|=
name|get_sleep_lock
argument_list|(
operator|&
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|sleep
argument_list|(
operator|&
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|spinunlock
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|error
operator|=
name|mpsleep
argument_list|(
operator|&
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
argument_list|,
name|PSUSP
operator||
name|PCATCH
argument_list|,
literal|"ipfread"
argument_list|,
literal|0
argument_list|,
operator|&
name|softl
operator|->
name|ipl_mutex
argument_list|,
name|MS_LOCK_SIMPLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|SLEEP
argument_list|(
name|unit
operator|+
name|softl
operator|->
name|iplh
argument_list|,
literal|"ipl sleep"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __osf__ */
endif|#
directive|endif
comment|/* __hpux */
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|40004
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* SOLARIS */
block|}
if|if
condition|(
name|softl
operator|->
name|ipl_log_init
operator|!=
literal|1
condition|)
block|{
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|40008
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199101
operator|)
operator|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__osf__
argument_list|)
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|copied
operator|=
literal|0
init|;
operator|(
name|ipl
operator|=
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|;
name|copied
operator|+=
name|dlen
control|)
block|{
name|dlen
operator|=
name|ipl
operator|->
name|ipl_dsize
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
break|break;
comment|/* 		 * Don't hold the mutex over the uiomove call. 		 */
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|-=
name|dlen
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|UIOMOVE
argument_list|(
name|ipl
argument_list|,
name|dlen
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|40006
argument_list|)
expr_stmt|;
name|ipl
operator|->
name|ipl_next
operator|=
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
expr_stmt|;
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
condition|)
block|{
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|softl
operator|->
name|ipll
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|softl
operator|->
name|ipl_readers
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_clear                                               */
end_comment

begin_comment
comment|/* Returns:     int      - number of log bytes cleared.                     */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Deletes all queued up log records for a given output device.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_clear
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|int
name|used
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ipl
operator|=
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|ipl
operator|->
name|ipl_dsize
argument_list|)
expr_stmt|;
block|}
name|softl
operator|->
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|softl
operator|->
name|ipll
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|used
operator|=
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
expr_stmt|;
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|softl
operator|->
name|ipl_crc
index|[
name|unit
index|]
argument_list|,
name|FI_CSIZE
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softl
operator|->
name|ipl_mutex
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_canread                                             */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == no data to read, 1 = data present           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns an indication of whether or not there is data present in the     */
end_comment

begin_comment
comment|/* current buffer for the selected ipf device.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_canread
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
return|return
name|softl
operator|->
name|iplt
index|[
name|unit
index|]
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_canread                                             */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == no data to read, 1 = data present           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns how many bytes are currently held in log buffers for the         */
end_comment

begin_comment
comment|/* selected ipf device.                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_log_bytesused
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
if|if
condition|(
name|softl
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|softl
operator|->
name|ipl_used
index|[
name|unit
index|]
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_failures                                            */
end_comment

begin_comment
comment|/* Returns:     U_QUAD_T - number of log failures                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns how many times we've tried to log a packet but failed to do so   */
end_comment

begin_comment
comment|/* for the selected ipf device.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_long
name|ipf_log_failures
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
if|if
condition|(
name|softl
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|softl
operator|->
name|ipl_logfail
index|[
name|unit
index|]
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_log_logok                                               */
end_comment

begin_comment
comment|/* Returns:     U_QUAD_T - number of packets logged                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              unit(I)  - device we are reading from                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns how many times we've successfully logged a packet for the        */
end_comment

begin_comment
comment|/* selected ipf device.                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_long
name|ipf_log_logok
parameter_list|(
name|softc
parameter_list|,
name|unit
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|ipf_log_softc_t
modifier|*
name|softl
init|=
name|softc
operator|->
name|ipf_log_soft
decl_stmt|;
if|if
condition|(
name|softl
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|softl
operator|->
name|ipl_logok
index|[
name|unit
index|]
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

end_unit

