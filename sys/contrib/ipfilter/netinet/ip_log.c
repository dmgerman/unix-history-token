begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1997-2003 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * $FreeBSD$  * Id: ip_log.c,v 2.75.2.6 2004/10/16 07:59:27 darrenr Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|>=
literal|199905
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter_log.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOLARIS
end_ifndef

begin_define
define|#
directive|define
name|SOLARIS
value|(defined(sun)&& (defined(__svr4__) || defined(__SVR4)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|__NetBSD_Version__
operator|>=
literal|104000000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_if
if|#
directive|if
operator|!
name|SOLARIS
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|NetBSD
operator|>
literal|199609
operator|)
operator|||
operator|(
name|OpenBSD
operator|>
literal|199603
operator|)
operator|||
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/ksynch.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOLARIS&& !__hpux */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|300000
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__sgi
end_ifdef

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IFF_DRVRLOCK
end_ifdef

begin_comment
comment|/* IRIX6 */
end_comment

begin_include
include|#
directive|include
file|<sys/hashing.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
expr|\
operator|!
operator|(
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IFF_DRVRLOCK
argument_list|)
operator|)
end_if

begin_comment
comment|/*IRIX<6*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_auth.h"
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPL_SELECT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread_iface.h>
end_include

begin_define
define|#
directive|define
name|READ_COLLISION
value|0x001
end_define

begin_decl_stmt
name|iplog_select_t
name|iplog_ss
index|[
name|IPL_LOGMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|selwait
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPL_SELECT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_decl_stmt
name|wait_queue_head_t
name|iplh_linux
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SOLARIS
end_if

begin_decl_stmt
specifier|extern
name|kcondvar_t
name|iplwait
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|iplog_t
modifier|*
modifier|*
name|iplh
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|,
modifier|*
name|iplt
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|,
modifier|*
name|ipll
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iplused
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fr_info_t
name|iplcrc
index|[
name|IPL_LOGSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_suppress
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_buffer_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_logmax
init|=
name|IPL_LOGMAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_logall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_log_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_logsize
init|=
name|IPFILTER_LOGSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipl_magic
index|[
name|IPL_LOGSIZE
index|]
init|=
block|{
name|IPL_MAGIC
block|,
name|IPL_MAGIC_NAT
block|,
name|IPL_MAGIC_STATE
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|,
name|IPL_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_loginit                                                  */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success (always returned)                        */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise log buffers& pointers.  Also iniialised the CRC to a local   */
end_comment

begin_comment
comment|/* secret for use in calculating the "last log checksum".                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_loginit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|iplt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ipll
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|iplh
index|[
name|i
index|]
operator|=
operator|&
name|iplt
index|[
name|i
index|]
expr_stmt|;
name|iplused
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iplcrc
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|iplcrc
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
name|iplog_ss
index|[
name|i
index|]
operator|.
name|read_waiter
operator|=
literal|0
expr_stmt|;
name|iplog_ss
index|[
name|i
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|init_waitqueue_head
argument_list|(
name|iplh_linux
operator|+
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_init
argument_list|(
operator|&
name|iplwait
argument_list|,
literal|"ipl condvar"
argument_list|,
name|CV_DRIVER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_INIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|,
literal|"ipf log mutex"
argument_list|)
expr_stmt|;
name|ipl_log_init
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_logunload                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Clean up any log data that has accumulated without being read.           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_logunload
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ipl_log_init
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|IPL_LOGMAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
name|void
operator|)
name|ipflog_clear
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_destroy
argument_list|(
operator|&
name|iplwait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|ipl_log_init
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipflog                                                      */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              flags(I) - flags from filter rules                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create a log record for a packet given that it has been triggered by a   */
end_comment

begin_comment
comment|/* rule (or the default setting).  Calculate the transport protocol header  */
end_comment

begin_comment
comment|/* size using predetermined size of a couple of popular protocols and thus  */
end_comment

begin_comment
comment|/* how much data to copy into the log, including part of the data body if   */
end_comment

begin_comment
comment|/* requested.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipflog
parameter_list|(
name|fin
parameter_list|,
name|flags
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
specifier|register
name|size_t
name|hlen
decl_stmt|;
name|int
name|types
index|[
literal|2
index|]
decl_stmt|,
name|mlen
decl_stmt|;
name|size_t
name|sizes
index|[
literal|2
index|]
decl_stmt|;
name|void
modifier|*
name|ptrs
index|[
literal|2
index|]
decl_stmt|;
name|ipflog_t
name|ipfl
decl_stmt|;
name|u_char
name|p
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
if|#
directive|if
operator|(
name|SOLARIS
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|qif_t
modifier|*
name|ifp
decl_stmt|;
else|#
directive|else
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
endif|#
directive|endif
comment|/* SOLARIS || __hpux */
name|ipfl
operator|.
name|fl_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|hlen
operator|=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
comment|/* 	 * calculate header size. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|IPPROTO_TCP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_UDP
condition|)
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|struct
name|icmp
modifier|*
name|icmp
decl_stmt|;
name|icmp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
comment|/* 			 * For ICMP, if the packet is an error packet, also 			 * include the information about the packet which 			 * caused the error. 			 */
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_UNREACH
case|:
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_REDIRECT
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|+
literal|8
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
default|default :
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|p
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icmp
decl_stmt|;
name|icmp
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
comment|/* 			 * For ICMPV6, if the packet is an error packet, also 			 * include the information about the packet which 			 * caused the error. 			 */
if|if
condition|(
name|icmp
operator|->
name|icmp6_type
operator|<
literal|128
condition|)
block|{
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
literal|8
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hlen
operator|+=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
argument_list|,
name|fin
operator|->
name|fin_dlen
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Get the interface number and name to which this packet is 	 * currently associated. 	 */
if|#
directive|if
operator|(
name|SOLARIS
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_int
operator|)
name|ifp
operator|->
name|qf_ppa
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|ifp
argument_list|,
name|ipfl
operator|.
name|fl_ifname
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NetBSD
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|<=
literal|1991011
operator|)
operator|&&
operator|(
name|NetBSD
operator|>=
literal|199603
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|OpenBSD
argument_list|)
operator|&&
operator|(
name|OpenBSD
operator|>=
literal|199603
operator|)
operator|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|501113
operator|)
operator|)
name|COPYIFNAME
argument_list|(
name|ifp
argument_list|,
name|ipfl
operator|.
name|fl_ifname
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipfl
operator|.
name|fl_unit
operator|=
operator|(
name|u_int
operator|)
name|ifp
operator|->
name|if_unit
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|0
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|0
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|1
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|1
index|]
operator|)
condition|)
if|if
condition|(
operator|(
name|ipfl
operator|.
name|fl_ifname
index|[
literal|2
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|2
index|]
operator|)
condition|)
name|ipfl
operator|.
name|fl_ifname
index|[
literal|3
index|]
operator|=
name|ifp
operator|->
name|if_name
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|,
name|IFNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|ipfl
operator|.
name|fl_ifname
index|[
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_ifname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* __hpux || SOLARIS */
name|mlen
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
operator|!
name|ipl_logall
condition|)
block|{
name|mlen
operator|=
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
condition|?
name|MIN
argument_list|(
name|mlen
argument_list|,
literal|128
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|FR_LOGBODY
operator|)
operator|==
literal|0
condition|)
block|{
name|mlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mlen
operator|<
literal|0
condition|)
name|mlen
operator|=
literal|0
expr_stmt|;
name|ipfl
operator|.
name|fl_plen
operator|=
operator|(
name|u_char
operator|)
name|mlen
expr_stmt|;
name|ipfl
operator|.
name|fl_hlen
operator|=
operator|(
name|u_char
operator|)
name|hlen
expr_stmt|;
name|ipfl
operator|.
name|fl_rule
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipfl
operator|.
name|fl_group
argument_list|,
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|!=
name|NULL
condition|)
block|{
name|ipfl
operator|.
name|fl_loglevel
operator|=
name|fin
operator|->
name|fin_fr
operator|->
name|fr_loglevel
expr_stmt|;
name|ipfl
operator|.
name|fl_logtag
operator|=
name|fin
operator|->
name|fin_fr
operator|->
name|fr_logtag
expr_stmt|;
block|}
else|else
block|{
name|ipfl
operator|.
name|fl_loglevel
operator|=
literal|0xffff
expr_stmt|;
name|ipfl
operator|.
name|fl_logtag
operator|=
name|FR_NOLOGTAG
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|fin
operator|->
name|fin_nattag
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ipfl
operator|.
name|fl_nattag
argument_list|,
sizeof|sizeof
argument_list|(
name|ipfl
operator|.
name|fl_nattag
argument_list|)
argument_list|)
expr_stmt|;
name|ipfl
operator|.
name|fl_flags
operator|=
name|flags
expr_stmt|;
name|ipfl
operator|.
name|fl_dir
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|ipfl
operator|.
name|fl_lflags
operator|=
name|fin
operator|->
name|fin_flx
expr_stmt|;
name|ptrs
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ipfl
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ipfl
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
comment|/* 	 * Are we copied from the mblk or an aligned array ? 	 */
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|m
operator|->
name|b_rptr
condition|)
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptrs
index|[
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|ptrs
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|sizes
index|[
literal|1
index|]
operator|=
name|hlen
operator|+
name|mlen
expr_stmt|;
name|types
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* MENTAT */
return|return
name|ipllog
argument_list|(
name|IPL_LOGIPF
argument_list|,
name|fin
argument_list|,
name|ptrs
argument_list|,
name|sizes
argument_list|,
name|types
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipllog                                                      */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  dev(I)    - device that owns this log record                */
end_comment

begin_comment
comment|/*              fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              items(I)  - array of pointers to log data                   */
end_comment

begin_comment
comment|/*              itemsz(I) - array of size of valid memory pointed to        */
end_comment

begin_comment
comment|/*              types(I)  - type of data pointed to by items pointers       */
end_comment

begin_comment
comment|/*              cnt(I)    - number of elements in arrays items/itemsz/types */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Takes an array of parameters and constructs one record to include the    */
end_comment

begin_comment
comment|/* miscellaneous packet information, as well as packet data, for reading    */
end_comment

begin_comment
comment|/* from the log device.                                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipllog
parameter_list|(
name|dev
parameter_list|,
name|fin
parameter_list|,
name|items
parameter_list|,
name|itemsz
parameter_list|,
name|types
parameter_list|,
name|cnt
parameter_list|)
name|int
name|dev
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|void
modifier|*
modifier|*
name|items
decl_stmt|;
name|size_t
modifier|*
name|itemsz
decl_stmt|;
name|int
modifier|*
name|types
decl_stmt|,
name|cnt
decl_stmt|;
block|{
name|caddr_t
name|buf
decl_stmt|,
name|ptr
decl_stmt|;
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SPL
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Check to see if this log record has a CRC which matches the last 	 * record logged.  If it does, just up the count on the previous one 	 * rather than create a new one. 	 */
if|if
condition|(
name|ipl_suppress
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ipll
index|[
name|dev
index|]
operator|!=
name|NULL
operator|)
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iplcrc
index|[
name|dev
index|]
argument_list|,
name|FI_LCSIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipll
index|[
name|dev
index|]
operator|->
name|ipl_count
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iplcrc
index|[
name|dev
index|]
argument_list|,
name|FI_LCSIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iplcrc
index|[
name|dev
index|]
argument_list|,
name|FI_CSIZE
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the total amount of data to be logged. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len
operator|=
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * check that we have space to record this information and can 	 * allocate that much. 	 */
name|KMALLOCS
argument_list|(
name|buf
argument_list|,
name|caddr_t
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iplused
index|[
name|dev
index|]
operator|+
name|len
operator|)
operator|>
name|ipl_logsize
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|iplused
index|[
name|dev
index|]
operator|+=
name|len
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * advance the log pointer to the next empty record and deduct the 	 * amount of space we're going to use. 	 */
name|ipl
operator|=
operator|(
name|iplog_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ipl
operator|->
name|ipl_magic
operator|=
name|ipl_magic
index|[
name|dev
index|]
expr_stmt|;
name|ipl
operator|->
name|ipl_count
operator|=
literal|1
expr_stmt|;
name|ipl
operator|->
name|ipl_next
operator|=
name|NULL
expr_stmt|;
name|ipl
operator|->
name|ipl_dsize
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|GETKTIME
argument_list|(
operator|&
name|ipl
operator|->
name|ipl_sec
argument_list|)
expr_stmt|;
else|#
directive|else
name|ipl
operator|->
name|ipl_sec
operator|=
literal|0
expr_stmt|;
name|ipl
operator|->
name|ipl_usec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Loop through all the items to be logged, copying each one to the 	 * buffer.  Use bcopy for normal data or the mb_t copyout routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ptr
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ipl
argument_list|)
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|COPYDATA
argument_list|(
name|items
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|itemsz
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|itemsz
index|[
name|i
index|]
expr_stmt|;
block|}
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|ipll
index|[
name|dev
index|]
operator|=
name|ipl
expr_stmt|;
operator|*
name|iplh
index|[
name|dev
index|]
operator|=
name|ipl
expr_stmt|;
name|iplh
index|[
name|dev
index|]
operator|=
operator|&
name|ipl
operator|->
name|ipl_next
expr_stmt|;
comment|/* 	 * Now that the log record has been completed and added to the queue, 	 * wake up any listeners who may want to read it. 	 */
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|cv_signal
argument_list|(
operator|&
name|iplwait
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|WAKEUP
argument_list|(
name|iplh
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
name|iplog_input_ready
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipflog_read                                                 */
end_comment

begin_comment
comment|/* Returns:     int    - 0 == success, else error value.                    */
end_comment

begin_comment
comment|/* Parameters:  unit(I) - device we are reading from                        */
end_comment

begin_comment
comment|/*              uio(O)  - pointer to information about where to store data  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called to handle a read on an IPFilter device.  Returns only complete    */
end_comment

begin_comment
comment|/* log messages - will not partially copy a log record out to userland.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: This function will block and wait for a signal to return data if   */
end_comment

begin_comment
comment|/* there is none present.  Asynchronous I/O is not implemented.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipflog_read
parameter_list|(
name|unit
parameter_list|,
name|uio
parameter_list|)
name|minor_t
name|unit
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
name|size_t
name|dlen
decl_stmt|,
name|copied
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SPL
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Sanity checks.  Make sure the minor # is valid and we're copying 	 * a valid chunk of data. 	 */
if|if
condition|(
name|IPL_LOGMAX
operator|<
name|unit
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
name|iplog_t
argument_list|)
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|ipl_logsize
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Lock the log so we can snapshot the variables.  Wait for a signal 	 * if the log is empty. 	 */
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|iplt
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|cv_wait_sig
argument_list|(
operator|&
name|iplwait
argument_list|,
operator|&
name|ipl_mutex
operator|.
name|ipf_lk
argument_list|)
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|lock_t
modifier|*
name|l
decl_stmt|;
ifdef|#
directive|ifdef
name|IPL_SELECT
if|if
condition|(
name|uio
operator|->
name|uio_fpflags
operator|&
operator|(
name|FNBLOCK
operator||
name|FNDELAY
operator|)
condition|)
block|{
comment|/* this is no blocking system call */
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|l
operator|=
name|get_sleep_lock
argument_list|(
operator|&
name|iplh
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|sleep
argument_list|(
operator|&
name|iplh
index|[
name|unit
index|]
argument_list|,
name|PZERO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|spinunlock
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|error
operator|=
name|mpsleep
argument_list|(
operator|&
name|iplh
index|[
name|unit
index|]
argument_list|,
name|PSUSP
operator||
name|PCATCH
argument_list|,
literal|"iplread"
argument_list|,
literal|0
argument_list|,
operator|&
name|ipl_mutex
argument_list|,
name|MS_LOCK_SIMPLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|SLEEP
argument_list|(
name|unit
operator|+
name|iplh
argument_list|,
literal|"ipl sleep"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __osf__ */
endif|#
directive|endif
comment|/* __hpux */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SOLARIS */
block|}
if|#
directive|if
operator|(
name|BSD
operator|>=
literal|199101
operator|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
name|uio
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|copied
operator|=
literal|0
init|;
operator|(
name|ipl
operator|=
name|iplt
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|;
name|copied
operator|+=
name|dlen
control|)
block|{
name|dlen
operator|=
name|ipl
operator|->
name|ipl_dsize
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
break|break;
comment|/* 		 * Don't hold the mutex over the uiomove call. 		 */
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|iplused
index|[
name|unit
index|]
operator|-=
name|dlen
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|dlen
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|ipl
operator|->
name|ipl_next
operator|=
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
expr_stmt|;
name|iplused
index|[
name|unit
index|]
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iplt
index|[
name|unit
index|]
condition|)
block|{
name|iplused
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|ipll
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipflog_clear                                                */
end_comment

begin_comment
comment|/* Returns:     int    - number of log bytes cleared.                       */
end_comment

begin_comment
comment|/* Parameters:  unit(I) - device we are reading from                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Deletes all queued up log records for a given output device.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipflog_clear
parameter_list|(
name|unit
parameter_list|)
name|minor_t
name|unit
decl_stmt|;
block|{
name|iplog_t
modifier|*
name|ipl
decl_stmt|;
name|int
name|used
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SPL
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ipl
operator|=
name|iplt
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|iplt
index|[
name|unit
index|]
operator|=
name|ipl
operator|->
name|ipl_next
expr_stmt|;
name|KFREES
argument_list|(
operator|(
name|caddr_t
operator|)
name|ipl
argument_list|,
name|ipl
operator|->
name|ipl_dsize
argument_list|)
expr_stmt|;
block|}
name|iplh
index|[
name|unit
index|]
operator|=
operator|&
name|iplt
index|[
name|unit
index|]
expr_stmt|;
name|ipll
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|used
operator|=
name|iplused
index|[
name|unit
index|]
expr_stmt|;
name|iplused
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iplcrc
index|[
name|unit
index|]
argument_list|,
name|FI_CSIZE
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipl_mutex
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|used
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

end_unit

