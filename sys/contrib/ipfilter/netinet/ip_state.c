begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * Copyright 2008 Sun Microsystems.  *  * $Id$  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
expr|\
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|220000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ipf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_proxy.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_lookup.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_dstlist.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_sync.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FREEBSD_GE_REV
argument_list|(
literal|300000
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ip_state.c	1.8 6/5/96 (C) 1993-2000 Darren Reed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ipftuneable_t
name|ipf_state_tuneables
index|[]
init|=
block|{
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_max
argument_list|)
block|}
block|,
literal|"state_max"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_max
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_size
argument_list|)
block|}
block|,
literal|"state_size"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_size
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|ipf_state_rehash
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_lock
argument_list|)
block|}
block|,
literal|"state_lock"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_lock
argument_list|)
block|,
name|IPFT_RDONLY
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_maxbucket
argument_list|)
block|}
block|,
literal|"state_maxbucket"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_maxbucket
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_logging
argument_list|)
block|}
block|,
literal|"state_logging"
block|,
literal|0
block|,
literal|1
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_logging
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_wm_high
argument_list|)
block|}
block|,
literal|"state_wm_high"
block|,
literal|2
block|,
literal|100
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_wm_high
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_wm_low
argument_list|)
block|}
block|,
literal|"state_wm_low"
block|,
literal|1
block|,
literal|99
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_wm_low
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
operator|(
name|void
operator|*
operator|)
name|offsetof
argument_list|(
argument|ipf_state_softc_t
argument_list|,
argument|ipf_state_wm_freq
argument_list|)
block|}
block|,
literal|"state_wm_freq"
block|,
literal|2
block|,
literal|999999
block|,
name|stsizeof
argument_list|(
name|ipf_state_softc_t
argument_list|,
name|ipf_state_wm_freq
argument_list|)
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
block|{
name|NULL
block|}
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SINCL
parameter_list|(
name|x
parameter_list|)
value|ATOMIC_INCL(softs->x)
end_define

begin_define
define|#
directive|define
name|SBUMP
parameter_list|(
name|x
parameter_list|)
value|(softs->x)++
end_define

begin_define
define|#
directive|define
name|SBUMPD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { (softs->x.y)++; DT(y); } while (0)
end_define

begin_define
define|#
directive|define
name|SBUMPDX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|do { (softs->x.y)++; DT(z); } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|ipf_checkicmp6matchingstate
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ipf_allowstateicmp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|ipf_matchsrcdst
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|u_32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|ipf_checkicmpmatchingstate
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_flush_entry
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ips_stat_t
modifier|*
name|ipf_state_stats
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_del
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_remove
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_match
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
name|is1
operator|,
name|ipstate_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matchaddresses
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
name|is1
operator|,
name|ipstate_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matchipv4addrs
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
name|is1
operator|,
name|ipstate_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matchipv6addrs
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
name|is1
operator|,
name|ipstate_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matchisps
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
name|is1
operator|,
name|ipstate_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matchports
name|__P
argument_list|(
operator|(
name|udpinfo_t
operator|*
name|is1
operator|,
name|udpinfo_t
operator|*
name|is2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_matcharray
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
operator|,
name|int
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_ipsmove
name|__P
argument_list|(
operator|(
name|ipf_state_softc_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_tcp
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipf_state_softc_t
operator|*
operator|,
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_tcpoptions
name|__P
argument_list|(
operator|(
name|ipf_state_softc_t
operator|*
operator|,
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|tcpdata_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|ipf_state_clone
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_fixinisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_fixoutisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipf_checknewisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_iter
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipftoken_t
operator|*
operator|,
name|ipfgeniter_t
operator|*
operator|,
name|ipfobj_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_gettable
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipf_state_softc_t
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_tcpinwindow
name|__P
argument_list|(
operator|(
expr|struct
name|fr_info
operator|*
operator|,
expr|struct
name|tcpdata
operator|*
operator|,
expr|struct
name|tcpdata
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_getent
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipf_state_softc_t
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_state_putent
name|__P
argument_list|(
operator|(
name|ipf_main_softc_t
operator|*
operator|,
name|ipf_state_softc_t
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ONE_DAY
value|IPF_TTLVAL(1 * 86400)
end_define

begin_comment
comment|/* 1 day */
end_comment

begin_define
define|#
directive|define
name|FIVE_DAYS
value|(5 * ONE_DAY)
end_define

begin_define
define|#
directive|define
name|DOUBLE_HASH
parameter_list|(
name|x
parameter_list|)
value|(((x) + softs->ipf_state_seed[(x) % \ 			 softs->ipf_state_size]) % softs->ipf_state_size)
end_define

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_main_load                                         */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A null-op function that exists as a placeholder so that the flow in      */
end_comment

begin_comment
comment|/* other functions is obvious.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_main_load
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_main_unload                                       */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A null-op function that exists as a placeholder so that the flow in      */
end_comment

begin_comment
comment|/* other functions is obvious.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_main_unload
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_soft_create                                       */
end_comment

begin_comment
comment|/* Returns:     void *   - NULL = failure, else pointer to soft context     */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create a new state soft context structure and populate it with the list  */
end_comment

begin_comment
comment|/* of tunables and other default settings.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|ipf_state_soft_create
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|KMALLOC
argument_list|(
name|softs
argument_list|,
name|ipf_state_softc_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|softs
argument_list|)
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_tune
operator|=
name|ipf_tune_array_copy
argument_list|(
name|softs
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_state_tuneables
argument_list|)
argument_list|,
name|ipf_state_tuneables
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_tune
operator|==
name|NULL
condition|)
block|{
name|ipf_state_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ipf_tune_array_link
argument_list|(
name|softc
argument_list|,
name|softs
operator|->
name|ipf_state_tune
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ipf_state_soft_destroy
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|softs
operator|->
name|ipf_state_logging
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|softs
operator|->
name|ipf_state_logging
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|softs
operator|->
name|ipf_state_size
operator|=
name|IPSTATE_SIZE
operator|,
name|softs
operator|->
name|ipf_state_maxbucket
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_freq
operator|=
name|IPF_TTLVAL
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_max
operator|=
name|IPSTATE_MAX
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_last
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_high
operator|=
literal|99
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_low
operator|=
literal|90
expr_stmt|;
name|softs
operator|->
name|ipf_state_inited
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_lock
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_doflush
operator|=
literal|0
expr_stmt|;
return|return
name|softs
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_soft_destroy                                      */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              arg(I)   - pointer to local context to use                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Undo only what we did in soft create: unlink and free the tunables and   */
end_comment

begin_comment
comment|/* free the soft context structure itself.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_soft_destroy
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_tune
operator|!=
name|NULL
condition|)
block|{
name|ipf_tune_array_unlink
argument_list|(
name|softc
argument_list|,
name|softs
operator|->
name|ipf_state_tune
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_tune
argument_list|,
sizeof|sizeof
argument_list|(
name|ipf_state_tuneables
argument_list|)
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_tune
operator|=
name|NULL
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|softs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_soft_init                                         */
end_comment

begin_comment
comment|/* Returns:     int      - 0 == success, -1 == failure                      */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              arg(I)   - pointer to local context to use                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise the state soft context structure so it is ready for use.      */
end_comment

begin_comment
comment|/* This involves:                                                           */
end_comment

begin_comment
comment|/* - allocating a hash table and zero'ing it out                            */
end_comment

begin_comment
comment|/* - building a secondary table of seeds for double hashing to make it more */
end_comment

begin_comment
comment|/*   difficult to attempt to attack the hash table itself (for DoS)         */
end_comment

begin_comment
comment|/* - initialise all of the timeout queues, including a table for TCP, some  */
end_comment

begin_comment
comment|/*   pairs of query/response for UDP and other IP protocols (typically the  */
end_comment

begin_comment
comment|/*   reply queue has a shorter timeout than the query)                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_soft_init
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KMALLOCS
argument_list|(
name|softs
operator|->
name|ipf_state_table
argument_list|,
name|ipstate_t
operator|*
operator|*
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softs
operator|->
name|ipf_state_table
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|KMALLOCS
argument_list|(
name|softs
operator|->
name|ipf_state_seed
argument_list|,
name|u_long
operator|*
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|softs
operator|->
name|ipf_state_seed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_seed
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|softs
operator|->
name|ipf_state_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX - ipf_state_seed[X] should be a random number of sorts. 		 */
if|#
directive|if
name|FREEBSD_GE_REV
argument_list|(
literal|400000
argument_list|)
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|=
name|arc4random
argument_list|()
expr_stmt|;
else|#
directive|else
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|u_long
operator|)
name|softs
operator|->
name|ipf_state_seed
operator|+
name|i
operator|)
operator|*
name|softs
operator|->
name|ipf_state_size
expr_stmt|;
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|^=
literal|0xa5a55a5a
expr_stmt|;
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|*=
operator|(
name|u_long
operator|)
name|softs
operator|->
name|ipf_state_seed
expr_stmt|;
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|^=
literal|0x5a5aa5a5
expr_stmt|;
name|softs
operator|->
name|ipf_state_seed
index|[
name|i
index|]
operator|*=
name|softs
operator|->
name|ipf_state_max
expr_stmt|;
endif|#
directive|endif
block|}
name|KMALLOCS
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|u_int
operator|*
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
operator|==
name|NULL
condition|)
return|return
operator|-
literal|3
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_maxbucket
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|softs
operator|->
name|ipf_state_size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
name|softs
operator|->
name|ipf_state_maxbucket
operator|++
expr_stmt|;
name|softs
operator|->
name|ipf_state_maxbucket
operator|*=
literal|2
expr_stmt|;
block|}
name|ipf_sttab_init
argument_list|(
name|softc
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_tcptab
operator|=
name|softs
operator|->
name|ipf_state_tcptq
expr_stmt|;
name|softs
operator|->
name|ipf_state_tcptq
index|[
name|IPF_TCP_NSTATES
operator|-
literal|1
index|]
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udptq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udptq
argument_list|,
name|softc
operator|->
name|ipf_udptimeout
argument_list|,
literal|"ipftq udp tab"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_udptq
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
argument_list|,
name|softc
operator|->
name|ipf_udpacktimeout
argument_list|,
literal|"ipftq udpack tab"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_udpacktq
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmptq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmptq
argument_list|,
name|softc
operator|->
name|ipf_icmptimeout
argument_list|,
literal|"ipftq icmp tab"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_icmptq
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
argument_list|,
name|softc
operator|->
name|ipf_icmpacktimeout
argument_list|,
literal|"ipftq icmpack tab"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_icmpacktq
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_iptq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_iptq
argument_list|,
name|softc
operator|->
name|ipf_iptimeout
argument_list|,
literal|"ipftq iptimeout tab"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_iptq
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_pending
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_pending
argument_list|,
name|IPF_HZ_DIVIDE
argument_list|,
literal|"ipftq pending"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_pending
operator|.
name|ifq_next
operator|=
operator|&
name|softs
operator|->
name|ipf_state_deletetq
expr_stmt|;
name|IPFTQ_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_deletetq
argument_list|,
literal|1
argument_list|,
literal|"ipftq delete"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_deletetq
operator|.
name|ifq_next
operator|=
name|NULL
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_stinsert
argument_list|,
literal|"ipf state insert mutex"
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_last
operator|=
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
name|softs
operator|->
name|ipf_state_inited
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_soft_fini                                         */
end_comment

begin_comment
comment|/* Returns:     int      - 0 = success, -1 = failure                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              arg(I)   - pointer to local context to use                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Release and destroy any resources acquired or initialised so that        */
end_comment

begin_comment
comment|/* IPFilter can be unloaded or re-initialised.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_soft_fini
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|arg
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_list
operator|)
operator|!=
name|NULL
condition|)
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_UNLOAD
argument_list|)
expr_stmt|;
comment|/* 	 * Proxy timeout queues are not cleaned here because although they 	 * exist on the state list, appr_unload is called after 	 * ipf_state_unload and the proxies actually are responsible for them 	 * being created. Should the proxy timeouts have their own list? 	 * There's no real justification as this is the only complication. 	 */
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_usertq
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
name|ipf_deletetimeoutqueue
argument_list|(
name|ifq
argument_list|)
operator|==
literal|0
condition|)
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|ifq
argument_list|)
expr_stmt|;
block|}
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_inited
operator|==
literal|1
condition|)
block|{
name|softs
operator|->
name|ipf_state_inited
operator|=
literal|0
expr_stmt|;
name|ipf_sttab_destroy
argument_list|(
name|softs
operator|->
name|ipf_state_tcptq
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_iptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_deletetq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_pending
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|softs
operator|->
name|ipf_stinsert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_table
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|softs
operator|->
name|ipf_state_table
argument_list|)
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_seed
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_seed
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|softs
operator|->
name|ipf_state_seed
argument_list|)
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_seed
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_set_lock                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  arg(I) - pointer to local context to use                    */
end_comment

begin_comment
comment|/*              tmp(I) - new value for lock                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stub function that allows for external manipulation of ipf_state_lock    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_setlock
parameter_list|(
name|arg
parameter_list|,
name|tmp
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|tmp
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|arg
decl_stmt|;
name|softs
operator|->
name|ipf_state_lock
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_stats                                             */
end_comment

begin_comment
comment|/* Returns:     ips_state_t* - pointer to state stats structure             */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Put all the current numbers and pointers into a single struct and return */
end_comment

begin_comment
comment|/* a pointer to it.                                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ips_stat_t
modifier|*
name|ipf_state_stats
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ips_stat_t
modifier|*
name|issp
init|=
operator|&
name|softs
operator|->
name|ipf_state_stats
decl_stmt|;
name|issp
operator|->
name|iss_state_size
operator|=
name|softs
operator|->
name|ipf_state_size
expr_stmt|;
name|issp
operator|->
name|iss_state_max
operator|=
name|softs
operator|->
name|ipf_state_max
expr_stmt|;
name|issp
operator|->
name|iss_table
operator|=
name|softs
operator|->
name|ipf_state_table
expr_stmt|;
name|issp
operator|->
name|iss_list
operator|=
name|softs
operator|->
name|ipf_state_list
expr_stmt|;
name|issp
operator|->
name|iss_ticks
operator|=
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOGGING
name|issp
operator|->
name|iss_log_ok
operator|=
name|ipf_log_logok
argument_list|(
name|softc
argument_list|,
name|IPF_LOGSTATE
argument_list|)
expr_stmt|;
name|issp
operator|->
name|iss_log_fail
operator|=
name|ipf_log_failures
argument_list|(
name|softc
argument_list|,
name|IPF_LOGSTATE
argument_list|)
expr_stmt|;
else|#
directive|else
name|issp
operator|->
name|iss_log_ok
operator|=
literal|0
expr_stmt|;
name|issp
operator|->
name|iss_log_fail
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|issp
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_remove                                            */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              data(I)  - pointer to state structure to delete from table  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for a state structure that matches the one passed, according to   */
end_comment

begin_comment
comment|/* the IP addresses and other protocol specific information.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_remove
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|sp
decl_stmt|,
name|st
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|&
name|st
expr_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|st
argument_list|,
name|IPFOBJ_IPSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|is_next
control|)
if|if
condition|(
operator|(
name|sp
operator|->
name|is_p
operator|==
name|st
operator|.
name|is_p
operator|)
operator|&&
operator|(
name|sp
operator|->
name|is_v
operator|==
name|st
operator|.
name|is_v
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_src
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_src
argument_list|)
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_dst
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_dst
argument_list|)
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_ps
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_ps
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_ps
argument_list|)
argument_list|)
condition|)
block|{
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|sp
argument_list|,
name|ISL_REMOVE
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100001
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_ioctl                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              data(I)  - pointer to ioctl data                            */
end_comment

begin_comment
comment|/*              cmd(I)   - ioctl command integer                            */
end_comment

begin_comment
comment|/*              mode(I)  - file mode bits used with open                    */
end_comment

begin_comment
comment|/*              uid(I)   - uid of process making the ioctl call             */
end_comment

begin_comment
comment|/*              ctx(I)   - pointer specific to context of the call          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Processes an ioctl call made to operate on the IP Filter state device.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_ioctl
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|,
name|cmd
parameter_list|,
name|mode
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|uid
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|ret
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * Delete an entry from the state table. 	 */
case|case
name|SIOCDELST
case|:
name|error
operator|=
name|ipf_state_remove
argument_list|(
name|softc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush the state table 	 */
case|case
name|SIOCIPFFL
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100002
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ipf_state_flush
argument_list|(
name|softc
argument_list|,
name|arg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|ret
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100003
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|SIOCIPFL6
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100004
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ipf_state_flush
argument_list|(
name|softc
argument_list|,
name|arg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|ret
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100005
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|SIOCMATCHFLUSH
case|:
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_state_matchflush
argument_list|(
name|softc
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
comment|/* 	 * Flush the state log. 	 */
case|case
name|SIOCIPFFB
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100008
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ipf_log_clear
argument_list|(
name|softc
argument_list|,
name|IPL_LOGSTATE
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100009
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Turn logging of state information on/off. 	 */
case|case
name|SIOCSETLG
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100010
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_logging
argument_list|,
sizeof|sizeof
argument_list|(
name|softs
operator|->
name|ipf_state_logging
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100011
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Return the current state of logging. 	 */
case|case
name|SIOCGETLG
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_logging
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|softs
operator|->
name|ipf_state_logging
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100012
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
comment|/* 	 * Return the number of bytes currently waiting to be read. 	 */
case|case
name|FIONREAD
case|:
name|arg
operator|=
name|ipf_log_bytesused
argument_list|(
name|softc
argument_list|,
name|IPL_LOGSTATE
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|arg
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100013
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* 	 * Get the current state statistics. 	 */
case|case
name|SIOCGETFS
case|:
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|ipf_state_stats
argument_list|(
name|softc
argument_list|)
argument_list|,
name|IPFOBJ_STATESTAT
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Lock/Unlock the state table.  (Locking prevents any changes, which 	 * means no packets match). 	 */
case|case
name|SIOCSTLCK
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100014
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ipf_lock
argument_list|(
name|data
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_lock
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Add an entry to the current state table. 	 */
case|case
name|SIOCSTPUT
case|:
if|if
condition|(
operator|!
name|softs
operator|->
name|ipf_state_lock
operator|||
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100015
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ipf_state_putent
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get a state table entry. 	 */
case|case
name|SIOCSTGET
case|:
if|if
condition|(
operator|!
name|softs
operator|->
name|ipf_state_lock
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100016
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ipf_state_getent
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Return a copy of the hash table bucket lengths 	 */
case|case
name|SIOCSTAT1
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|data
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100017
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGENITER
case|:
block|{
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
name|iter
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|iter
argument_list|,
name|IPFOBJ_GENITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|token
operator|=
name|ipf_token_find
argument_list|(
name|softc
argument_list|,
name|IPFGENITER_STATE
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ipf_state_iter
argument_list|(
name|softc
argument_list|,
name|token
argument_list|,
operator|&
name|iter
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
name|ipf_token_deref
argument_list|(
name|softc
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_tokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|100018
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGTABL
case|:
name|error
operator|=
name|ipf_state_gettable
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFDELTOK
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100019
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_token_del
argument_list|(
name|softc
argument_list|,
name|arg
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGTQTAB
case|:
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|,
name|IPFOBJ_STATETQTAB
argument_list|)
expr_stmt|;
break|break;
default|default :
name|IPFERROR
argument_list|(
literal|100020
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_getent                                            */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              softs(I) - pointer to state context structure               */
end_comment

begin_comment
comment|/*              data(I)  - pointer to state structure to retrieve from table*/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy out state information from the kernel to a user space process.  If  */
end_comment

begin_comment
comment|/* there is a filter rule associated with the state entry, copy that out    */
end_comment

begin_comment
comment|/* as well.  The entry to copy out is taken from the value of "ips_next" in */
end_comment

begin_comment
comment|/* the struct passed in and if not null and not found in the list of current*/
end_comment

begin_comment
comment|/* state entries, the retrieval fails.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_getent
parameter_list|(
name|softc
parameter_list|,
name|softs
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|isn
decl_stmt|;
name|ipstate_save_t
name|ips
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|isn
operator|=
name|ips
operator|.
name|ips_next
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
name|isn
operator|=
name|softs
operator|->
name|ipf_state_list
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ips
operator|.
name|ips_next
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100021
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure the pointer we're copying from exists in the 		 * current list of entries.  Security precaution to prevent 		 * copying of random kernel data. 		 */
for|for
control|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
if|if
condition|(
name|is
operator|==
name|isn
condition|)
break|break;
if|if
condition|(
operator|!
name|is
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100022
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
block|}
name|ips
operator|.
name|ips_next
operator|=
name|isn
operator|->
name|is_next
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_is
argument_list|,
sizeof|sizeof
argument_list|(
name|ips
operator|.
name|ips_is
argument_list|)
argument_list|)
expr_stmt|;
name|ips
operator|.
name|ips_rule
operator|=
name|isn
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|isn
operator|->
name|is_rule
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
operator|->
name|is_rule
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_fr
argument_list|,
sizeof|sizeof
argument_list|(
name|ips
operator|.
name|ips_fr
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_putent                                            */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              softs(I) - pointer to state context structure               */
end_comment

begin_comment
comment|/*              data(I)  - pointer to state information struct              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function implements the SIOCSTPUT ioctl: insert a state entry into  */
end_comment

begin_comment
comment|/* the state table.  If the state info. includes a pointer to a filter rule */
end_comment

begin_comment
comment|/* then also add in an orphaned rule (will not show up in any "ipfstat -io" */
end_comment

begin_comment
comment|/* output.                                                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_putent
parameter_list|(
name|softc
parameter_list|,
name|softs
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|isn
decl_stmt|;
name|ipstate_save_t
name|ips
decl_stmt|;
name|int
name|error
decl_stmt|,
name|out
decl_stmt|,
name|i
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|KMALLOC
argument_list|(
name|isn
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100023
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_is
argument_list|,
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isn
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_pkts
argument_list|)
argument_list|)
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_pnext
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_parent
operator|=
name|isn
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sync
operator|=
name|NULL
expr_stmt|;
name|fr
operator|=
name|ips
operator|.
name|ips_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|int
name|inserr
decl_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|inserr
operator|=
name|ipf_state_insert
argument_list|(
name|softc
argument_list|,
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|inserr
return|;
block|}
if|if
condition|(
name|isn
operator|->
name|is_flags
operator|&
name|SI_NEWFR
condition|)
block|{
name|KMALLOC
argument_list|(
name|fr
argument_list|,
name|frentry_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100024
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_fr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fr
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|fr
operator|->
name|fr_flags
operator|&
name|FR_OUTQUE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|isn
operator|->
name|is_rule
operator|=
name|fr
expr_stmt|;
name|ips
operator|.
name|ips_is
operator|.
name|is_rule
operator|=
name|fr
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|,
literal|"state filter rule lock"
argument_list|)
expr_stmt|;
comment|/* 		 * Look up all the interface names in the rule. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_ifnames
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_ifnames
index|[
name|i
index|]
expr_stmt|;
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|name
argument_list|,
name|fr
operator|->
name|fr_family
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|isn
operator|->
name|is_ifname
index|[
name|i
index|]
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|name
argument_list|,
name|isn
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
name|fr
operator|->
name|fr_ref
operator|=
literal|0
expr_stmt|;
name|fr
operator|->
name|fr_dsize
operator|=
literal|0
expr_stmt|;
name|fr
operator|->
name|fr_data
operator|=
name|NULL
expr_stmt|;
name|fr
operator|->
name|fr_type
operator|=
name|FR_T_NONE
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|0
index|]
argument_list|,
name|fr
operator|->
name|fr_family
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_family
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_resolvedest
argument_list|(
name|softc
argument_list|,
name|fr
operator|->
name|fr_names
argument_list|,
operator|&
name|fr
operator|->
name|fr_dif
argument_list|,
name|fr
operator|->
name|fr_family
argument_list|)
expr_stmt|;
comment|/* 		 * send a copy back to userland of what we ended up 		 * to allow for verification. 		 */
name|error
operator|=
name|ipf_outobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|fr
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100025
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_state_insert
argument_list|(
name|softc
argument_list|,
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
if|if
condition|(
name|is
operator|->
name|is_rule
operator|==
name|fr
condition|)
block|{
name|error
operator|=
name|ipf_state_insert
argument_list|(
name|softc
argument_list|,
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
name|isn
operator|=
name|NULL
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100033
argument_list|)
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_insert                                            */
end_comment

begin_comment
comment|/* Returns:     int    - 0 == success, -1 == failure                        */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/* Parameters:  is(I)    - pointer to state structure                       */
end_comment

begin_comment
comment|/*              rev(I) - flag indicating direction of packet                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Inserts a state structure into the hash table (for lookups) and the list */
end_comment

begin_comment
comment|/* of state entries (for enumeration).  Resolves all of the interface names */
end_comment

begin_comment
comment|/* to pointers and adjusts running stats for the hash table as appropriate. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function can fail if the filter rule has had a population policy of */
end_comment

begin_comment
comment|/* IP addresses used with stateful filtering assigned to it.                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking: it is assumed that some kind of lock on ipf_state is held.      */
end_comment

begin_comment
comment|/*          Exits with is_lock initialised and held - *EVEN IF ERROR*.      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_insert
parameter_list|(
name|softc
parameter_list|,
name|is
parameter_list|,
name|rev
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Look up all the interface names in the state entry. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
continue|continue;
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|i
index|]
argument_list|,
name|is
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we could trust is_hv, then the modulus would not be needed, 	 * but when running with IPFILTER_SYNC, this stops bad values. 	 */
name|hv
operator|=
name|is
operator|->
name|is_hv
operator|%
name|softs
operator|->
name|ipf_state_size
expr_stmt|;
comment|/* TRACE is, hv */
name|is
operator|->
name|is_hv
operator|=
name|hv
expr_stmt|;
comment|/* 	 * We need to get both of these locks...the first because it is 	 * possible that once the insert is complete another packet might 	 * come along, match the entry and want to update it. 	 */
name|MUTEX_INIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|,
literal|"ipf state entry"
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|softs
operator|->
name|ipf_stinsert
argument_list|)
expr_stmt|;
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_srctrack
operator|.
name|ht_max_nodes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ipf_ht_node_add
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
operator|->
name|fr_srctrack
argument_list|,
name|is
operator|->
name|is_family
argument_list|,
operator|&
name|is
operator|->
name|is_src
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_max_track
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_stinsert
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_statecnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
condition|)
block|{
name|DT
argument_list|(
name|iss_wild_plus_one
argument_list|)
expr_stmt|;
name|SINCL
argument_list|(
name|ipf_state_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_proto
index|[
name|is
operator|->
name|is_p
index|]
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_active_proto
index|[
name|is
operator|->
name|is_p
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * add into list table. 	 */
if|if
condition|(
name|softs
operator|->
name|ipf_state_list
operator|!=
name|NULL
condition|)
name|softs
operator|->
name|ipf_state_list
operator|->
name|is_pnext
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
name|is
operator|->
name|is_pnext
operator|=
operator|&
name|softs
operator|->
name|ipf_state_list
expr_stmt|;
name|is
operator|->
name|is_next
operator|=
name|softs
operator|->
name|ipf_state_list
expr_stmt|;
name|softs
operator|->
name|ipf_state_list
operator|=
name|is
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|!=
name|NULL
condition|)
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|->
name|is_phnext
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
else|else
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|++
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|softs
operator|->
name|ipf_state_table
operator|+
name|hv
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
expr_stmt|;
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|=
name|is
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|hv
index|]
operator|++
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|softs
operator|->
name|ipf_stinsert
argument_list|)
expr_stmt|;
name|ipf_state_setqueue
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_matchipv4addrs                                    */
end_comment

begin_comment
comment|/* Returns:     int - 2 addresses match (strong match), 1 reverse match,    */
end_comment

begin_comment
comment|/*                    0 no match                                            */
end_comment

begin_comment
comment|/* Parameters:  is1, is2 pointers to states we are checking                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Function matches IPv4 addresses it returns strong match for ICMP proto   */
end_comment

begin_comment
comment|/* even there is only reverse match                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matchipv4addrs
parameter_list|(
name|is1
parameter_list|,
name|is2
parameter_list|)
name|ipstate_t
modifier|*
name|is1
decl_stmt|,
decl|*
name|is2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|is1
operator|->
name|is_saddr
operator|==
name|is2
operator|->
name|is_saddr
operator|&&
name|is1
operator|->
name|is_daddr
operator|==
name|is2
operator|->
name|is_daddr
condition|)
name|rv
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|is1
operator|->
name|is_saddr
operator|==
name|is2
operator|->
name|is_daddr
operator|&&
name|is1
operator|->
name|is_daddr
operator|==
name|is2
operator|->
name|is_saddr
condition|)
block|{
comment|/* force strong match for ICMP protocol */
name|rv
operator|=
operator|(
name|is1
operator|->
name|is_p
operator|==
name|IPPROTO_ICMP
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
name|rv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_matchipv6addrs                                    */
end_comment

begin_comment
comment|/* Returns:     int - 2 addresses match (strong match), 1 reverse match,    */
end_comment

begin_comment
comment|/*                    0 no match                                            */
end_comment

begin_comment
comment|/* Parameters:  is1, is2 pointers to states we are checking                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Function matches IPv6 addresses it returns strong match for ICMP proto   */
end_comment

begin_comment
comment|/* even there is only reverse match                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matchipv6addrs
parameter_list|(
name|is1
parameter_list|,
name|is2
parameter_list|)
name|ipstate_t
modifier|*
name|is1
decl_stmt|,
decl|*
name|is2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|IP6_EQ
argument_list|(
operator|&
name|is1
operator|->
name|is_src
argument_list|,
operator|&
name|is2
operator|->
name|is_src
argument_list|)
operator|&&
name|IP6_EQ
argument_list|(
operator|&
name|is1
operator|->
name|is_dst
argument_list|,
operator|&
name|is2
operator|->
name|is_dst
argument_list|)
condition|)
name|rv
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|IP6_EQ
argument_list|(
operator|&
name|is1
operator|->
name|is_src
argument_list|,
operator|&
name|is2
operator|->
name|is_dst
argument_list|)
operator|&&
name|IP6_EQ
argument_list|(
operator|&
name|is1
operator|->
name|is_dst
argument_list|,
operator|&
name|is2
operator|->
name|is_src
argument_list|)
condition|)
block|{
comment|/* force strong match for ICMPv6 protocol */
name|rv
operator|=
operator|(
name|is1
operator|->
name|is_p
operator|==
name|IPPROTO_ICMPV6
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
name|rv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_matchaddresses                                    */
end_comment

begin_comment
comment|/* Returns:     int - 2 addresses match, 1 reverse match, zero no match     */
end_comment

begin_comment
comment|/* Parameters:  is1, is2 pointers to states we are checking                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* function retruns true if two pairs of addresses belong to single         */
end_comment

begin_comment
comment|/* connection. suppose there are two endpoints:                             */
end_comment

begin_comment
comment|/*      endpoint1 1.1.1.1                                                   */
end_comment

begin_comment
comment|/*      endpoint2 1.1.1.2                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* the state is established by packet flying from .1 to .2 so we see:       */
end_comment

begin_comment
comment|/*      is1->src = 1.1.1.1                                                  */
end_comment

begin_comment
comment|/*      is1->dst = 1.1.1.2                                                  */
end_comment

begin_comment
comment|/* now endpoint 1.1.1.2 sends answer                                        */
end_comment

begin_comment
comment|/* retreives is1 record created by first packat and compares it with is2    */
end_comment

begin_comment
comment|/* temporal record, is2 is initialized as follows:                          */
end_comment

begin_comment
comment|/*      is2->src = 1.1.1.2                                                  */
end_comment

begin_comment
comment|/*      is2->dst = 1.1.1.1                                                  */
end_comment

begin_comment
comment|/* in this case 1 will be returned                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* the ipf_matchaddresses() assumes those two records to be same. of course */
end_comment

begin_comment
comment|/* the ipf_matchaddresses() also assume records are same in case you pass   */
end_comment

begin_comment
comment|/* identical arguments (i.e. ipf_matchaddress(is1, is1) would return 2      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matchaddresses
parameter_list|(
name|is1
parameter_list|,
name|is2
parameter_list|)
name|ipstate_t
modifier|*
name|is1
decl_stmt|,
decl|*
name|is2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|is1
operator|->
name|is_v
operator|==
literal|4
condition|)
block|{
name|rv
operator|=
name|ipf_state_matchipv4addrs
argument_list|(
name|is1
argument_list|,
name|is2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
name|ipf_state_matchipv6addrs
argument_list|(
name|is1
argument_list|,
name|is2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matchports                                              */
end_comment

begin_comment
comment|/* Returns:     int - 2 match, 1 rverse match, 0 no match                   */
end_comment

begin_comment
comment|/* Parameters:  ppairs1, ppairs - src, dst ports we want to match           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* performs the same match for isps members as for addresses                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matchports
parameter_list|(
name|ppairs1
parameter_list|,
name|ppairs2
parameter_list|)
name|udpinfo_t
modifier|*
name|ppairs1
decl_stmt|,
decl|*
name|ppairs2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|ppairs1
operator|->
name|us_sport
operator|==
name|ppairs2
operator|->
name|us_sport
operator|&&
name|ppairs1
operator|->
name|us_dport
operator|==
name|ppairs2
operator|->
name|us_dport
condition|)
name|rv
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|ppairs1
operator|->
name|us_sport
operator|==
name|ppairs2
operator|->
name|us_dport
operator|&&
name|ppairs1
operator|->
name|us_dport
operator|==
name|ppairs2
operator|->
name|us_sport
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
else|else
name|rv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matchisps                                               */
end_comment

begin_comment
comment|/* Returns:     int - nonzero if isps members match, 0 nomatch              */
end_comment

begin_comment
comment|/* Parameters:  is1, is2 - states we want to match                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* performs the same match for isps members as for addresses                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matchisps
parameter_list|(
name|is1
parameter_list|,
name|is2
parameter_list|)
name|ipstate_t
modifier|*
name|is1
decl_stmt|,
decl|*
name|is2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|is1
operator|->
name|is_p
operator|==
name|is2
operator|->
name|is_p
condition|)
block|{
switch|switch
condition|(
name|is1
operator|->
name|is_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
case|case
name|IPPROTO_GRE
case|:
comment|/* greinfo_t can be also interprted as port pair */
name|rv
operator|=
name|ipf_state_matchports
argument_list|(
operator|&
name|is1
operator|->
name|is_ps
operator|.
name|is_us
argument_list|,
operator|&
name|is2
operator|->
name|is_ps
operator|.
name|is_us
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
case|case
name|IPPROTO_ICMPV6
case|:
comment|/* force strong match for ICMP datagram. */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|is1
operator|->
name|is_ps
argument_list|,
operator|&
name|is2
operator|->
name|is_ps
argument_list|,
sizeof|sizeof
argument_list|(
name|icmpinfo_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|rv
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|rv
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_match                                             */
end_comment

begin_comment
comment|/* Returns:     int - nonzero match, zero no match                          */
end_comment

begin_comment
comment|/* Parameters:  is1, is2 - states we want to match                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_match
parameter_list|(
name|is1
parameter_list|,
name|is2
parameter_list|)
name|ipstate_t
modifier|*
name|is1
decl_stmt|,
decl|*
name|is2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rv
decl_stmt|;
name|int
name|amatch
decl_stmt|;
name|int
name|pomatch
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|is1
operator|->
name|is_pass
argument_list|,
operator|&
name|is2
operator|->
name|is_pass
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_authmsk
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_pass
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pomatch
operator|=
name|ipf_state_matchisps
argument_list|(
name|is1
argument_list|,
name|is2
argument_list|)
expr_stmt|;
name|amatch
operator|=
name|ipf_state_matchaddresses
argument_list|(
name|is1
argument_list|,
name|is2
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
name|amatch
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|amatch
operator|==
name|pomatch
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rv
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_add                                               */
end_comment

begin_comment
comment|/* Returns:     ipstate_t - 0 = success                                     */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to soft context main structure          */
end_comment

begin_comment
comment|/*              fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              stsave(O) - pointer to place to save pointer to created     */
end_comment

begin_comment
comment|/*                          state structure.                                */
end_comment

begin_comment
comment|/*              flags(I)  - flags to use when creating the structure        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Creates a new IP state structure from the packet information collected.  */
end_comment

begin_comment
comment|/* Inserts it into the state table and appends to the bottom of the active  */
end_comment

begin_comment
comment|/* list.  If the capacity of the table has reached the maximum allowed then */
end_comment

begin_comment
comment|/* the call will fail and a flush is scheduled for the next timeout call.   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: The use of stsave to point to nat_state will result in memory      */
end_comment

begin_comment
comment|/*       corruption.  It should only be used to point to objects that will  */
end_comment

begin_comment
comment|/*       either outlive this (not expired) or will deref the ip_state_t     */
end_comment

begin_comment
comment|/*       when they are deleted.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_add
parameter_list|(
name|softc
parameter_list|,
name|fin
parameter_list|,
name|stsave
parameter_list|,
name|flags
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
modifier|*
name|stsave
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
name|ips
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|u_int
name|pass
decl_stmt|,
name|hv
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|int
name|out
decl_stmt|;
comment|/* 	 * If a packet that was created locally is trying to go out but we 	 * do not match here here because of this lock, it is likely that 	 * the policy will block it and return network unreachable back up 	 * the stack. To mitigate this error, EAGAIN is returned instead, 	 * telling the IP stack to try sending this packet again later. 	 */
if|if
condition|(
name|softs
operator|->
name|ipf_state_lock
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_add_locked
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_error
operator|=
name|EAGAIN
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_SHORT
operator||
name|FI_STATE
operator||
name|FI_FRAGBODY
operator||
name|FI_BAD
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_add_bad
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_tcpf
operator|&
name|TH_SYN
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_add_oow
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|*
literal|100
operator|/
name|softs
operator|->
name|ipf_state_max
operator|)
operator|>
name|softs
operator|->
name|ipf_state_wm_high
condition|)
block|{
name|softs
operator|->
name|ipf_state_doflush
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If a "keep state" rule has reached the maximum number of references 	 * to it, then schedule an automatic flush in case we can clear out 	 * some "dead old wood".  Note that because the lock isn't held on 	 * fr it is possible that we could overflow.  The cost of overflowing 	 * is being ignored here as the number by which it can overflow is 	 * a product of the number of simultaneous threads that could be 	 * executing in here, so a limit of 100 won't result in 200, but could 	 * result in 101 or 102. 	 */
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|>=
name|softs
operator|->
name|ipf_state_max
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_statemax
operator|==
literal|0
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_statemax
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_statecnt
operator|>=
name|fr
operator|->
name|fr_statemax
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_max_ref
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
name|is
operator|=
operator|&
name|ips
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|pass
operator|=
name|softc
operator|->
name|ipf_flags
expr_stmt|;
name|is
operator|->
name|is_tag
operator|=
name|FR_NOLOGTAG
expr_stmt|;
block|}
else|else
block|{
name|pass
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
block|}
name|ic
operator|=
name|NULL
expr_stmt|;
name|tcp
operator|=
name|NULL
expr_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_die
operator|=
literal|1
operator|+
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
comment|/* 	 * We want to check everything that is a property of this packet, 	 * but we don't (automatically) care about it's fragment status as 	 * this may change. 	 */
name|is
operator|->
name|is_pass
operator|=
name|pass
expr_stmt|;
name|is
operator|->
name|is_v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
name|is
operator|->
name|is_sec
operator|=
name|fin
operator|->
name|fin_secmsk
expr_stmt|;
name|is
operator|->
name|is_secmsk
operator|=
literal|0xffff
expr_stmt|;
name|is
operator|->
name|is_auth
operator|=
name|fin
operator|->
name|fin_auth
expr_stmt|;
name|is
operator|->
name|is_authmsk
operator|=
literal|0xffff
expr_stmt|;
name|is
operator|->
name|is_family
operator|=
name|fin
operator|->
name|fin_family
expr_stmt|;
name|is
operator|->
name|is_opt
index|[
literal|0
index|]
operator|=
name|fin
operator|->
name|fin_optmsk
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
condition|)
block|{
name|is
operator|->
name|is_opt
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
block|}
comment|/* 	 * Copy and calculate... 	 */
name|hv
operator|=
operator|(
name|is
operator|->
name|is_p
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|)
expr_stmt|;
name|is
operator|->
name|is_src
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_saddr
expr_stmt|;
name|is
operator|->
name|is_dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_daddr
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
comment|/* 		 * For ICMPv6, we check to see if the destination address is 		 * a multicast address.  If it is, do not include it in the 		 * calculation of the hash because the correct reply will come 		 * back from a real address, not a multicast address. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|IPPROTO_ICMPV6
operator|)
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|is
operator|->
name|is_dst
operator|.
name|in6
argument_list|)
condition|)
block|{
comment|/* 			 * So you can do keep state with neighbour discovery. 			 * 			 * Here we could use the address from the neighbour 			 * solicit message to put in the state structure and 			 * we could use that without a wildcard flag too... 			 */
name|flags
operator||=
name|SI_W_DADDR
expr_stmt|;
name|hv
operator|-=
name|is
operator|->
name|is_daddr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_v
operator|==
literal|4
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_MULTICAST
operator||
name|FI_BROADCAST
operator||
name|FI_MBCAST
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|SI_W_DADDR
expr_stmt|;
name|hv
operator|-=
name|is
operator|->
name|is_daddr
expr_stmt|;
block|}
switch|switch
condition|(
name|is
operator|->
name|is_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP6_ECHO_REQUEST
case|:
name|hv
operator|+=
operator|(
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|=
name|ic
operator|->
name|icmp_id
operator|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|ICMP6_MEMBERSHIP_QUERY
case|:
case|case
name|ND_ROUTER_SOLICIT
case|:
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
case|case
name|ICMP6_NI_QUERY
case|:
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
break|break;
default|default :
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp6_notquery
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_TSTAMP
case|:
case|case
name|ICMP_IREQ
case|:
case|case
name|ICMP_MASKREQ
case|:
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
name|hv
operator|+=
operator|(
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|=
name|ic
operator|->
name|icmp_id
operator|)
expr_stmt|;
break|break;
default|default :
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_notquery
argument_list|)
expr_stmt|;
return|return
operator|-
literal|3
return|;
block|}
break|break;
if|#
directive|if
literal|0
block|case IPPROTO_GRE : 		gre = fin->fin_dp;  		is->is_gre.gs_flags = gre->gr_flags; 		is->is_gre.gs_ptype = gre->gr_ptype; 		if (GRE_REV(is->is_gre.gs_flags) == 1) { 			is->is_call[0] = fin->fin_data[0]; 			is->is_call[1] = fin->fin_data[1]; 		} 		break;
endif|#
directive|endif
case|case
name|IPPROTO_TCP
case|:
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_tcp_rstadd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|4
return|;
block|}
comment|/* TRACE is, flags, hv */
comment|/* 		 * The endian of the ports doesn't matter, but the ack and 		 * sequence numbers do as we do mathematics on them later. 		 */
name|is
operator|->
name|is_sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_DPORT
operator||
name|SI_W_SPORT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hv
operator|+=
name|is
operator|->
name|is_sport
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dport
expr_stmt|;
block|}
comment|/* TRACE is, flags, hv */
comment|/* 		 * If this is a real packet then initialise fields in the 		 * state information structure from the TCP header information. 		 */
name|is
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|is_maxswin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_maxswin
operator|==
literal|0
condition|)
name|is
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|is
operator|->
name|is_maxsend
operator|=
name|is
operator|->
name|is_send
expr_stmt|;
comment|/* 			 * Window scale option is only present in 			 * SYN/SYN-ACK packet. 			 */
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_FIN
operator||
name|TH_ACK
operator||
name|TH_ECNALL
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_tcpoptions
argument_list|(
name|softs
argument_list|,
name|fin
argument_list|,
name|tcp
argument_list|,
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_tcpoptions_th_fin_ack_ecnall
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pass
operator|&
name|FR_NEWISN
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipf_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|ipf_fixoutisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
name|flags
operator||=
name|IS_TCPFSM
expr_stmt|;
else|else
block|{
name|is
operator|->
name|is_maxdwin
operator|=
name|is
operator|->
name|is_maxswin
operator|*
literal|2
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_maxdend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_maxdwin
operator|*=
literal|2
expr_stmt|;
block|}
block|}
comment|/* 		 * If we're creating state for a starting connection, start 		 * the timer on it as we'll never see an error if it fails 		 * to connect. 		 */
break|break;
case|case
name|IPPROTO_UDP
case|:
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|is
operator|->
name|is_sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_DPORT
operator||
name|SI_W_SPORT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hv
operator|+=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|hv
operator|+=
name|tcp
operator|->
name|th_sport
expr_stmt|;
block|}
break|break;
default|default :
break|break;
block|}
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_hv
operator|=
name|hv
expr_stmt|;
comment|/* 	 * Look for identical state. 	 */
for|for
control|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
operator|%
name|softs
operator|->
name|ipf_state_size
index|]
init|;
name|is
operator|!=
name|NULL
condition|;
name|is
operator|=
name|is
operator|->
name|is_hnext
control|)
block|{
if|if
condition|(
name|ipf_state_match
argument_list|(
operator|&
name|ips
argument_list|,
name|is
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_add_dup
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|hv
index|]
operator|>=
name|softs
operator|->
name|ipf_state_maxbucket
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_bucket_full
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/* 	 * No existing state; create new 	 */
name|KMALLOC
argument_list|(
name|is
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_nomem
argument_list|)
expr_stmt|;
return|return
literal|5
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
argument_list|,
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|flags
operator|&
name|IS_INHERITED
expr_stmt|;
name|is
operator|->
name|is_rulen
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
name|is
operator|->
name|is_rule
operator|=
name|fr
expr_stmt|;
comment|/* 	 * Do not do the modulus here, it is done in ipf_state_insert(). 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|ipftq_t
modifier|*
name|tq
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|is
operator|->
name|is_group
argument_list|,
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_group
argument_list|)
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_age
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|tq
operator|=
name|ipf_addtimeoutqueue
argument_list|(
name|softc
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_usertq
argument_list|,
name|fr
operator|->
name|fr_age
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|=
name|tq
expr_stmt|;
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator||=
name|TQE_RULEBASED
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_age
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|tq
operator|=
name|ipf_addtimeoutqueue
argument_list|(
name|softc
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_usertq
argument_list|,
name|fr
operator|->
name|fr_age
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|=
name|tq
expr_stmt|;
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator||=
name|TQE_RULEBASED
expr_stmt|;
block|}
name|is
operator|->
name|is_tag
operator|=
name|fr
operator|->
name|fr_logtag
expr_stmt|;
block|}
comment|/* 	 * It may seem strange to set is_ref to 2, but if stsave is not NULL 	 * then a copy of the pointer is being stored somewhere else and in 	 * the end, it will expect to be able to do something with it. 	 */
name|is
operator|->
name|is_me
operator|=
name|stsave
expr_stmt|;
if|if
condition|(
name|stsave
operator|!=
name|NULL
condition|)
block|{
operator|*
name|stsave
operator|=
name|is
expr_stmt|;
name|is
operator|->
name|is_ref
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_ref
operator|=
literal|1
expr_stmt|;
block|}
name|is
operator|->
name|is_pkts
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|1
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|2
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|3
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_pkts
index|[
name|out
index|]
operator|=
literal|1
expr_stmt|;
name|fin
operator|->
name|fin_pktnum
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|is_bytes
index|[
name|out
index|]
operator|=
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
literal|0
index|]
operator|=
name|fin
operator|->
name|fin_flx
operator|&
name|FI_CMP
expr_stmt|;
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
literal|0
index|]
operator|&=
operator|~
name|FI_OOW
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|&
name|FR_STLOOSE
condition|)
name|is
operator|->
name|is_flags
operator||=
name|IS_LOOSE
expr_stmt|;
if|if
condition|(
name|pass
operator|&
name|FR_STSTRICT
condition|)
name|is
operator|->
name|is_flags
operator||=
name|IS_STRICT
expr_stmt|;
if|if
condition|(
name|pass
operator|&
name|FR_STATESYNC
condition|)
name|is
operator|->
name|is_flags
operator||=
name|IS_STATESYNC
expr_stmt|;
if|if
condition|(
name|pass
operator|&
name|FR_LOGFIRST
condition|)
name|is
operator|->
name|is_pass
operator|&=
operator|~
operator|(
name|FR_LOGFIRST
operator||
name|FR_LOG
operator|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_state_insert
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
comment|/* 		 * This is a bit more manual than it should be but 		 * ipf_state_del cannot be called. 		 */
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ipf_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ipf_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Filling in the interface name is after the insert so that an 	 * event (such as add/delete) of an interface that is referenced 	 * by this rule will see this state entry. 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The name '-' is special for network interfaces and causes 		 * a NULL name to be present, always, allowing packets to 		 * match it, regardless of their interface. 		 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fr
operator|->
name|fr_ifnames
index|[
name|out
operator|<<
literal|1
index|]
operator|!=
operator|-
literal|1
operator|&&
name|fr
operator|->
name|fr_names
index|[
name|fr
operator|->
name|fr_ifnames
index|[
name|out
operator|<<
literal|1
index|]
operator|+
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fr
operator|->
name|fr_names
index|[
name|fr
operator|->
name|fr_ifnames
index|[
name|out
operator|<<
literal|1
index|]
operator|+
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|0
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_ifnames
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_v
argument_list|,
name|fin
operator|->
name|fin_ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_ifp
index|[
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_ifnames
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_ifp
index|[
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|2
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
index|]
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_ifp
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|3
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_names
operator|+
name|fr
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fin
operator|->
name|fin_ifp
operator|!=
name|NULL
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_v
argument_list|,
name|fin
operator|->
name|fin_ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
comment|/* 		* If we're creating state for a starting connection, start the 		* timer on it as we'll never see an error if it fails to 		* connect. 		*/
operator|(
name|void
operator|)
name|ipf_tcp_age
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|,
name|is
operator|->
name|is_flags
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
operator|)
operator|&&
operator|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_CLONE
operator|)
operator|==
literal|0
operator|)
condition|)
name|is
operator|->
name|is_sync
operator|=
name|ipf_sync_new
argument_list|(
name|softc
argument_list|,
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_logging
condition|)
name|ipf_state_log
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_NEW
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_STATE
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
condition|)
operator|(
name|void
operator|)
name|ipf_frag_new
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
block|{
name|ipf_dstlist_select_node
argument_list|(
name|fin
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|is
operator|->
name|is_tifs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|fdp
argument_list|,
operator|&
name|is
operator|->
name|is_tifs
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
block|{
name|ipf_dstlist_select_node
argument_list|(
name|fin
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|is
operator|->
name|is_tifs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|fdp
argument_list|,
operator|&
name|is
operator|->
name|is_tifs
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_tif
operator|=
operator|&
name|is
operator|->
name|is_tifs
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_dif
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_type
operator|==
name|FRD_DSTLIST
condition|)
block|{
name|ipf_dstlist_select_node
argument_list|(
name|fin
argument_list|,
name|fdp
operator|->
name|fd_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|is
operator|->
name|is_dif
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|fdp
argument_list|,
operator|&
name|is
operator|->
name|is_dif
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_dif
operator|=
operator|&
name|is
operator|->
name|is_dif
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tcpoptions                                              */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet matches state entry, 0 == it does not,    */
end_comment

begin_comment
comment|/*                   -1 == packet has bad TCP options data                  */
end_comment

begin_comment
comment|/* Parameters:  softs(I) - pointer to state context structure               */
end_comment

begin_comment
comment|/*              fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP packet header                       */
end_comment

begin_comment
comment|/*              td(I)  - pointer to TCP data held as part of the state      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look after the TCP header for any options and deal with those that are   */
end_comment

begin_comment
comment|/* present.  Record details about those that we recogise.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_tcpoptions
parameter_list|(
name|softs
parameter_list|,
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|td
parameter_list|)
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|tcpdata_t
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|off
decl_stmt|,
name|mlen
decl_stmt|,
name|ol
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|opt
decl_stmt|;
name|mb_t
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|len
operator|=
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|len
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_tcp_toosmall
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
expr_stmt|;
name|off
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|fin
operator|->
name|fin_dlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
operator|+
name|fin
operator|->
name|fin_ipoff
expr_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
name|mlen
operator|=
name|MSGDSIZE
argument_list|(
name|m
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|mlen
condition|)
block|{
name|len
operator|=
name|mlen
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|COPYDATA
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
name|opt
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
elseif|else
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|ol
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
break|break;
name|ol
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ol
operator|<
literal|2
operator|||
name|ol
operator|>
name|len
condition|)
break|break;
comment|/* 			 * Extract the TCP options we are interested in out of 			 * the header and store them in the the tcpdata struct. 			 */
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_WINDOW
case|:
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_WINDOW
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|TCP_WSCALE_MAX
condition|)
name|i
operator|=
name|TCP_WSCALE_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_winscale
operator|=
name|i
expr_stmt|;
name|td
operator|->
name|td_winflags
operator||=
name|TCP_WSCALE_SEEN
operator||
name|TCP_WSCALE_FIRST
expr_stmt|;
block|}
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TCPOPT_MAXSEG
case|:
comment|/* 				 * So, if we wanted to set the TCP MAXSEG, 				 * it should be done here... 				 */
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_MAXSEG
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
name|i
operator|<<=
literal|8
expr_stmt|;
name|i
operator|+=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
expr_stmt|;
name|td
operator|->
name|td_maxseg
operator|=
name|i
expr_stmt|;
block|}
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK_PERMITTED
case|:
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_SACK_PERMITTED
condition|)
name|td
operator|->
name|td_winflags
operator||=
name|TCP_SACK_PERMIT
expr_stmt|;
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|-=
name|ol
expr_stmt|;
name|s
operator|+=
name|ol
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_tcp_badopt
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_tcp                                               */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet matches state entry, 0 == it does not     */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to soft context main structure          */
end_comment

begin_comment
comment|/*              softs(I) - pointer to state context structure               */
end_comment

begin_comment
comment|/*              fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              tcp(I)   - pointer to TCP packet header                     */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if a packet with TCP headers fits within the TCP window.    */
end_comment

begin_comment
comment|/* Change timeout depending on whether new packet is a SYN-ACK returning    */
end_comment

begin_comment
comment|/* for a SYN or a RST or FIN which indicate time to close up shop.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_tcp
parameter_list|(
name|softc
parameter_list|,
name|softs
parameter_list|,
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|is
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|tcpdata_t
modifier|*
name|fdata
decl_stmt|,
modifier|*
name|tdata
decl_stmt|;
name|int
name|source
decl_stmt|,
name|ret
decl_stmt|,
name|flags
decl_stmt|;
name|source
operator|=
operator|!
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_TCPFSM
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|source
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|is
operator|->
name|is_sport
argument_list|)
operator|!=
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|)
condition|)
name|source
operator|=
literal|0
expr_stmt|;
name|fdata
operator|=
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
operator|!
name|source
index|]
expr_stmt|;
name|tdata
operator|=
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
name|source
index|]
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If a SYN packet is received for a connection that is on the way out 	 * but hasn't yet departed then advance this session along the way. 	 */
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
block|{
if|if
condition|(
operator|(
name|is
operator|->
name|is_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
name|is
operator|->
name|is_state
index|[
operator|!
name|source
index|]
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
name|ipf_movequeue
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_deletetq
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|DT1
argument_list|(
name|iss_tcp_closing
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_tcp_closing
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|IS_LOOSE
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
name|ret
operator|=
name|ipf_state_tcpinwindow
argument_list|(
name|fin
argument_list|,
name|fdata
argument_list|,
name|tdata
argument_list|,
name|tcp
argument_list|,
name|is
operator|->
name|is_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Nearing end of connection, start timeout. 		 */
name|ret
operator|=
name|ipf_tcp_age
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|,
name|is
operator|->
name|is_flags
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|DT2
argument_list|(
name|iss_tcp_fsm
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_tcp_fsm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_logging
operator|>
literal|4
condition|)
name|ipf_state_log
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_STATECHANGE
argument_list|)
expr_stmt|;
comment|/* 		 * set s0's as appropriate.  Use syn-ack packet as it 		 * contains both pieces of required information. 		 */
comment|/* 		 * Window scale option is only present in SYN/SYN-ACK packet. 		 * Compare with ~TH_FIN to mask out T/TCP setups. 		 */
name|flags
operator|=
name|tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_FIN
operator||
name|TH_ECNALL
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
condition|)
block|{
name|is
operator|->
name|is_s0
index|[
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_s0
index|[
operator|!
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_tcpoptions
argument_list|(
name|softs
argument_list|,
name|fin
argument_list|,
name|tcp
argument_list|,
name|fdata
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_winscale_syn_ack
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
operator|)
condition|)
name|ipf_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|TH_SYN
condition|)
block|{
name|is
operator|->
name|is_s0
index|[
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_tcpoptions
argument_list|(
name|softs
argument_list|,
name|fin
argument_list|,
name|tcp
argument_list|,
name|fdata
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
name|DT1
argument_list|(
name|ipf_fi_bad_winscale_syn
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
operator|)
condition|)
name|ipf_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DT2
argument_list|(
name|iss_tcp_oow
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_tcp_oow
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checknewisn                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if this TCP connection is expecting and needs a new         */
end_comment

begin_comment
comment|/* sequence number for a particular direction of the connection.            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: This does not actually change the sequence numbers, only gets new  */
end_comment

begin_comment
comment|/* one ready.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_checknewisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|u_32_t
name|sumd
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|)
condition|)
block|{
name|old
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|new
operator|=
name|ipf_newisn
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_isninc
index|[
name|i
index|]
operator|=
name|new
operator|-
name|old
expr_stmt|;
name|CALC_SUMD
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|sumd
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_sumd
index|[
name|i
index|]
operator|=
operator|(
name|sumd
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sumd
operator|>>
literal|16
operator|)
expr_stmt|;
name|is
operator|->
name|is_flags
operator||=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|IS_ISNSYN
else|:
name|IS_ISNACK
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_tcpinwindow                                       */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet inside TCP "window", 0 == not inside.     */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              fdata(I) - pointer to tcp state informatio (forward)        */
end_comment

begin_comment
comment|/*              tdata(I) - pointer to tcp state informatio (reverse)        */
end_comment

begin_comment
comment|/*              tcp(I)   - pointer to TCP packet header                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a packet has matched addresses and ports, check to see if it is    */
end_comment

begin_comment
comment|/* within the TCP data window.  In a show of generosity, allow packets that */
end_comment

begin_comment
comment|/* are within the window space behind the current sequence # as well.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_tcpinwindow
parameter_list|(
name|fin
parameter_list|,
name|fdata
parameter_list|,
name|tdata
parameter_list|,
name|tcp
parameter_list|,
name|flags
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcpdata_t
modifier|*
name|fdata
decl_stmt|,
decl|*
name|tdata
decl_stmt|;
end_function

begin_decl_stmt
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|tcp_seq
name|seq
decl_stmt|,
name|ack
decl_stmt|,
name|end
decl_stmt|;
name|int
name|ackskew
decl_stmt|,
name|tcpflags
decl_stmt|;
name|u_32_t
name|win
decl_stmt|,
name|maxwin
decl_stmt|;
name|int
name|dsize
decl_stmt|,
name|inseq
decl_stmt|;
comment|/* 	 * Find difference between last checked packet and this packet. 	 */
name|tcpflags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_SYN
condition|)
name|win
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
else|else
name|win
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
operator|<<
name|fdata
operator|->
name|td_winscale
expr_stmt|;
comment|/* 	 * A window of 0 produces undesirable behaviour from this function. 	 */
if|if
condition|(
name|win
operator|==
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
name|dsize
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcpflags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcpflags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * if window scaling is present, the scaling is only allowed 	 * for windows not in the first SYN packet. In that packet the 	 * window is 65535 to specify the largest window possible 	 * for receivers not implementing the window scale option. 	 * Currently, we do not assume TTCP here. That means that 	 * if we see a second packet from a host (after the initial 	 * SYN), we can assume that the receiver of the SYN did 	 * already send back the SYN/ACK (and thus that we know if 	 * the receiver also does window scaling) 	 */
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
name|TCP_WSCALE_FIRST
operator|)
condition|)
block|{
name|fdata
operator|->
name|td_winflags
operator|&=
operator|~
name|TCP_WSCALE_FIRST
expr_stmt|;
name|fdata
operator|->
name|td_maxwin
operator|=
name|win
expr_stmt|;
block|}
name|end
operator|=
name|seq
operator|+
name|dsize
expr_stmt|;
if|if
condition|(
operator|(
name|fdata
operator|->
name|td_end
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
operator|||
operator|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Must be a (outgoing) SYN-ACK in reply to a SYN. 		 */
name|fdata
operator|->
name|td_end
operator|=
name|end
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|td_maxwin
operator|=
literal|1
expr_stmt|;
name|fdata
operator|->
name|td_maxend
operator|=
name|end
operator|+
name|win
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* Pretend an ack was sent */
name|ack
operator|=
name|tdata
operator|->
name|td_end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|==
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|&&
operator|(
name|ack
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* gross hack to get around certain broken tcp stacks */
name|ack
operator|=
name|tdata
operator|->
name|td_end
expr_stmt|;
block|}
name|maxwin
operator|=
name|tdata
operator|->
name|td_maxwin
expr_stmt|;
name|ackskew
operator|=
name|tdata
operator|->
name|td_end
operator|-
name|ack
expr_stmt|;
comment|/* 	 * Strict sequencing only allows in-order delivery. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IS_STRICT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|seq
operator|!=
name|fdata
operator|->
name|td_end
condition|)
block|{
name|DT2
argument_list|(
name|iss_tcp_struct
argument_list|,
name|tcpdata_t
operator|*
argument_list|,
name|fdata
argument_list|,
name|int
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_tcp_strict
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_OOW
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
define|#
directive|define
name|SEQ_GE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((int)((a) - (b))>= 0)
define|#
directive|define
name|SEQ_GT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((int)((a) - (b))> 0)
name|inseq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_GE
argument_list|(
name|fdata
operator|->
name|td_maxend
argument_list|,
name|end
argument_list|)
operator|)
operator|&&
operator|(
name|SEQ_GE
argument_list|(
name|seq
argument_list|,
name|fdata
operator|->
name|td_end
operator|-
name|maxwin
argument_list|)
operator|)
operator|&&
comment|/* XXX what about big packets */
define|#
directive|define
name|MAXACKWINDOW
value|66000
operator|(
operator|-
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|)
operator|)
operator|&&
operator|(
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|<<
name|fdata
operator|->
name|td_winscale
operator|)
operator|)
condition|)
block|{
name|inseq
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Microsoft Windows will send the next packet to the right of the 	 * window if SACK is in use. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
name|seq
operator|==
name|fdata
operator|->
name|td_maxend
operator|)
operator|&&
operator|(
name|ackskew
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
name|TCP_SACK_PERMIT
operator|)
operator|&&
operator|(
name|tdata
operator|->
name|td_winflags
operator|&
name|TCP_SACK_PERMIT
operator|)
condition|)
block|{
name|DT2
argument_list|(
name|iss_sinsack
argument_list|,
name|tcpdata_t
operator|*
argument_list|,
name|fdata
argument_list|,
name|int
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_winsack
argument_list|)
expr_stmt|;
name|inseq
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Sometimes a TCP RST will be generated with only the ACK field 	 * set to non-zero. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
name|seq
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tcpflags
operator|==
operator|(
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|&&
operator|(
name|ackskew
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ackskew
operator|<=
literal|1
operator|)
condition|)
block|{
name|inseq
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|fin
operator|->
name|fin_rev
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
if|#
directive|if
literal|0
block|if (is_pkts[i]0 == 0) {
comment|/* 			 * Picking up a connection in the middle, the "next" 			 * packet seen from a direction that is new should be 			 * accepted, even if it appears out of sequence. 			 */
block|inseq = 1; 		} else
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
operator|(
name|TCP_WSCALE_SEEN
operator||
name|TCP_WSCALE_FIRST
operator|)
operator|)
condition|)
block|{
comment|/* 			 * No TCPFSM and no window scaling, so make some 			 * extra guesses. 			 */
if|if
condition|(
operator|(
name|seq
operator|==
name|fdata
operator|->
name|td_maxend
operator|)
operator|&&
operator|(
name|ackskew
operator|==
literal|0
operator|)
condition|)
name|inseq
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SEQ_GE
argument_list|(
name|seq
operator|+
name|maxwin
argument_list|,
name|fdata
operator|->
name|td_end
operator|-
name|maxwin
argument_list|)
condition|)
name|inseq
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* TRACE(inseq, fdata, tdata, seq, end, ack, ackskew, win, maxwin) */
if|if
condition|(
name|inseq
condition|)
block|{
comment|/* if ackskew< 0 then this should be due to fragmented 		 * packets. There is no way to know the length of the 		 * total packet in advance. 		 * We do know the total length from the fragment cache though. 		 * Note however that there might be more sessions with 		 * exactly the same source and destination parameters in the 		 * state cache (and source and destination is the only stuff 		 * that is saved in the fragment cache). Note further that 		 * some TCP connections in the state cache are hashed with 		 * sport and dport as well which makes it not worthwhile to 		 * look for them. 		 * Thus, when ackskew is negative but still seems to belong 		 * to this session, we bump up the destinations end value. 		 */
if|if
condition|(
name|ackskew
operator|<
literal|0
condition|)
name|tdata
operator|->
name|td_end
operator|=
name|ack
expr_stmt|;
comment|/* update max window seen */
if|if
condition|(
name|fdata
operator|->
name|td_maxwin
operator|<
name|win
condition|)
name|fdata
operator|->
name|td_maxwin
operator|=
name|win
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|end
argument_list|,
name|fdata
operator|->
name|td_end
argument_list|)
condition|)
name|fdata
operator|->
name|td_end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|SEQ_GE
argument_list|(
name|ack
operator|+
name|win
argument_list|,
name|tdata
operator|->
name|td_maxend
argument_list|)
condition|)
name|tdata
operator|->
name|td_maxend
operator|=
name|ack
operator|+
name|win
expr_stmt|;
return|return
literal|1
return|;
block|}
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_oow
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_OOW
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_clone                                             */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == cloning failed,                        */
end_comment

begin_comment
comment|/*                           else pointer to new state structure            */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP/UDP header                          */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create a "duplcate" state table entry from the master.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|ipf_state_clone
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|clone
decl_stmt|;
name|u_32_t
name|send
decl_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|==
name|softs
operator|->
name|ipf_state_max
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_max
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_doflush
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KMALLOC
argument_list|(
name|clone
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|==
name|NULL
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_clone_nomem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|clone
operator|->
name|is_lock
argument_list|)
expr_stmt|;
comment|/* 	 * It has not yet been placed on any timeout queue, so make sure 	 * all of that data is zero'd out. 	 */
name|clone
operator|->
name|is_sti
operator|.
name|tqe_pnext
operator|=
name|NULL
expr_stmt|;
name|clone
operator|->
name|is_sti
operator|.
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|clone
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
name|clone
operator|->
name|is_sti
operator|.
name|tqe_parent
operator|=
name|clone
expr_stmt|;
name|clone
operator|->
name|is_die
operator|=
name|ONE_DAY
operator|+
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
name|clone
operator|->
name|is_state
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_state
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_rev
operator|==
literal|1
condition|)
block|{
name|clone
operator|->
name|is_dend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_maxdend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_send
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
name|clone
operator|->
name|is_maxdwin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_maxdwin
operator|==
literal|0
condition|)
name|clone
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|clone
operator|->
name|is_send
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_maxsend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_dend
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
name|clone
operator|->
name|is_maxswin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_maxswin
operator|==
literal|0
condition|)
name|clone
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
block|}
name|clone
operator|->
name|is_flags
operator|&=
operator|~
name|SI_CLONE
expr_stmt|;
name|clone
operator|->
name|is_flags
operator||=
name|SI_CLONED
expr_stmt|;
if|if
condition|(
name|ipf_state_insert
argument_list|(
name|softc
argument_list|,
name|clone
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|KFREE
argument_list|(
name|clone
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|clone
operator|->
name|is_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
operator|(
name|void
operator|)
name|ipf_tcp_age
argument_list|(
operator|&
name|clone
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|,
name|clone
operator|->
name|is_flags
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|clone
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
condition|)
name|clone
operator|->
name|is_sync
operator|=
name|ipf_sync_new
argument_list|(
name|softc
argument_list|,
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|clone
argument_list|)
expr_stmt|;
name|DT2
argument_list|(
name|iss_clone
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|clone
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_cloned
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_matchsrcdst                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)    - pointer to state structure                       */
end_comment

begin_comment
comment|/*              src(I)   - pointer to source address                        */
end_comment

begin_comment
comment|/*              dst(I)   - pointer to destination address                   */
end_comment

begin_comment
comment|/*              tcp(I)   - pointer to TCP/UDP header                        */
end_comment

begin_comment
comment|/*              cmask(I) - mask of FI_* bits to check                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Match a state table entry against an IP packet.  The logic below is that */
end_comment

begin_comment
comment|/* ret gets set to one if the match succeeds, else remains 0.  If it is     */
end_comment

begin_comment
comment|/* still 0 after the test. no match.                                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|ipf_matchsrcdst
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|tcp
parameter_list|,
name|cmask
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|i6addr_t
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_32_t
name|cmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|rev
decl_stmt|,
name|out
decl_stmt|,
name|flags
decl_stmt|,
name|flx
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
name|u_short
name|sp
decl_stmt|,
name|dp
decl_stmt|;
name|u_32_t
name|cflx
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
comment|/* 	 * If a connection is about to be deleted, no packets 	 * are allowed to match it. 	 */
if|if
condition|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|==
operator|&
name|softs
operator|->
name|ipf_state_deletetq
condition|)
return|return
name|NULL
return|;
name|rev
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|flags
operator|=
name|is
operator|->
name|is_flags
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcp
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_sport
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ntohs
argument_list|(
name|fin
operator|->
name|fin_dport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rev
condition|)
block|{
if|if
condition|(
name|tcp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|sp
operator|!=
name|is
operator|->
name|is_sport
operator|)
condition|)
name|rev
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SI_W_DPORT
operator|)
operator|&&
operator|(
name|dp
operator|!=
name|is
operator|->
name|is_dport
operator|)
condition|)
name|rev
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|idx
operator|=
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
name|rev
expr_stmt|;
comment|/* 	 * If the interface for this 'direction' is set, make sure it matches. 	 * An interface name that is not set matches any, as does a name of *. 	 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|ifp
operator|)
operator|||
operator|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'-'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|DT2
argument_list|(
name|iss_lookup_badifp
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_lookup_badifp
argument_list|)
expr_stmt|;
comment|/* TRACE is, out, rev, idx */
return|return
name|NULL
return|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Match addresses and ports. 	 */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|)
operator|&&
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|src
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tcp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|==
name|is
operator|->
name|is_sport
operator|||
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|dp
operator|==
name|is
operator|->
name|is_dport
operator|||
name|flags
operator|&
name|SI_W_DPORT
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|src
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|)
operator|&&
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tcp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|==
name|is
operator|->
name|is_sport
operator|||
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|sp
operator|==
name|is
operator|->
name|is_dport
operator|||
name|flags
operator|&
name|SI_W_DPORT
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_lookup_badport
argument_list|)
expr_stmt|;
name|DT2
argument_list|(
name|iss_lookup_badport
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
comment|/* TRACE rev, is, sp, dp, src, dst */
return|return
name|NULL
return|;
block|}
comment|/* 	 * Whether or not this should be here, is questionable, but the aim 	 * is to get this out of the main line. 	 */
if|if
condition|(
name|tcp
operator|==
name|NULL
condition|)
name|flags
operator|=
name|is
operator|->
name|is_flags
operator|&
operator|~
operator|(
name|SI_WILDP
operator||
name|SI_NEWFR
operator||
name|SI_CLONE
operator||
name|SI_CLONED
operator|)
expr_stmt|;
comment|/* 	 * Only one of the source or destination address can be flaged as a 	 * wildcard.  Fill in the missing address, if set. 	 * For IPv6, if the address being copied in is multicast, then 	 * don't reset the wild flag - multicast causes it to be set in the 	 * first place! 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_SADDR
operator||
name|SI_W_DADDR
operator|)
operator|)
condition|)
block|{
name|fr_ip_t
modifier|*
name|fi
init|=
operator|&
name|fin
operator|->
name|fin_fi
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_src
operator|=
name|fi
operator|->
name|fi_src
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_SADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_MULTICAST
operator||
name|FI_MBCAST
operator|)
operator|)
condition|)
block|{
name|is
operator|->
name|is_src
operator|=
name|fi
operator|->
name|fi_dst
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_SADDR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_MULTICAST
operator||
name|FI_MBCAST
operator|)
operator|)
condition|)
block|{
name|is
operator|->
name|is_dst
operator|=
name|fi
operator|->
name|fi_dst
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_DADDR
expr_stmt|;
block|}
block|}
else|else
block|{
name|is
operator|->
name|is_dst
operator|=
name|fi
operator|->
name|fi_src
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_DADDR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_WILDA
operator||
name|SI_WILDP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ATOMIC_DECL
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
block|}
name|flx
operator|=
name|fin
operator|->
name|fin_flx
operator|&
name|cmask
expr_stmt|;
name|cflx
operator|=
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
expr_stmt|;
comment|/* 	 * Match up any flags set from IP options. 	 */
if|if
condition|(
operator|(
name|cflx
operator|&&
operator|(
name|flx
operator|!=
operator|(
name|cflx
operator|&
name|cmask
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_optmsk
operator|&
name|is
operator|->
name|is_optmsk
index|[
name|rev
index|]
operator|)
operator|!=
name|is
operator|->
name|is_opt
index|[
name|rev
index|]
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_secmsk
operator|&
name|is
operator|->
name|is_secmsk
operator|)
operator|!=
name|is
operator|->
name|is_sec
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_auth
operator|&
name|is
operator|->
name|is_authmsk
operator|)
operator|!=
name|is
operator|->
name|is_auth
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_miss_mask
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_rev
operator|=
name|rev
expr_stmt|;
return|return
name|is
return|;
block|}
comment|/* 	 * Only one of the source or destination port can be flagged as a 	 * wildcard.  When filling it in, fill in a copy of the matched entry 	 * if it has the cloning flag set. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_SPORT
operator||
name|SI_W_DPORT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_CLONE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipstate_t
modifier|*
name|clone
decl_stmt|;
name|clone
operator|=
name|ipf_state_clone
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|is
operator|=
name|clone
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_DECL
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_sport
operator|=
name|sp
expr_stmt|;
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_sport
operator|=
name|dp
expr_stmt|;
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_maxsend
operator|=
name|is
operator|->
name|is_send
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_DPORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_dport
operator|=
name|dp
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_dport
operator|=
name|sp
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_maxdend
operator|=
name|is
operator|->
name|is_dend
operator|+
literal|1
expr_stmt|;
block|}
name|is
operator|->
name|is_flags
operator|&=
operator|~
operator|(
name|SI_W_SPORT
operator||
name|SI_W_DPORT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_CLONED
operator|)
operator|&&
name|softs
operator|->
name|ipf_state_logging
condition|)
name|ipf_state_log
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_CLONE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
operator|=
name|flx
expr_stmt|;
if|if
condition|(
name|rev
operator|==
literal|1
operator|&&
name|is
operator|->
name|is_optmsk
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_opt
index|[
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_optmsk
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
condition|)
block|{
name|is
operator|->
name|is_opt
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check if the interface name for this "direction" is set and if not, 	 * fill it in. 	 */
if|if
condition|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'*'
operator|)
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|=
name|ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_v
argument_list|,
name|ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_rev
operator|=
name|rev
expr_stmt|;
return|return
name|is
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checkicmpmatchingstate                                  */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we've got an ICMP error message, using the information stored in the  */
end_comment

begin_comment
comment|/* ICMP packet, look for a matching state table entry.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we return NULL then no lock on ipf_state is held.                     */
end_comment

begin_comment
comment|/* If we return non-null then a read-lock on ipf_state is held.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|ipf_checkicmpmatchingstate
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|i6addr_t
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|u_short
name|savelen
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|fr_info_t
name|ofin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|pr
decl_stmt|;
name|ip_t
modifier|*
name|oip
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
comment|/* 	 * Does it at least have the return (basic) IP header ? 	 * Is it an actual recognised ICMP error type? 	 * Only a basic IP header (no options) should be with 	 * an ICMP error header. 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_v
operator|!=
literal|4
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_hlen
operator|!=
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMPERR_MINPKTLEN
operator|)
operator|||
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_bad
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
name|oip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ic
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
comment|/* 	 * Check if the at least the old IP header (with options) and 	 * 8 bytes of payload is present. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMPERR_MAXPKTLEN
operator|+
operator|(
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|-
literal|5
operator|)
operator|<<
literal|2
operator|)
condition|)
block|{
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_short
argument_list|,
name|iss_icmp_short_1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Sanity Checks. 	 */
name|len
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
name|ICMPERR_ICMPHLEN
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|>
name|len
operator|)
condition|)
block|{
name|DT2
argument_list|(
name|iss_icmp_len
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
expr|struct
name|ip
operator|*
argument_list|,
name|oip
argument_list|)
expr_stmt|;
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_short
argument_list|,
name|iss_icmp_short_1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Is the buffer big enough for all of it ?  It's the size of the IP 	 * header claimed in the encapsulated part which is of concern.  It 	 * may be too big to be in this buffer but not so big that it's 	 * outside the ICMP packet, leading to TCP deref's causing problems. 	 * This is possible because we don't know how big oip_hl is when we 	 * do the pullup early in ipf_check() and thus can't guarantee it is 	 * all here now. 	 */
ifdef|#
directive|ifdef
name|_KERNEL
block|{
name|mb_t
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
name|len
operator|>
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|b_wptr
condition|)
block|{
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_short
argument_list|,
name|iss_icmp_short_2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
name|len
operator|>
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|m
operator|->
name|m_len
condition|)
block|{
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_short
argument_list|,
name|iss_icmp_short_3
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ofin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * in the IPv4 case we must zero the i6addr union otherwise 	 * the IP6_EQ and IP6_NEQ macros produce the wrong results because 	 * of the 'junk' in the unused part of the union 	 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * we make an fin entry to be able to feed it to 	 * matchsrcdst note that not all fields are encessary 	 * but this is the cleanest way. Note further we fill 	 * in fin_mp such that if someone uses it we'll get 	 * a kernel panic. ipf_matchsrcdst does not use this. 	 * 	 * watch out here, as ip is in host order and oip in network 	 * order. Any change we make must be undone afterwards, like 	 * oip->ip_len. 	 */
name|savelen
operator|=
name|oip
operator|->
name|ip_len
expr_stmt|;
name|oip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|=
name|FI_NOCKSUM
expr_stmt|;
name|ofin
operator|.
name|fin_v
operator|=
literal|4
expr_stmt|;
name|ofin
operator|.
name|fin_ip
operator|=
name|oip
expr_stmt|;
name|ofin
operator|.
name|fin_m
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
name|ofin
operator|.
name|fin_mp
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
operator|(
name|void
operator|)
name|ipf_makefrip
argument_list|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
argument_list|,
name|oip
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|ofin
operator|.
name|fin_out
operator|=
operator|!
name|fin
operator|->
name|fin_out
expr_stmt|;
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip
operator|->
name|ip_p
operator|)
expr_stmt|;
name|src
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * Reset the short and bad flag here because in ipf_matchsrcdst() 	 * the flags for the current packet (fin_flx) are compared against 	 * those for the existing session. 	 */
name|ofin
operator|.
name|fin_flx
operator|&=
operator|~
operator|(
name|FI_BAD
operator||
name|FI_SHORT
operator|)
expr_stmt|;
comment|/* 	 * Put old values of ip_len back as we don't know 	 * if we have to forward the packet or process it again. 	 */
name|oip
operator|->
name|ip_len
operator|=
name|savelen
expr_stmt|;
switch|switch
condition|(
name|oip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_ICMP
case|:
comment|/* 		 * an ICMP error can only be generated as a result of an 		 * ICMP query, not as the response on an ICMP error 		 * 		 * XXX theoretically ICMP_ECHOREP and the other reply's are 		 * ICMP query's as well, but adding them here seems strange XXX 		 */
if|if
condition|(
operator|(
name|ofin
operator|.
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|DT1
argument_list|(
name|iss_icmp_icmperr
argument_list|,
name|fr_info_t
operator|*
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_icmp_icmperr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * perform a lookup of the ICMP packet in the state table 		 */
name|icmp
operator|=
operator|(
name|icmphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|hv
operator|+=
name|icmp
operator|->
name|icmp_id
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
literal|4
operator|)
condition|)
continue|continue;
if|if
condition|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
condition|)
continue|continue;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_ICMPCMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|ipf_allowstateicmp
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|)
condition|)
return|return
name|is
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_miss
argument_list|,
name|iss_icmp_miss_1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
break|break;
default|default :
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_miss
argument_list|,
name|iss_icmp_miss_2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tcp
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|hv
operator|+=
name|tcp
operator|->
name|th_dport
expr_stmt|;
empty_stmt|;
name|hv
operator|+=
name|tcp
operator|->
name|th_sport
expr_stmt|;
empty_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
comment|/* 		 * Only allow this icmp though if the 		 * encapsulated packet was allowed through the 		 * other way around. Note that the minimal amount 		 * of info present does not allow for checking against 		 * tcp internals such as seq and ack numbers.   Only the 		 * ports are known to be present and can be even if the 		 * short flag is set. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|pr
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_v
operator|==
literal|4
operator|)
operator|&&
operator|(
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_ICMPCMP
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_allowstateicmp
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|)
operator|==
literal|0
condition|)
return|return
name|is
return|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPDX
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_miss
argument_list|,
name|iss_icmp_miss_3
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_allowstateicmp                                          */
end_comment

begin_comment
comment|/* Returns:     int - 1 = packet denied, 0 = packet allowed                 */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              is(I)  - pointer to state table entry                       */
end_comment

begin_comment
comment|/*              src(I) - source address to check permission for             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* For an ICMP packet that has so far matched a state table entry, check if */
end_comment

begin_comment
comment|/* there are any further refinements that might mean we want to block this  */
end_comment

begin_comment
comment|/* packet.  This code isn't specific to either IPv4 or IPv6.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_allowstateicmp
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|,
name|src
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|i6addr_t
modifier|*
name|src
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|frentry_t
modifier|*
name|savefr
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|u_32_t
name|ipass
decl_stmt|;
name|int
name|backward
decl_stmt|;
name|int
name|oi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
operator|&&
name|fr
operator|->
name|fr_icmpgrp
operator|!=
name|NULL
condition|)
block|{
name|savefr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
operator|->
name|fr_icmpgrp
operator|->
name|fg_start
expr_stmt|;
name|ipass
operator|=
name|ipf_scanlist
argument_list|(
name|fin
argument_list|,
name|softc
operator|->
name|ipf_pass
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|savefr
expr_stmt|;
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|ipass
argument_list|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_headblock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 	 * i  : the index of this packet (the icmp unreachable) 	 * oi : the index of the original packet found in the 	 *      icmp header (i.e. the packet causing this icmp) 	 * backward : original packet was backward compared to 	 *            the state 	 */
name|backward
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
operator|!
name|backward
expr_stmt|;
name|i
operator|=
operator|(
operator|!
name|backward
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|oi
operator|=
operator|(
name|backward
operator|<<
literal|1
operator|)
operator|+
operator|!
name|fin
operator|->
name|fin_out
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_banned
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|>
name|is
operator|->
name|is_pkts
index|[
name|oi
index|]
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_toomany
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|DT2
argument_list|(
name|iss_icmp_hits
argument_list|,
name|fr_info_t
operator|*
argument_list|,
name|fin
argument_list|,
name|ipstate_t
operator|*
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_icmp_hits
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* 	 * we deliberately do not touch the timeouts 	 * for the accompanying state table entry. 	 * It remains to be seen if that is correct. XXX 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_ipsmove                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  is(I) - pointer to state table entry                        */
end_comment

begin_comment
comment|/*              hv(I) - new hash value for state table entry                */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a state entry from one position in the hash table to another.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_ipsmove
parameter_list|(
name|softs
parameter_list|,
name|is
parameter_list|,
name|hv
parameter_list|)
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
block|{
name|ipstate_t
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_int
name|hvm
decl_stmt|;
name|hvm
operator|=
name|is
operator|->
name|is_hv
expr_stmt|;
comment|/* TRACE is, is_hv, hvm */
comment|/* 	 * Remove the hash from the old location... 	 */
name|isp
operator|=
name|is
operator|->
name|is_phnext
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_hnext
condition|)
name|is
operator|->
name|is_hnext
operator|->
name|is_phnext
operator|=
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
index|[
name|hvm
index|]
operator|==
name|NULL
condition|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|--
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|hvm
index|]
operator|--
expr_stmt|;
comment|/* 	 * ...and put the hash in the new one. 	 */
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_hv
operator|=
name|hvm
expr_stmt|;
comment|/* TRACE is, hv, is_hv, hvm */
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hvm
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|isp
condition|)
operator|(
operator|*
name|isp
operator|)
operator|->
name|is_phnext
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
else|else
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|++
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|hvm
index|]
operator|++
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|isp
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
operator|*
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|is
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_lookup                                            */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == no matching state found,               */
end_comment

begin_comment
comment|/*                           else pointer to state information is returned  */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              tcp(I)  - pointer to TCP/UDP header.                        */
end_comment

begin_comment
comment|/*              ifqp(O) - pointer for storing tailq timeout                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search the state table for a matching entry to the packet described by   */
end_comment

begin_comment
comment|/* the contents of *fin. For certain protocols, when a match is found the   */
end_comment

begin_comment
comment|/* timeout queue is also selected and stored in ifpq if it is non-NULL.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we return NULL then no lock on ipf_state is held.                     */
end_comment

begin_comment
comment|/* If we return non-null then a read-lock on ipf_state is held.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipstate_t
modifier|*
name|ipf_state_lookup
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|ifqp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipftq_t
modifier|*
modifier|*
name|ifqp
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|u_int
name|hv
decl_stmt|,
name|hvm
decl_stmt|,
name|pr
decl_stmt|,
name|v
decl_stmt|,
name|tryagain
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_short
name|dport
decl_stmt|,
name|sport
decl_stmt|;
name|i6addr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|int
name|oow
decl_stmt|;
name|is
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|=
name|NULL
expr_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|tcp
expr_stmt|;
name|hv
operator|=
operator|(
name|pr
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|)
expr_stmt|;
name|src
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
expr_stmt|;
name|dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|v
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_v
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_ICMPV6
operator|)
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|in6
argument_list|)
condition|)
block|{
name|hv
operator|-=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|v
operator|==
literal|4
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_MULTICAST
operator||
name|FI_BROADCAST
operator||
name|FI_MBCAST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
block|{
name|hv
operator|-=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|-=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
block|}
comment|/* TRACE fin_saddr, fin_daddr, hv */
comment|/* 	 * Search the hash table for matching packet header info. 	 */
switch|switch
condition|(
name|pr
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|tryagain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
operator|(
name|ic
operator|->
name|icmp_type
operator|==
name|ICMP6_ECHO_REQUEST
operator|)
operator|||
operator|(
name|ic
operator|->
name|icmp_type
operator|==
name|ICMP6_ECHO_REPLY
operator|)
condition|)
block|{
name|hv
operator|+=
name|ic
operator|->
name|icmp_id
expr_stmt|;
block|}
block|}
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|icmp6again
label|:
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
operator|&&
name|ipf_matchicmpqueryreply
argument_list|(
name|v
argument_list|,
operator|&
name|is
operator|->
name|is_icmp
argument_list|,
name|ic
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tryagain
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_W_DADDR
operator|)
condition|)
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|ipf_ipsmove
argument_list|(
name|softs
argument_list|,
name|is
argument_list|,
name|hv
argument_list|)
expr_stmt|;
name|MUTEX_DOWNGRADE
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
comment|/* 		 * No matching icmp state entry. Perhaps this is a 		 * response to another state entry. 		 * 		 * XXX With some ICMP6 packets, the "other" address is already 		 * in the packet, after the ICMP6 header, and this could be 		 * used in place of the multicast address.  However, taking 		 * advantage of this requires some significant code changes 		 * to handle the specific types where that is the case. 		 */
if|if
condition|(
operator|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_wild
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_NOWILD
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|v
operator|==
literal|6
operator|)
operator|&&
operator|(
name|tryagain
operator|==
literal|0
operator|)
condition|)
block|{
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|tryagain
operator|=
literal|1
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
goto|goto
name|icmp6again
goto|;
block|}
name|is
operator|=
name|ipf_checkicmp6matchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
name|is
return|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
name|hv
operator|+=
name|ic
operator|->
name|icmp_id
expr_stmt|;
block|}
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ic
operator|->
name|icmp_id
operator|==
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|)
operator|&&
name|ipf_matchicmpqueryreply
argument_list|(
name|v
argument_list|,
operator|&
name|is
operator|->
name|is_icmp
argument_list|,
name|ic
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
name|ifqp
operator|=
name|NULL
expr_stmt|;
name|sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
name|dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hv
operator|+=
name|dport
expr_stmt|;
name|oow
operator|=
literal|0
expr_stmt|;
name|tryagain
operator|=
literal|0
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|retry_tcpudp
label|:
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
comment|/* TRACE hv, hvm */
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|fin
operator|->
name|fin_flx
operator|&=
operator|~
name|FI_OOW
expr_stmt|;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pr
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
operator|!
name|ipf_state_tcp
argument_list|(
name|softc
argument_list|,
name|softs
argument_list|,
name|fin
argument_list|,
name|tcp
argument_list|,
name|is
argument_list|)
condition|)
block|{
name|oow
operator||=
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tryagain
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_CLONE
operator||
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
operator|)
condition|)
block|{
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
name|ipf_ipsmove
argument_list|(
name|softs
argument_list|,
name|is
argument_list|,
name|hv
argument_list|)
expr_stmt|;
name|MUTEX_DOWNGRADE
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_wild
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_NOWILD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tryagain
operator|==
literal|0
condition|)
block|{
name|hv
operator|-=
name|dport
expr_stmt|;
name|hv
operator|-=
name|sport
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tryagain
operator|==
literal|1
condition|)
block|{
name|hv
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
expr_stmt|;
comment|/* 				 * If we try to pretend this is a reply to a 				 * multicast/broadcast packet then we need to 				 * exclude part of the address from the hash 				 * calculation. 				 */
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
block|{
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
block|}
name|tryagain
operator|++
expr_stmt|;
if|if
condition|(
name|tryagain
operator|<=
literal|2
condition|)
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
goto|goto
name|retry_tcpudp
goto|;
block|}
block|}
name|fin
operator|->
name|fin_flx
operator||=
name|oow
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case IPPROTO_GRE : 		gre = fin->fin_dp; 		if (GRE_REV(gre->gr_flags) == 1) { 			hv += gre->gr_call; 		}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default :
name|ifqp
operator|=
name|NULL
expr_stmt|;
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_iptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
operator|!=
name|NULL
operator|)
condition|)
name|ifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
operator|&&
name|ifqp
operator|!=
name|NULL
condition|)
operator|*
name|ifqp
operator|=
name|ifq
expr_stmt|;
block|}
else|else
block|{
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_lookup_miss
argument_list|)
expr_stmt|;
block|}
return|return
name|is
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_check                                             */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - NULL == search failed,                         */
end_comment

begin_comment
comment|/*                           else pointer to rule for matching state        */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              passp(I) - pointer to filtering result flags                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if a packet is associated with an entry in the state table.        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|ipf_state_check
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|u_int
name|pass
decl_stmt|;
name|int
name|inout
decl_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_lock
operator|||
operator|(
name|softs
operator|->
name|ipf_state_list
operator|==
name|NULL
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_SHORT
operator||
name|FI_FRAGBODY
operator||
name|FI_BAD
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_check_bad
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_TCPUDP
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|==
name|IPPROTO_ICMP
operator|)
ifdef|#
directive|ifdef
name|USE_INET6
operator|||
operator|(
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|==
name|IPPROTO_ICMPV6
operator|)
endif|#
directive|endif
condition|)
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
else|else
name|tcp
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Search the hash table for matching packet header info. 	 */
name|is
operator|=
name|ipf_state_lookup
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
operator|&
name|ifq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
name|is
operator|=
name|ipf_checkicmp6matchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * No matching icmp state entry. Perhaps this is a 		 * response to another state entry. 		 */
name|is
operator|=
name|ipf_checkicmpmatchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
name|ipf_fixinisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|1
condition|)
name|ipf_fixoutisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udptq
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_check_miss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_check_notag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ipf_matchtag
argument_list|(
operator|&
name|fr
operator|->
name|fr_nattag
argument_list|,
name|fin
operator|->
name|fin_nattag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_check_nattag
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_NAME
argument_list|(
name|fr
argument_list|,
name|fr_group
argument_list|)
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_icode
operator|=
name|fr
operator|->
name|fr_icode
expr_stmt|;
block|}
name|fin
operator|->
name|fin_rule
operator|=
name|is
operator|->
name|is_rulen
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
comment|/* 	 * If this packet is a fragment and the rule says to track fragments, 	 * then create a new fragment cache entry. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|&&
name|FR_ISPASS
argument_list|(
name|is
operator|->
name|is_pass
argument_list|)
operator|&&
name|is
operator|->
name|is_pass
operator|&
name|FR_KEEPFRAG
condition|)
operator|(
name|void
operator|)
name|ipf_frag_new
argument_list|(
name|softc
argument_list|,
name|fin
argument_list|,
name|is
operator|->
name|is_pass
argument_list|)
expr_stmt|;
comment|/* 	 * For TCP packets, ifq == NULL.  For all others, check if this new 	 * queue is different to the last one it was on and move it if so. 	 */
name|tqe
operator|=
operator|&
name|is
operator|->
name|is_sti
expr_stmt|;
if|if
condition|(
operator|(
name|tqe
operator|->
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
condition|)
name|ifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
condition|)
name|ipf_movequeue
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
name|tqe
argument_list|,
name|tqe
operator|->
name|tqe_ifq
argument_list|,
name|ifq
argument_list|)
expr_stmt|;
name|inout
operator|=
operator|(
name|fin
operator|->
name|fin_rev
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
name|inout
index|]
operator|++
expr_stmt|;
name|is
operator|->
name|is_bytes
index|[
name|inout
index|]
operator|+=
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|fin
operator|->
name|fin_pktnum
operator|=
name|is
operator|->
name|is_pkts
index|[
name|inout
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
name|inout
index|]
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|pass
operator|=
name|is
operator|->
name|is_pass
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
condition|)
name|ipf_sync_update
argument_list|(
name|softc
argument_list|,
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|is
operator|->
name|is_sync
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_hits
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dif
operator|=
operator|&
name|is
operator|->
name|is_dif
expr_stmt|;
name|fin
operator|->
name|fin_tif
operator|=
operator|&
name|is
operator|->
name|is_tifs
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_STATE
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGFIRST
operator|)
operator|!=
literal|0
condition|)
name|pass
operator|&=
operator|~
operator|(
name|FR_LOGFIRST
operator||
name|FR_LOG
operator|)
expr_stmt|;
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_fixoutisn                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called only for outbound packets, adjusts the sequence number and the    */
end_comment

begin_comment
comment|/* TCP checksum to match that change.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_fixoutisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|u_32_t
name|seq
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rev
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_cksum
operator|<
name|FI_CK_L4PART
operator|)
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|seq
operator|+=
name|is
operator|->
name|is_isninc
index|[
literal|0
index|]
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|ipf_fix_outcksum
argument_list|(
literal|0
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_cksum
operator|<
name|FI_CK_L4PART
operator|)
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|seq
operator|+=
name|is
operator|->
name|is_isninc
index|[
literal|1
index|]
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|ipf_fix_outcksum
argument_list|(
literal|0
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_fixinisn                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called only for inbound packets, adjusts the acknowledge number and the  */
end_comment

begin_comment
comment|/* TCP checksum to match that change.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|ipf_fixinisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|u_32_t
name|ack
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rev
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rev
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_cksum
operator|<
name|FI_CK_L4PART
operator|)
condition|)
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|ack
operator|-=
name|is
operator|->
name|is_isninc
index|[
literal|0
index|]
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ack
argument_list|)
expr_stmt|;
name|ipf_fix_incksum
argument_list|(
literal|0
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_cksum
operator|<
name|FI_CK_L4PART
operator|)
condition|)
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|ack
operator|-=
name|is
operator|->
name|is_isninc
index|[
literal|1
index|]
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ack
argument_list|)
expr_stmt|;
name|ipf_fix_incksum
argument_list|(
literal|0
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_sync                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              ifp(I)   - pointer to interface                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk through all state entries and if an interface pointer match is      */
end_comment

begin_comment
comment|/* found then look it up again, based on its name in case the pointer has   */
end_comment

begin_comment
comment|/* changed since last time.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If ifp is passed in as being non-null then we are only doing updates for */
end_comment

begin_comment
comment|/* existing, matching, uses of it.                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_sync
parameter_list|(
name|softc
parameter_list|,
name|ifp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|<=
literal|0
condition|)
return|return;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|softc
operator|->
name|ipf_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
block|{
comment|/* 		 * Look up all the interface names in the state entry. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
condition|)
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|ipf_resolvenic
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|i
index|]
argument_list|,
name|is
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_del                                               */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = deleted, else refernce count on active struct  */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              is(I)  - pointer to state structure to delete               */
end_comment

begin_comment
comment|/*              why(I) - if not 0, log reason why it was deleted            */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Deletes a state entry from the enumerated list as well as the hash table */
end_comment

begin_comment
comment|/* and timeout queue lists.  Make adjustments to hash table statistics and  */
end_comment

begin_comment
comment|/* global counters as required.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_del
parameter_list|(
name|softc
parameter_list|,
name|is
parameter_list|,
name|why
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|why
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|int
name|orphan
init|=
literal|1
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
comment|/* 	 * Since we want to delete this, remove it from the state table, 	 * where it can be found& used, first. 	 */
if|if
condition|(
name|is
operator|->
name|is_phnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_phnext
operator|=
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_hnext
operator|!=
name|NULL
condition|)
name|is
operator|->
name|is_hnext
operator|->
name|is_phnext
operator|=
name|is
operator|->
name|is_phnext
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
index|[
name|is
operator|->
name|is_hv
index|]
operator|==
name|NULL
condition|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|--
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|is
operator|->
name|is_hv
index|]
operator|--
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
name|NULL
expr_stmt|;
name|orphan
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Because ipf_state_stats.iss_wild is a count of entries in the state 	 * table that have wildcard flags set, only decerement it once 	 * and do it here. 	 */
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_CLONED
operator|)
condition|)
block|{
name|ATOMIC_DECL
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_flags
operator|&=
operator|~
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
expr_stmt|;
block|}
comment|/* 	 * Next, remove it from the timeout queue it is in. 	 */
if|if
condition|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|!=
name|NULL
condition|)
name|ipf_deletequeueentry
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|)
expr_stmt|;
comment|/* 	 * If it is still in use by something else, do not go any further, 	 * but note that at this point it is now an orphan.  How can this 	 * be?  ipf_state_flush() calls ipf_delete() directly because it wants 	 * to empty the table out and if something has a hold on a state 	 * entry (such as ipfstat), it'll do the deref path that'll bring 	 * us back here to do the real delete& free. 	 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_me
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
block|}
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_ref
operator|>
literal|0
condition|)
block|{
name|int
name|refs
decl_stmt|;
name|refs
operator|=
name|is
operator|->
name|is_ref
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orphan
condition|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_orphan
operator|++
expr_stmt|;
return|return
name|refs
return|;
block|}
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
name|is
operator|->
name|is_rule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_srctrack
operator|.
name|ht_max_nodes
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ipf_ht_node_del
argument_list|(
operator|&
name|fr
operator|->
name|fr_srctrack
argument_list|,
name|is
operator|->
name|is_family
argument_list|,
operator|&
name|is
operator|->
name|is_src
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|is
operator|->
name|is_ref
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ipf_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ipf_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|->
name|is_sync
condition|)
name|ipf_sync_del_state
argument_list|(
name|softc
operator|->
name|ipf_sync_soft
argument_list|,
name|is
operator|->
name|is_sync
argument_list|)
expr_stmt|;
comment|/* 	 * Now remove it from the linked list of known states 	 */
if|if
condition|(
name|is
operator|->
name|is_pnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_pnext
operator|=
name|is
operator|->
name|is_next
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_next
operator|!=
name|NULL
condition|)
name|is
operator|->
name|is_next
operator|->
name|is_pnext
operator|=
name|is
operator|->
name|is_pnext
expr_stmt|;
name|is
operator|->
name|is_pnext
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_logging
operator|!=
literal|0
operator|&&
name|why
operator|!=
literal|0
condition|)
name|ipf_state_log
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|==
name|IPPROTO_TCP
condition|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_fin
operator|++
expr_stmt|;
else|else
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_expire
operator|++
expr_stmt|;
if|if
condition|(
name|orphan
condition|)
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_orphan
operator|--
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|fr
operator|->
name|fr_statecnt
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_derefrule
argument_list|(
name|softc
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
block|}
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active_proto
index|[
name|is
operator|->
name|is_p
index|]
operator|--
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_expire                                            */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Slowly expire held state for thingslike UDP and ICMP.  The algorithm     */
end_comment

begin_comment
comment|/* used here is to keep the queue sorted with the oldest things at the top  */
end_comment

begin_comment
comment|/* and the youngest at the bottom.  So if the top one doesn't need to be    */
end_comment

begin_comment
comment|/* expired then neither will any under it.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_expire
parameter_list|(
name|softc
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|,
modifier|*
name|tqn
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_tcptq
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tqe
operator|->
name|tqe_die
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_usertq
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tqe
operator|->
name|tqe_die
operator|>
name|softc
operator|->
name|ipf_ticks
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_usertq
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_DELETE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifq
operator|->
name|ifq_ref
operator|==
literal|0
operator|)
condition|)
block|{
name|ipf_freetimeoutqueue
argument_list|(
name|softc
argument_list|,
name|ifq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|softs
operator|->
name|ipf_state_doflush
condition|)
block|{
operator|(
name|void
operator|)
name|ipf_state_flush
argument_list|(
name|softc
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_doflush
operator|=
literal|0
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_last
operator|=
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_flush                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              which(I) - which flush action to perform                    */
end_comment

begin_comment
comment|/*              proto(I) - which protocol to flush (0 == ALL)               */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Flush state tables.  Three actions currently defined:                    */
end_comment

begin_comment
comment|/* which == 0 : flush all state table entries                               */
end_comment

begin_comment
comment|/* which == 1 : flush TCP connections which have started to close but are   */
end_comment

begin_comment
comment|/*	      stuck for some reason.                                        */
end_comment

begin_comment
comment|/* which == 2 : flush TCP connections which have been idle for a long time, */
end_comment

begin_comment
comment|/*	      starting at> 4 days idle and working back in successive half-*/
end_comment

begin_comment
comment|/*	      days to at most 12 hours old.  If this fails to free enough   */
end_comment

begin_comment
comment|/*            slots then work backwards in half hour slots to 30 minutes.   */
end_comment

begin_comment
comment|/*            If that too fails, then work backwards in 30 second intervals */
end_comment

begin_comment
comment|/*            for the last 30 minutes to at worst 30 seconds idle.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_flush
parameter_list|(
name|softc
parameter_list|,
name|which
parameter_list|,
name|proto
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|which
decl_stmt|,
name|proto
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|,
modifier|*
name|tqn
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|int
name|removed
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|0
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_flush_all
argument_list|)
expr_stmt|;
comment|/* 		 * Style 0 flush removes everything... 		 */
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_list
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|proto
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_v
operator|!=
name|proto
operator|)
condition|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
else|else
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_flush_closing
argument_list|)
expr_stmt|;
comment|/* 		 * Since we're only interested in things that are closing, 		 * we can start with the appropriate timeout queue. 		 */
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_tcptq
operator|+
name|IPF_TCPS_CLOSE_WAIT
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|!=
name|IPPROTO_TCP
condition|)
break|break;
if|if
condition|(
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Also need to look through the user defined queues. 		 */
for|for
control|(
name|ifq
operator|=
name|softs
operator|->
name|ipf_state_usertq
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|!=
name|IPPROTO_TCP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|is
operator|->
name|is_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
if|if
condition|(
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|2
case|:
break|break;
comment|/* 		 * Args 5-11 correspond to flushing those particular states 		 * for TCP connections. 		 */
case|case
name|IPF_TCPS_CLOSE_WAIT
case|:
case|case
name|IPF_TCPS_FIN_WAIT_1
case|:
case|case
name|IPF_TCPS_CLOSING
case|:
case|case
name|IPF_TCPS_LAST_ACK
case|:
case|case
name|IPF_TCPS_FIN_WAIT_2
case|:
case|case
name|IPF_TCPS_TIME_WAIT
case|:
case|case
name|IPF_TCPS_CLOSED
case|:
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_flush_queue
argument_list|)
expr_stmt|;
name|tqn
operator|=
name|softs
operator|->
name|ipf_state_tcptq
index|[
name|which
index|]
operator|.
name|ifq_head
expr_stmt|;
while|while
condition|(
name|tqn
operator|!=
name|NULL
condition|)
block|{
name|tqe
operator|=
name|tqn
expr_stmt|;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
break|break;
default|default :
if|if
condition|(
name|which
operator|<
literal|30
condition|)
break|break;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_flush_state
argument_list|)
expr_stmt|;
comment|/* 		 * Take a large arbitrary number to mean the number of seconds 		 * for which which consider to be the maximum value we'll allow 		 * the expiration to be. 		 */
name|which
operator|=
name|IPF_TTLVAL
argument_list|(
name|which
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_list
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|proto
operator|==
literal|0
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|==
name|proto
operator|)
condition|)
block|{
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|-
name|is
operator|->
name|is_touched
operator|>
name|which
condition|)
block|{
if|if
condition|(
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|which
operator|!=
literal|2
condition|)
block|{
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|removed
return|;
block|}
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_flush_timeout
argument_list|)
expr_stmt|;
comment|/* 	 * Asked to remove inactive entries because the table is full, try 	 * again, 3 times, if first attempt failed with a different criteria 	 * each time.  The order tried in must be in decreasing age. 	 * Another alternative is to implement random drop and drop N entries 	 * at random until N have been freed up. 	 */
if|if
condition|(
name|softc
operator|->
name|ipf_ticks
operator|-
name|softs
operator|->
name|ipf_state_wm_last
operator|>
name|softs
operator|->
name|ipf_state_wm_freq
condition|)
block|{
name|removed
operator|=
name|ipf_queueflush
argument_list|(
name|softc
argument_list|,
name|ipf_state_flush_entry
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|,
name|softs
operator|->
name|ipf_state_usertq
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_active
argument_list|,
name|softs
operator|->
name|ipf_state_size
argument_list|,
name|softs
operator|->
name|ipf_state_wm_low
argument_list|)
expr_stmt|;
name|softs
operator|->
name|ipf_state_wm_last
operator|=
name|softc
operator|->
name|ipf_ticks
expr_stmt|;
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|removed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_flush_entry                                       */
end_comment

begin_comment
comment|/* Returns:     int - 0 = entry deleted, else not deleted                   */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              entry(I)  - pointer to state structure to delete            */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is a stepping stone between ipf_queueflush() and           */
end_comment

begin_comment
comment|/* ipf_state_del().  It is used so we can provide a uniform interface via   */
end_comment

begin_comment
comment|/* the ipf_queueflush() function.                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_flush_entry
parameter_list|(
name|softc
parameter_list|,
name|entry
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|entry
argument_list|,
name|ISL_FLUSH
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_tcp_age                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 1 == state transition made, 0 == no change (rejected) */
end_comment

begin_comment
comment|/* Parameters:  tqe(I)   - pointer to timeout queue information             */
end_comment

begin_comment
comment|/*              fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              tqtab(I) - TCP timeout queue table this is in               */
end_comment

begin_comment
comment|/*              flags(I) - flags from state/NAT entry                       */
end_comment

begin_comment
comment|/*              ok(I)    - can we advance state                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Rewritten by Arjan de Vet<Arjan.deVet@adv.iae.nl>, 2000-07-29:          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - (try to) base state transitions on real evidence only,                 */
end_comment

begin_comment
comment|/*   i.e. packets that are sent and have been received by ipfilter;         */
end_comment

begin_comment
comment|/*   diagram 18.12 of TCP/IP volume 1 by W. Richard Stevens was used.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - deal with half-closed connections correctly;                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - store the state of the source in state[0] such that ipfstat            */
end_comment

begin_comment
comment|/*   displays the state as source/dest instead of dest/source; the calls    */
end_comment

begin_comment
comment|/*   to ipf_tcp_age have been changed accordingly.                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Internal Parameters:                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    state[0] = state of source (host that initiated connection)           */
end_comment

begin_comment
comment|/*    state[1] = state of dest   (host that accepted the connection)        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    dir == 0 : a packet from source to dest                               */
end_comment

begin_comment
comment|/*    dir == 1 : a packet from dest to source                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A typical procession for a connection is as follows:                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/* | Side '0'     | Side '1'          |                                     */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/* | 0 -> 1 (SYN) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 0 -> 2 (SYN-ACK)  |                                     */
end_comment

begin_comment
comment|/* | 1 -> 3 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 2 -> 4 (ACK-PUSH) |                                     */
end_comment

begin_comment
comment|/* | 3 -> 4 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |   ...        |   ...             |                                     */
end_comment

begin_comment
comment|/* |              | 4 -> 6 (FIN-ACK)  |                                     */
end_comment

begin_comment
comment|/* | 4 -> 5 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 6 -> 6 (ACK-PUSH) |                                     */
end_comment

begin_comment
comment|/* | 5 -> 5 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* | 5 -> 8 (FIN) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 6 -> 10 (ACK)     |                                     */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking: it is assumed that the parent of the tqe structure is locked.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_tcp_age
parameter_list|(
name|tqe
parameter_list|,
name|fin
parameter_list|,
name|tqtab
parameter_list|,
name|flags
parameter_list|,
name|ok
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipftq_t
modifier|*
name|tqtab
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|ok
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|int
name|dlen
decl_stmt|,
name|ostate
decl_stmt|,
name|nstate
decl_stmt|,
name|rval
decl_stmt|,
name|dir
decl_stmt|;
name|u_char
name|tcpflags
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
name|tcpflags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|dlen
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|ostate
operator|=
name|tqe
operator|->
name|tqe_state
index|[
literal|1
operator|-
name|dir
index|]
expr_stmt|;
name|nstate
operator|=
name|tqe
operator|->
name|tqe_state
index|[
name|dir
index|]
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_RST
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_PUSH
operator|)
operator|&&
operator|!
name|dlen
condition|)
name|nstate
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
else|else
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
if|if
condition|(
name|ostate
operator|<=
name|IPF_TCPS_ESTABLISHED
condition|)
block|{
name|tqe
operator|->
name|tqe_state
index|[
literal|1
operator|-
name|dir
index|]
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
block|}
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
comment|/* 0 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * 'dir' received an S and sends SA in 				 * response, LISTEN -> SYN_RECEIVED 				 */
name|nstate
operator|=
name|IPF_TCPS_SYN_RECEIVED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
block|{
comment|/* 'dir' sent S, LISTEN -> SYN_SENT */
name|nstate
operator|=
name|IPF_TCPS_SYN_SENT
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * the next piece of code makes it possible to get 			 * already established connections into the state table 			 * after a restart or reload of the filter rules; this 			 * does not work when a strict 'flags S keep state' is 			 * used for tcp connections of course 			 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tcpflags
operator|&
name|TH_ACKMASK
operator|)
operator|==
name|TH_ACK
operator|)
condition|)
block|{
comment|/* 				 * we saw an A, guess 'dir' is in ESTABLISHED 				 * mode 				 */
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
name|nstate
operator|=
name|IPF_TCPS_HALF_ESTAB
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
case|case
name|IPF_TCPS_ESTABLISHED
case|:
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
comment|/* 			 * TODO: besides regular ACK packets we can have other 			 * packets as well; it is yet to be determined how we 			 * should initialize the states in those cases 			 */
break|break;
case|case
name|IPF_TCPS_SYN_SENT
case|:
comment|/* 1 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|~
operator|(
name|TH_ECN
operator||
name|TH_CWR
operator|)
operator|)
operator|==
name|TH_SYN
condition|)
block|{
comment|/* 				 * A retransmitted SYN packet.  We do not reset 				 * the timeout here to ipf_tcptimeout because a 				 * connection connect timeout does not renew 				 * after every packet that is sent.  We need to 				 * set rval so as to indicate the packet has 				 * passed the check for its flags being valid 				 * in the TCP FSM.  Setting rval to 2 has the 				 * result of not resetting the timeout. 				 */
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * we see an A from 'dir' which is in SYN_SENT 				 * state: 'dir' sent an A in response to an SA 				 * which it received, SYN_SENT -> ESTABLISHED 				 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * we see an F from 'dir' which is in SYN_SENT 				 * state and wants to close its side of the 				 * connection; SYN_SENT -> FIN_WAIT_1 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * we see an SA from 'dir' which is already in 				 * SYN_SENT state, this means we have a 				 * simultaneous open; SYN_SENT -> SYN_RECEIVED 				 */
name|nstate
operator|=
name|IPF_TCPS_SYN_RECEIVED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
comment|/* 2 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * we see an A from 'dir' which was in 				 * SYN_RECEIVED state so it must now be in 				 * established state, SYN_RECEIVED -> 				 * ESTABLISHED 				 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|~
operator|(
name|TH_ECN
operator||
name|TH_CWR
operator|)
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * We see an SA from 'dir' which is already in 				 * SYN_RECEIVED state. 				 */
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * we see an F from 'dir' which is in 				 * SYN_RECEIVED state and wants to close its 				 * side of the connection; SYN_RECEIVED -> 				 * FIN_WAIT_1 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
comment|/* 3 */
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_ACKMASK
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * If we've picked up a connection in mid 				 * flight, we could be looking at a follow on 				 * packet from the same direction as the one 				 * that created this state.  Recognise it but 				 * do not advance the entire connection's 				 * state. 				 */
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
case|case
name|IPF_TCPS_SYN_SENT
case|:
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
case|case
name|IPF_TCPS_ESTABLISHED
case|:
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
break|break;
case|case
name|IPF_TCPS_ESTABLISHED
case|:
comment|/* 4 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * 'dir' closed its side of the connection; 				 * this gives us a half-closed connection; 				 * ESTABLISHED -> FIN_WAIT_1 				 */
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_FIN_WAIT_1
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_CLOSING
expr_stmt|;
block|}
else|else
block|{
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_ACK
condition|)
block|{
comment|/* 				 * an ACK, should we exclude other flags here? 				 */
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_FIN_WAIT_1
condition|)
block|{
comment|/* 					 * We know the other side did an active 					 * close, so we are ACKing the recvd 					 * FIN packet (does the window matching 					 * code guarantee this?) and go into 					 * CLOSE_WAIT state; this gives us a 					 * half-closed connection 					 */
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ostate
operator|<
name|IPF_TCPS_CLOSE_WAIT
condition|)
block|{
comment|/* 					 * still a fully established 					 * connection reset timeout 					 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IPF_TCPS_CLOSE_WAIT
case|:
comment|/* 5 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * application closed and 'dir' sent a FIN, 				 * we're now going into LAST_ACK state 				 */
name|nstate
operator|=
name|IPF_TCPS_LAST_ACK
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we remain in CLOSE_WAIT because the other 				 * side has closed already and we did not 				 * close our side yet; reset timeout 				 */
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_FIN_WAIT_1
case|:
comment|/* 6 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_ACK
operator|)
operator|&&
name|ostate
operator|>
name|IPF_TCPS_CLOSE_WAIT
condition|)
block|{
comment|/* 				 * if the other side is not active anymore 				 * it has sent us a FIN packet that we are 				 * ack'ing now with an ACK; this means both 				 * sides have now closed the connection and 				 * we go into TIME_WAIT 				 */
comment|/* 				 * XXX: how do we know we really are ACKing 				 * the FIN packet here? does the window code 				 * guarantee that? 				 */
name|nstate
operator|=
name|IPF_TCPS_LAST_ACK
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we closed our side of the connection 				 * already but the other side is still active 				 * (ESTABLISHED/CLOSE_WAIT); continue with 				 * this half-closed connection 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_CLOSING
case|:
comment|/* 7 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_TIME_WAIT
expr_stmt|;
block|}
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_LAST_ACK
case|:
comment|/* 8 */
if|if
condition|(
name|tcpflags
operator|&
name|TH_ACK
condition|)
block|{
name|rval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * we cannot detect when we go out of LAST_ACK state 			 * to CLOSED because that is based on the reception 			 * of ACK packets; ipfilter can only detect that a 			 * packet has been sent by a host 			 */
break|break;
case|case
name|IPF_TCPS_FIN_WAIT_2
case|:
comment|/* 9 */
comment|/* NOT USED */
break|break;
case|case
name|IPF_TCPS_TIME_WAIT
case|:
comment|/* 10 */
comment|/* we're in 2MSL timeout now */
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_LAST_ACK
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_CLOSED
case|:
comment|/* 11 */
name|rval
operator|=
literal|2
expr_stmt|;
break|break;
default|default :
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 	 * If rval == 2 then do not update the queue position, but treat the 	 * packet as being ok. 	 */
if|if
condition|(
name|rval
operator|==
literal|2
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ok
condition|)
name|tqe
operator|->
name|tqe_state
index|[
name|dir
index|]
operator|=
name|nstate
expr_stmt|;
if|if
condition|(
operator|(
name|tqe
operator|->
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|==
literal|0
condition|)
name|ipf_movequeue
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
name|tqe
argument_list|,
name|tqe
operator|->
name|tqe_ifq
argument_list|,
name|tqtab
operator|+
name|nstate
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_log                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              is(I)    - pointer to state structure                       */
end_comment

begin_comment
comment|/*              type(I)  - type of log entry to create                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Creates a state table log entry using the state structure and type info. */
end_comment

begin_comment
comment|/* passed in.  Log packet/byte counts, source/destination address and other */
end_comment

begin_comment
comment|/* protocol specific information.                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_log
parameter_list|(
name|softc
parameter_list|,
name|is
parameter_list|,
name|type
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|struct
name|ipstate
modifier|*
name|is
decl_stmt|;
name|u_int
name|type
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|struct
name|ipslog
name|ipsl
decl_stmt|;
name|size_t
name|sizes
index|[
literal|1
index|]
decl_stmt|;
name|void
modifier|*
name|items
index|[
literal|1
index|]
decl_stmt|;
name|int
name|types
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * Copy information out of the ipstate_t structure and into the 	 * structure used for logging. 	 */
name|ipsl
operator|.
name|isl_type
operator|=
name|type
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|0
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|1
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|1
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|1
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|2
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|2
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|2
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|2
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|2
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|3
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|3
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|3
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|3
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|3
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_src
operator|=
name|is
operator|->
name|is_src
expr_stmt|;
name|ipsl
operator|.
name|isl_dst
operator|=
name|is
operator|->
name|is_dst
expr_stmt|;
name|ipsl
operator|.
name|isl_p
operator|=
name|is
operator|->
name|is_p
expr_stmt|;
name|ipsl
operator|.
name|isl_v
operator|=
name|is
operator|->
name|is_v
expr_stmt|;
name|ipsl
operator|.
name|isl_flags
operator|=
name|is
operator|->
name|is_flags
expr_stmt|;
name|ipsl
operator|.
name|isl_tag
operator|=
name|is
operator|->
name|is_tag
expr_stmt|;
name|ipsl
operator|.
name|isl_rulen
operator|=
name|is
operator|->
name|is_rulen
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipsl
operator|.
name|isl_group
argument_list|,
name|is
operator|->
name|is_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_TCP
operator|||
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|ipsl
operator|.
name|isl_sport
operator|=
name|is
operator|->
name|is_sport
expr_stmt|;
name|ipsl
operator|.
name|isl_dport
operator|=
name|is
operator|->
name|is_dport
expr_stmt|;
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|ipsl
operator|.
name|isl_state
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_state
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_state
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_state
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|ipsl
operator|.
name|isl_itype
operator|=
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|ipsl
operator|.
name|isl_itype
operator|=
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
expr_stmt|;
block|}
else|else
block|{
name|ipsl
operator|.
name|isl_ps
operator|.
name|isl_filler
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ipsl
operator|.
name|isl_ps
operator|.
name|isl_filler
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|items
index|[
literal|0
index|]
operator|=
operator|&
name|ipsl
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ipsl
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_log_items
argument_list|(
name|softc
argument_list|,
name|IPL_LOGSTATE
argument_list|,
name|NULL
argument_list|,
name|items
argument_list|,
name|sizes
argument_list|,
name|types
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_checkicmp6matchingstate                                 */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == no match found,                        */
end_comment

begin_comment
comment|/*                           else  pointer to matching state entry          */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/* Locks:       NULL == no locks, else Read Lock on ipf_state               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we've got an ICMPv6 error message, using the information stored in    */
end_comment

begin_comment
comment|/* the ICMPv6 packet, look for a matching state table entry.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|ipf_checkicmp6matchingstate
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipf_main_softc_t
modifier|*
name|softc
init|=
name|fin
operator|->
name|fin_main_soft
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|ic6
decl_stmt|,
modifier|*
name|oic
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_short
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|i6addr_t
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|u_short
name|savelen
decl_stmt|;
name|icmpinfo_t
modifier|*
name|ic
decl_stmt|;
name|fr_info_t
name|ofin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ip6_t
modifier|*
name|oip6
decl_stmt|;
name|u_char
name|pr
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* 	 * Does it at least have the return (basic) IP header ? 	 * Is it an actual recognised ICMP error type? 	 * Only a basic IP header (no options) should be with 	 * an ICMP error header. 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_v
operator|!=
literal|6
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMP6ERR_MINPKTLEN
operator|)
operator|||
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_bad
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ic6
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|type
operator|=
name|ic6
operator|->
name|icmp6_type
expr_stmt|;
name|oip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ic6
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|oip6
argument_list|)
condition|)
block|{
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_short
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ofin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_v
operator|=
literal|6
expr_stmt|;
name|ofin
operator|.
name|fin_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|ofin
operator|.
name|fin_out
operator|=
operator|!
name|fin
operator|->
name|fin_out
expr_stmt|;
name|ofin
operator|.
name|fin_m
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
name|ofin
operator|.
name|fin_mp
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
comment|/* 	 * We make a fin entry to be able to feed it to 	 * matchsrcdst. Note that not all fields are necessary 	 * but this is the cleanest way. Note further we fill 	 * in fin_mp such that if someone uses it we'll get 	 * a kernel panic. ipf_matchsrcdst does not use this. 	 * 	 * watch out here, as ip is in host order and oip6 in network 	 * order. Any change we make must be undone afterwards. 	 */
name|savelen
operator|=
name|oip6
operator|->
name|ip6_plen
expr_stmt|;
name|oip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_dlen
operator|-
name|ICMPERR_ICMPHLEN
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|=
name|FI_NOCKSUM
expr_stmt|;
name|ofin
operator|.
name|fin_ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|oip6
expr_stmt|;
operator|(
name|void
operator|)
name|ipf_makefrip
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|oip6
argument_list|)
argument_list|,
operator|(
name|ip_t
operator|*
operator|)
name|oip6
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|&=
operator|~
operator|(
name|FI_BAD
operator||
name|FI_SHORT
operator|)
expr_stmt|;
name|oip6
operator|->
name|ip6_plen
operator|=
name|savelen
expr_stmt|;
name|pr
operator|=
name|ofin
operator|.
name|fin_p
expr_stmt|;
comment|/* 	 * an ICMP error can never generate an ICMP error in response. 	 */
if|if
condition|(
name|ofin
operator|.
name|fin_flx
operator|&
name|FI_ICMPERR
condition|)
block|{
name|DT1
argument_list|(
name|iss_icmp6_icmperr
argument_list|,
name|fr_info_t
operator|*
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_icmp6_icmperr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|oip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|oic
operator|=
name|ofin
operator|.
name|fin_dp
expr_stmt|;
comment|/* 		 * an ICMP error can only be generated as a result of an 		 * ICMP query, not as the response on an ICMP error 		 * 		 * XXX theoretically ICMP_ECHOREP and the other reply's are 		 * ICMP query's as well, but adding them here seems strange XXX 		 */
if|if
condition|(
operator|!
operator|(
name|oic
operator|->
name|icmp6_type
operator|&
name|ICMP6_INFOMSG_MASK
operator|)
condition|)
block|{
name|DT1
argument_list|(
name|iss_icmp6_notinfo
argument_list|,
name|fr_info_t
operator|*
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|SBUMP
argument_list|(
name|ipf_state_stats
operator|.
name|iss_icmp6_notinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * perform a lookup of the ICMP packet in the state table 		 */
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip6
operator|->
name|ip6_nxt
operator|)
expr_stmt|;
name|src
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_id
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_seq
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|ic
operator|=
operator|&
name|is
operator|->
name|is_icmp
expr_stmt|;
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|pr
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_id
operator|==
name|ic
operator|->
name|ici_id
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_seq
operator|==
name|ic
operator|->
name|ici_seq
operator|)
operator|&&
operator|(
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_ICMPCMP
argument_list|)
operator|)
condition|)
block|{
comment|/* 			    	 * in the state table ICMP query's are stored 			    	 * with the type of the corresponding ICMP 			    	 * response. Correct here 			    	 */
if|if
condition|(
operator|(
operator|(
name|ic
operator|->
name|ici_type
operator|==
name|ICMP6_ECHO_REPLY
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_type
operator|==
name|ICMP6_ECHO_REQUEST
operator|)
operator|)
operator|||
operator|(
name|ic
operator|->
name|ici_type
operator|-
literal|1
operator|==
name|oic
operator|->
name|icmp6_type
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ipf_allowstateicmp
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|)
condition|)
return|return
name|is
return|;
block|}
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp6_miss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip6
operator|->
name|ip6_nxt
operator|)
expr_stmt|;
name|src
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|dst
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|tcp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|oip6
operator|->
name|ip6_nxt
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
name|tcp
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
name|oip6
operator|+
literal|1
operator|)
expr_stmt|;
name|dport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|sport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
name|oic
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
operator|(
name|oip6
operator|+
literal|1
operator|)
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_id
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_seq
expr_stmt|;
break|break;
default|default :
break|break;
block|}
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
comment|/* 		 * Only allow this icmp though if the 		 * encapsulated packet was allowed through the 		 * other way around. Note that the minimal amount 		 * of info present does not allow for checking against 		 * tcp internals such as seq and ack numbers. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
literal|6
operator|)
operator|||
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
operator|)
condition|)
continue|continue;
name|is
operator|=
name|ipf_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_ICMPCMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ipf_allowstateicmp
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|is
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|SBUMPD
argument_list|(
name|ipf_state_stats
argument_list|,
name|iss_icmp_miss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_sttab_init                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              tqp(I)   - pointer to an array of timeout queues for TCP    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise the array of timeout queues for TCP.                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_sttab_init
parameter_list|(
name|softc
parameter_list|,
name|tqp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftq_t
modifier|*
name|tqp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPF_TCP_NSTATES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|IPFTQ_INIT
argument_list|(
operator|&
name|tqp
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|"ipftq tcp tab"
argument_list|)
expr_stmt|;
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_next
operator|=
name|tqp
operator|+
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|tqp
index|[
name|IPF_TCP_NSTATES
operator|-
literal|1
index|]
operator|.
name|ifq_next
operator|=
name|NULL
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSED
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcpclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_LISTEN
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_SYN_SENT
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcpsynsent
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_SYN_RECEIVED
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcpsynrecv
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_ESTABLISHED
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcpidletimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSE_WAIT
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcphalfclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_FIN_WAIT_1
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcphalfclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSING
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_LAST_ACK
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcplastack
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_FIN_WAIT_2
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcpclosewait
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_TIME_WAIT
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcptimewait
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_HALF_ESTAB
index|]
operator|.
name|ifq_ttl
operator|=
name|softc
operator|->
name|ipf_tcptimeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_sttab_destroy                                           */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqp(I) - pointer to an array of timeout queues for TCP      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Do whatever is necessary to "destroy" each of the entries in the array   */
end_comment

begin_comment
comment|/* of timeout queues for TCP.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_sttab_destroy
parameter_list|(
name|tqp
parameter_list|)
name|ipftq_t
modifier|*
name|tqp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPF_TCP_NSTATES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|MUTEX_DESTROY
argument_list|(
operator|&
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_deref                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              isp(I) - pointer to pointer to state table entry            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Decrement the reference counter for this state table entry and free it   */
end_comment

begin_comment
comment|/* if there are no more things using it.                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is only called when cleaning up after increasing is_ref by */
end_comment

begin_comment
comment|/* one earlier in the 'code path' so if is_ref is 1 when entering, we do    */
end_comment

begin_comment
comment|/* have an orphan, otherwise not.  However there is a possible race between */
end_comment

begin_comment
comment|/* the entry being deleted via flushing with an ioctl call (that calls the  */
end_comment

begin_comment
comment|/* delete function directly) and the tail end of packet processing so we    */
end_comment

begin_comment
comment|/* need to grab is_lock before doing the check to synchronise the two code  */
end_comment

begin_comment
comment|/* paths.                                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When operating in userland (ipftest), we have no timers to clear a state */
end_comment

begin_comment
comment|/* entry.  Therefore, we make a few simple tests before deleting an entry   */
end_comment

begin_comment
comment|/* outright.  We compare states on each side looking for a combination of   */
end_comment

begin_comment
comment|/* TIME_WAIT (should really be FIN_WAIT_2?) and LAST_ACK.  Then we factor   */
end_comment

begin_comment
comment|/* in packet direction with the interface list to make sure we don't        */
end_comment

begin_comment
comment|/* prematurely delete an entry on a final inbound packet that's we're also  */
end_comment

begin_comment
comment|/* supposed to route elsewhere.                                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Internal parameters:                                                     */
end_comment

begin_comment
comment|/*    state[0] = state of source (host that initiated connection)           */
end_comment

begin_comment
comment|/*    state[1] = state of dest   (host that accepted the connection)        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    dir == 0 : a packet from source to dest                               */
end_comment

begin_comment
comment|/*    dir == 1 : a packet from dest to source                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_deref
parameter_list|(
name|softc
parameter_list|,
name|isp
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipstate_t
modifier|*
modifier|*
name|isp
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
init|=
operator|*
name|isp
decl_stmt|;
name|is
operator|=
operator|*
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|NULL
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_ref
operator|>
literal|1
condition|)
block|{
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
if|if
condition|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|||
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|is
argument_list|,
name|ISL_ORPHAN
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_setqueue                                          */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to soft context main structure           */
end_comment

begin_comment
comment|/*              is(I)    - pointer to state structure                       */
end_comment

begin_comment
comment|/*              rev(I)   - forward(0) or reverse(1) direction               */
end_comment

begin_comment
comment|/* Locks:       ipf_state (read or write)                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Put the state entry on its default queue entry, using rev as a helped in */
end_comment

begin_comment
comment|/* determining which queue it should be placed on.                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_setqueue
parameter_list|(
name|softc
parameter_list|,
name|is
parameter_list|,
name|rev
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipftq_t
modifier|*
name|oifq
decl_stmt|,
modifier|*
name|nifq
decl_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
condition|)
name|nifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|rev
index|]
expr_stmt|;
else|else
name|nifq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nifq
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|is
operator|->
name|is_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmptq
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_icmptq
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|nifq
operator|=
name|softs
operator|->
name|ipf_state_tcptq
operator|+
name|is
operator|->
name|is_state
index|[
name|rev
index|]
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_udptq
expr_stmt|;
break|break;
default|default :
name|nifq
operator|=
operator|&
name|softs
operator|->
name|ipf_state_iptq
expr_stmt|;
break|break;
block|}
block|}
name|oifq
operator|=
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
expr_stmt|;
comment|/* 	 * If it's currently on a timeout queue, move it from one queue to 	 * another, else put it on the end of the newly determined queue. 	 */
if|if
condition|(
name|oifq
operator|!=
name|NULL
condition|)
name|ipf_movequeue
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|oifq
argument_list|,
name|nifq
argument_list|)
expr_stmt|;
else|else
name|ipf_queueappend
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|nifq
argument_list|,
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_iter                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else error                              */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              token(I) - pointer to ipftoken structure                    */
end_comment

begin_comment
comment|/*              itp(I)   - pointer to ipfgeniter structure                  */
end_comment

begin_comment
comment|/*              obj(I)   - pointer to data description structure            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles the SIOCGENITER ioctl for the state tables and     */
end_comment

begin_comment
comment|/* walks through the list of entries in the state table list (softs->ipf_state_list.)    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_iter
parameter_list|(
name|softc
parameter_list|,
name|token
parameter_list|,
name|itp
parameter_list|,
name|obj
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
modifier|*
name|itp
decl_stmt|;
name|ipfobj_t
modifier|*
name|obj
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|next
decl_stmt|,
name|zero
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|itp
operator|->
name|igi_data
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100026
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
name|itp
operator|->
name|igi_nitems
operator|<
literal|1
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100027
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
if|if
condition|(
name|itp
operator|->
name|igi_type
operator|!=
name|IPFGENITER_STATE
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100028
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|is
operator|=
name|token
operator|->
name|ipt_data
expr_stmt|;
if|if
condition|(
name|is
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100029
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|ipfo_type
operator|=
name|IPFOBJ_IPSTATE
expr_stmt|;
name|obj
operator|->
name|ipfo_size
operator|=
sizeof|sizeof
argument_list|(
name|ipstate_t
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|is
operator|=
name|token
operator|->
name|ipt_data
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|softs
operator|->
name|ipf_state_list
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|is
operator|->
name|is_next
expr_stmt|;
block|}
comment|/* 	 * If we find a state entry to use, bump its reference count so that 	 * it can be used for is_next when we come back. 	 */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|next
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|next
operator|->
name|is_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|next
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|token
operator|->
name|ipt_data
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|zero
expr_stmt|;
name|token
operator|->
name|ipt_data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|->
name|is_next
operator|==
name|NULL
condition|)
name|ipf_token_mark_complete
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
name|obj
operator|->
name|ipfo_ptr
operator|=
name|itp
operator|->
name|igi_data
expr_stmt|;
name|error
operator|=
name|ipf_outobjk
argument_list|(
name|softc
argument_list|,
name|obj
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
name|ipf_state_deref
argument_list|(
name|softc
argument_list|,
operator|&
name|is
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_gettable                                          */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else error                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              softs(I) - pointer to state context structure               */
end_comment

begin_comment
comment|/*              data(I)  - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles ioctl requests for tables of state information.    */
end_comment

begin_comment
comment|/* At present the only table it deals with is the hash bucket statistics.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_gettable
parameter_list|(
name|softc
parameter_list|,
name|softs
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipf_state_softc_t
modifier|*
name|softs
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|ipftable_t
name|table
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ipf_inobj
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|,
operator|&
name|table
argument_list|,
name|IPFOBJ_GTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|table
operator|.
name|ita_type
operator|!=
name|IPFTABLE_BUCKETS
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100031
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|COPYOUT
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|table
operator|.
name|ita_table
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100032
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_setpending                                        */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              is(I)    - pointer to state structure                       */
end_comment

begin_comment
comment|/* Locks:       ipf_state (read or write)                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Put the state entry on to the pending queue - this queue has a very      */
end_comment

begin_comment
comment|/* short lifetime where items are put that can't be deleted straight away   */
end_comment

begin_comment
comment|/* because of locking issues but we want to delete them ASAP, anyway.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipf_state_setpending
parameter_list|(
name|softc
parameter_list|,
name|is
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipftq_t
modifier|*
name|oifq
decl_stmt|;
name|oifq
operator|=
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|oifq
operator|!=
name|NULL
condition|)
name|ipf_movequeue
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|oifq
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_pending
argument_list|)
expr_stmt|;
else|else
name|ipf_queueappend
argument_list|(
name|softc
operator|->
name|ipf_ticks
argument_list|,
operator|&
name|is
operator|->
name|is_sti
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_pending
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_me
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_matchflush                                        */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  softc(I) - pointer to main soft context                     */
end_comment

begin_comment
comment|/*              data(I)  - pointer to state structure                       */
end_comment

begin_comment
comment|/* Locks:       ipf_state (read or write)                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Flush all entries from the list of state entries that match the          */
end_comment

begin_comment
comment|/* properties in the array loaded.                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_matchflush
parameter_list|(
name|softc
parameter_list|,
name|data
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|int
modifier|*
name|array
decl_stmt|,
name|flushed
decl_stmt|,
name|error
decl_stmt|;
name|ipstate_t
modifier|*
name|state
decl_stmt|,
modifier|*
name|statenext
decl_stmt|;
name|ipfobj_t
name|obj
decl_stmt|;
name|error
operator|=
name|ipf_matcharray_load
argument_list|(
name|softc
argument_list|,
name|data
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|flushed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|state
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|state
operator|!=
name|NULL
condition|;
name|state
operator|=
name|statenext
control|)
block|{
name|statenext
operator|=
name|state
operator|->
name|is_next
expr_stmt|;
if|if
condition|(
name|ipf_state_matcharray
argument_list|(
name|state
argument_list|,
name|array
argument_list|,
name|softc
operator|->
name|ipf_ticks
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipf_state_del
argument_list|(
name|softc
argument_list|,
name|state
argument_list|,
name|ISL_FLUSH
argument_list|)
expr_stmt|;
name|flushed
operator|++
expr_stmt|;
block|}
block|}
name|obj
operator|.
name|ipfo_retval
operator|=
name|flushed
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|&
name|obj
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|KFREES
argument_list|(
name|array
argument_list|,
name|array
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_matcharray                                        */
end_comment

begin_comment
comment|/* Returns:     int   - 0 = no match, 1 = match                             */
end_comment

begin_comment
comment|/* Parameters:  state(I) - pointer to state structure                       */
end_comment

begin_comment
comment|/*              array(I) - pointer to ipf matching expression               */
end_comment

begin_comment
comment|/*              ticks(I) - current value of ipfilter tick timer             */
end_comment

begin_comment
comment|/* Locks:       ipf_state (read or write)                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compare a state entry with the match array passed in and return a value  */
end_comment

begin_comment
comment|/* to indicate whether or not the matching was successful.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|ipf_state_matcharray
parameter_list|(
name|state
parameter_list|,
name|array
parameter_list|,
name|ticks
parameter_list|)
name|ipstate_t
modifier|*
name|state
decl_stmt|;
name|int
modifier|*
name|array
decl_stmt|;
name|u_long
name|ticks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
modifier|*
name|x
decl_stmt|,
name|rv
decl_stmt|,
name|p
decl_stmt|;
name|ipfexp_t
modifier|*
name|e
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|array
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|x
operator|+=
literal|3
operator|+
name|x
index|[
literal|3
index|]
operator|,
name|rv
operator|=
literal|0
control|)
block|{
name|e
operator|=
operator|(
name|ipfexp_t
operator|*
operator|)
name|x
expr_stmt|;
name|n
operator|-=
name|e
operator|->
name|ipfe_size
expr_stmt|;
if|if
condition|(
name|x
index|[
literal|0
index|]
operator|==
name|IPF_EXP_END
condition|)
break|break;
comment|/* 		 * If we need to match the protocol and that doesn't match, 		 * don't even both with the instruction array. 		 */
name|p
operator|=
name|e
operator|->
name|ipfe_cmd
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|state
operator|->
name|is_p
operator|)
condition|)
break|break;
switch|switch
condition|(
name|e
operator|->
name|ipfe_cmd
condition|)
block|{
case|case
name|IPF_EXP_IP_PR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|state
operator|->
name|is_p
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_SRCADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|state
operator|->
name|is_saddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_DSTADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|state
operator|->
name|is_daddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP_ADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|4
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
operator|(
name|state
operator|->
name|is_saddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
operator|||
operator|(
operator|(
name|state
operator|->
name|is_daddr
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|)
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|2
index|]
operator|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPF_EXP_IP6_SRCADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|x
index|[
literal|3
index|]
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|state
operator|->
name|is_src
operator|.
name|in6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP6_DSTADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|x
index|[
literal|3
index|]
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|state
operator|->
name|is_dst
operator|.
name|in6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IP6_ADDR
case|:
if|if
condition|(
name|state
operator|->
name|is_v
operator|!=
literal|6
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|x
index|[
literal|3
index|]
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
name|IP6_MASKEQ
argument_list|(
operator|&
name|state
operator|->
name|is_src
operator|.
name|in6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
operator|||
name|IP6_MASKEQ
argument_list|(
operator|&
name|state
operator|->
name|is_dst
operator|.
name|in6
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
operator|+
literal|4
index|]
argument_list|,
operator|&
name|e
operator|->
name|ipfe_arg0
index|[
name|i
operator|*
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|IPF_EXP_UDP_PORT
case|:
case|case
name|IPF_EXP_TCP_PORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|state
operator|->
name|is_sport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|state
operator|->
name|is_dport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_UDP_SPORT
case|:
case|case
name|IPF_EXP_TCP_SPORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|state
operator|->
name|is_sport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_UDP_DPORT
case|:
case|case
name|IPF_EXP_TCP_DPORT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|state
operator|->
name|is_dport
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_TCP_STATE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|rv
operator|&&
name|i
operator|<
name|e
operator|->
name|ipfe_narg
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator||=
operator|(
name|state
operator|->
name|is_state
index|[
literal|0
index|]
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|state
operator|->
name|is_state
index|[
literal|1
index|]
operator|==
name|e
operator|->
name|ipfe_arg0
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|IPF_EXP_IDLE_GT
case|:
name|rv
operator||=
operator|(
name|ticks
operator|-
name|state
operator|->
name|is_touched
operator|>
name|e
operator|->
name|ipfe_arg0
index|[
literal|0
index|]
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Factor in doing a negative match. 		 */
name|rv
operator|^=
name|e
operator|->
name|ipfe_not
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_settimeout                                        */
end_comment

begin_comment
comment|/* Returns:     int 0 = success, else failure                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to main soft context                    */
end_comment

begin_comment
comment|/*              t(I)      - pointer to tuneable being changed               */
end_comment

begin_comment
comment|/*              p(I)      - pointer to the new value                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Sets a timeout value for one of the many timeout queues.  We find the    */
end_comment

begin_comment
comment|/* correct queue using a somewhat manual process of comparing the timeout   */
end_comment

begin_comment
comment|/* names for each specific value available and calling ipf_apply_timeout on */
end_comment

begin_comment
comment|/* that queue so that all of the items on it are updated accordingly.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_settimeout
parameter_list|(
name|softc
parameter_list|,
name|t
parameter_list|,
name|p
parameter_list|)
name|struct
name|ipf_main_softc_s
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|t
decl_stmt|;
name|ipftuneval_t
modifier|*
name|p
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
comment|/* 	 * In case there is nothing to do... 	 */
if|if
condition|(
operator|*
name|t
operator|->
name|ipft_pint
operator|==
name|p
operator|->
name|ipftu_int
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"tcp_"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|ipf_settimeout_tcp
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|softs
operator|->
name|ipf_state_tcptq
argument_list|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"udp_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udptq
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"udp_ack_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_udpacktq
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"icmp_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmptq
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"icmp_ack_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_icmpacktq
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|ipft_name
argument_list|,
literal|"ip_timeout"
argument_list|)
condition|)
block|{
name|ipf_apply_timeout
argument_list|(
operator|&
name|softs
operator|->
name|ipf_state_iptq
argument_list|,
name|p
operator|->
name|ipftu_int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IPFERROR
argument_list|(
literal|100034
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
comment|/* 	 * Update the tuneable being set. 	 */
operator|*
name|t
operator|->
name|ipft_pint
operator|=
name|p
operator|->
name|ipftu_int
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_rehash                                            */
end_comment

begin_comment
comment|/* Returns:     int 0 = success, else failure                               */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to main soft context                    */
end_comment

begin_comment
comment|/*              t(I)      - pointer to tuneable being changed               */
end_comment

begin_comment
comment|/*              p(I)      - pointer to the new value                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* To change the size of the state hash table at runtime, a new table has   */
end_comment

begin_comment
comment|/* to be allocated and then all of the existing entries put in it, bumping  */
end_comment

begin_comment
comment|/* up the bucketlength for it as we go along.                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|ipf_state_rehash
parameter_list|(
name|softc
parameter_list|,
name|t
parameter_list|,
name|p
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|ipftuneable_t
modifier|*
name|t
decl_stmt|;
name|ipftuneval_t
modifier|*
name|p
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
name|ipstate_t
modifier|*
modifier|*
name|newtab
decl_stmt|,
modifier|*
name|is
decl_stmt|;
name|u_int
modifier|*
name|bucketlens
decl_stmt|;
name|u_int
name|maxbucket
decl_stmt|;
name|u_int
name|newsize
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|newsize
operator|=
name|p
operator|->
name|ipftu_int
expr_stmt|;
comment|/* 	 * In case there is nothing to do... 	 */
if|if
condition|(
name|newsize
operator|==
name|softs
operator|->
name|ipf_state_size
condition|)
return|return
literal|0
return|;
name|KMALLOCS
argument_list|(
name|newtab
argument_list|,
name|ipstate_t
operator|*
operator|*
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtab
operator|==
name|NULL
condition|)
block|{
name|IPFERROR
argument_list|(
literal|100035
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|KMALLOCS
argument_list|(
name|bucketlens
argument_list|,
name|u_int
operator|*
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketlens
operator|==
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|newtab
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|softs
operator|->
name|ipf_state_table
argument_list|)
argument_list|)
expr_stmt|;
name|IPFERROR
argument_list|(
literal|100036
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
for|for
control|(
name|maxbucket
operator|=
literal|0
operator|,
name|i
operator|=
name|newsize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
name|maxbucket
operator|++
expr_stmt|;
name|maxbucket
operator|*=
literal|2
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newtab
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bucketlens
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_table
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|softs
operator|->
name|ipf_state_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|softs
operator|->
name|ipf_state_table
operator|=
name|newtab
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
argument_list|,
name|softs
operator|->
name|ipf_state_size
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
operator|=
name|bucketlens
expr_stmt|;
name|softs
operator|->
name|ipf_state_maxbucket
operator|=
name|maxbucket
expr_stmt|;
name|softs
operator|->
name|ipf_state_size
operator|=
name|newsize
expr_stmt|;
comment|/* 	 * Walk through the entire list of state table entries and put them 	 * in the new state table, somewhere.  Because we have a new table, 	 * we need to restart the counter of how many chains are in use. 	 */
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|is
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|is
operator|!=
name|NULL
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
block|{
name|is
operator|->
name|is_hnext
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|NULL
expr_stmt|;
name|hv
operator|=
name|is
operator|->
name|is_hv
operator|%
name|softs
operator|->
name|ipf_state_size
expr_stmt|;
if|if
condition|(
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|!=
name|NULL
condition|)
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|->
name|is_phnext
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
else|else
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_inuse
operator|++
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|softs
operator|->
name|ipf_state_table
operator|+
name|hv
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
expr_stmt|;
name|softs
operator|->
name|ipf_state_table
index|[
name|hv
index|]
operator|=
name|is
expr_stmt|;
name|softs
operator|->
name|ipf_state_stats
operator|.
name|iss_bucketlen
index|[
name|hv
index|]
operator|++
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|softc
operator|->
name|ipf_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_state_add_tq                                            */
end_comment

begin_comment
comment|/* Returns:     ipftq_t * - NULL = failure, else pointer to new timeout     */
end_comment

begin_comment
comment|/*                          queue                                           */
end_comment

begin_comment
comment|/* Parameters:  softc(I)  - pointer to main soft context                    */
end_comment

begin_comment
comment|/*              ttl(I)    - pointer to the ttl for the new queue            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Request a pointer to a timeout queue that has a ttl as given by the      */
end_comment

begin_comment
comment|/* value being passed in.  The timeout queue is added tot the list of those */
end_comment

begin_comment
comment|/* used internally for stateful filtering.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipftq_t
modifier|*
name|ipf_state_add_tq
parameter_list|(
name|softc
parameter_list|,
name|ttl
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|int
name|ttl
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|softc
operator|->
name|ipf_state_soft
decl_stmt|;
return|return
name|ipf_addtimeoutqueue
argument_list|(
name|softc
argument_list|,
operator|&
name|softs
operator|->
name|ipf_state_usertq
argument_list|,
name|ttl
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_comment
comment|/*  * Display the built up state table rules and mapping entries.  */
end_comment

begin_function
name|void
name|ipf_state_dump
parameter_list|(
name|softc
parameter_list|,
name|arg
parameter_list|)
name|ipf_main_softc_t
modifier|*
name|softc
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ipf_state_softc_t
modifier|*
name|softs
init|=
name|arg
decl_stmt|;
name|ipstate_t
modifier|*
name|ips
decl_stmt|;
name|printf
argument_list|(
literal|"List of active state sessions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ips
operator|=
name|softs
operator|->
name|ipf_state_list
init|;
name|ips
operator|!=
name|NULL
condition|;
control|)
name|ips
operator|=
name|printstate
argument_list|(
name|ips
argument_list|,
name|opts
operator|&
operator|(
name|OPT_DEBUG
operator||
name|OPT_VERBOSE
operator|)
argument_list|,
name|softc
operator|->
name|ipf_ticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

