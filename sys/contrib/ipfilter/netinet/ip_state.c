begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995-2003 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|(
name|NetBSD
operator|>=
literal|199905
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|__NetBSD_Version__
operator|<
literal|399001400
operator|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter_log.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"opt_ipfilter.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
expr|\
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|220000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_proxy.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_sync.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_scan.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ip_state.c	1.8 6/5/96 (C) 1993-2000 Darren Reed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$Id: ip_state.c,v 2.186.2.69 2007/05/26 13:05:14 darrenr Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
modifier|*
name|ips_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
modifier|*
name|ips_seed
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ips_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ips_last_force_flush
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ips_stat_t
name|ips_stats
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|fr_checkicmp6matchingstate
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|fr_matchsrcdst
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|,
name|i6addr_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|u_32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|fr_checkicmpmatchingstate
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_state_flush
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_state_flush_entry
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ips_stat_t
modifier|*
name|fr_statetstats
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_delstate
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_state_remove
name|__P
argument_list|(
operator|(
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr_ipsmove
name|__P
argument_list|(
operator|(
name|ipstate_t
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_tcpstate
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_tcpoptions
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|tcpdata_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipstate_t
modifier|*
name|fr_stclone
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|tcphdr_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr_fixinisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr_fixoutisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr_checknewisn
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|ipstate_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_stateiter
name|__P
argument_list|(
operator|(
name|ipftoken_t
operator|*
operator|,
name|ipfgeniter_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_stgettable
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_stputent
name|__P
argument_list|(
operator|(
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_stgetent
name|__P
argument_list|(
operator|(
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ONE_DAY
value|IPF_TTLVAL(1 * 86400)
end_define

begin_comment
comment|/* 1 day */
end_comment

begin_define
define|#
directive|define
name|FIVE_DAYS
value|(5 * ONE_DAY)
end_define

begin_define
define|#
directive|define
name|DOUBLE_HASH
parameter_list|(
name|x
parameter_list|)
value|(((x) + ips_seed[(x) % fr_statesize]) % fr_statesize)
end_define

begin_decl_stmt
name|u_long
name|fr_tcpidletimeout
init|=
name|FIVE_DAYS
decl_stmt|,
name|fr_tcpclosewait
init|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
decl_stmt|,
name|fr_tcplastack
init|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
decl_stmt|,
name|fr_tcptimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
decl_stmt|,
name|fr_tcptimewait
init|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
name|TCP_MSL
argument_list|)
decl_stmt|,
name|fr_tcpclosed
init|=
name|IPF_TTLVAL
argument_list|(
literal|30
argument_list|)
decl_stmt|,
name|fr_tcphalfclosed
init|=
name|IPF_TTLVAL
argument_list|(
literal|2
operator|*
literal|3600
argument_list|)
decl_stmt|,
comment|/* 2 hours */
name|fr_udptimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|120
argument_list|)
decl_stmt|,
name|fr_udpacktimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|12
argument_list|)
decl_stmt|,
name|fr_icmptimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|60
argument_list|)
decl_stmt|,
name|fr_icmpacktimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|6
argument_list|)
decl_stmt|,
name|fr_iptimeout
init|=
name|IPF_TTLVAL
argument_list|(
literal|60
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_statemax
init|=
name|IPSTATE_MAX
decl_stmt|,
name|fr_statesize
init|=
name|IPSTATE_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_state_doflush
init|=
literal|0
decl_stmt|,
name|fr_state_lock
init|=
literal|0
decl_stmt|,
name|fr_state_maxbucket
init|=
literal|0
decl_stmt|,
name|fr_state_maxbucket_reset
init|=
literal|1
decl_stmt|,
name|fr_state_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ipftq_t
name|ips_tqtqb
index|[
name|IPF_TCP_NSTATES
index|]
decl_stmt|,
name|ips_udptq
decl_stmt|,
name|ips_udpacktq
decl_stmt|,
name|ips_iptq
decl_stmt|,
name|ips_icmptq
decl_stmt|,
name|ips_icmpacktq
decl_stmt|,
name|ips_deletetq
decl_stmt|,
modifier|*
name|ips_utqe
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_decl_stmt
name|int
name|ipstate_logging
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|ipstate_logging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|ipstate_t
modifier|*
name|ips_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stateinit                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise all the global variables used within the state code.          */
end_comment

begin_comment
comment|/* This action also includes initiailising locks.                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_stateinit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|KMALLOCS
argument_list|(
name|ips_table
argument_list|,
name|ipstate_t
operator|*
operator|*
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ips_table
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ips_table
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|ipstate_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|KMALLOCS
argument_list|(
name|ips_seed
argument_list|,
name|u_long
operator|*
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ips_seed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ips_seed
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fr_statesize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX - ips_seed[X] should be a random number of sorts. 		 */
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
name|ips_seed
index|[
name|i
index|]
operator|=
name|arc4random
argument_list|()
expr_stmt|;
else|#
directive|else
name|ips_seed
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|u_long
operator|)
name|ips_seed
operator|+
name|i
operator|)
operator|*
name|fr_statesize
expr_stmt|;
name|ips_seed
index|[
name|i
index|]
operator|^=
literal|0xa5a55a5a
expr_stmt|;
name|ips_seed
index|[
name|i
index|]
operator|*=
operator|(
name|u_long
operator|)
name|ips_seed
expr_stmt|;
name|ips_seed
index|[
name|i
index|]
operator|^=
literal|0x5a5aa5a5
expr_stmt|;
name|ips_seed
index|[
name|i
index|]
operator|*=
name|fr_statemax
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* fill icmp reply type table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ICMP_MAXTYPE
condition|;
name|i
operator|++
control|)
name|icmpreplytype4
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_ECHO
index|]
operator|=
name|ICMP_ECHOREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_TSTAMP
index|]
operator|=
name|ICMP_TSTAMPREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_IREQ
index|]
operator|=
name|ICMP_IREQREPLY
expr_stmt|;
name|icmpreplytype4
index|[
name|ICMP_MASKREQ
index|]
operator|=
name|ICMP_MASKREPLY
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
comment|/* fill icmp reply type table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ICMP6_MAXTYPE
condition|;
name|i
operator|++
control|)
name|icmpreplytype6
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_ECHO_REQUEST
index|]
operator|=
name|ICMP6_ECHO_REPLY
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_MEMBERSHIP_QUERY
index|]
operator|=
name|ICMP6_MEMBERSHIP_REPORT
expr_stmt|;
name|icmpreplytype6
index|[
name|ICMP6_NI_QUERY
index|]
operator|=
name|ICMP6_NI_REPLY
expr_stmt|;
name|icmpreplytype6
index|[
name|ND_ROUTER_SOLICIT
index|]
operator|=
name|ND_ROUTER_ADVERT
expr_stmt|;
name|icmpreplytype6
index|[
name|ND_NEIGHBOR_SOLICIT
index|]
operator|=
name|ND_NEIGHBOR_ADVERT
expr_stmt|;
endif|#
directive|endif
name|KMALLOCS
argument_list|(
name|ips_stats
operator|.
name|iss_bucketlen
argument_list|,
name|u_long
operator|*
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ips_stats
operator|.
name|iss_bucketlen
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ips_stats
operator|.
name|iss_bucketlen
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_state_maxbucket
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|fr_statesize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
name|fr_state_maxbucket
operator|++
expr_stmt|;
name|fr_state_maxbucket
operator|*=
literal|2
expr_stmt|;
block|}
name|ips_stats
operator|.
name|iss_tcptab
operator|=
name|ips_tqtqb
expr_stmt|;
name|fr_sttab_init
argument_list|(
name|ips_tqtqb
argument_list|)
expr_stmt|;
name|ips_tqtqb
index|[
name|IPF_TCP_NSTATES
operator|-
literal|1
index|]
operator|.
name|ifq_next
operator|=
operator|&
name|ips_udptq
expr_stmt|;
name|ips_udptq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
name|fr_udptimeout
expr_stmt|;
name|ips_udptq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_udptq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_udptq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_udptq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_udptq
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq udp tab"
argument_list|)
expr_stmt|;
name|ips_udptq
operator|.
name|ifq_next
operator|=
operator|&
name|ips_udpacktq
expr_stmt|;
name|ips_udpacktq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
name|fr_udpacktimeout
expr_stmt|;
name|ips_udpacktq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_udpacktq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_udpacktq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_udpacktq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_udpacktq
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq udpack tab"
argument_list|)
expr_stmt|;
name|ips_udpacktq
operator|.
name|ifq_next
operator|=
operator|&
name|ips_icmptq
expr_stmt|;
name|ips_icmptq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
name|fr_icmptimeout
expr_stmt|;
name|ips_icmptq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_icmptq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_icmptq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_icmptq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_icmptq
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq icmp tab"
argument_list|)
expr_stmt|;
name|ips_icmptq
operator|.
name|ifq_next
operator|=
operator|&
name|ips_icmpacktq
expr_stmt|;
name|ips_icmpacktq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
name|fr_icmpacktimeout
expr_stmt|;
name|ips_icmpacktq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_icmpacktq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_icmpacktq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_icmpacktq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_icmpacktq
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq icmpack tab"
argument_list|)
expr_stmt|;
name|ips_icmpacktq
operator|.
name|ifq_next
operator|=
operator|&
name|ips_iptq
expr_stmt|;
name|ips_iptq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
name|fr_iptimeout
expr_stmt|;
name|ips_iptq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_iptq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_iptq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_iptq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_iptq
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq ip tab"
argument_list|)
expr_stmt|;
name|ips_iptq
operator|.
name|ifq_next
operator|=
operator|&
name|ips_deletetq
expr_stmt|;
name|ips_deletetq
operator|.
name|ifq_ttl
operator|=
operator|(
name|u_long
operator|)
literal|1
expr_stmt|;
name|ips_deletetq
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ips_deletetq
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ips_deletetq
operator|.
name|ifq_tail
operator|=
operator|&
name|ips_deletetq
operator|.
name|ifq_head
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ips_deletetq
operator|.
name|ifq_lock
argument_list|,
literal|"state delete queue"
argument_list|)
expr_stmt|;
name|ips_deletetq
operator|.
name|ifq_next
operator|=
name|NULL
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|ipf_state
argument_list|,
literal|"ipf IP state rwlock"
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ipf_stinsert
argument_list|,
literal|"ipf state insert mutex"
argument_list|)
expr_stmt|;
name|fr_state_init
operator|=
literal|1
expr_stmt|;
name|ips_last_force_flush
operator|=
name|fr_ticks
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stateunload                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Release and destroy any resources acquired or initialised so that        */
end_comment

begin_comment
comment|/* IPFilter can be unloaded or re-initialised.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_stateunload
parameter_list|()
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
while|while
condition|(
operator|(
name|is
operator|=
name|ips_list
operator|)
operator|!=
name|NULL
condition|)
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_UNLOAD
argument_list|)
expr_stmt|;
comment|/* 	 * Proxy timeout queues are not cleaned here because although they 	 * exist on the state list, appr_unload is called after fr_stateunload 	 * and the proxies actually are responsible for them being created. 	 * Should the proxy timeouts have their own list?  There's no real 	 * justification as this is the only complicationA 	 */
for|for
control|(
name|ifq
operator|=
name|ips_utqe
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_PROXY
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fr_deletetimeoutqueue
argument_list|(
name|ifq
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|fr_freetimeoutqueue
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
block|}
name|ips_stats
operator|.
name|iss_inuse
operator|=
literal|0
expr_stmt|;
name|ips_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fr_state_init
operator|==
literal|1
condition|)
block|{
name|fr_sttab_destroy
argument_list|(
name|ips_tqtqb
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_udptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_icmptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_udpacktq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_icmpacktq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_iptq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ips_deletetq
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ips_table
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|ips_table
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ips_table
argument_list|)
argument_list|)
expr_stmt|;
name|ips_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ips_seed
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|ips_seed
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ips_seed
argument_list|)
argument_list|)
expr_stmt|;
name|ips_seed
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ips_stats
operator|.
name|iss_bucketlen
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|ips_stats
operator|.
name|iss_bucketlen
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|ips_stats
operator|.
name|iss_bucketlen
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fr_state_maxbucket_reset
operator|==
literal|1
condition|)
name|fr_state_maxbucket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fr_state_init
operator|==
literal|1
condition|)
block|{
name|fr_state_init
operator|=
literal|0
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ipf_stinsert
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_statetstats                                              */
end_comment

begin_comment
comment|/* Returns:     ips_state_t* - pointer to state stats structure             */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Put all the current numbers and pointers into a single struct and return */
end_comment

begin_comment
comment|/* a pointer to it.                                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ips_stat_t
modifier|*
name|fr_statetstats
parameter_list|()
block|{
name|ips_stats
operator|.
name|iss_active
operator|=
name|ips_num
expr_stmt|;
name|ips_stats
operator|.
name|iss_statesize
operator|=
name|fr_statesize
expr_stmt|;
name|ips_stats
operator|.
name|iss_statemax
operator|=
name|fr_statemax
expr_stmt|;
name|ips_stats
operator|.
name|iss_table
operator|=
name|ips_table
expr_stmt|;
name|ips_stats
operator|.
name|iss_list
operator|=
name|ips_list
expr_stmt|;
name|ips_stats
operator|.
name|iss_ticks
operator|=
name|fr_ticks
expr_stmt|;
return|return
operator|&
name|ips_stats
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_state_remove                                             */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to state structure to delete from table   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for a state structure that matches the one passed, according to   */
end_comment

begin_comment
comment|/* the IP addresses and other protocol specific information.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_state_remove
parameter_list|(
name|data
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|sp
decl_stmt|,
name|st
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sp
operator|=
operator|&
name|st
expr_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|st
argument_list|,
name|IPFOBJ_IPSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|ips_list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|is_next
control|)
if|if
condition|(
operator|(
name|sp
operator|->
name|is_p
operator|==
name|st
operator|.
name|is_p
operator|)
operator|&&
operator|(
name|sp
operator|->
name|is_v
operator|==
name|st
operator|.
name|is_v
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_src
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_src
argument_list|)
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_src
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_dst
argument_list|)
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|is_ps
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|st
operator|.
name|is_ps
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|.
name|is_ps
argument_list|)
argument_list|)
condition|)
block|{
name|fr_delstate
argument_list|(
name|sp
argument_list|,
name|ISL_REMOVE
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_state_ioctl                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              cmd(I)  - ioctl command integer                             */
end_comment

begin_comment
comment|/*              mode(I) - file mode bits used with open                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Processes an ioctl call made to operate on the IP Filter state device.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_state_ioctl
parameter_list|(
name|data
parameter_list|,
name|cmd
parameter_list|,
name|mode
parameter_list|,
name|uid
parameter_list|,
name|ctx
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|uid
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|int
name|arg
decl_stmt|,
name|ret
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * Delete an entry from the state table. 	 */
case|case
name|SIOCDELST
case|:
name|error
operator|=
name|fr_state_remove
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush the state table 	 */
case|case
name|SIOCIPFFL
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fr_state_flush
argument_list|(
name|arg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ret
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|SIOCIPFL6
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fr_state_flush
argument_list|(
name|arg
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ret
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOG
comment|/* 	 * Flush the state log. 	 */
case|case
name|SIOCIPFFB
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ipflog_clear
argument_list|(
name|IPL_LOGSTATE
argument_list|)
expr_stmt|;
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
comment|/* 	 * Turn logging of state information on/off. 	 */
case|case
name|SIOCSETLG
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
block|{
name|error
operator|=
name|BCOPYIN
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ipstate_logging
argument_list|,
sizeof|sizeof
argument_list|(
name|ipstate_logging
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
break|break;
comment|/* 	 * Return the current state of logging. 	 */
case|case
name|SIOCGETLG
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipstate_logging
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ipstate_logging
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
comment|/* 	 * Return the number of bytes currently waiting to be read. 	 */
case|case
name|FIONREAD
case|:
name|arg
operator|=
name|iplused
index|[
name|IPL_LOGSTATE
index|]
expr_stmt|;
comment|/* returned in an int */
name|error
operator|=
name|BCOPYOUT
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* 	 * Get the current state statistics. 	 */
case|case
name|SIOCGETFS
case|:
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
name|fr_statetstats
argument_list|()
argument_list|,
name|IPFOBJ_STATESTAT
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Lock/Unlock the state table.  (Locking prevents any changes, which 	 * means no packets match). 	 */
case|case
name|SIOCSTLCK
case|:
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|fr_lock
argument_list|(
name|data
argument_list|,
operator|&
name|fr_state_lock
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Add an entry to the current state table. 	 */
case|case
name|SIOCSTPUT
case|:
if|if
condition|(
operator|!
name|fr_state_lock
operator|||
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|fr_stputent
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get a state table entry. 	 */
case|case
name|SIOCSTGET
case|:
if|if
condition|(
operator|!
name|fr_state_lock
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|fr_stgetent
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Return a copy of the hash table bucket lengths 	 */
case|case
name|SIOCSTAT1
case|:
name|error
operator|=
name|BCOPYOUT
argument_list|(
name|ips_stats
operator|.
name|iss_bucketlen
argument_list|,
name|data
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
case|case
name|SIOCGENITER
case|:
block|{
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
name|iter
decl_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|iter
argument_list|,
name|IPFOBJ_GENITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|token
operator|=
name|ipf_findtoken
argument_list|(
name|IPFGENITER_STATE
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|NULL
condition|)
name|error
operator|=
name|fr_stateiter
argument_list|(
name|token
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ESRCH
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_tokens
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGTABL
case|:
name|error
operator|=
name|fr_stgettable
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFDELTOK
case|:
name|error
operator|=
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
block|}
else|else
block|{
name|SPL_SCHED
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|ipf_deltoken
argument_list|(
name|arg
argument_list|,
name|uid
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGTQTAB
case|:
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
name|ips_tqtqb
argument_list|,
name|IPFOBJ_STATETQTAB
argument_list|)
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stgetent                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to state structure to retrieve from table */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy out state information from the kernel to a user space process.  If  */
end_comment

begin_comment
comment|/* there is a filter rule associated with the state entry, copy that out    */
end_comment

begin_comment
comment|/* as well.  The entry to copy out is taken from the value of "ips_next" in */
end_comment

begin_comment
comment|/* the struct passed in and if not null and not found in the list of current*/
end_comment

begin_comment
comment|/* state entries, the retrieval fails.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_stgetent
parameter_list|(
name|data
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|isn
decl_stmt|;
name|ipstate_save_t
name|ips
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|isn
operator|=
name|ips
operator|.
name|ips_next
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
name|isn
operator|=
name|ips_list
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ips
operator|.
name|ips_next
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure the pointer we're copying from exists in the 		 * current list of entries.  Security precaution to prevent 		 * copying of random kernel data. 		 */
for|for
control|(
name|is
operator|=
name|ips_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
if|if
condition|(
name|is
operator|==
name|isn
condition|)
break|break;
if|if
condition|(
operator|!
name|is
condition|)
return|return
name|ESRCH
return|;
block|}
name|ips
operator|.
name|ips_next
operator|=
name|isn
operator|->
name|is_next
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_is
argument_list|,
sizeof|sizeof
argument_list|(
name|ips
operator|.
name|ips_is
argument_list|)
argument_list|)
expr_stmt|;
name|ips
operator|.
name|ips_rule
operator|=
name|isn
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|isn
operator|->
name|is_rule
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
operator|->
name|is_rule
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_fr
argument_list|,
sizeof|sizeof
argument_list|(
name|ips
operator|.
name|ips_fr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stputent                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, != 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to state information struct               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function implements the SIOCSTPUT ioctl: insert a state entry into  */
end_comment

begin_comment
comment|/* the state table.  If the state info. includes a pointer to a filter rule */
end_comment

begin_comment
comment|/* then also add in an orphaned rule (will not show up in any "ipfstat -io" */
end_comment

begin_comment
comment|/* output.                                                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_stputent
parameter_list|(
name|data
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|isn
decl_stmt|;
name|ipstate_save_t
name|ips
decl_stmt|;
name|int
name|error
decl_stmt|,
name|out
decl_stmt|,
name|i
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|KMALLOC
argument_list|(
name|isn
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_is
argument_list|,
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isn
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isn
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_pkts
argument_list|)
argument_list|)
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_pnext
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sti
operator|.
name|tqe_parent
operator|=
name|isn
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|isn
operator|->
name|is_sync
operator|=
name|NULL
expr_stmt|;
name|fr
operator|=
name|ips
operator|.
name|ips_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|fr_stinsert
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isn
operator|->
name|is_flags
operator|&
name|SI_NEWFR
condition|)
block|{
name|KMALLOC
argument_list|(
name|fr
argument_list|,
name|frentry_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
operator|.
name|ips_fr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fr
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|fr
operator|->
name|fr_flags
operator|&
name|FR_OUTQUE
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|isn
operator|->
name|is_rule
operator|=
name|fr
expr_stmt|;
name|ips
operator|.
name|ips_is
operator|.
name|is_rule
operator|=
name|fr
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|,
literal|"state filter rule lock"
argument_list|)
expr_stmt|;
comment|/* 		 * Look up all the interface names in the rule. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|fr
operator|->
name|fr_ifnames
index|[
name|i
index|]
expr_stmt|;
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|=
name|fr_resolvenic
argument_list|(
name|name
argument_list|,
name|fr
operator|->
name|fr_v
argument_list|)
expr_stmt|;
name|name
operator|=
name|isn
operator|->
name|is_ifname
index|[
name|i
index|]
expr_stmt|;
name|isn
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|fr_resolvenic
argument_list|(
name|name
argument_list|,
name|isn
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
name|fr
operator|->
name|fr_ref
operator|=
literal|0
expr_stmt|;
name|fr
operator|->
name|fr_dsize
operator|=
literal|0
expr_stmt|;
name|fr
operator|->
name|fr_data
operator|=
name|NULL
expr_stmt|;
name|fr
operator|->
name|fr_type
operator|=
name|FR_T_NONE
expr_stmt|;
name|fr_resolvedest
argument_list|(
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|0
index|]
argument_list|,
name|fr
operator|->
name|fr_v
argument_list|)
expr_stmt|;
name|fr_resolvedest
argument_list|(
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_v
argument_list|)
expr_stmt|;
name|fr_resolvedest
argument_list|(
operator|&
name|fr
operator|->
name|fr_dif
argument_list|,
name|fr
operator|->
name|fr_v
argument_list|)
expr_stmt|;
comment|/* 		 * send a copy back to userland of what we ended up 		 * to allow for verification. 		 */
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|ips
argument_list|,
name|IPFOBJ_STATESAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|fr
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|fr_stinsert
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|is
operator|=
name|ips_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
if|if
condition|(
name|is
operator|->
name|is_rule
operator|==
name|fr
condition|)
block|{
name|fr_stinsert
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|isn
operator|->
name|is_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|isn
argument_list|)
expr_stmt|;
name|isn
operator|=
name|NULL
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|isn
operator|==
name|NULL
operator|)
condition|?
name|ESRCH
else|:
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:   fr_stinsert                                                  */
end_comment

begin_comment
comment|/* Returns:    Nil                                                          */
end_comment

begin_comment
comment|/* Parameters: is(I)  - pointer to state structure                          */
end_comment

begin_comment
comment|/*             rev(I) - flag indicating forward/reverse direction of packet */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Inserts a state structure into the hash table (for lookups) and the list */
end_comment

begin_comment
comment|/* of state entries (for enumeration).  Resolves all of the interface names */
end_comment

begin_comment
comment|/* to pointers and adjusts running stats for the hash table as appropriate. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking: it is assumed that some kind of lock on ipf_state is held.      */
end_comment

begin_comment
comment|/*          Exits with is_lock initialised and held.                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_stinsert
parameter_list|(
name|is
parameter_list|,
name|rev
parameter_list|)
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|,
literal|"ipf state entry"
argument_list|)
expr_stmt|;
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|++
expr_stmt|;
name|fr
operator|->
name|fr_statecnt
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look up all the interface names in the state entry. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
continue|continue;
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|fr_resolvenic
argument_list|(
name|is
operator|->
name|is_ifname
index|[
name|i
index|]
argument_list|,
name|is
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we could trust is_hv, then the modulous would not be needed, but 	 * when running with IPFILTER_SYNC, this stops bad values. 	 */
name|hv
operator|=
name|is
operator|->
name|is_hv
operator|%
name|fr_statesize
expr_stmt|;
name|is
operator|->
name|is_hv
operator|=
name|hv
expr_stmt|;
comment|/* 	 * We need to get both of these locks...the first because it is 	 * possible that once the insert is complete another packet might 	 * come along, match the entry and want to update it. 	 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipf_stinsert
argument_list|)
expr_stmt|;
comment|/* 	 * add into list table. 	 */
if|if
condition|(
name|ips_list
operator|!=
name|NULL
condition|)
name|ips_list
operator|->
name|is_pnext
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
name|is
operator|->
name|is_pnext
operator|=
operator|&
name|ips_list
expr_stmt|;
name|is
operator|->
name|is_next
operator|=
name|ips_list
expr_stmt|;
name|ips_list
operator|=
name|is
expr_stmt|;
if|if
condition|(
name|ips_table
index|[
name|hv
index|]
operator|!=
name|NULL
condition|)
name|ips_table
index|[
name|hv
index|]
operator|->
name|is_phnext
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
else|else
name|ips_stats
operator|.
name|iss_inuse
operator|++
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|ips_table
operator|+
name|hv
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
name|ips_table
index|[
name|hv
index|]
expr_stmt|;
name|ips_table
index|[
name|hv
index|]
operator|=
name|is
expr_stmt|;
name|ips_stats
operator|.
name|iss_bucketlen
index|[
name|hv
index|]
operator|++
expr_stmt|;
name|ips_num
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipf_stinsert
argument_list|)
expr_stmt|;
name|fr_setstatequeue
argument_list|(
name|is
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_addstate                                                 */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == failure, else pointer to new state     */
end_comment

begin_comment
comment|/* Parameters:  fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              stsave(O) - pointer to place to save pointer to created     */
end_comment

begin_comment
comment|/*                          state structure.                                */
end_comment

begin_comment
comment|/*              flags(I)  - flags to use when creating the structure        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Creates a new IP state structure from the packet information collected.  */
end_comment

begin_comment
comment|/* Inserts it into the state table and appends to the bottom of the active  */
end_comment

begin_comment
comment|/* list.  If the capacity of the table has reached the maximum allowed then */
end_comment

begin_comment
comment|/* the call will fail and a flush is scheduled for the next timeout call.   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: The use of stsave to point to nat_state will result in memory      */
end_comment

begin_comment
comment|/*       corruption.  It should only be used to point to objects that will  */
end_comment

begin_comment
comment|/*       either outlive this (not expired) or will deref the ip_state_t     */
end_comment

begin_comment
comment|/*       when they are deleted.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipstate_t
modifier|*
name|fr_addstate
parameter_list|(
name|fin
parameter_list|,
name|stsave
parameter_list|,
name|flags
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
modifier|*
name|stsave
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
name|ips
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|u_int
name|pass
decl_stmt|,
name|hv
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|grehdr_t
modifier|*
name|gre
decl_stmt|;
name|int
name|out
decl_stmt|;
if|if
condition|(
name|fr_state_lock
operator|||
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_SHORT
operator||
name|FI_STATE
operator||
name|FI_FRAGBODY
operator||
name|FI_BAD
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_tcpf
operator|&
name|TH_SYN
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * If a "keep state" rule has reached the maximum number of references 	 * to it, then schedule an automatic flush in case we can clear out 	 * some "dead old wood".  Note that because the lock isn't held on 	 * fr it is possible that we could overflow.  The cost of overflowing 	 * is being ignored here as the number by which it can overflow is 	 * a product of the number of simultaneous threads that could be 	 * executing in here, so a limit of 100 won't result in 200, but could 	 * result in 101 or 102. 	 */
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ips_num
operator|>=
name|fr_statemax
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_statemax
operator|==
literal|0
operator|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_max
argument_list|)
expr_stmt|;
name|fr_state_doflush
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_statemax
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_statecnt
operator|>=
name|fr
operator|->
name|fr_statemax
operator|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_maxref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|pass
operator|=
operator|(
name|fr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|fr
operator|->
name|fr_flags
expr_stmt|;
name|ic
operator|=
name|NULL
expr_stmt|;
name|tcp
operator|=
name|NULL
expr_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|is
operator|=
operator|&
name|ips
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_die
operator|=
literal|1
operator|+
name|fr_ticks
expr_stmt|;
comment|/* 	 * Copy and calculate... 	 */
name|hv
operator|=
operator|(
name|is
operator|->
name|is_p
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|)
expr_stmt|;
name|is
operator|->
name|is_src
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_saddr
expr_stmt|;
name|is
operator|->
name|is_dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_daddr
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
comment|/* 		 * For ICMPv6, we check to see if the destination address is 		 * a multicast address.  If it is, do not include it in the 		 * calculation of the hash because the correct reply will come 		 * back from a real address, not a multicast address. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|IPPROTO_ICMPV6
operator|)
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|is
operator|->
name|is_dst
operator|.
name|in6
argument_list|)
condition|)
block|{
comment|/* 			 * So you can do keep state with neighbour discovery. 			 * 			 * Here we could use the address from the neighbour 			 * solicit message to put in the state structure and 			 * we could use that without a wildcard flag too... 			 */
name|flags
operator||=
name|SI_W_DADDR
expr_stmt|;
name|hv
operator|-=
name|is
operator|->
name|is_daddr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|is
operator|->
name|is_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP6_ECHO_REQUEST
case|:
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
name|hv
operator|+=
operator|(
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|=
name|ic
operator|->
name|icmp_id
operator|)
expr_stmt|;
break|break;
case|case
name|ICMP6_MEMBERSHIP_QUERY
case|:
case|case
name|ND_ROUTER_SOLICIT
case|:
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
case|case
name|ICMP6_NI_QUERY
case|:
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
break|break;
default|default :
return|return
name|NULL
return|;
block|}
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_icmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHO
case|:
case|case
name|ICMP_TSTAMP
case|:
case|case
name|ICMP_IREQ
case|:
case|case
name|ICMP_MASKREQ
case|:
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
name|hv
operator|+=
operator|(
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|=
name|ic
operator|->
name|icmp_id
operator|)
expr_stmt|;
break|break;
default|default :
return|return
name|NULL
return|;
block|}
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_icmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
name|gre
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|is
operator|->
name|is_gre
operator|.
name|gs_flags
operator|=
name|gre
operator|->
name|gr_flags
expr_stmt|;
name|is
operator|->
name|is_gre
operator|.
name|gs_ptype
operator|=
name|gre
operator|->
name|gr_ptype
expr_stmt|;
if|if
condition|(
name|GRE_REV
argument_list|(
name|is
operator|->
name|is_gre
operator|.
name|gs_flags
argument_list|)
operator|==
literal|1
condition|)
block|{
name|is
operator|->
name|is_call
index|[
literal|0
index|]
operator|=
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
expr_stmt|;
name|is
operator|->
name|is_call
index|[
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_TCP
case|:
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_RST
condition|)
return|return
name|NULL
return|;
comment|/* 		 * The endian of the ports doesn't matter, but the ack and 		 * sequence numbers do as we do mathematics on them later. 		 */
name|is
operator|->
name|is_sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_DPORT
operator||
name|SI_W_SPORT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hv
operator|+=
name|is
operator|->
name|is_sport
expr_stmt|;
name|hv
operator|+=
name|is
operator|->
name|is_dport
expr_stmt|;
block|}
comment|/* 		 * If this is a real packet then initialise fields in the 		 * state information structure from the TCP header information. 		 */
name|is
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|is_maxswin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_maxswin
operator|==
literal|0
condition|)
name|is
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|is
operator|->
name|is_maxsend
operator|=
name|is
operator|->
name|is_send
expr_stmt|;
comment|/* 			 * Window scale option is only present in 			 * SYN/SYN-ACK packet. 			 */
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_FIN
operator||
name|TH_ACK
operator||
name|TH_ECNALL
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fr_tcpoptions
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pass
operator|&
name|FR_NEWISN
operator|)
operator|!=
literal|0
condition|)
block|{
name|fr_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|fr_fixoutisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
name|flags
operator||=
name|IS_TCPFSM
expr_stmt|;
else|else
block|{
name|is
operator|->
name|is_maxdwin
operator|=
name|is
operator|->
name|is_maxswin
operator|*
literal|2
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_maxdend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_maxdwin
operator|*=
literal|2
expr_stmt|;
block|}
block|}
comment|/* 		 * If we're creating state for a starting connection, start the 		 * timer on it as we'll never see an error if it fails to 		 * connect. 		 */
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_tcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|is
operator|->
name|is_sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_DPORT
operator||
name|SI_W_SPORT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hv
operator|+=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|hv
operator|+=
name|tcp
operator|->
name|th_sport
expr_stmt|;
block|}
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_udp
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_hv
operator|=
name|hv
expr_stmt|;
name|is
operator|->
name|is_rule
operator|=
name|fr
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|flags
operator|&
name|IS_INHERITED
expr_stmt|;
comment|/* 	 * Look for identical state. 	 */
for|for
control|(
name|is
operator|=
name|ips_table
index|[
name|is
operator|->
name|is_hv
operator|%
name|fr_statesize
index|]
init|;
name|is
operator|!=
name|NULL
condition|;
name|is
operator|=
name|is
operator|->
name|is_hnext
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|ips
operator|.
name|is_src
argument_list|,
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_ps
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|ipstate
argument_list|,
name|is_src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ips_stats
operator|.
name|iss_bucketlen
index|[
name|hv
index|]
operator|>=
name|fr_state_maxbucket
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_bucketfull
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KMALLOC
argument_list|(
name|is
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_nomem
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ips
argument_list|,
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Do not do the modulous here, it is done in fr_stinsert(). 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|is
operator|->
name|is_group
argument_list|,
name|fr
operator|->
name|fr_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_age
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|=
name|fr_addtimeoutqueue
argument_list|(
operator|&
name|ips_utqe
argument_list|,
name|fr
operator|->
name|fr_age
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator||=
name|TQE_RULEBASED
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_age
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|=
name|fr_addtimeoutqueue
argument_list|(
operator|&
name|ips_utqe
argument_list|,
name|fr
operator|->
name|fr_age
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator||=
name|TQE_RULEBASED
expr_stmt|;
block|}
name|is
operator|->
name|is_tag
operator|=
name|fr
operator|->
name|fr_logtag
expr_stmt|;
comment|/* 		 * The name '-' is special for network interfaces and causes 		 * a NULL name to be present, always, allowing packets to 		 * match it, regardless of their interface. 		 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fr
operator|->
name|fr_ifnames
index|[
name|out
operator|<<
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|fr
operator|->
name|fr_ifnames
index|[
name|out
operator|<<
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|0
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_ifnames
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_ifp
index|[
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|1
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_ifnames
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ifp
index|[
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|2
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
index|]
argument_list|,
name|fr
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ifp
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
name|fr
operator|->
name|fr_ifas
index|[
literal|3
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|is
operator|->
name|is_ifname
index|[
operator|(
operator|(
literal|1
operator|-
name|out
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|,
name|fr
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pass
operator|=
name|fr_flags
expr_stmt|;
name|is
operator|->
name|is_tag
operator|=
name|FR_NOLOGTAG
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_ifp
operator|!=
name|NULL
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|out
operator|<<
literal|1
index|]
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|fin
operator|->
name|fin_ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|out
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * It may seem strange to set is_ref to 2, but fr_check() will call 	 * fr_statederef() after calling fr_addstate() and the idea is to 	 * have it exist at the end of fr_check() with is_ref == 1. 	 */
name|is
operator|->
name|is_ref
operator|=
literal|2
expr_stmt|;
name|is
operator|->
name|is_pass
operator|=
name|pass
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|0
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|1
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|2
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
literal|3
index|]
operator|=
literal|0
operator|,
name|is
operator|->
name|is_bytes
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_pkts
index|[
name|out
index|]
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|is_bytes
index|[
name|out
index|]
operator|=
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
literal|0
index|]
operator|=
name|fin
operator|->
name|fin_flx
operator|&
name|FI_CMP
expr_stmt|;
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
literal|0
index|]
operator|&=
operator|~
name|FI_OOW
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|&
name|FR_STSTRICT
condition|)
name|is
operator|->
name|is_flags
operator||=
name|IS_STRICT
expr_stmt|;
if|if
condition|(
name|pass
operator|&
name|FR_STATESYNC
condition|)
name|is
operator|->
name|is_flags
operator||=
name|IS_STATESYNC
expr_stmt|;
comment|/* 	 * We want to check everything that is a property of this packet, 	 * but we don't (automatically) care about it's fragment status as 	 * this may change. 	 */
name|is
operator|->
name|is_v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
name|is
operator|->
name|is_opt
index|[
literal|0
index|]
operator|=
name|fin
operator|->
name|fin_optmsk
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
condition|)
block|{
name|is
operator|->
name|is_opt
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|0
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
block|}
name|is
operator|->
name|is_me
operator|=
name|stsave
expr_stmt|;
name|is
operator|->
name|is_sec
operator|=
name|fin
operator|->
name|fin_secmsk
expr_stmt|;
name|is
operator|->
name|is_secmsk
operator|=
literal|0xffff
expr_stmt|;
name|is
operator|->
name|is_auth
operator|=
name|fin
operator|->
name|fin_auth
expr_stmt|;
name|is
operator|->
name|is_authmsk
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_rulen
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
if|if
condition|(
name|pass
operator|&
name|FR_LOGFIRST
condition|)
name|is
operator|->
name|is_pass
operator|&=
operator|~
operator|(
name|FR_LOGFIRST
operator||
name|FR_LOG
operator|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|fr_stinsert
argument_list|(
name|is
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
comment|/* 		* If we're creating state for a starting connection, start the 		* timer on it as we'll never see an error if it fails to 		* connect. 		*/
operator|(
name|void
operator|)
name|fr_tcp_age
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|ips_tqtqb
argument_list|,
name|is
operator|->
name|is_flags
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_CLONE
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|ipsc_attachis
argument_list|(
name|is
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
operator|)
operator|&&
operator|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_CLONE
operator|)
operator|==
literal|0
operator|)
condition|)
name|is
operator|->
name|is_sync
operator|=
name|ipfsync_new
argument_list|(
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipstate_logging
condition|)
name|ipstate_log
argument_list|(
name|is
argument_list|,
name|ISL_NEW
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_state
operator|=
name|is
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
operator|&
name|fin
operator|->
name|fin_daddr
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_STATE
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
condition|)
operator|(
name|void
operator|)
name|fr_newfrag
argument_list|(
name|fin
argument_list|,
name|pass
operator|^
name|FR_KEEPSTATE
argument_list|)
expr_stmt|;
return|return
name|is
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_tcpoptions                                               */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet matches state entry, 0 == it does not,    */
end_comment

begin_comment
comment|/*                   -1 == packet has bad TCP options data                  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP packet header                       */
end_comment

begin_comment
comment|/*              td(I)  - pointer to TCP data held as part of the state      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look after the TCP header for any options and deal with those that are   */
end_comment

begin_comment
comment|/* present.  Record details about those that we recogise.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_tcpoptions
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|td
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|tcpdata_t
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|off
decl_stmt|,
name|mlen
decl_stmt|,
name|ol
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|retval
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|opt
decl_stmt|;
name|mb_t
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|len
operator|=
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|len
condition|)
return|return
literal|0
return|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
expr_stmt|;
name|off
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|fin
operator|->
name|fin_dlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
operator|+
name|fin
operator|->
name|fin_ipoff
expr_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
name|mlen
operator|=
name|MSGDSIZE
argument_list|(
name|m
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|mlen
condition|)
block|{
name|len
operator|=
name|mlen
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|COPYDATA
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
name|opt
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|TCPOPT_EOL
condition|)
break|break;
elseif|else
if|if
condition|(
name|opt
operator|==
name|TCPOPT_NOP
condition|)
name|ol
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
break|break;
name|ol
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ol
operator|<
literal|2
operator|||
name|ol
operator|>
name|len
condition|)
break|break;
comment|/* 			 * Extract the TCP options we are interested in out of 			 * the header and store them in the the tcpdata struct. 			 */
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|TCPOPT_WINDOW
case|:
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_WINDOW
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|TCP_WSCALE_MAX
condition|)
name|i
operator|=
name|TCP_WSCALE_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_winscale
operator|=
name|i
expr_stmt|;
name|td
operator|->
name|td_winflags
operator||=
name|TCP_WSCALE_SEEN
operator||
name|TCP_WSCALE_FIRST
expr_stmt|;
block|}
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TCPOPT_MAXSEG
case|:
comment|/* 				 * So, if we wanted to set the TCP MAXSEG, 				 * it should be done here... 				 */
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_MAXSEG
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
name|i
operator|<<=
literal|8
expr_stmt|;
name|i
operator|+=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
expr_stmt|;
name|td
operator|->
name|td_maxseg
operator|=
name|i
expr_stmt|;
block|}
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|TCPOPT_SACK_PERMITTED
case|:
if|if
condition|(
name|ol
operator|==
name|TCPOLEN_SACK_PERMITTED
condition|)
name|td
operator|->
name|td_winflags
operator||=
name|TCP_SACK_PERMIT
expr_stmt|;
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|-=
name|ol
expr_stmt|;
name|s
operator|+=
name|ol
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_tcpstate                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet matches state entry, 0 == it does not     */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              tcp(I)   - pointer to TCP packet header                     */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if a packet with TCP headers fits within the TCP window.    */
end_comment

begin_comment
comment|/* Change timeout depending on whether new packet is a SYN-ACK returning    */
end_comment

begin_comment
comment|/* for a SYN or a RST or FIN which indicate time to close up shop.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_tcpstate
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|int
name|source
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|tcpdata_t
modifier|*
name|fdata
decl_stmt|,
modifier|*
name|tdata
decl_stmt|;
name|source
operator|=
operator|!
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_TCPFSM
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|source
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|is
operator|->
name|is_sport
argument_list|)
operator|!=
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|)
condition|)
name|source
operator|=
literal|0
expr_stmt|;
name|fdata
operator|=
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
operator|!
name|source
index|]
expr_stmt|;
name|tdata
operator|=
operator|&
name|is
operator|->
name|is_tcp
operator|.
name|ts_data
index|[
name|source
index|]
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If a SYN packet is received for a connection that is on the way out 	 * but hasn't yet departed then advance this session along the way. 	 */
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
block|{
if|if
condition|(
operator|(
name|is
operator|->
name|is_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
name|is
operator|->
name|is_state
index|[
operator|!
name|source
index|]
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
name|fr_movequeue
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
argument_list|,
operator|&
name|ips_deletetq
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|fr_tcpinwindow
argument_list|(
name|fin
argument_list|,
name|fdata
argument_list|,
name|tdata
argument_list|,
name|tcp
argument_list|,
name|is
operator|->
name|is_flags
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|IS_SC_CLIENT
operator||
name|IS_SC_SERVER
operator|)
condition|)
block|{
name|ipsc_packet
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|is
operator|->
name|is_pass
argument_list|)
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Nearing end of connection, start timeout. 		 */
name|ret
operator|=
name|fr_tcp_age
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|ips_tqtqb
argument_list|,
name|is
operator|->
name|is_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * set s0's as appropriate.  Use syn-ack packet as it 		 * contains both pieces of required information. 		 */
comment|/* 		 * Window scale option is only present in SYN/SYN-ACK packet. 		 * Compare with ~TH_FIN to mask out T/TCP setups. 		 */
name|flags
operator|=
name|tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_FIN
operator||
name|TH_ECNALL
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
condition|)
block|{
name|is
operator|->
name|is_s0
index|[
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_s0
index|[
operator|!
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fr_tcpoptions
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
name|fdata
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
operator|)
condition|)
name|fr_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|TH_SYN
condition|)
block|{
name|is
operator|->
name|is_s0
index|[
name|source
index|]
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
operator|>>
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|fr_tcpoptions
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
name|fdata
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
operator|)
condition|)
name|fr_checknewisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_OOW
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_checknewisn                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if this TCP connection is expecting and needs a new         */
end_comment

begin_comment
comment|/* sequence number for a particular direction of the connection.            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: This does not actually change the sequence numbers, only gets new  */
end_comment

begin_comment
comment|/* one ready.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|fr_checknewisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|u_32_t
name|sumd
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|)
condition|)
block|{
name|old
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|new
operator|=
name|fr_newisn
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_isninc
index|[
name|i
index|]
operator|=
name|new
operator|-
name|old
expr_stmt|;
name|CALC_SUMD
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|sumd
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_sumd
index|[
name|i
index|]
operator|=
operator|(
name|sumd
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sumd
operator|>>
literal|16
operator|)
expr_stmt|;
name|is
operator|->
name|is_flags
operator||=
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|IS_ISNSYN
else|:
name|IS_ISNACK
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_tcpinwindow                                              */
end_comment

begin_comment
comment|/* Returns:     int - 1 == packet inside TCP "window", 0 == not inside.     */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              fdata(I) - pointer to tcp state informatio (forward)        */
end_comment

begin_comment
comment|/*              tdata(I) - pointer to tcp state informatio (reverse)        */
end_comment

begin_comment
comment|/*              tcp(I)   - pointer to TCP packet header                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a packet has matched addresses and ports, check to see if it is    */
end_comment

begin_comment
comment|/* within the TCP data window.  In a show of generosity, allow packets that */
end_comment

begin_comment
comment|/* are within the window space behind the current sequence # as well.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_tcpinwindow
parameter_list|(
name|fin
parameter_list|,
name|fdata
parameter_list|,
name|tdata
parameter_list|,
name|tcp
parameter_list|,
name|flags
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcpdata_t
modifier|*
name|fdata
decl_stmt|,
decl|*
name|tdata
decl_stmt|;
end_function

begin_decl_stmt
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tcp_seq
name|seq
decl_stmt|,
name|ack
decl_stmt|,
name|end
decl_stmt|;
name|int
name|ackskew
decl_stmt|,
name|tcpflags
decl_stmt|;
name|u_32_t
name|win
decl_stmt|,
name|maxwin
decl_stmt|;
name|int
name|dsize
decl_stmt|,
name|inseq
decl_stmt|;
comment|/* 	 * Find difference between last checked packet and this packet. 	 */
name|tcpflags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_SYN
condition|)
name|win
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
else|else
name|win
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
operator|<<
name|fdata
operator|->
name|td_winscale
expr_stmt|;
comment|/* 	 * A window of 0 produces undesirable behaviour from this function. 	 */
if|if
condition|(
name|win
operator|==
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
name|dsize
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcpflags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcpflags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * if window scaling is present, the scaling is only allowed 	 * for windows not in the first SYN packet. In that packet the 	 * window is 65535 to specify the largest window possible 	 * for receivers not implementing the window scale option. 	 * Currently, we do not assume TTCP here. That means that 	 * if we see a second packet from a host (after the initial 	 * SYN), we can assume that the receiver of the SYN did 	 * already send back the SYN/ACK (and thus that we know if 	 * the receiver also does window scaling) 	 */
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
name|TCP_WSCALE_FIRST
operator|)
condition|)
block|{
name|fdata
operator|->
name|td_winflags
operator|&=
operator|~
name|TCP_WSCALE_FIRST
expr_stmt|;
name|fdata
operator|->
name|td_maxwin
operator|=
name|win
expr_stmt|;
block|}
name|end
operator|=
name|seq
operator|+
name|dsize
expr_stmt|;
if|if
condition|(
operator|(
name|fdata
operator|->
name|td_end
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
operator|||
operator|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Must be a (outgoing) SYN-ACK in reply to a SYN. 		 */
name|fdata
operator|->
name|td_end
operator|=
name|end
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|td_maxwin
operator|=
literal|1
expr_stmt|;
name|fdata
operator|->
name|td_maxend
operator|=
name|end
operator|+
name|win
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* Pretend an ack was sent */
name|ack
operator|=
name|tdata
operator|->
name|td_end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|==
operator|(
name|TH_ACK
operator||
name|TH_RST
operator|)
operator|)
operator|&&
operator|(
name|ack
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* gross hack to get around certain broken tcp stacks */
name|ack
operator|=
name|tdata
operator|->
name|td_end
expr_stmt|;
block|}
name|maxwin
operator|=
name|tdata
operator|->
name|td_maxwin
expr_stmt|;
name|ackskew
operator|=
name|tdata
operator|->
name|td_end
operator|-
name|ack
expr_stmt|;
comment|/* 	 * Strict sequencing only allows in-order delivery. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IS_STRICT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|seq
operator|!=
name|fdata
operator|->
name|td_end
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
define|#
directive|define
name|SEQ_GE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((int)((a) - (b))>= 0)
define|#
directive|define
name|SEQ_GT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((int)((a) - (b))> 0)
name|inseq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_GE
argument_list|(
name|fdata
operator|->
name|td_maxend
argument_list|,
name|end
argument_list|)
operator|)
operator|&&
operator|(
name|SEQ_GE
argument_list|(
name|seq
argument_list|,
name|fdata
operator|->
name|td_end
operator|-
name|maxwin
argument_list|)
operator|)
operator|&&
comment|/* XXX what about big packets */
define|#
directive|define
name|MAXACKWINDOW
value|66000
operator|(
operator|-
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|)
operator|)
operator|&&
operator|(
name|ackskew
operator|<=
operator|(
name|MAXACKWINDOW
operator|<<
name|fdata
operator|->
name|td_winscale
operator|)
operator|)
condition|)
block|{
name|inseq
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Microsoft Windows will send the next packet to the right of the 	 * window if SACK is in use. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
name|seq
operator|==
name|fdata
operator|->
name|td_maxend
operator|)
operator|&&
operator|(
name|ackskew
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
name|TCP_SACK_PERMIT
operator|)
operator|&&
operator|(
name|tdata
operator|->
name|td_winflags
operator|&
name|TCP_SACK_PERMIT
operator|)
condition|)
block|{
name|inseq
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Sometimes a TCP RST will be generated with only the ACK field 	 * set to non-zero. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
name|seq
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tcpflags
operator|==
operator|(
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|&&
operator|(
name|ackskew
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ackskew
operator|<=
literal|1
operator|)
condition|)
block|{
name|inseq
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|fin
operator|->
name|fin_rev
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
if|#
directive|if
literal|0
block|if (is_pkts[i]0 == 0) {
comment|/* 			 * Picking up a connection in the middle, the "next" 			 * packet seen from a direction that is new should be 			 * accepted, even if it appears out of sequence. 			 */
block|inseq = 1; 		} else
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|fdata
operator|->
name|td_winflags
operator|&
operator|(
name|TCP_WSCALE_SEEN
operator||
name|TCP_WSCALE_FIRST
operator|)
operator|)
condition|)
block|{
comment|/* 			 * No TCPFSM and no window scaling, so make some 			 * extra guesses. 			 */
if|if
condition|(
operator|(
name|seq
operator|==
name|fdata
operator|->
name|td_maxend
operator|)
operator|&&
operator|(
name|ackskew
operator|==
literal|0
operator|)
condition|)
name|inseq
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|SEQ_GE
argument_list|(
name|seq
operator|+
name|maxwin
argument_list|,
name|fdata
operator|->
name|td_end
operator|-
name|maxwin
argument_list|)
condition|)
name|inseq
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* TRACE(inseq, fdata, tdata, seq, end, ack, ackskew, win, maxwin) */
if|if
condition|(
name|inseq
condition|)
block|{
comment|/* if ackskew< 0 then this should be due to fragmented 		 * packets. There is no way to know the length of the 		 * total packet in advance. 		 * We do know the total length from the fragment cache though. 		 * Note however that there might be more sessions with 		 * exactly the same source and destination parameters in the 		 * state cache (and source and destination is the only stuff 		 * that is saved in the fragment cache). Note further that 		 * some TCP connections in the state cache are hashed with 		 * sport and dport as well which makes it not worthwhile to 		 * look for them. 		 * Thus, when ackskew is negative but still seems to belong 		 * to this session, we bump up the destinations end value. 		 */
if|if
condition|(
name|ackskew
operator|<
literal|0
condition|)
name|tdata
operator|->
name|td_end
operator|=
name|ack
expr_stmt|;
comment|/* update max window seen */
if|if
condition|(
name|fdata
operator|->
name|td_maxwin
operator|<
name|win
condition|)
name|fdata
operator|->
name|td_maxwin
operator|=
name|win
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|end
argument_list|,
name|fdata
operator|->
name|td_end
argument_list|)
condition|)
name|fdata
operator|->
name|td_end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|SEQ_GE
argument_list|(
name|ack
operator|+
name|win
argument_list|,
name|tdata
operator|->
name|td_maxend
argument_list|)
condition|)
name|tdata
operator|->
name|td_maxend
operator|=
name|ack
operator|+
name|win
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stclone                                                  */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == cloning failed,                        */
end_comment

begin_comment
comment|/*                           else pointer to new state structure            */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP/UDP header                          */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Create a "duplcate" state table entry from the master.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|fr_stclone
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|clone
decl_stmt|;
name|u_32_t
name|send
decl_stmt|;
if|if
condition|(
name|ips_num
operator|==
name|fr_statemax
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_max
argument_list|)
expr_stmt|;
name|fr_state_doflush
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KMALLOC
argument_list|(
name|clone
argument_list|,
name|ipstate_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|is
argument_list|,
operator|(
name|char
operator|*
operator|)
name|clone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|clone
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|clone
operator|->
name|is_die
operator|=
name|ONE_DAY
operator|+
name|fr_ticks
expr_stmt|;
name|clone
operator|->
name|is_state
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_state
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
operator|+
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_SYN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_FIN
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_rev
operator|==
literal|1
condition|)
block|{
name|clone
operator|->
name|is_dend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_maxdend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_send
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
name|clone
operator|->
name|is_maxdwin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_maxdwin
operator|==
literal|0
condition|)
name|clone
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|clone
operator|->
name|is_send
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_maxsend
operator|=
name|send
expr_stmt|;
name|clone
operator|->
name|is_dend
operator|=
literal|0
expr_stmt|;
name|clone
operator|->
name|is_maxdwin
operator|=
literal|1
expr_stmt|;
name|clone
operator|->
name|is_maxswin
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_win
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_maxswin
operator|==
literal|0
condition|)
name|clone
operator|->
name|is_maxswin
operator|=
literal|1
expr_stmt|;
block|}
name|clone
operator|->
name|is_flags
operator|&=
operator|~
name|SI_CLONE
expr_stmt|;
name|clone
operator|->
name|is_flags
operator||=
name|SI_CLONED
expr_stmt|;
name|fr_stinsert
argument_list|(
name|clone
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
expr_stmt|;
name|clone
operator|->
name|is_ref
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|is_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
operator|(
name|void
operator|)
name|fr_tcp_age
argument_list|(
operator|&
name|clone
operator|->
name|is_sti
argument_list|,
name|fin
argument_list|,
name|ips_tqtqb
argument_list|,
name|clone
operator|->
name|is_flags
argument_list|)
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|clone
operator|->
name|is_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
operator|(
name|void
operator|)
name|ipsc_attachis
argument_list|(
name|is
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
condition|)
name|clone
operator|->
name|is_sync
operator|=
name|ipfsync_new
argument_list|(
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|clone
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|clone
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_matchsrcdst                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              is(I)  - pointer to state structure                         */
end_comment

begin_comment
comment|/*              src(I) - pointer to source address                          */
end_comment

begin_comment
comment|/*              dst(I) - pointer to destination address                     */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP/UDP header                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Match a state table entry against an IP packet.  The logic below is that */
end_comment

begin_comment
comment|/* ret gets set to one if the match succeeds, else remains 0.  If it is     */
end_comment

begin_comment
comment|/* still 0 after the test. no match.                                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|fr_matchsrcdst
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|tcp
parameter_list|,
name|cmask
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|i6addr_t
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_32_t
name|cmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|rev
decl_stmt|,
name|out
decl_stmt|,
name|flags
decl_stmt|,
name|flx
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
name|u_short
name|sp
decl_stmt|,
name|dp
decl_stmt|;
name|u_32_t
name|cflx
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
name|rev
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|flags
operator|=
name|is
operator|->
name|is_flags
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcp
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_sport
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ntohs
argument_list|(
name|fin
operator|->
name|fin_dport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rev
condition|)
block|{
if|if
condition|(
name|tcp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|sp
operator|!=
name|is
operator|->
name|is_sport
operator|)
condition|)
name|rev
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SI_W_DPORT
operator|)
operator|&&
operator|(
name|dp
operator|!=
name|is
operator|->
name|is_dport
operator|)
condition|)
name|rev
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|idx
operator|=
operator|(
name|out
operator|<<
literal|1
operator|)
operator|+
name|rev
expr_stmt|;
comment|/* 	 * If the interface for this 'direction' is set, make sure it matches. 	 * An interface name that is not set matches any, as does a name of *. 	 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|ifp
operator|)
operator|||
operator|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'-'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Match addresses and ports. 	 */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|)
operator|&&
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|src
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tcp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|==
name|is
operator|->
name|is_sport
operator|||
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|dp
operator|==
name|is
operator|->
name|is_dport
operator|||
name|flags
operator|&
name|SI_W_DPORT
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
name|src
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|)
operator|&&
operator|(
name|IP6_EQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
name|dst
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tcp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|==
name|is
operator|->
name|is_sport
operator|||
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|&&
operator|(
name|sp
operator|==
name|is
operator|->
name|is_dport
operator|||
name|flags
operator|&
name|SI_W_DPORT
operator|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Whether or not this should be here, is questionable, but the aim 	 * is to get this out of the main line. 	 */
if|if
condition|(
name|tcp
operator|==
name|NULL
condition|)
name|flags
operator|=
name|is
operator|->
name|is_flags
operator|&
operator|~
operator|(
name|SI_WILDP
operator||
name|SI_NEWFR
operator||
name|SI_CLONE
operator||
name|SI_CLONED
operator|)
expr_stmt|;
comment|/* 	 * Only one of the source or destination address can be flaged as a 	 * wildcard.  Fill in the missing address, if set. 	 * For IPv6, if the address being copied in is multicast, then 	 * don't reset the wild flag - multicast causes it to be set in the 	 * first place! 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_SADDR
operator||
name|SI_W_DADDR
operator|)
operator|)
condition|)
block|{
name|fr_ip_t
modifier|*
name|fi
init|=
operator|&
name|fin
operator|->
name|fin_fi
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_SADDR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fi
operator|->
name|fi_src
operator|.
name|in6
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
else|else
endif|#
directive|endif
block|{
name|is
operator|->
name|is_src
operator|=
name|fi
operator|->
name|fi_src
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_SADDR
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fi
operator|->
name|fi_dst
operator|.
name|in6
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
else|else
endif|#
directive|endif
block|{
name|is
operator|->
name|is_src
operator|=
name|fi
operator|->
name|fi_dst
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_SADDR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_DADDR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fi
operator|->
name|fi_dst
operator|.
name|in6
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
else|else
endif|#
directive|endif
block|{
name|is
operator|->
name|is_dst
operator|=
name|fi
operator|->
name|fi_dst
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_DADDR
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fi
operator|->
name|fi_src
operator|.
name|in6
argument_list|)
condition|)
comment|/*EMPTY*/
empty_stmt|;
else|else
endif|#
directive|endif
block|{
name|is
operator|->
name|is_dst
operator|=
name|fi
operator|->
name|fi_src
expr_stmt|;
name|is
operator|->
name|is_flags
operator|&=
operator|~
name|SI_W_DADDR
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_WILDA
operator||
name|SI_WILDP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ATOMIC_DECL
argument_list|(
name|ips_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
block|}
name|flx
operator|=
name|fin
operator|->
name|fin_flx
operator|&
name|cmask
expr_stmt|;
name|cflx
operator|=
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
expr_stmt|;
comment|/* 	 * Match up any flags set from IP options. 	 */
if|if
condition|(
operator|(
name|cflx
operator|&&
operator|(
name|flx
operator|!=
operator|(
name|cflx
operator|&
name|cmask
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_optmsk
operator|&
name|is
operator|->
name|is_optmsk
index|[
name|rev
index|]
operator|)
operator|!=
name|is
operator|->
name|is_opt
index|[
name|rev
index|]
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_secmsk
operator|&
name|is
operator|->
name|is_secmsk
operator|)
operator|!=
name|is
operator|->
name|is_sec
operator|)
operator|||
operator|(
operator|(
name|fin
operator|->
name|fin_auth
operator|&
name|is
operator|->
name|is_authmsk
operator|)
operator|!=
name|is
operator|->
name|is_auth
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Only one of the source or destination port can be flagged as a 	 * wildcard.  When filling it in, fill in a copy of the matched entry 	 * if it has the cloning flag set. 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_IGNORE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_rev
operator|=
name|rev
expr_stmt|;
return|return
name|is
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SI_W_SPORT
operator||
name|SI_W_DPORT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_CLONE
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipstate_t
modifier|*
name|clone
decl_stmt|;
name|clone
operator|=
name|fr_stclone
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|is
operator|=
name|clone
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_DECL
argument_list|(
name|ips_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_SPORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_sport
operator|=
name|sp
expr_stmt|;
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_sport
operator|=
name|dp
expr_stmt|;
name|is
operator|->
name|is_send
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_maxsend
operator|=
name|is
operator|->
name|is_send
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_W_DPORT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_dport
operator|=
name|dp
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is
operator|->
name|is_dport
operator|=
name|sp
expr_stmt|;
name|is
operator|->
name|is_dend
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_maxdend
operator|=
name|is
operator|->
name|is_dend
operator|+
literal|1
expr_stmt|;
block|}
name|is
operator|->
name|is_flags
operator|&=
operator|~
operator|(
name|SI_W_SPORT
operator||
name|SI_W_DPORT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SI_CLONED
operator|)
operator|&&
name|ipstate_logging
condition|)
name|ipstate_log
argument_list|(
name|is
argument_list|,
name|ISL_CLONE
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_flx
index|[
name|out
index|]
index|[
name|rev
index|]
operator|=
name|flx
expr_stmt|;
name|is
operator|->
name|is_opt
index|[
name|rev
index|]
operator|=
name|fin
operator|->
name|fin_optmsk
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_v
operator|==
literal|6
condition|)
block|{
name|is
operator|->
name|is_opt
index|[
name|rev
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
name|is
operator|->
name|is_optmsk
index|[
name|rev
index|]
operator|&=
operator|~
literal|0x8
expr_stmt|;
block|}
block|}
comment|/* 	 * Check if the interface name for this "direction" is set and if not, 	 * fill it in. 	 */
if|if
condition|(
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
operator|==
literal|'*'
operator|)
condition|)
block|{
name|is
operator|->
name|is_ifp
index|[
name|idx
index|]
operator|=
name|ifp
expr_stmt|;
name|COPYIFNAME
argument_list|(
name|ifp
argument_list|,
name|is
operator|->
name|is_ifname
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_rev
operator|=
name|rev
expr_stmt|;
return|return
name|is
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_checkicmpmatchingstate                                   */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we've got an ICMP error message, using the information stored in the  */
end_comment

begin_comment
comment|/* ICMP packet, look for a matching state table entry.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we return NULL then no lock on ipf_state is held.                     */
end_comment

begin_comment
comment|/* If we return non-null then a read-lock on ipf_state is held.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|fr_checkicmpmatchingstate
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_short
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|u_char
name|pr
decl_stmt|;
name|int
name|backward
decl_stmt|,
name|i
decl_stmt|,
name|oi
decl_stmt|;
name|i6addr_t
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|u_short
name|savelen
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|fr_info_t
name|ofin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|len
decl_stmt|;
name|ip_t
modifier|*
name|oip
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
comment|/* 	 * Does it at least have the return (basic) IP header ? 	 * Is it an actual recognised ICMP error type? 	 * Only a basic IP header (no options) should be with 	 * an ICMP error header. 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_v
operator|!=
literal|4
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_hlen
operator|!=
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMPERR_MINPKTLEN
operator|)
operator|||
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
condition|)
return|return
name|NULL
return|;
name|ic
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|type
operator|=
name|ic
operator|->
name|icmp_type
expr_stmt|;
name|oip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ic
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
comment|/* 	 * Check if the at least the old IP header (with options) and 	 * 8 bytes of payload is present. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMPERR_MAXPKTLEN
operator|+
operator|(
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|-
literal|5
operator|)
operator|<<
literal|2
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Sanity Checks. 	 */
name|len
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
name|ICMPERR_ICMPHLEN
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|>
name|len
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Is the buffer big enough for all of it ?  It's the size of the IP 	 * header claimed in the encapsulated part which is of concern.  It 	 * may be too big to be in this buffer but not so big that it's 	 * outside the ICMP packet, leading to TCP deref's causing problems. 	 * This is possible because we don't know how big oip_hl is when we 	 * do the pullup early in fr_check() and thus can't guarantee it is 	 * all here now. 	 */
ifdef|#
directive|ifdef
name|_KERNEL
block|{
name|mb_t
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|fin
operator|->
name|fin_m
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
name|len
operator|>
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|b_wptr
condition|)
return|return
name|NULL
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
name|len
operator|>
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|m
operator|->
name|m_len
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ofin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * in the IPv4 case we must zero the i6addr union otherwise 	 * the IP6_EQ and IP6_NEQ macros produce the wrong results because 	 * of the 'junk' in the unused part of the union 	 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * we make an fin entry to be able to feed it to 	 * matchsrcdst note that not all fields are encessary 	 * but this is the cleanest way. Note further we fill 	 * in fin_mp such that if someone uses it we'll get 	 * a kernel panic. fr_matchsrcdst does not use this. 	 * 	 * watch out here, as ip is in host order and oip in network 	 * order. Any change we make must be undone afterwards, like 	 * oip->ip_off - it is still in network byte order so fix it. 	 */
name|savelen
operator|=
name|oip
operator|->
name|ip_len
expr_stmt|;
name|oip
operator|->
name|ip_len
operator|=
name|len
expr_stmt|;
name|oip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|oip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|=
name|FI_NOCKSUM
expr_stmt|;
name|ofin
operator|.
name|fin_v
operator|=
literal|4
expr_stmt|;
name|ofin
operator|.
name|fin_ip
operator|=
name|oip
expr_stmt|;
name|ofin
operator|.
name|fin_m
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
name|ofin
operator|.
name|fin_mp
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
operator|(
name|void
operator|)
name|fr_makefrip
argument_list|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
argument_list|,
name|oip
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|ofin
operator|.
name|fin_out
operator|=
operator|!
name|fin
operator|->
name|fin_out
expr_stmt|;
comment|/* 	 * Reset the short and bad flag here because in fr_matchsrcdst() 	 * the flags for the current packet (fin_flx) are compared against 	 * those for the existing session. 	 */
name|ofin
operator|.
name|fin_flx
operator|&=
operator|~
operator|(
name|FI_BAD
operator||
name|FI_SHORT
operator|)
expr_stmt|;
comment|/* 	 * Put old values of ip_len and ip_off back as we don't know 	 * if we have to forward the packet (or process it again. 	 */
name|oip
operator|->
name|ip_len
operator|=
name|savelen
expr_stmt|;
name|oip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|oip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_ICMP
case|:
comment|/* 		 * an ICMP error can only be generated as a result of an 		 * ICMP query, not as the response on an ICMP error 		 * 		 * XXX theoretically ICMP_ECHOREP and the other reply's are 		 * ICMP query's as well, but adding them here seems strange XXX 		 */
if|if
condition|(
operator|(
name|ofin
operator|.
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 		 * perform a lookup of the ICMP packet in the state table 		 */
name|icmp
operator|=
operator|(
name|icmphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip
operator|->
name|ip_p
operator|)
expr_stmt|;
name|src
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|icmp
operator|->
name|icmp_id
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
literal|4
operator|)
condition|)
continue|continue;
if|if
condition|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
condition|)
continue|continue;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_ICMPCMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * i  : the index of this packet (the icmp 				 *      unreachable) 				 * oi : the index of the original packet found 				 *      in the icmp header (i.e. the packet 				 *      causing this icmp) 				 * backward : original packet was backward 				 *      compared to the state 				 */
name|backward
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
operator|!
name|backward
expr_stmt|;
name|i
operator|=
operator|(
operator|!
name|backward
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|oi
operator|=
operator|(
name|backward
operator|<<
literal|1
operator|)
operator|+
name|ofin
operator|.
name|fin_out
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|>
name|is
operator|->
name|is_pkts
index|[
name|oi
index|]
condition|)
continue|continue;
name|ips_stats
operator|.
name|iss_hits
operator|++
expr_stmt|;
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|++
expr_stmt|;
return|return
name|is
return|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
break|break;
default|default :
return|return
name|NULL
return|;
block|}
name|tcp
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|oip
operator|+
operator|(
name|IP_HL
argument_list|(
name|oip
argument_list|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|dport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|sport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip
operator|->
name|ip_p
operator|)
expr_stmt|;
name|src
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|.
name|in4
operator|=
name|oip
operator|->
name|ip_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
comment|/* 		 * Only allow this icmp though if the 		 * encapsulated packet was allowed through the 		 * other way around. Note that the minimal amount 		 * of info present does not allow for checking against 		 * tcp internals such as seq and ack numbers.   Only the 		 * ports are known to be present and can be even if the 		 * short flag is set. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|pr
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_v
operator|==
literal|4
operator|)
operator|&&
operator|(
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_ICMPCMP
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * i  : the index of this packet (the icmp unreachable) 			 * oi : the index of the original packet found in the 			 *      icmp header (i.e. the packet causing this icmp) 			 * backward : original packet was backward compared to 			 *            the state 			 */
name|backward
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_src
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
operator|!
name|backward
expr_stmt|;
name|i
operator|=
operator|(
operator|!
name|backward
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|oi
operator|=
operator|(
name|backward
operator|<<
literal|1
operator|)
operator|+
name|ofin
operator|.
name|fin_out
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|>
name|is
operator|->
name|is_pkts
index|[
name|oi
index|]
operator|)
condition|)
break|break;
name|ips_stats
operator|.
name|iss_hits
operator|++
expr_stmt|;
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* 			 * we deliberately do not touch the timeouts 			 * for the accompanying state table entry. 			 * It remains to be seen if that is correct. XXX 			 */
return|return
name|is
return|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ipsmove                                                  */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  is(I) - pointer to state table entry                        */
end_comment

begin_comment
comment|/*              hv(I) - new hash value for state table entry                */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a state entry from one position in the hash table to another.       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|fr_ipsmove
parameter_list|(
name|is
parameter_list|,
name|hv
parameter_list|)
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
block|{
name|ipstate_t
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_int
name|hvm
decl_stmt|;
name|ASSERT
argument_list|(
name|rw_read_locked
argument_list|(
operator|&
name|ipf_state
operator|.
name|ipf_lk
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hvm
operator|=
name|is
operator|->
name|is_hv
expr_stmt|;
comment|/* 	 * Remove the hash from the old location... 	 */
name|isp
operator|=
name|is
operator|->
name|is_phnext
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_hnext
condition|)
name|is
operator|->
name|is_hnext
operator|->
name|is_phnext
operator|=
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
name|ips_table
index|[
name|hvm
index|]
operator|==
name|NULL
condition|)
name|ips_stats
operator|.
name|iss_inuse
operator|--
expr_stmt|;
name|ips_stats
operator|.
name|iss_bucketlen
index|[
name|hvm
index|]
operator|--
expr_stmt|;
comment|/* 	 * ...and put the hash in the new one. 	 */
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_hv
operator|=
name|hvm
expr_stmt|;
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hvm
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|isp
condition|)
operator|(
operator|*
name|isp
operator|)
operator|->
name|is_phnext
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
else|else
name|ips_stats
operator|.
name|iss_inuse
operator|++
expr_stmt|;
name|ips_stats
operator|.
name|iss_bucketlen
index|[
name|hvm
index|]
operator|++
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|isp
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
operator|*
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|is
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stlookup                                                 */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == no matching state found,               */
end_comment

begin_comment
comment|/*                           else pointer to state information is returned  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              tcp(I) - pointer to TCP/UDP header.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search the state table for a matching entry to the packet described by   */
end_comment

begin_comment
comment|/* the contents of *fin.                                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we return NULL then no lock on ipf_state is held.                     */
end_comment

begin_comment
comment|/* If we return non-null then a read-lock on ipf_state is held.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipstate_t
modifier|*
name|fr_stlookup
parameter_list|(
name|fin
parameter_list|,
name|tcp
parameter_list|,
name|ifqp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipftq_t
modifier|*
modifier|*
name|ifqp
decl_stmt|;
block|{
name|u_int
name|hv
decl_stmt|,
name|hvm
decl_stmt|,
name|pr
decl_stmt|,
name|v
decl_stmt|,
name|tryagain
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_short
name|dport
decl_stmt|,
name|sport
decl_stmt|;
name|i6addr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|struct
name|icmp
modifier|*
name|ic
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|int
name|oow
decl_stmt|;
name|is
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|=
name|NULL
expr_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|ic
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|tcp
expr_stmt|;
name|hv
operator|=
operator|(
name|pr
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|)
expr_stmt|;
name|src
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
expr_stmt|;
name|dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|v
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_v
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_ICMPV6
operator|)
operator|&&
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|in6
argument_list|)
condition|)
block|{
name|hv
operator|-=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Search the hash table for matching packet header info. 	 */
switch|switch
condition|(
name|pr
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
name|tryagain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
operator|(
name|ic
operator|->
name|icmp_type
operator|==
name|ICMP6_ECHO_REQUEST
operator|)
operator|||
operator|(
name|ic
operator|->
name|icmp_type
operator|==
name|ICMP6_ECHO_REPLY
operator|)
condition|)
block|{
name|hv
operator|+=
name|ic
operator|->
name|icmp_id
expr_stmt|;
block|}
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|icmp6again
label|:
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
comment|/* 			 * If a connection is about to be deleted, no packets 			 * are allowed to match it. 			 */
if|if
condition|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|==
operator|&
name|ips_deletetq
condition|)
continue|continue;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
operator|&&
name|fr_matchicmpqueryreply
argument_list|(
name|v
argument_list|,
operator|&
name|is
operator|->
name|is_icmp
argument_list|,
name|ic
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|ips_icmpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|ips_icmptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tryagain
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_W_DADDR
operator|)
condition|)
block|{
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|fr_ipsmove
argument_list|(
name|is
argument_list|,
name|hv
argument_list|)
expr_stmt|;
name|MUTEX_DOWNGRADE
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
comment|/* 		 * No matching icmp state entry. Perhaps this is a 		 * response to another state entry. 		 * 		 * XXX With some ICMP6 packets, the "other" address is already 		 * in the packet, after the ICMP6 header, and this could be 		 * used in place of the multicast address.  However, taking 		 * advantage of this requires some significant code changes 		 * to handle the specific types where that is the case. 		 */
if|if
condition|(
operator|(
name|ips_stats
operator|.
name|iss_wild
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|v
operator|==
literal|6
operator|)
operator|&&
operator|(
name|tryagain
operator|==
literal|0
operator|)
operator|&&
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|in6
argument_list|)
condition|)
block|{
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|-=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|tryagain
operator|=
literal|1
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
goto|goto
name|icmp6again
goto|;
block|}
name|is
operator|=
name|fr_checkicmp6matchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
name|is
return|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
name|hv
operator|+=
name|ic
operator|->
name|icmp_id
expr_stmt|;
block|}
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ic
operator|->
name|icmp_id
operator|==
name|is
operator|->
name|is_icmp
operator|.
name|ici_id
operator|)
operator|&&
name|fr_matchicmpqueryreply
argument_list|(
name|v
argument_list|,
operator|&
name|is
operator|->
name|is_icmp
argument_list|,
name|ic
argument_list|,
name|fin
operator|->
name|fin_rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|ips_icmpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|ips_icmptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
name|ifqp
operator|=
name|NULL
expr_stmt|;
name|sport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
name|dport
operator|=
name|htons
argument_list|(
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hv
operator|+=
name|dport
expr_stmt|;
name|oow
operator|=
literal|0
expr_stmt|;
name|tryagain
operator|=
literal|0
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|retry_tcpudp
label|:
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|fin
operator|->
name|fin_flx
operator|&=
operator|~
name|FI_OOW
expr_stmt|;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pr
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
operator|!
name|fr_tcpstate
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
name|is
argument_list|)
condition|)
block|{
name|oow
operator||=
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tryagain
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_CLONE
operator||
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
operator|)
condition|)
block|{
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
name|fr_ipsmove
argument_list|(
name|is
argument_list|,
name|hv
argument_list|)
expr_stmt|;
name|MUTEX_DOWNGRADE
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tryagain
operator|&&
name|ips_stats
operator|.
name|iss_wild
condition|)
block|{
name|hv
operator|-=
name|dport
expr_stmt|;
name|hv
operator|-=
name|sport
expr_stmt|;
name|tryagain
operator|=
literal|1
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
goto|goto
name|retry_tcpudp
goto|;
block|}
name|fin
operator|->
name|fin_flx
operator||=
name|oow
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case IPPROTO_GRE : 		gre = fin->fin_dp; 		if (GRE_REV(gre->gr_flags) == 1) { 			hv += gre->gr_call; 		}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default :
name|ifqp
operator|=
name|NULL
expr_stmt|;
name|hvm
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hvm
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
name|v
operator|)
condition|)
continue|continue;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_CMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
name|ifq
operator|=
operator|&
name|ips_iptq
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
operator|!=
name|NULL
operator|)
condition|)
name|ifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
operator|&&
name|ifqp
operator|!=
name|NULL
condition|)
operator|*
name|ifqp
operator|=
name|ifq
expr_stmt|;
block|}
return|return
name|is
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_updatestate                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              is(I)  - pointer to state table entry                       */
end_comment

begin_comment
comment|/* Read Locks:  ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Updates packet and byte counters for a newly received packet.  Seeds the */
end_comment

begin_comment
comment|/* fragment cache with a new entry as required.                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_updatestate
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|,
name|ifq
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
block|{
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pass
decl_stmt|;
name|i
operator|=
operator|(
name|fin
operator|->
name|fin_rev
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
comment|/* 	 * For TCP packets, ifq == NULL.  For all others, check if this new 	 * queue is different to the last one it was on and move it if so. 	 */
name|tqe
operator|=
operator|&
name|is
operator|->
name|is_sti
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tqe
operator|->
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
condition|)
name|ifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
condition|)
name|fr_movequeue
argument_list|(
name|tqe
argument_list|,
name|tqe
operator|->
name|tqe_ifq
argument_list|,
name|ifq
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_pkts
index|[
name|i
index|]
operator|++
expr_stmt|;
name|is
operator|->
name|is_bytes
index|[
name|i
index|]
operator|+=
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|IS_STATESYNC
condition|)
name|ipfsync_update
argument_list|(
name|SMC_STATE
argument_list|,
name|fin
argument_list|,
name|is
operator|->
name|is_sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_hits
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
comment|/* 	 * If this packet is a fragment and the rule says to track fragments, 	 * then create a new fragment cache entry. 	 */
name|pass
operator|=
name|is
operator|->
name|is_pass
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|)
operator|&&
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fr_newfrag
argument_list|(
name|fin
argument_list|,
name|pass
operator|^
name|FR_KEEPSTATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_checkstate                                               */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - NULL == search failed,                         */
end_comment

begin_comment
comment|/*                           else pointer to rule for matching state        */
end_comment

begin_comment
comment|/* Parameters:  ifp(I)   - pointer to interface                             */
end_comment

begin_comment
comment|/*              passp(I) - pointer to filtering result flags                */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if a packet is associated with an entry in the state table.        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_checkstate
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|u_int
name|pass
decl_stmt|;
if|if
condition|(
name|fr_state_lock
operator|||
operator|(
name|ips_list
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_SHORT
operator||
name|FI_STATE
operator||
name|FI_FRAGBODY
operator||
name|FI_BAD
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
name|is
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_TCPUDP
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|==
name|IPPROTO_ICMP
operator|)
ifdef|#
directive|ifdef
name|USE_INET6
operator|||
operator|(
name|fin
operator|->
name|fin_fi
operator|.
name|fi_p
operator|==
name|IPPROTO_ICMPV6
operator|)
endif|#
directive|endif
condition|)
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
else|else
name|tcp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Search the hash table for matching packet header info. 	 */
name|ifq
operator|=
name|NULL
expr_stmt|;
name|is
operator|=
name|fin
operator|->
name|fin_state
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
name|is
operator|=
name|fr_stlookup
argument_list|(
name|fin
argument_list|,
name|tcp
argument_list|,
operator|&
name|ifq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fin
operator|->
name|fin_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
block|{
name|is
operator|=
name|fr_checkicmp6matchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
goto|goto
name|matched
goto|;
block|}
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * No matching icmp state entry. Perhaps this is a 		 * response to another state entry. 		 */
name|is
operator|=
name|fr_checkicmpmatchingstate
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
goto|goto
name|matched
goto|;
break|break;
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NEWISN
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
name|fr_fixinisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|1
condition|)
name|fr_fixoutisn
argument_list|(
name|fin
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
if|if
condition|(
name|fin
operator|->
name|fin_rev
condition|)
name|ifq
operator|=
operator|&
name|ips_udpacktq
expr_stmt|;
else|else
name|ifq
operator|=
operator|&
name|ips_udptq
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_miss
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|matched
label|:
name|fr
operator|=
name|is
operator|->
name|is_rule
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fr_matchtag
argument_list|(
operator|&
name|fr
operator|->
name|fr_nattag
argument_list|,
name|fin
operator|->
name|fin_nattag
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|fr
operator|->
name|fr_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_icode
operator|=
name|fr
operator|->
name|fr_icode
expr_stmt|;
block|}
name|fin
operator|->
name|fin_rule
operator|=
name|is
operator|->
name|is_rulen
expr_stmt|;
name|pass
operator|=
name|is
operator|->
name|is_pass
expr_stmt|;
name|fr_updatestate
argument_list|(
name|fin
argument_list|,
name|is
argument_list|,
name|ifq
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_state
operator|=
name|is
expr_stmt|;
name|is
operator|->
name|is_touched
operator|=
name|fr_ticks
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_STATE
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGFIRST
operator|)
operator|!=
literal|0
condition|)
name|pass
operator|&=
operator|~
operator|(
name|FR_LOGFIRST
operator||
name|FR_LOG
operator|)
expr_stmt|;
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_fixoutisn                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called only for outbound packets, adjusts the sequence number and the    */
end_comment

begin_comment
comment|/* TCP checksum to match that change.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|fr_fixoutisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|u_32_t
name|seq
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rev
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|seq
operator|+=
name|is
operator|->
name|is_isninc
index|[
literal|0
index|]
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fix_outcksum
argument_list|(
name|fin
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|seq
operator|+=
name|is
operator|->
name|is_isninc
index|[
literal|1
index|]
expr_stmt|;
name|tcp
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|fix_outcksum
argument_list|(
name|fin
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_fixinisn                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              is(I)  - pointer to master state structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Called only for inbound packets, adjusts the acknowledge number and the  */
end_comment

begin_comment
comment|/* TCP checksum to match that change.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|fr_fixinisn
parameter_list|(
name|fin
parameter_list|,
name|is
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|u_32_t
name|ack
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rev
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNSYN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|ack
operator|-=
name|is
operator|->
name|is_isninc
index|[
literal|0
index|]
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ack
argument_list|)
expr_stmt|;
name|fix_incksum
argument_list|(
name|fin
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|IS_ISNACK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
block|{
name|ack
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_ack
argument_list|)
expr_stmt|;
name|ack
operator|-=
name|is
operator|->
name|is_isninc
index|[
literal|1
index|]
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ack
argument_list|)
expr_stmt|;
name|fix_incksum
argument_list|(
name|fin
argument_list|,
operator|&
name|tcp
operator|->
name|th_sum
argument_list|,
name|is
operator|->
name|is_sumd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_statesync                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  ifp(I) - pointer to interface                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk through all state entries and if an interface pointer match is      */
end_comment

begin_comment
comment|/* found then look it up again, based on its name in case the pointer has   */
end_comment

begin_comment
comment|/* changed since last time.                                                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If ifp is passed in as being non-null then we are only doing updates for */
end_comment

begin_comment
comment|/* existing, matching, uses of it.                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_statesync
parameter_list|(
name|ifp
parameter_list|)
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
return|return;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|is
operator|=
name|ips_list
init|;
name|is
condition|;
name|is
operator|=
name|is
operator|->
name|is_next
control|)
block|{
comment|/* 		 * Look up all the interface names in the state entry. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
condition|)
name|is
operator|->
name|is_ifp
index|[
name|i
index|]
operator|=
name|fr_resolvenic
argument_list|(
name|is
operator|->
name|is_ifname
index|[
name|i
index|]
argument_list|,
name|is
operator|->
name|is_v
argument_list|)
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_delstate                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 = entry deleted, else reference count on struct     */
end_comment

begin_comment
comment|/* Parameters:  is(I)  - pointer to state structure to delete               */
end_comment

begin_comment
comment|/*              why(I) - if not 0, log reason why it was deleted            */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Deletes a state entry from the enumerated list as well as the hash table */
end_comment

begin_comment
comment|/* and timeout queue lists.  Make adjustments to hash table statistics and  */
end_comment

begin_comment
comment|/* global counters as required.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_delstate
parameter_list|(
name|is
parameter_list|,
name|why
parameter_list|)
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|why
decl_stmt|;
block|{
name|ASSERT
argument_list|(
name|rw_read_locked
argument_list|(
operator|&
name|ipf_state
operator|.
name|ipf_lk
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Since we want to delete this, remove it from the state table, 	 * where it can be found& used, first. 	 */
if|if
condition|(
name|is
operator|->
name|is_phnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_phnext
operator|=
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_hnext
operator|!=
name|NULL
condition|)
name|is
operator|->
name|is_hnext
operator|->
name|is_phnext
operator|=
name|is
operator|->
name|is_phnext
expr_stmt|;
if|if
condition|(
name|ips_table
index|[
name|is
operator|->
name|is_hv
index|]
operator|==
name|NULL
condition|)
name|ips_stats
operator|.
name|iss_inuse
operator|--
expr_stmt|;
name|ips_stats
operator|.
name|iss_bucketlen
index|[
name|is
operator|->
name|is_hv
index|]
operator|--
expr_stmt|;
name|is
operator|->
name|is_phnext
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_hnext
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Because ips_stats.iss_wild is a count of entries in the state 	 * table that have wildcard flags set, only decerement it once 	 * and do it here. 	 */
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SI_CLONED
operator|)
condition|)
block|{
name|ATOMIC_DECL
argument_list|(
name|ips_stats
operator|.
name|iss_wild
argument_list|)
expr_stmt|;
block|}
name|is
operator|->
name|is_flags
operator|&=
operator|~
operator|(
name|SI_WILDP
operator||
name|SI_WILDA
operator|)
expr_stmt|;
block|}
comment|/* 	 * Next, remove it from the timeout queue it is in. 	 */
if|if
condition|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
operator|!=
name|NULL
condition|)
name|fr_deletequeueentry
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_me
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_me
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If it is still in use by something else, do not go any further, 	 * but note that at this point it is now an orphan.  How can this 	 * be?  fr_state_flush() calls fr_delete() directly because it wants 	 * to empty the table out and if something has a hold on a state 	 * entry (such as ipfstat), it'll do the deref path that'll bring 	 * us back here to do the real delete& free. 	 */
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_ref
operator|>
literal|0
condition|)
return|return
name|is
operator|->
name|is_ref
return|;
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fr_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
name|fr_freetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fr_deletetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|fr_freetimeoutqueue
argument_list|(
name|is
operator|->
name|is_tqehead
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
if|if
condition|(
name|is
operator|->
name|is_sync
condition|)
name|ipfsync_del
argument_list|(
name|is
operator|->
name|is_sync
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
operator|(
name|void
operator|)
name|ipsc_detachis
argument_list|(
name|is
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now remove it from the linked list of known states 	 */
if|if
condition|(
name|is
operator|->
name|is_pnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|is
operator|->
name|is_pnext
operator|=
name|is
operator|->
name|is_next
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_next
operator|!=
name|NULL
condition|)
name|is
operator|->
name|is_next
operator|->
name|is_pnext
operator|=
name|is
operator|->
name|is_pnext
expr_stmt|;
name|is
operator|->
name|is_pnext
operator|=
name|NULL
expr_stmt|;
name|is
operator|->
name|is_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ipstate_logging
operator|!=
literal|0
operator|&&
name|why
operator|!=
literal|0
condition|)
name|ipstate_log
argument_list|(
name|is
argument_list|,
name|why
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|==
name|IPPROTO_TCP
condition|)
name|ips_stats
operator|.
name|iss_fin
operator|++
expr_stmt|;
else|else
name|ips_stats
operator|.
name|iss_expire
operator|++
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_rule
operator|!=
name|NULL
condition|)
block|{
name|is
operator|->
name|is_rule
operator|->
name|fr_statecnt
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|fr_derefrule
argument_list|(
operator|&
name|is
operator|->
name|is_rule
argument_list|)
expr_stmt|;
block|}
name|MUTEX_DESTROY
argument_list|(
operator|&
name|is
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|ips_num
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_timeoutstate                                             */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Slowly expire held state for thingslike UDP and ICMP.  The algorithm     */
end_comment

begin_comment
comment|/* used here is to keep the queue sorted with the oldest things at the top  */
end_comment

begin_comment
comment|/* and the youngest at the bottom.  So if the top one doesn't need to be    */
end_comment

begin_comment
comment|/* expired then neither will any under it.                                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_timeoutstate
parameter_list|()
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|,
modifier|*
name|tqn
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|ifq
operator|=
name|ips_tqtqb
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tqe
operator|->
name|tqe_die
operator|>
name|fr_ticks
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ifq
operator|=
name|ips_utqe
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tqe
operator|->
name|tqe_die
operator|>
name|fr_ticks
condition|)
break|break;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ifq
operator|=
name|ips_utqe
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_DELETE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifq
operator|->
name|ifq_ref
operator|==
literal|0
operator|)
condition|)
block|{
name|fr_freetimeoutqueue
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fr_state_doflush
condition|)
block|{
operator|(
name|void
operator|)
name|fr_state_flush
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fr_state_doflush
operator|=
literal|0
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_state_flush                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == failure                           */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Flush state tables.  Three actions currently defined:                    */
end_comment

begin_comment
comment|/* which == 0 : flush all state table entries                               */
end_comment

begin_comment
comment|/* which == 1 : flush TCP connections which have started to close but are   */
end_comment

begin_comment
comment|/*	      stuck for some reason.                                        */
end_comment

begin_comment
comment|/* which == 2 : flush TCP connections which have been idle for a long time, */
end_comment

begin_comment
comment|/*	      starting at> 4 days idle and working back in successive half-*/
end_comment

begin_comment
comment|/*	      days to at most 12 hours old.  If this fails to free enough   */
end_comment

begin_comment
comment|/*            slots then work backwards in half hour slots to 30 minutes.   */
end_comment

begin_comment
comment|/*            If that too fails, then work backwards in 30 second intervals */
end_comment

begin_comment
comment|/*            for the last 30 minutes to at worst 30 seconds idle.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_state_flush
parameter_list|(
name|which
parameter_list|,
name|proto
parameter_list|)
name|int
name|which
decl_stmt|,
name|proto
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|,
modifier|*
name|ifqnext
decl_stmt|;
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|,
modifier|*
name|tqn
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|int
name|removed
decl_stmt|;
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|0
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Style 0 flush removes everything... 		 */
for|for
control|(
name|isp
operator|=
operator|&
name|ips_list
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|proto
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_v
operator|!=
name|proto
operator|)
condition|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
else|else
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* 		 * Since we're only interested in things that are closing, 		 * we can start with the appropriate timeout queue. 		 */
for|for
control|(
name|ifq
operator|=
name|ips_tqtqb
operator|+
name|IPF_TCPS_CLOSE_WAIT
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|!=
name|IPPROTO_TCP
condition|)
break|break;
if|if
condition|(
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Also need to look through the user defined queues. 		 */
for|for
control|(
name|ifq
operator|=
name|ips_utqe
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifqnext
control|)
block|{
name|ifqnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
for|for
control|(
name|tqn
operator|=
name|ifq
operator|->
name|ifq_head
init|;
operator|(
operator|(
name|tqe
operator|=
name|tqn
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_p
operator|!=
name|IPPROTO_TCP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|is
operator|->
name|is_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|&&
operator|(
name|is
operator|->
name|is_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
if|if
condition|(
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|2
case|:
break|break;
comment|/*   		 * Args 5-11 correspond to flushing those particular states 		 * for TCP connections. 		 */
case|case
name|IPF_TCPS_CLOSE_WAIT
case|:
case|case
name|IPF_TCPS_FIN_WAIT_1
case|:
case|case
name|IPF_TCPS_CLOSING
case|:
case|case
name|IPF_TCPS_LAST_ACK
case|:
case|case
name|IPF_TCPS_FIN_WAIT_2
case|:
case|case
name|IPF_TCPS_TIME_WAIT
case|:
case|case
name|IPF_TCPS_CLOSED
case|:
name|tqn
operator|=
name|ips_tqtqb
index|[
name|which
index|]
operator|.
name|ifq_head
expr_stmt|;
while|while
condition|(
name|tqn
operator|!=
name|NULL
condition|)
block|{
name|tqe
operator|=
name|tqn
expr_stmt|;
name|tqn
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|is
operator|=
name|tqe
operator|->
name|tqe_parent
expr_stmt|;
if|if
condition|(
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
name|removed
operator|++
expr_stmt|;
block|}
break|break;
default|default :
if|if
condition|(
name|which
operator|<
literal|30
condition|)
break|break;
comment|/*  		 * Take a large arbitrary number to mean the number of seconds 		 * for which which consider to be the maximum value we'll allow 		 * the expiration to be. 		 */
name|which
operator|=
name|IPF_TTLVAL
argument_list|(
name|which
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_list
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|proto
operator|==
literal|0
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|==
name|proto
operator|)
condition|)
block|{
if|if
condition|(
name|fr_ticks
operator|-
name|is
operator|->
name|is_touched
operator|>
name|which
condition|)
block|{
if|if
condition|(
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_FLUSH
argument_list|)
operator|==
literal|0
condition|)
block|{
name|removed
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|isp
operator|=
operator|&
name|is
operator|->
name|is_next
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|which
operator|!=
literal|2
condition|)
block|{
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|removed
return|;
block|}
comment|/* 	 * Asked to remove inactive entries because the table is full. 	 */
if|if
condition|(
name|fr_ticks
operator|-
name|ips_last_force_flush
operator|>
name|IPF_TTLVAL
argument_list|(
literal|5
argument_list|)
condition|)
block|{
name|ips_last_force_flush
operator|=
name|fr_ticks
expr_stmt|;
name|removed
operator|=
name|ipf_queueflush
argument_list|(
name|fr_state_flush_entry
argument_list|,
name|ips_tqtqb
argument_list|,
name|ips_utqe
argument_list|)
expr_stmt|;
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|removed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_state_flush_entry                                        */
end_comment

begin_comment
comment|/* Returns:     int - 0 = entry deleted, else not deleted                   */
end_comment

begin_comment
comment|/* Parameters:  entry(I)  - pointer to state structure to delete            */
end_comment

begin_comment
comment|/* Write Locks: ipf_state                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is a stepping stone between ipf_queueflush() and           */
end_comment

begin_comment
comment|/* fr_delstate().  It is used so we can provide a uniform interface via the */
end_comment

begin_comment
comment|/* ipf_queueflush() function.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_state_flush_entry
parameter_list|(
name|entry
parameter_list|)
name|void
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|fr_delstate
argument_list|(
name|entry
argument_list|,
name|ISL_FLUSH
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_tcp_age                                                  */
end_comment

begin_comment
comment|/* Returns:     int - 1 == state transition made, 0 == no change (rejected) */
end_comment

begin_comment
comment|/* Parameters:  tq(I)    - pointer to timeout queue information             */
end_comment

begin_comment
comment|/*              fin(I)   - pointer to packet information                    */
end_comment

begin_comment
comment|/*              tqtab(I) - TCP timeout queue table this is in               */
end_comment

begin_comment
comment|/*              flags(I) - flags from state/NAT entry                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Rewritten by Arjan de Vet<Arjan.deVet@adv.iae.nl>, 2000-07-29:          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - (try to) base state transitions on real evidence only,                 */
end_comment

begin_comment
comment|/*   i.e. packets that are sent and have been received by ipfilter;         */
end_comment

begin_comment
comment|/*   diagram 18.12 of TCP/IP volume 1 by W. Richard Stevens was used.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - deal with half-closed connections correctly;                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* - store the state of the source in state[0] such that ipfstat            */
end_comment

begin_comment
comment|/*   displays the state as source/dest instead of dest/source; the calls    */
end_comment

begin_comment
comment|/*   to fr_tcp_age have been changed accordingly.                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Internal Parameters:                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    state[0] = state of source (host that initiated connection)           */
end_comment

begin_comment
comment|/*    state[1] = state of dest   (host that accepted the connection)        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    dir == 0 : a packet from source to dest                               */
end_comment

begin_comment
comment|/*    dir == 1 : a packet from dest to source                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* A typical procession for a connection is as follows:                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/* | Side '0'     | Side '1'          |                                     */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/* | 0 -> 1 (SYN) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 0 -> 2 (SYN-ACK)  |                                     */
end_comment

begin_comment
comment|/* | 1 -> 3 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 2 -> 4 (ACK-PUSH) |                                     */
end_comment

begin_comment
comment|/* | 3 -> 4 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |   ...        |   ...             |                                     */
end_comment

begin_comment
comment|/* |              | 4 -> 6 (FIN-ACK)  |                                     */
end_comment

begin_comment
comment|/* | 4 -> 5 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 6 -> 6 (ACK-PUSH) |                                     */
end_comment

begin_comment
comment|/* | 5 -> 5 (ACK) |                   |                                     */
end_comment

begin_comment
comment|/* | 5 -> 8 (FIN) |                   |                                     */
end_comment

begin_comment
comment|/* |              | 6 -> 10 (ACK)     |                                     */
end_comment

begin_comment
comment|/* +--------------+-------------------+                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking: it is assumed that the parent of the tqe structure is locked.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_tcp_age
parameter_list|(
name|tqe
parameter_list|,
name|fin
parameter_list|,
name|tqtab
parameter_list|,
name|flags
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|ipftq_t
modifier|*
name|tqtab
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|dlen
decl_stmt|,
name|ostate
decl_stmt|,
name|nstate
decl_stmt|,
name|rval
decl_stmt|,
name|dir
decl_stmt|;
name|u_char
name|tcpflags
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
name|fin
operator|->
name|fin_rev
expr_stmt|;
name|tcpflags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|dlen
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
operator|(
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_RST
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tcpflags
operator|&
name|TH_PUSH
operator|)
operator|&&
operator|!
name|dlen
condition|)
name|nstate
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
else|else
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ostate
operator|=
name|tqe
operator|->
name|tqe_state
index|[
literal|1
operator|-
name|dir
index|]
expr_stmt|;
name|nstate
operator|=
name|tqe
operator|->
name|tqe_state
index|[
name|dir
index|]
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
comment|/* 0 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * 'dir' received an S and sends SA in 				 * response, LISTEN -> SYN_RECEIVED 				 */
name|nstate
operator|=
name|IPF_TCPS_SYN_RECEIVED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_SYN
condition|)
block|{
comment|/* 'dir' sent S, LISTEN -> SYN_SENT */
name|nstate
operator|=
name|IPF_TCPS_SYN_SENT
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * the next piece of code makes it possible to get 			 * already established connections into the state table 			 * after a restart or reload of the filter rules; this 			 * does not work when a strict 'flags S keep state' is 			 * used for tcp connections of course 			 */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|IS_TCPFSM
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tcpflags
operator|&
name|TH_ACKMASK
operator|)
operator|==
name|TH_ACK
operator|)
condition|)
block|{
comment|/* 				 * we saw an A, guess 'dir' is in ESTABLISHED 				 * mode 				 */
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
name|nstate
operator|=
name|IPF_TCPS_HALF_ESTAB
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
case|case
name|IPF_TCPS_ESTABLISHED
case|:
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
comment|/* 			 * TODO: besides regular ACK packets we can have other 			 * packets as well; it is yet to be determined how we 			 * should initialize the states in those cases 			 */
break|break;
case|case
name|IPF_TCPS_SYN_SENT
case|:
comment|/* 1 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|~
operator|(
name|TH_ECN
operator||
name|TH_CWR
operator|)
operator|)
operator|==
name|TH_SYN
condition|)
block|{
comment|/* 				 * A retransmitted SYN packet.  We do not reset 				 * the timeout here to fr_tcptimeout because a 				 * connection connect timeout does not renew 				 * after every packet that is sent.  We need to 				 * set rval so as to indicate the packet has 				 * passed the check for its flags being valid 				 * in the TCP FSM.  Setting rval to 2 has the 				 * result of not resetting the timeout. 				 */
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * we see an A from 'dir' which is in SYN_SENT 				 * state: 'dir' sent an A in response to an SA 				 * which it received, SYN_SENT -> ESTABLISHED 				 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * we see an F from 'dir' which is in SYN_SENT 				 * state and wants to close its side of the 				 * connection; SYN_SENT -> FIN_WAIT_1 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_OPENING
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * we see an SA from 'dir' which is already in 				 * SYN_SENT state, this means we have a 				 * simultaneous open; SYN_SENT -> SYN_RECEIVED 				 */
name|nstate
operator|=
name|IPF_TCPS_SYN_RECEIVED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
comment|/* 2 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * we see an A from 'dir' which was in 				 * SYN_RECEIVED state so it must now be in 				 * established state, SYN_RECEIVED -> 				 * ESTABLISHED 				 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|~
operator|(
name|TH_ECN
operator||
name|TH_CWR
operator|)
operator|)
operator|==
name|TH_OPENING
condition|)
block|{
comment|/* 				 * We see an SA from 'dir' which is already in 				 * SYN_RECEIVED state. 				 */
name|rval
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * we see an F from 'dir' which is in 				 * SYN_RECEIVED state and wants to close its 				 * side of the connection; SYN_RECEIVED -> 				 * FIN_WAIT_1 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
comment|/* 3 */
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_ACKMASK
operator|)
operator|==
name|TH_ACK
condition|)
block|{
comment|/* 				 * If we've picked up a connection in mid 				 * flight, we could be looking at a follow on 				 * packet from the same direction as the one 				 * that created this state.  Recognise it but 				 * do not advance the entire connection's 				 * state. 				 */
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IPF_TCPS_LISTEN
case|:
case|case
name|IPF_TCPS_SYN_SENT
case|:
case|case
name|IPF_TCPS_SYN_RECEIVED
case|:
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_HALF_ESTAB
case|:
case|case
name|IPF_TCPS_ESTABLISHED
case|:
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
break|break;
case|case
name|IPF_TCPS_ESTABLISHED
case|:
comment|/* 4 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * 'dir' closed its side of the connection; 				 * this gives us a half-closed connection; 				 * ESTABLISHED -> FIN_WAIT_1 				 */
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_FIN_WAIT_1
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_CLOSING
expr_stmt|;
block|}
else|else
block|{
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tcpflags
operator|&
name|TH_ACK
condition|)
block|{
comment|/* 				 * an ACK, should we exclude other flags here? 				 */
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_FIN_WAIT_1
condition|)
block|{
comment|/* 					 * We know the other side did an active 					 * close, so we are ACKing the recvd 					 * FIN packet (does the window matching 					 * code guarantee this?) and go into 					 * CLOSE_WAIT state; this gives us a 					 * half-closed connection 					 */
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ostate
operator|<
name|IPF_TCPS_CLOSE_WAIT
condition|)
block|{
comment|/* 					 * still a fully established 					 * connection reset timeout 					 */
name|nstate
operator|=
name|IPF_TCPS_ESTABLISHED
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IPF_TCPS_CLOSE_WAIT
case|:
comment|/* 5 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tcpflags
operator|&
name|TH_FIN
condition|)
block|{
comment|/* 				 * application closed and 'dir' sent a FIN, 				 * we're now going into LAST_ACK state 				 */
name|nstate
operator|=
name|IPF_TCPS_LAST_ACK
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we remain in CLOSE_WAIT because the other 				 * side has closed already and we did not 				 * close our side yet; reset timeout 				 */
name|nstate
operator|=
name|IPF_TCPS_CLOSE_WAIT
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_FIN_WAIT_1
case|:
comment|/* 6 */
name|rval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_ACK
operator|)
operator|&&
name|ostate
operator|>
name|IPF_TCPS_CLOSE_WAIT
condition|)
block|{
comment|/* 				 * if the other side is not active anymore 				 * it has sent us a FIN packet that we are 				 * ack'ing now with an ACK; this means both 				 * sides have now closed the connection and 				 * we go into TIME_WAIT 				 */
comment|/* 				 * XXX: how do we know we really are ACKing 				 * the FIN packet here? does the window code 				 * guarantee that? 				 */
name|nstate
operator|=
name|IPF_TCPS_TIME_WAIT
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we closed our side of the connection 				 * already but the other side is still active 				 * (ESTABLISHED/CLOSE_WAIT); continue with 				 * this half-closed connection 				 */
name|nstate
operator|=
name|IPF_TCPS_FIN_WAIT_1
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_CLOSING
case|:
comment|/* 7 */
if|if
condition|(
operator|(
name|tcpflags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_TIME_WAIT
expr_stmt|;
block|}
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPF_TCPS_LAST_ACK
case|:
comment|/* 8 */
if|if
condition|(
name|tcpflags
operator|&
name|TH_ACK
condition|)
block|{
if|if
condition|(
operator|(
name|tcpflags
operator|&
name|TH_PUSH
operator|)
operator|||
name|dlen
condition|)
comment|/* 					 * there is still data to be delivered, 					 * reset timeout 					 */
name|rval
operator|=
literal|1
expr_stmt|;
else|else
name|rval
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 			 * we cannot detect when we go out of LAST_ACK state to 			 * CLOSED because that is based on the reception of ACK 			 * packets; ipfilter can only detect that a packet 			 * has been sent by a host 			 */
break|break;
case|case
name|IPF_TCPS_FIN_WAIT_2
case|:
comment|/* 9 */
comment|/* NOT USED */
if|#
directive|if
literal|0
block|rval = 1; 			if ((tcpflags& TH_OPENING) == TH_OPENING) { 				nstate = IPF_TCPS_SYN_RECEIVED; 			} else if (tcpflags& TH_SYN) { 				nstate = IPF_TCPS_SYN_SENT; 			} else if ((tcpflags& (TH_FIN|TH_ACK)) != 0) { 				nstate = IPF_TCPS_TIME_WAIT; 			}
endif|#
directive|endif
break|break;
case|case
name|IPF_TCPS_TIME_WAIT
case|:
comment|/* 10 */
comment|/* we're in 2MSL timeout now */
name|rval
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ostate
operator|==
name|IPF_TCPS_LAST_ACK
condition|)
block|{
name|nstate
operator|=
name|IPF_TCPS_CLOSED
expr_stmt|;
block|}
break|break;
case|case
name|IPF_TCPS_CLOSED
case|:
comment|/* 11 */
name|rval
operator|=
literal|2
expr_stmt|;
break|break;
default|default :
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|#
directive|if
name|SOLARIS
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"tcp %lx flags %x si %lx nstate %d ostate %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|tcp
argument_list|,
name|tcpflags
argument_list|,
operator|(
name|u_long
operator|)
name|tqe
argument_list|,
name|nstate
argument_list|,
name|ostate
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"tcp %lx flags %x si %lx nstate %d ostate %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|tcp
argument_list|,
name|tcpflags
argument_list|,
operator|(
name|u_long
operator|)
name|tqe
argument_list|,
name|nstate
argument_list|,
name|ostate
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 	 * If rval == 2 then do not update the queue position, but treat the 	 * packet as being ok. 	 */
if|if
condition|(
name|rval
operator|==
literal|2
condition|)
name|rval
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
literal|1
condition|)
block|{
name|tqe
operator|->
name|tqe_state
index|[
name|dir
index|]
operator|=
name|nstate
expr_stmt|;
if|if
condition|(
operator|(
name|tqe
operator|->
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|==
literal|0
condition|)
name|fr_movequeue
argument_list|(
name|tqe
argument_list|,
name|tqe
operator|->
name|tqe_ifq
argument_list|,
name|tqtab
operator|+
name|nstate
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipstate_log                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  is(I)   - pointer to state structure                        */
end_comment

begin_comment
comment|/*              type(I) - type of log entry to create                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Creates a state table log entry using the state structure and type info. */
end_comment

begin_comment
comment|/* passed in.  Log packet/byte counts, source/destination address and other */
end_comment

begin_comment
comment|/* protocol specific information.                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|ipstate_log
parameter_list|(
name|is
parameter_list|,
name|type
parameter_list|)
name|struct
name|ipstate
modifier|*
name|is
decl_stmt|;
name|u_int
name|type
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|struct
name|ipslog
name|ipsl
decl_stmt|;
name|size_t
name|sizes
index|[
literal|1
index|]
decl_stmt|;
name|void
modifier|*
name|items
index|[
literal|1
index|]
decl_stmt|;
name|int
name|types
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * Copy information out of the ipstate_t structure and into the 	 * structure used for logging. 	 */
name|ipsl
operator|.
name|isl_type
operator|=
name|type
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|0
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|1
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|1
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|1
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|2
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|2
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|2
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|2
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|2
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_pkts
index|[
literal|3
index|]
operator|=
name|is
operator|->
name|is_pkts
index|[
literal|3
index|]
operator|+
name|is
operator|->
name|is_icmppkts
index|[
literal|3
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_bytes
index|[
literal|3
index|]
operator|=
name|is
operator|->
name|is_bytes
index|[
literal|3
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_src
operator|=
name|is
operator|->
name|is_src
expr_stmt|;
name|ipsl
operator|.
name|isl_dst
operator|=
name|is
operator|->
name|is_dst
expr_stmt|;
name|ipsl
operator|.
name|isl_p
operator|=
name|is
operator|->
name|is_p
expr_stmt|;
name|ipsl
operator|.
name|isl_v
operator|=
name|is
operator|->
name|is_v
expr_stmt|;
name|ipsl
operator|.
name|isl_flags
operator|=
name|is
operator|->
name|is_flags
expr_stmt|;
name|ipsl
operator|.
name|isl_tag
operator|=
name|is
operator|->
name|is_tag
expr_stmt|;
name|ipsl
operator|.
name|isl_rulen
operator|=
name|is
operator|->
name|is_rulen
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ipsl
operator|.
name|isl_group
argument_list|,
name|is
operator|->
name|is_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_TCP
operator|||
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|ipsl
operator|.
name|isl_sport
operator|=
name|is
operator|->
name|is_sport
expr_stmt|;
name|ipsl
operator|.
name|isl_dport
operator|=
name|is
operator|->
name|is_dport
expr_stmt|;
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|ipsl
operator|.
name|isl_state
index|[
literal|0
index|]
operator|=
name|is
operator|->
name|is_state
index|[
literal|0
index|]
expr_stmt|;
name|ipsl
operator|.
name|isl_state
index|[
literal|1
index|]
operator|=
name|is
operator|->
name|is_state
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|ipsl
operator|.
name|isl_itype
operator|=
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ipsl
operator|.
name|isl_p
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|ipsl
operator|.
name|isl_itype
operator|=
name|is
operator|->
name|is_icmp
operator|.
name|ici_type
expr_stmt|;
block|}
else|else
block|{
name|ipsl
operator|.
name|isl_ps
operator|.
name|isl_filler
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ipsl
operator|.
name|isl_ps
operator|.
name|isl_filler
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|items
index|[
literal|0
index|]
operator|=
operator|&
name|ipsl
expr_stmt|;
name|sizes
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|ipsl
argument_list|)
expr_stmt|;
name|types
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ipllog
argument_list|(
name|IPL_LOGSTATE
argument_list|,
name|NULL
argument_list|,
name|items
argument_list|,
name|sizes
argument_list|,
name|types
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_logged
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|ips_stats
operator|.
name|iss_logfail
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_checkicmp6matchingstate                                  */
end_comment

begin_comment
comment|/* Returns:     ipstate_t* - NULL == no match found,                        */
end_comment

begin_comment
comment|/*                           else  pointer to matching state entry          */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/* Locks:       NULL == no locks, else Read Lock on ipf_state               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If we've got an ICMPv6 error message, using the information stored in    */
end_comment

begin_comment
comment|/* the ICMPv6 packet, look for a matching state table entry.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipstate_t
modifier|*
name|fr_checkicmp6matchingstate
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|icmp6_hdr
modifier|*
name|ic6
decl_stmt|,
modifier|*
name|oic
decl_stmt|;
name|int
name|type
decl_stmt|,
name|backward
decl_stmt|,
name|i
decl_stmt|;
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
modifier|*
name|isp
decl_stmt|;
name|u_short
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|i6addr_t
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|u_short
name|savelen
decl_stmt|;
name|icmpinfo_t
modifier|*
name|ic
decl_stmt|;
name|fr_info_t
name|ofin
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|ip6_t
modifier|*
name|oip6
decl_stmt|;
name|u_char
name|pr
decl_stmt|;
name|u_int
name|hv
decl_stmt|;
comment|/* 	 * Does it at least have the return (basic) IP header ? 	 * Is it an actual recognised ICMP error type? 	 * Only a basic IP header (no options) should be with 	 * an ICMP error header. 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_v
operator|!=
literal|6
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_plen
operator|<
name|ICMP6ERR_MINPKTLEN
operator|)
operator|||
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_ICMPERR
operator|)
condition|)
return|return
name|NULL
return|;
name|ic6
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|type
operator|=
name|ic6
operator|->
name|icmp6_type
expr_stmt|;
name|oip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ic6
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|oip6
argument_list|)
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ofin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_v
operator|=
literal|6
expr_stmt|;
name|ofin
operator|.
name|fin_ifp
operator|=
name|fin
operator|->
name|fin_ifp
expr_stmt|;
name|ofin
operator|.
name|fin_out
operator|=
operator|!
name|fin
operator|->
name|fin_out
expr_stmt|;
name|ofin
operator|.
name|fin_m
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
name|ofin
operator|.
name|fin_mp
operator|=
name|NULL
expr_stmt|;
comment|/* if dereferenced, panic XXX */
comment|/* 	 * We make a fin entry to be able to feed it to 	 * matchsrcdst. Note that not all fields are necessary 	 * but this is the cleanest way. Note further we fill 	 * in fin_mp such that if someone uses it we'll get 	 * a kernel panic. fr_matchsrcdst does not use this. 	 * 	 * watch out here, as ip is in host order and oip6 in network 	 * order. Any change we make must be undone afterwards. 	 */
name|savelen
operator|=
name|oip6
operator|->
name|ip6_plen
expr_stmt|;
name|oip6
operator|->
name|ip6_plen
operator|=
name|fin
operator|->
name|fin_dlen
operator|-
name|ICMPERR_ICMPHLEN
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|=
name|FI_NOCKSUM
expr_stmt|;
name|ofin
operator|.
name|fin_ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|oip6
expr_stmt|;
operator|(
name|void
operator|)
name|fr_makefrip
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|oip6
argument_list|)
argument_list|,
operator|(
name|ip_t
operator|*
operator|)
name|oip6
argument_list|,
operator|&
name|ofin
argument_list|)
expr_stmt|;
name|ofin
operator|.
name|fin_flx
operator|&=
operator|~
operator|(
name|FI_BAD
operator||
name|FI_SHORT
operator|)
expr_stmt|;
name|oip6
operator|->
name|ip6_plen
operator|=
name|savelen
expr_stmt|;
if|if
condition|(
name|oip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_ICMPV6
condition|)
block|{
name|oic
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
operator|(
name|oip6
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 		 * an ICMP error can only be generated as a result of an 		 * ICMP query, not as the response on an ICMP error 		 * 		 * XXX theoretically ICMP_ECHOREP and the other reply's are 		 * ICMP query's as well, but adding them here seems strange XXX 		 */
if|if
condition|(
operator|!
operator|(
name|oic
operator|->
name|icmp6_type
operator|&
name|ICMP6_INFOMSG_MASK
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 		 * perform a lookup of the ICMP packet in the state table 		 */
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip6
operator|->
name|ip6_nxt
operator|)
expr_stmt|;
name|src
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|dst
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|in4
operator|.
name|s_addr
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_id
expr_stmt|;
name|hv
operator|+=
name|oic
operator|->
name|icmp6_seq
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|ic
operator|=
operator|&
name|is
operator|->
name|is_icmp
expr_stmt|;
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|==
name|pr
operator|)
operator|&&
operator|!
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_id
operator|==
name|ic
operator|->
name|ici_id
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_seq
operator|==
name|ic
operator|->
name|ici_seq
operator|)
operator|&&
operator|(
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|,
name|FI_ICMPCMP
argument_list|)
operator|)
condition|)
block|{
comment|/* 			    	 * in the state table ICMP query's are stored 			    	 * with the type of the corresponding ICMP 			    	 * response. Correct here 			    	 */
if|if
condition|(
operator|(
operator|(
name|ic
operator|->
name|ici_type
operator|==
name|ICMP6_ECHO_REPLY
operator|)
operator|&&
operator|(
name|oic
operator|->
name|icmp6_type
operator|==
name|ICMP6_ECHO_REQUEST
operator|)
operator|)
operator|||
operator|(
name|ic
operator|->
name|ici_type
operator|-
literal|1
operator|==
name|oic
operator|->
name|icmp6_type
operator|)
condition|)
block|{
name|ips_stats
operator|.
name|iss_hits
operator|++
expr_stmt|;
name|backward
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
operator|!
name|backward
expr_stmt|;
name|i
operator|=
operator|(
name|backward
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|++
expr_stmt|;
return|return
name|is
return|;
block|}
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hv
operator|=
operator|(
name|pr
operator|=
name|oip6
operator|->
name|ip6_nxt
operator|)
expr_stmt|;
name|src
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_src
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|src
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
name|dst
operator|.
name|in6
operator|=
name|oip6
operator|->
name|ip6_dst
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|hv
operator|+=
name|dst
operator|.
name|i6
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|oip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_TCP
operator|)
operator|||
operator|(
name|oip6
operator|->
name|ip6_nxt
operator|==
name|IPPROTO_UDP
operator|)
condition|)
block|{
name|tcp
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
name|oip6
operator|+
literal|1
operator|)
expr_stmt|;
name|dport
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|sport
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|hv
operator|+=
name|dport
expr_stmt|;
name|hv
operator|+=
name|sport
expr_stmt|;
block|}
else|else
name|tcp
operator|=
name|NULL
expr_stmt|;
name|hv
operator|=
name|DOUBLE_HASH
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
for|for
control|(
name|isp
operator|=
operator|&
name|ips_table
index|[
name|hv
index|]
init|;
operator|(
operator|(
name|is
operator|=
operator|*
name|isp
operator|)
operator|!=
name|NULL
operator|)
condition|;
control|)
block|{
name|isp
operator|=
operator|&
name|is
operator|->
name|is_hnext
expr_stmt|;
comment|/* 		 * Only allow this icmp though if the 		 * encapsulated packet was allowed through the 		 * other way around. Note that the minimal amount 		 * of info present does not allow for checking against 		 * tcp internals such as seq and ack numbers. 		 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_p
operator|!=
name|pr
operator|)
operator|||
operator|(
name|is
operator|->
name|is_v
operator|!=
literal|6
operator|)
operator|||
operator|(
name|is
operator|->
name|is_pass
operator|&
name|FR_NOICMPERR
operator|)
condition|)
continue|continue;
name|is
operator|=
name|fr_matchsrcdst
argument_list|(
operator|&
name|ofin
argument_list|,
name|is
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
name|tcp
argument_list|,
name|FI_ICMPCMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
name|ips_stats
operator|.
name|iss_hits
operator|++
expr_stmt|;
name|backward
operator|=
name|IP6_NEQ
argument_list|(
operator|&
name|is
operator|->
name|is_dst
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rev
operator|=
operator|!
name|backward
expr_stmt|;
name|i
operator|=
operator|(
name|backward
operator|<<
literal|1
operator|)
operator|+
name|fin
operator|->
name|fin_out
expr_stmt|;
name|is
operator|->
name|is_icmppkts
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* 			 * we deliberately do not touch the timeouts 			 * for the accompanying state table entry. 			 * It remains to be seen if that is correct. XXX 			 */
return|return
name|is
return|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_sttab_init                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqp(I) - pointer to an array of timeout queues for TCP      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Initialise the array of timeout queues for TCP.                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_sttab_init
parameter_list|(
name|tqp
parameter_list|)
name|ipftq_t
modifier|*
name|tqp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPF_TCP_NSTATES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_ttl
operator|=
literal|0
expr_stmt|;
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_tail
operator|=
operator|&
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_head
expr_stmt|;
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_next
operator|=
name|tqp
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_lock
argument_list|,
literal|"ipftq tcp tab"
argument_list|)
expr_stmt|;
block|}
name|tqp
index|[
name|IPF_TCP_NSTATES
operator|-
literal|1
index|]
operator|.
name|ifq_next
operator|=
name|NULL
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSED
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcpclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_LISTEN
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_SYN_SENT
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_SYN_RECEIVED
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_ESTABLISHED
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcpidletimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSE_WAIT
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcphalfclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_FIN_WAIT_1
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcphalfclosed
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_CLOSING
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimeout
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_LAST_ACK
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcplastack
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_FIN_WAIT_2
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcpclosewait
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_TIME_WAIT
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimewait
expr_stmt|;
name|tqp
index|[
name|IPF_TCPS_HALF_ESTAB
index|]
operator|.
name|ifq_ttl
operator|=
name|fr_tcptimeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_sttab_destroy                                            */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqp(I) - pointer to an array of timeout queues for TCP      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Do whatever is necessary to "destroy" each of the entries in the array   */
end_comment

begin_comment
comment|/* of timeout queues for TCP.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_sttab_destroy
parameter_list|(
name|tqp
parameter_list|)
name|ipftq_t
modifier|*
name|tqp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|IPF_TCP_NSTATES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|MUTEX_DESTROY
argument_list|(
operator|&
name|tqp
index|[
name|i
index|]
operator|.
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_statederef                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  isp(I) - pointer to pointer to state table entry            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Decrement the reference counter for this state table entry and free it   */
end_comment

begin_comment
comment|/* if there are no more things using it.                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When operating in userland (ipftest), we have no timers to clear a state */
end_comment

begin_comment
comment|/* entry.  Therefore, we make a few simple tests before deleting an entry   */
end_comment

begin_comment
comment|/* outright.  We compare states on each side looking for a combination of   */
end_comment

begin_comment
comment|/* TIME_WAIT (should really be FIN_WAIT_2?) and LAST_ACK.  Then we factor   */
end_comment

begin_comment
comment|/* in packet direction with the interface list to make sure we don't        */
end_comment

begin_comment
comment|/* prematurely delete an entry on a final inbound packet that's we're also  */
end_comment

begin_comment
comment|/* supposed to route elsewhere.                                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Internal parameters:                                                     */
end_comment

begin_comment
comment|/*    state[0] = state of source (host that initiated connection)           */
end_comment

begin_comment
comment|/*    state[1] = state of dest   (host that accepted the connection)        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/*    dir == 0 : a packet from source to dest                               */
end_comment

begin_comment
comment|/*    dir == 1 : a packet from dest to source                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_statederef
parameter_list|(
name|isp
parameter_list|)
name|ipstate_t
modifier|*
modifier|*
name|isp
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|is
operator|=
operator|*
name|isp
expr_stmt|;
operator|*
name|isp
operator|=
name|NULL
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ref
operator|--
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_ref
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_ref
operator|++
expr_stmt|;
comment|/* To counter ref-- in fr_delstate() */
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_EXPIRE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
block|}
elseif|else
if|if
condition|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_state
index|[
literal|0
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
operator|||
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_state
index|[
literal|1
index|]
operator|>
name|IPF_TCPS_ESTABLISHED
operator|)
condition|)
block|{
name|fr_delstate
argument_list|(
name|is
argument_list|,
name|ISL_ORPHAN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_setstatequeue                                            */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  is(I) - pointer to state structure                          */
end_comment

begin_comment
comment|/*              rev(I) - forward(0) or reverse(1) direction                 */
end_comment

begin_comment
comment|/* Locks:       ipf_state (read or write)                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Put the state entry on its default queue entry, using rev as a helped in */
end_comment

begin_comment
comment|/* determining which queue it should be placed on.                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_setstatequeue
parameter_list|(
name|is
parameter_list|,
name|rev
parameter_list|)
name|ipstate_t
modifier|*
name|is
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|oifq
decl_stmt|,
modifier|*
name|nifq
decl_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|is_sti
operator|.
name|tqe_flags
operator|&
name|TQE_RULEBASED
operator|)
operator|!=
literal|0
condition|)
name|nifq
operator|=
name|is
operator|->
name|is_tqehead
index|[
name|rev
index|]
expr_stmt|;
else|else
name|nifq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nifq
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|is
operator|->
name|is_p
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_INET6
case|case
name|IPPROTO_ICMPV6
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|ips_icmpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|ips_icmptq
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_ICMP
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|ips_icmpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|ips_icmptq
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|nifq
operator|=
name|ips_tqtqb
operator|+
name|is
operator|->
name|is_state
index|[
name|rev
index|]
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|rev
operator|==
literal|1
condition|)
name|nifq
operator|=
operator|&
name|ips_udpacktq
expr_stmt|;
else|else
name|nifq
operator|=
operator|&
name|ips_udptq
expr_stmt|;
break|break;
default|default :
name|nifq
operator|=
operator|&
name|ips_iptq
expr_stmt|;
break|break;
block|}
block|}
name|oifq
operator|=
name|is
operator|->
name|is_sti
operator|.
name|tqe_ifq
expr_stmt|;
comment|/* 	 * If it's currently on a timeout queue, move it from one queue to 	 * another, else put it on the end of the newly determined queue. 	 */
if|if
condition|(
name|oifq
operator|!=
name|NULL
condition|)
name|fr_movequeue
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|oifq
argument_list|,
name|nifq
argument_list|)
expr_stmt|;
else|else
name|fr_queueappend
argument_list|(
operator|&
name|is
operator|->
name|is_sti
argument_list|,
name|nifq
argument_list|,
name|is
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stateiter                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else error                              */
end_comment

begin_comment
comment|/* Parameters:  token(I) - pointer to ipftoken structure                    */
end_comment

begin_comment
comment|/*              itp(I)   - pointer to ipfgeniter structure                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles the SIOCGENITER ioctl for the state tables and     */
end_comment

begin_comment
comment|/* walks through the list of entries in the state table list (ips_list.)    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_stateiter
parameter_list|(
name|token
parameter_list|,
name|itp
parameter_list|)
name|ipftoken_t
modifier|*
name|token
decl_stmt|;
name|ipfgeniter_t
modifier|*
name|itp
decl_stmt|;
block|{
name|ipstate_t
modifier|*
name|is
decl_stmt|,
modifier|*
name|next
decl_stmt|,
name|zero
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|itp
operator|->
name|igi_data
operator|==
name|NULL
condition|)
return|return
name|EFAULT
return|;
if|if
condition|(
name|itp
operator|->
name|igi_nitems
operator|==
literal|0
condition|)
return|return
name|ENOSPC
return|;
if|if
condition|(
name|itp
operator|->
name|igi_type
operator|!=
name|IPFGENITER_STATE
condition|)
return|return
name|EINVAL
return|;
name|is
operator|=
name|token
operator|->
name|ipt_data
expr_stmt|;
if|if
condition|(
name|is
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|ipf_freetoken
argument_list|(
name|token
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|dst
operator|=
name|itp
operator|->
name|igi_data
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|ips_list
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|is
operator|->
name|is_next
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
name|itp
operator|->
name|igi_nitems
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If we find a state entry to use, bump its 			 * reference count so that it can be used for 			 * is_next when we come back. 			 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|next
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|next
operator|->
name|is_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|next
operator|->
name|is_lock
argument_list|)
expr_stmt|;
name|token
operator|->
name|ipt_data
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|zero
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
operator|&
name|zero
expr_stmt|;
name|token
operator|->
name|ipt_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
comment|/* 		 * If we had a prior pointer to a state entry, release it. 		 */
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
name|fr_statederef
argument_list|(
operator|&
name|is
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * This should arguably be via fr_outobj() so that the state 		 * structure can (if required) be massaged going out. 		 */
name|error
operator|=
name|COPYOUT
argument_list|(
name|next
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|==
literal|1
operator|)
operator|||
operator|(
name|error
operator|!=
literal|0
operator|)
condition|)
break|break;
name|dst
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|next
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_state
argument_list|)
expr_stmt|;
name|is
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|is
operator|->
name|is_next
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_stgettable                                               */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else error                           */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles ioctl requests for tables of state information.    */
end_comment

begin_comment
comment|/* At present the only table it deals with is the hash bucket statistics.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_stgettable
parameter_list|(
name|data
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|ipftable_t
name|table
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|table
argument_list|,
name|IPFOBJ_GTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|table
operator|.
name|ita_type
operator|!=
name|IPFTABLE_BUCKETS
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|COPYOUT
argument_list|(
name|ips_stats
operator|.
name|iss_bucketlen
argument_list|,
name|table
operator|.
name|ita_table
argument_list|,
name|fr_statesize
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

