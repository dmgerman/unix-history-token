begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1993-2003 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_define
define|#
directive|define
name|_KERNEL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|NetBSD
operator|>=
literal|199905
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter_log.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
expr|\
operator|(
name|__FreeBSD_version
operator|>=
literal|220000
operator|)
end_if

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400000
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|==
literal|400019
operator|)
end_if

begin_define
define|#
directive|define
name|CSUM_DELAY_DATA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_AIX51
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_struct_decl
struct_decl|struct
name|file
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SOLARIS2
operator|<
literal|5
operator|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|_NET_ROUTE_INCLUDED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|504000
operator|)
end_if

begin_undef
undef|#
directive|undef
name|_RADIX_H_
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"radix_ipf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
name|defined
argument_list|(
name|IFF_DRVRLOCK
argument_list|)
end_if

begin_comment
comment|/* IRIX 6 */
end_comment

begin_include
include|#
directive|include
file|<sys/hashing.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AIX
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_undef
undef|#
directive|undef
name|_NET_ROUTE_INCLUDED
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_compat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_if
if|#
directive|if
operator|!
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hpux
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|"netinet/ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_frag.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_state.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_proxy.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_auth.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_scan.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_sync.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ip_pool.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip_htable.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
end_ifdef

begin_include
include|#
directive|include
file|"netinet/ip_rules.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|300000
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IPFILTER_LKM
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ipfilter.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"netinet/ipl.h"
end_include

begin_comment
comment|/* END OF INCLUDES */
end_comment

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fil.c	1.36 6/5/96 (C) 1993-2000 Darren Reed"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static const char rcsid[] = "@(#)Id: fil.c,v 2.243.2.57 2005/03/28 10:47:50 darrenr Exp"; */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|"ipf.h"
end_include

begin_include
include|#
directive|include
file|"ipt.h"
end_include

begin_include
include|#
directive|include
file|"bpf-ipf.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|opts
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FR_VERBOSE
parameter_list|(
name|verb_pr
parameter_list|)
value|verbose verb_pr
end_define

begin_define
define|#
directive|define
name|FR_DEBUG
parameter_list|(
name|verb_pr
parameter_list|)
value|debug verb_pr
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* #ifndef _KERNEL */
end_comment

begin_define
define|#
directive|define
name|FR_VERBOSE
parameter_list|(
name|verb_pr
parameter_list|)
end_define

begin_define
define|#
directive|define
name|FR_DEBUG
parameter_list|(
name|verb_pr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_decl_stmt
name|fr_info_t
name|frcache
index|[
literal|2
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|filterstats
name|frstats
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frentry
modifier|*
name|ipfilter
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|,
modifier|*
name|ipfilter6
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|,
modifier|*
name|ipacct6
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|,
modifier|*
name|ipacct
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|,
modifier|*
name|ipnatrules
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frgroup
modifier|*
name|ipfgroups
index|[
name|IPL_LOGSIZE
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ipfilter_version
index|[]
init|=
name|IPL_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_refcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For fr_running:  * 0 == loading, 1 = running, -1 = disabled, -2 = unloading  */
end_comment

begin_decl_stmt
name|int
name|fr_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_flags
init|=
name|IPF_LOGGING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_control_forwarding
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_update_ipid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|fr_ip_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_chksrc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* causes a system crash if enabled */
end_comment

begin_decl_stmt
name|int
name|fr_minttl
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fr_icmpminfragmtu
init|=
literal|68
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|fr_frouteok
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|fr_userifqs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|fr_badcoalesces
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ipf_iss_secret
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_DEFAULT_BLOCK
argument_list|)
end_if

begin_decl_stmt
name|int
name|fr_pass
init|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|fr_pass
init|=
operator|(
name|IPF_DEFAULT_PASS
operator|)
operator||
name|FR_NOMATCH
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|fr_features
init|=
literal|0
ifdef|#
directive|ifdef
name|IPFILTER_LKM
operator||
name|IPF_FEAT_LKM
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOG
operator||
name|IPF_FEAT_LOG
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
operator||
name|IPF_FEAT_LOOKUP
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_BPF
operator||
name|IPF_FEAT_BPF
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
operator||
name|IPF_FEAT_COMPILED
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_CKSUM
operator||
name|IPF_FEAT_CKSUM
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
operator||
name|IPF_FEAT_SYNC
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
operator||
name|IPF_FEAT_SCAN
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_INET6
operator||
name|IPF_FEAT_IPV6
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|fr_ipfcheck
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|frentry_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_portcheck
name|__P
argument_list|(
operator|(
name|frpcmp_t
operator|*
operator|,
name|u_short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frflushlist
name|__P
argument_list|(
operator|(
name|int
operator|,
name|minor_t
operator|,
name|int
operator|*
operator|,
name|frentry_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipfunc_t
name|fr_findfunc
name|__P
argument_list|(
operator|(
name|ipfunc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|frentry_t
modifier|*
name|fr_firewall
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|u_32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_funcinit
name|__P
argument_list|(
operator|(
name|frentry_t
operator|*
name|fr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_ah
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_esp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_gre
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_udp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_tcp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_icmp
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_ipv4hdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_pullup
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_short
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_tcpcommon
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_udpcommon
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fr_updateipid
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|fr_grpmapinit
name|__P
argument_list|(
operator|(
name|frentry_t
operator|*
name|fr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
modifier|*
name|fr_resolvelookup
name|__P
argument_list|(
operator|(
name|u_int
operator|,
name|u_int
operator|,
name|lookupfunc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|frsynclist
name|__P
argument_list|(
operator|(
name|frentry_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
modifier|*
name|fr_findtunebyname
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
modifier|*
name|fr_findtunebycookie
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bit values for identifying presence of individual IP options  * All of these tables should be ordered by increasing key value on the left  * hand side to allow for binary searching of the array and include a trailer  * with a 0 for the bitmask for linear searches to easily find the end with.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|optlist
name|ipopts
index|[
literal|20
index|]
init|=
block|{
block|{
name|IPOPT_NOP
block|,
literal|0x000001
block|}
block|,
block|{
name|IPOPT_RR
block|,
literal|0x000002
block|}
block|,
block|{
name|IPOPT_ZSU
block|,
literal|0x000004
block|}
block|,
block|{
name|IPOPT_MTUP
block|,
literal|0x000008
block|}
block|,
block|{
name|IPOPT_MTUR
block|,
literal|0x000010
block|}
block|,
block|{
name|IPOPT_ENCODE
block|,
literal|0x000020
block|}
block|,
block|{
name|IPOPT_TS
block|,
literal|0x000040
block|}
block|,
block|{
name|IPOPT_TR
block|,
literal|0x000080
block|}
block|,
block|{
name|IPOPT_SECURITY
block|,
literal|0x000100
block|}
block|,
block|{
name|IPOPT_LSRR
block|,
literal|0x000200
block|}
block|,
block|{
name|IPOPT_E_SEC
block|,
literal|0x000400
block|}
block|,
block|{
name|IPOPT_CIPSO
block|,
literal|0x000800
block|}
block|,
block|{
name|IPOPT_SATID
block|,
literal|0x001000
block|}
block|,
block|{
name|IPOPT_SSRR
block|,
literal|0x002000
block|}
block|,
block|{
name|IPOPT_ADDEXT
block|,
literal|0x004000
block|}
block|,
block|{
name|IPOPT_VISA
block|,
literal|0x008000
block|}
block|,
block|{
name|IPOPT_IMITD
block|,
literal|0x010000
block|}
block|,
block|{
name|IPOPT_EIP
block|,
literal|0x020000
block|}
block|,
block|{
name|IPOPT_FINN
block|,
literal|0x040000
block|}
block|,
block|{
literal|0
block|,
literal|0x000000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
name|struct
name|optlist
name|ip6exthdr
index|[]
init|=
block|{
block|{
name|IPPROTO_HOPOPTS
block|,
literal|0x000001
block|}
block|,
block|{
name|IPPROTO_IPV6
block|,
literal|0x000002
block|}
block|,
block|{
name|IPPROTO_ROUTING
block|,
literal|0x000004
block|}
block|,
block|{
name|IPPROTO_FRAGMENT
block|,
literal|0x000008
block|}
block|,
block|{
name|IPPROTO_ESP
block|,
literal|0x000010
block|}
block|,
block|{
name|IPPROTO_AH
block|,
literal|0x000020
block|}
block|,
block|{
name|IPPROTO_NONE
block|,
literal|0x000040
block|}
block|,
block|{
name|IPPROTO_DSTOPTS
block|,
literal|0x000080
block|}
block|,
block|{
name|IPPROTO_MOBILITY
block|,
literal|0x000100
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|optlist
name|tcpopts
index|[]
init|=
block|{
block|{
name|TCPOPT_NOP
block|,
literal|0x000001
block|}
block|,
block|{
name|TCPOPT_MAXSEG
block|,
literal|0x000002
block|}
block|,
block|{
name|TCPOPT_WINDOW
block|,
literal|0x000004
block|}
block|,
block|{
name|TCPOPT_SACK_PERMITTED
block|,
literal|0x000008
block|}
block|,
block|{
name|TCPOPT_SACK
block|,
literal|0x000010
block|}
block|,
block|{
name|TCPOPT_TIMESTAMP
block|,
literal|0x000020
block|}
block|,
block|{
literal|0
block|,
literal|0x000000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bit values for identifying presence of individual IP security options  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|optlist
name|secopt
index|[
literal|8
index|]
init|=
block|{
block|{
name|IPSO_CLASS_RES4
block|,
literal|0x01
block|}
block|,
block|{
name|IPSO_CLASS_TOPS
block|,
literal|0x02
block|}
block|,
block|{
name|IPSO_CLASS_SECR
block|,
literal|0x04
block|}
block|,
block|{
name|IPSO_CLASS_RES3
block|,
literal|0x08
block|}
block|,
block|{
name|IPSO_CLASS_CONF
block|,
literal|0x10
block|}
block|,
block|{
name|IPSO_CLASS_UNCL
block|,
literal|0x20
block|}
block|,
block|{
name|IPSO_CLASS_RES2
block|,
literal|0x40
block|}
block|,
block|{
name|IPSO_CLASS_RES1
block|,
literal|0x80
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of functions available for use with call rules.  */
end_comment

begin_decl_stmt
specifier|static
name|ipfunc_resolve_t
name|fr_availfuncs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
block|{
literal|"fr_srcgrpmap"
block|,
name|fr_srcgrpmap
block|,
name|fr_grpmapinit
block|}
block|,
block|{
literal|"fr_dstgrpmap"
block|,
name|fr_dstgrpmap
block|,
name|fr_grpmapinit
block|}
block|,
endif|#
directive|endif
block|{
literal|""
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The next section of code is a a collection of small routines that set  * fields in the fr_info_t structure passed based on properties of the  * current packet.  There are different routines for the same protocol  * for each of IPv4 and IPv6.  Adding a new protocol, for which there  * will "special" inspection for setup, is now more easily done by adding  * a new routine and expanding the frpr_ipinit*() function rather than by  * adding more code to a growing switch statement.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_ah6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_esp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_gre6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_udp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_tcp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_icmp6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_ipv6hdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_short6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_hopopts6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_mobility6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_routing6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_dstopts6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|void
name|frpr_fragment6
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|frpr_ipv6exthdr
name|__P
argument_list|(
operator|(
name|fr_info_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_short6                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function enforces the 'is a packet too short to be legit' rule   */
end_comment

begin_comment
comment|/* for IPv6 and marks the packet with FI_SHORT if so.  See function comment */
end_comment

begin_comment
comment|/* for frpr_short() for more details.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_short6
parameter_list|(
name|fin
parameter_list|,
name|xmin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|xmin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|xmin
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_ipv6hdr                                                */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = IPv6 packet intact, -1 = packet lost           */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Copy values from the IPv6 header into the fr_info_t struct and call the  */
end_comment

begin_comment
comment|/* per-protocol analyzer if it exists.  In validating the packet, a protocol*/
end_comment

begin_comment
comment|/* analyzer may pullup or free the packet itself so we need to be vigiliant */
end_comment

begin_comment
comment|/* of that possibility arising.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_ipv6hdr
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|ip6_t
modifier|*
name|ip6
init|=
operator|(
name|ip6_t
operator|*
operator|)
name|fin
operator|->
name|fin_ip
decl_stmt|;
name|int
name|p
decl_stmt|,
name|go
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|hdrcount
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
init|=
operator|&
name|fin
operator|->
name|fin_fi
decl_stmt|;
name|fin
operator|->
name|fin_off
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_tos
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_optmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|fi
operator|->
name|fi_ttl
operator|=
name|ip6
operator|->
name|ip6_hlim
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|in6
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|in6
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|fin
operator|->
name|fin_id
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ip6
operator|->
name|ip6_flow
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hdrcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|go
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_BAD
operator||
name|FI_SHORT
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|frpr_udp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|frpr_tcp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMPV6
case|:
name|frpr_icmp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
name|frpr_gre6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
name|p
operator|=
name|frpr_hopopts6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_MOBILITY
case|:
name|p
operator|=
name|frpr_mobility6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_DSTOPTS
case|:
name|p
operator|=
name|frpr_dstopts6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
name|p
operator|=
name|frpr_routing6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|p
operator|=
name|frpr_ah6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ESP
case|:
name|frpr_esp6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPV6
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_val
operator|==
name|p
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
expr_stmt|;
break|break;
block|}
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_NONE
case|:
name|go
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IPPROTO_FRAGMENT
case|:
name|frpr_fragment6
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
name|go
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|hdrcount
operator|++
expr_stmt|;
comment|/* 		 * It is important to note that at this point, for the 		 * extension headers (go != 0), the entire header may not have 		 * been pulled up when the code gets to this point.  This is 		 * only done for "go != 0" because the other header handlers 		 * will all pullup their complete header.  The other indicator 		 * of an incomplete packet is that this was just an extension 		 * header. 		 */
if|if
condition|(
operator|(
name|go
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|p
operator|!=
name|IPPROTO_NONE
operator|)
operator|&&
operator|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|p
operator|=
name|IPPROTO_NONE
expr_stmt|;
name|go
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fi
operator|->
name|fi_p
operator|=
name|p
expr_stmt|;
comment|/* 	 * Some of the above functions, like frpr_esp6(), can call fr_pullup 	 * and destroy whatever packet was here.  The caller of this function 	 * expects us to return -1 if there is a problem with fr_pullup. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_ipv6exthdr                                             */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I)      - pointer to packet information                 */
end_comment

begin_comment
comment|/*              multiple(I) - flag indicating yes/no if multiple occurances */
end_comment

begin_comment
comment|/*                            of this extension header are allowed.         */
end_comment

begin_comment
comment|/*              proto(I)    - protocol number for this extension header     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_ipv6exthdr
parameter_list|(
name|fin
parameter_list|,
name|multiple
parameter_list|,
name|proto
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|multiple
decl_stmt|,
name|proto
decl_stmt|;
block|{
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|u_short
name|shift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_V6EXTHDR
expr_stmt|;
comment|/* 8 is default length of extension hdr */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_dlen
operator|-
literal|8
operator|)
operator|<
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|IPPROTO_NONE
return|;
name|hdr
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|shift
operator|=
literal|8
operator|+
operator|(
name|hdr
operator|->
name|ip6e_len
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|fin
operator|->
name|fin_dlen
condition|)
block|{
comment|/* Nasty extension header length? */
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_val
operator|==
name|proto
condition|)
block|{
comment|/* 			 * Most IPv6 extension headers are only allowed once. 			 */
if|if
condition|(
operator|(
name|multiple
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_optmsk
operator|&
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
operator|)
operator|!=
literal|0
operator|)
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
else|else
name|fin
operator|->
name|fin_optmsk
operator||=
name|ip6exthdr
index|[
name|i
index|]
operator|.
name|ol_bit
expr_stmt|;
break|break;
block|}
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
name|shift
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|-=
name|shift
expr_stmt|;
return|return
name|hdr
operator|->
name|ip6e_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_hopopts6                                               */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending hop by hop options extension header      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_hopopts6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
return|return
name|frpr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_HOPOPTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_mobility6                                              */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks the IPv6 mobility extension header               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_mobility6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
return|return
name|frpr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_MOBILITY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_routing6                                               */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending routing extension header                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_routing6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|ip6_ext
modifier|*
name|hdr
decl_stmt|;
name|int
name|shift
decl_stmt|;
if|if
condition|(
name|frpr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_ROUTING
argument_list|)
operator|==
name|IPPROTO_NONE
condition|)
return|return
name|IPPROTO_NONE
return|;
name|hdr
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|shift
operator|=
literal|8
operator|+
operator|(
name|hdr
operator|->
name|ip6e_len
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* 	 * Nasty extension header length? 	 */
if|if
condition|(
operator|(
name|shift
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|shift
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
operator|&
literal|15
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
comment|/* 		 * Compensate for the changes made in frpr_ipv6exthdr() 		 */
name|fin
operator|->
name|fin_dlen
operator|+=
name|shift
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
name|shift
expr_stmt|;
return|return
name|IPPROTO_NONE
return|;
block|}
return|return
name|hdr
operator|->
name|ip6e_nxt
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_fragment6                                              */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Examine the IPv6 fragment header and extract fragment offset information.*/
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* We don't know where the transport layer header (or whatever is next is), */
end_comment

begin_comment
comment|/* as it could be behind destination options (amongst others).  Because     */
end_comment

begin_comment
comment|/* there is no fragment cache, there is no knowledge about whether or not an*/
end_comment

begin_comment
comment|/* upper layer header has been seen (or where it ends) and thus we are not  */
end_comment

begin_comment
comment|/* able to continue processing beyond this header with any confidence.      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_fragment6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|struct
name|ip6_frag
modifier|*
name|frag
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAG
expr_stmt|;
if|if
condition|(
name|frpr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|0
argument_list|,
name|IPPROTO_FRAGMENT
argument_list|)
operator|==
name|IPPROTO_NONE
condition|)
return|return;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|frag
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
comment|/* 	 * Fragment but no fragmentation info set?  Bad packet... 	 */
if|if
condition|(
name|frag
operator|->
name|ip6f_offlg
operator|==
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
return|return;
block|}
name|fin
operator|->
name|fin_off
operator|=
name|frag
operator|->
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
expr_stmt|;
name|fin
operator|->
name|fin_off
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAGBODY
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_dstopts6                                               */
end_comment

begin_comment
comment|/* Returns:     int    - value of the next header or IPPROTO_NONE if error  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              nextheader(I) - stores next header value                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This is function checks pending destination options extension header     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_dstopts6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
return|return
name|frpr_ipv6exthdr
argument_list|(
name|fin
argument_list|,
literal|1
argument_list|,
name|IPPROTO_DSTOPTS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_icmp6                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* This routine is mainly concerned with determining the minimum valid size */
end_comment

begin_comment
comment|/* for an ICMPv6 packet.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_icmp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|int
name|minicmpsz
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
decl_stmt|;
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
decl_stmt|;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
name|ICMP6ERR_MINPKTLEN
operator|+
literal|8
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|1
condition|)
block|{
name|icmp6
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|icmp6
expr_stmt|;
switch|switch
condition|(
name|icmp6
operator|->
name|icmp6_type
condition|)
block|{
case|case
name|ICMP6_ECHO_REPLY
case|:
case|case
name|ICMP6_ECHO_REQUEST
case|:
name|minicmpsz
operator|=
name|ICMP6ERR_MINPKTLEN
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH
case|:
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
case|case
name|ICMP6_TIME_EXCEEDED
case|:
case|case
name|ICMP6_PARAM_PROB
case|:
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|M_LEN
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
operator|<
name|fin
operator|->
name|fin_plen
operator|)
condition|)
block|{
if|if
condition|(
name|fr_coalesce
argument_list|(
name|fin
argument_list|)
operator|!=
literal|1
condition|)
return|return;
block|}
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPERR
expr_stmt|;
name|minicmpsz
operator|=
name|ICMP6ERR_IPICMPHLEN
operator|-
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
name|frpr_short6
argument_list|(
name|fin
argument_list|,
name|minicmpsz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_udp6                                                   */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv6/UDP properties.                              */
end_comment

begin_comment
comment|/* Is not expected to be called for fragmented packets.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_udp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|frpr_short6
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_udpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|fr_checkv6sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_tcp6                                                   */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv6/TCP properties.                              */
end_comment

begin_comment
comment|/* Is not expected to be called for fragmented packets.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_tcp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|frpr_short6
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_tcpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|fr_checkv6sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_esp6                                                   */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for ESP properties.                                   */
end_comment

begin_comment
comment|/* The minimum length is taken to be the SPI (32bits) plus a tail (32bits)  */
end_comment

begin_comment
comment|/* even though the newer ESP packets must also have a sequence number that  */
end_comment

begin_comment
comment|/* is 32bits as well, it is not possible(?) to determine the version from a */
end_comment

begin_comment
comment|/* simple packet header.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_esp6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|frpr_short6
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_ah6                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for AH properties.                                    */
end_comment

begin_comment
comment|/* The minimum length is taken to be the combination of all fields in the   */
end_comment

begin_comment
comment|/* header being present and no authentication data (null algorithm used.)   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_ah6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|authhdr_t
modifier|*
name|ah
decl_stmt|;
name|frpr_short6
argument_list|(
name|fin
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|IPPROTO_NONE
return|;
name|ah
operator|=
operator|(
name|authhdr_t
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
return|return
name|ah
operator|->
name|ah_next
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_gre6                                                   */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for GRE properties.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_gre6
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|grehdr_t
modifier|*
name|gre
decl_stmt|;
name|frpr_short6
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|grehdr_t
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|gre
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|GRE_REV
argument_list|(
name|gre
operator|->
name|gr_flags
argument_list|)
operator|==
literal|1
condition|)
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
name|gre
operator|->
name|gr_call
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_INET6 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_pullup                                                 */
end_comment

begin_comment
comment|/* Returns:     int     - 0 == pullup succeeded, -1 == failure              */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              plen(I) - length (excluding L3 header) to pullup            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Short inline function to cut down on code duplication to perform a call  */
end_comment

begin_comment
comment|/* to fr_pullup to ensure there is the required amount of data,             */
end_comment

begin_comment
comment|/* consecutively in the packet buffer.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_pullup
parameter_list|(
name|fin
parameter_list|,
name|plen
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dp
operator|!=
name|NULL
condition|)
name|plen
operator|+=
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_ip
operator|+
name|fin
operator|->
name|fin_hlen
operator|)
expr_stmt|;
name|plen
operator|+=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
if|if
condition|(
name|M_LEN
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
operator|<
name|plen
condition|)
block|{
if|if
condition|(
name|fr_pullup
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|,
name|plen
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_short                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I)  - pointer to packet information                     */
end_comment

begin_comment
comment|/*              xmin(I) - minimum header size                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if a packet is "short" as defined by xmin.  The rule we are        */
end_comment

begin_comment
comment|/* applying here is that the packet must not be fragmented within the layer */
end_comment

begin_comment
comment|/* 4 header.  That is, it must not be a fragment that has its offset set to */
end_comment

begin_comment
comment|/* start within the layer 4 header (hdrmin) or if it is at offset 0, the    */
end_comment

begin_comment
comment|/* entire layer 4 header must be present (min).                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_short
parameter_list|(
name|fin
parameter_list|,
name|xmin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|int
name|xmin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|<
name|xmin
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|<
name|xmin
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_icmp                                                   */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Do a sanity check on the packet for ICMP (v4).  In nearly all cases,     */
end_comment

begin_comment
comment|/* except extrememly bad packets, both type and code will be present.       */
end_comment

begin_comment
comment|/* The expected minimum size of an ICMP packet is very much dependent on    */
end_comment

begin_comment
comment|/* the type of it.                                                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* XXX - other ICMP sanity checks?                                          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_icmp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|int
name|minicmpsz
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|ip_t
modifier|*
name|oip
decl_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|frpr_short
argument_list|(
name|fin
argument_list|,
name|ICMPERR_ICMPHLEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
name|ICMPERR_ICMPHLEN
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|1
condition|)
block|{
name|icmp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
name|icmp
expr_stmt|;
switch|switch
condition|(
name|icmp
operator|->
name|icmp_type
condition|)
block|{
case|case
name|ICMP_ECHOREPLY
case|:
case|case
name|ICMP_ECHO
case|:
comment|/* Router discovery messaes - RFC 1256 */
case|case
name|ICMP_ROUTERADVERT
case|:
case|case
name|ICMP_ROUTERSOLICIT
case|:
name|minicmpsz
operator|=
name|ICMP_MINLEN
expr_stmt|;
break|break;
comment|/* 		 * type(1) + code(1) + cksum(2) + id(2) seq(2) + 		 * 3 * timestamp(3 * 4) 		 */
case|case
name|ICMP_TSTAMP
case|:
case|case
name|ICMP_TSTAMPREPLY
case|:
name|minicmpsz
operator|=
literal|20
expr_stmt|;
break|break;
comment|/* 		 * type(1) + code(1) + cksum(2) + id(2) seq(2) + 		 * mask(4) 		 */
case|case
name|ICMP_MASKREQ
case|:
case|case
name|ICMP_MASKREPLY
case|:
name|minicmpsz
operator|=
literal|12
expr_stmt|;
break|break;
comment|/* 		 * type(1) + code(1) + cksum(2) + id(2) seq(2) + ip(20+) 		 */
case|case
name|ICMP_UNREACH
case|:
ifdef|#
directive|ifdef
name|icmp_nextmtu
if|if
condition|(
name|icmp
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_NEEDFRAG
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_nextmtu
operator|<
name|fr_icmpminfragmtu
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
endif|#
directive|endif
case|case
name|ICMP_SOURCEQUENCH
case|:
case|case
name|ICMP_REDIRECT
case|:
case|case
name|ICMP_TIMXCEED
case|:
case|case
name|ICMP_PARAMPROB
case|:
name|fin
operator|->
name|fin_flx
operator||=
name|FI_ICMPERR
expr_stmt|;
if|if
condition|(
name|fr_coalesce
argument_list|(
name|fin
argument_list|)
operator|!=
literal|1
condition|)
return|return;
comment|/* 			 * ICMP error packets should not be generated for IP 			 * packets that are a fragment that isn't the first 			 * fragment. 			 */
name|oip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|+
name|ICMPERR_ICMPHLEN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|oip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_OFFMASK
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
break|break;
default|default :
break|break;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>=
literal|6
condition|)
comment|/* ID field */
name|fin
operator|->
name|fin_data
index|[
literal|1
index|]
operator|=
name|icmp
operator|->
name|icmp_id
expr_stmt|;
block|}
name|frpr_short
argument_list|(
name|fin
argument_list|,
name|minicmpsz
argument_list|)
expr_stmt|;
name|fr_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_tcpcommon                                              */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = header ok, 1 = bad packet, -1 = buffer error   */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* TCP header sanity checking.  Look for bad combinations of TCP flags,     */
end_comment

begin_comment
comment|/* and make some checks with how they interact with other fields.           */
end_comment

begin_comment
comment|/* If compiled with IPFILTER_CKSUM, check to see if the TCP checksum is     */
end_comment

begin_comment
comment|/* valid and mark the packet as bad if not.                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_tcpcommon
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|tlen
decl_stmt|;
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|tcp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
condition|)
block|{
name|fin
operator|->
name|fin_sport
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_sport
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dport
operator|=
name|ntohs
argument_list|(
name|tcp
operator|->
name|th_dport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * Use of the TCP data offset *must* result in a value that is at 	 * least the same size as the TCP header. 	 */
name|tlen
operator|=
name|TCP_OFF
argument_list|(
name|tcp
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
return|return
literal|1
return|;
block|}
name|flags
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
name|fin
operator|->
name|fin_tcpf
operator|=
name|tcp
operator|->
name|th_flags
expr_stmt|;
comment|/* 	 * If the urgent flag is set, then the urgent pointer must 	 * also be set and vice versa.  Good TCP packets do not have 	 * just one of these set. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|TH_URG
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tcp
operator|->
name|th_urp
operator|==
literal|0
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|TH_URG
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tcp
operator|->
name|th_urp
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Ignore this case, it shows up in "real" traffic with */
comment|/* bogus values in the urgent pointer field. */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_RST
operator|)
condition|)
block|{
comment|/* TH_FIN|TH_RST|TH_ACK seems to appear "naturally" */
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TH_ACK
operator|)
condition|)
block|{
comment|/* 		 * If the ack bit isn't set, then either the SYN or 		 * RST bit must be set.  If the SYN bit is set, then 		 * we expect the ACK field to be 0.  If the ACK is 		 * not set and if URG, PSH or FIN are set, consdier 		 * that to indicate a bad TCP packet. 		 */
if|if
condition|(
operator|(
name|flags
operator|==
name|TH_SYN
operator|)
operator|&&
operator|(
name|tcp
operator|->
name|th_ack
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Cisco PIX sets the ACK field to a random value. 			 * In light of this, do not set FI_BAD until a patch 			 * is available from Cisco to ensure that 			 * interoperability between existing systems is 			 * achieved. 			 */
comment|/*fin->fin_flx |= FI_BAD*/
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_SYN
operator|)
operator|)
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_PUSH
operator||
name|TH_FIN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
block|}
comment|/* 	 * At this point, it's not exactly clear what is to be gained by 	 * marking up which TCP options are and are not present.  The one we 	 * are most interested in is the TCP window scale.  This is only in 	 * a SYN packet [RFC1323] so we don't need this here...? 	 * Now if we were to analyse the header for passive fingerprinting, 	 * then that might add some weight to adding this... 	 */
if|if
condition|(
name|tlen
operator|==
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
name|tlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
literal|0
block|ip = fin->fin_ip; 	s = (u_char *)(tcp + 1); 	off = IP_HL(ip)<< 2;
ifdef|#
directive|ifdef
name|_KERNEL
block|if (fin->fin_mp != NULL) { 		mb_t *m = *fin->fin_mp;  		if (off + tlen> M_LEN(m)) 			return; 	}
endif|#
directive|endif
block|for (tlen -= (int)sizeof(*tcp); tlen> 0; ) { 		opt = *s; 		if (opt == '\0') 			break; 		else if (opt == TCPOPT_NOP) 			ol = 1; 		else { 			if (tlen< 2) 				break; 			ol = (int)*(s + 1); 			if (ol< 2 || ol> tlen) 				break; 		}  		for (i = 9, mv = 4; mv>= 0; ) { 			op = ipopts + i; 			if (opt == (u_char)op->ol_val) { 				optmsk |= op->ol_bit; 				break; 			} 		} 		tlen -= ol; 		s += ol; 	}
endif|#
directive|endif
comment|/* 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_udpcommon                                              */
end_comment

begin_comment
comment|/* Returns:     int    - 0 = header ok, 1 = bad packet                      */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Extract the UDP source and destination ports, if present.  If compiled   */
end_comment

begin_comment
comment|/* with IPFILTER_CKSUM, check to see if the UDP checksum is valid.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|frpr_udpcommon
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|udphdr_t
modifier|*
name|udp
decl_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
if|if
condition|(
operator|!
name|fin
operator|->
name|fin_off
operator|&&
operator|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udp
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_SHORT
expr_stmt|;
return|return
literal|1
return|;
block|}
name|udp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|fin
operator|->
name|fin_sport
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_sport
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_dport
operator|=
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_tcp                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv4/TCP properties.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_tcp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|frpr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_tcpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|fr_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_udp                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyse the packet for IPv4/UDP properties.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_udp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|frpr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frpr_udpcommon
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
condition|)
name|fr_checkv4sum
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_esp                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for ESP properties.                                   */
end_comment

begin_comment
comment|/* The minimum length is taken to be the SPI (32bits) plus a tail (32bits)  */
end_comment

begin_comment
comment|/* even though the newer ESP packets must also have a sequence number that  */
end_comment

begin_comment
comment|/* is 32bits as well, it is not possible(?) to determine the version from a */
end_comment

begin_comment
comment|/* simple packet header.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_esp
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
name|frpr_short
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_ah                                                     */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for AH properties.                                    */
end_comment

begin_comment
comment|/* The minimum length is taken to be the combination of all fields in the   */
end_comment

begin_comment
comment|/* header being present and no authentication data (null algorithm used.)   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_ah
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|authhdr_t
modifier|*
name|ah
decl_stmt|;
name|int
name|len
decl_stmt|;
name|frpr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|ah
operator|=
operator|(
name|authhdr_t
operator|*
operator|)
name|fin
operator|->
name|fin_dp
expr_stmt|;
name|len
operator|=
operator|(
name|ah
operator|->
name|ah_plen
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|frpr_short
argument_list|(
name|fin
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_gre                                                    */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Analyse the packet for GRE properties.                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_gre
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|grehdr_t
modifier|*
name|gre
decl_stmt|;
name|frpr_short
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|frpr_pullup
argument_list|(
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
condition|)
block|{
name|gre
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|GRE_REV
argument_list|(
name|gre
operator|->
name|gr_flags
argument_list|)
operator|==
literal|1
condition|)
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|=
name|gre
operator|->
name|gr_call
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frpr_ipv4hdr                                                */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 Only                                                                */
end_comment

begin_comment
comment|/* Analyze the IPv4 header and set fields in the fr_info_t structure.       */
end_comment

begin_comment
comment|/* Check all options present and flag their presence if any exist.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|frpr_ipv4hdr
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|optmsk
init|=
literal|0
decl_stmt|,
name|secmsk
init|=
literal|0
decl_stmt|,
name|auth
init|=
literal|0
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|ol
decl_stmt|,
name|mv
decl_stmt|,
name|p
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|struct
name|optlist
modifier|*
name|op
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|,
name|opt
decl_stmt|;
name|u_short
name|off
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|fi
operator|=
operator|&
name|fin
operator|->
name|fin_fi
expr_stmt|;
name|hlen
operator|=
name|fin
operator|->
name|fin_hlen
expr_stmt|;
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fi
operator|->
name|fi_p
operator|=
name|p
expr_stmt|;
name|fi
operator|->
name|fi_tos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|fin
operator|->
name|fin_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|off
operator|=
name|ip
operator|->
name|ip_off
expr_stmt|;
comment|/* Get both TTL and protocol */
name|fi
operator|->
name|fi_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fi
operator|->
name|fi_ttl
operator|=
name|ip
operator|->
name|ip_ttl
expr_stmt|;
if|#
directive|if
literal|0
block|(*(((u_short *)fi) + 1)) = (*(((u_short *)ip) + 4));
endif|#
directive|endif
comment|/* Zero out bits not used in IPv6 address */
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_src
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_dst
operator|.
name|i6
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_saddr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|fi
operator|->
name|fi_daddr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * set packet attribute flags based on the offset and 	 * calculate the byte offset that it represents. 	 */
name|off
operator|&=
name|IP_MF
operator||
name|IP_OFFMASK
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
name|fi
operator|->
name|fi_flx
operator||=
name|FI_FRAG
expr_stmt|;
name|off
operator|&=
name|IP_OFFMASK
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_flx
operator||=
name|FI_FRAGBODY
expr_stmt|;
name|off
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|fin
operator|->
name|fin_dlen
operator|>
literal|65535
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_dlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|fin
operator|->
name|fin_dlen
operator|&
literal|7
operator|)
condition|)
block|{
comment|/*  				 * The length of the packet, starting at its 				 * offset cannot exceed 65535 (0xffff) as the  				 * length of an IP packet is only 16 bits. 				 * 				 * Any fragment that isn't the last fragment 				 * must have a length greater than 0 and it 				 * must be an even multiple of 8. 				 */
name|fi
operator|->
name|fi_flx
operator||=
name|FI_BAD
expr_stmt|;
block|}
block|}
block|}
name|fin
operator|->
name|fin_off
operator|=
name|off
expr_stmt|;
comment|/* 	 * Call per-protocol setup and checking 	 */
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|frpr_udp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|frpr_tcp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|frpr_icmp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|frpr_ah
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ESP
case|:
name|frpr_esp
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_GRE
case|:
name|frpr_gre
argument_list|(
name|fin
argument_list|)
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If it is a standard IP header (no options), set the flag fields 	 * which relate to options to 0. 	 */
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|fi
operator|->
name|fi_optmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * So the IP header has some IP options attached.  Walk the entire 	 * list of options present with this packet and set flags to indicate 	 * which ones are here and which ones are not.  For the somewhat out 	 * of date and obscure security classification options, set a flag to 	 * represent which classification is present. 	 */
name|fi
operator|->
name|fi_flx
operator||=
name|FI_OPTIONS
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|,
name|hlen
operator|-=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
init|;
name|hlen
operator|>
literal|0
condition|;
control|)
block|{
name|opt
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
name|ol
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hlen
operator|<
literal|2
condition|)
break|break;
name|ol
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ol
operator|<
literal|2
operator|||
name|ol
operator|>
name|hlen
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
operator|,
name|mv
operator|=
literal|4
init|;
name|mv
operator|>=
literal|0
condition|;
control|)
block|{
name|op
operator|=
name|ipopts
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|==
operator|(
name|u_char
operator|)
name|op
operator|->
name|ol_val
operator|)
operator|&&
operator|(
name|ol
operator|>
literal|4
operator|)
condition|)
block|{
name|optmsk
operator||=
name|op
operator|->
name|ol_bit
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_SECURITY
condition|)
block|{
specifier|const
name|struct
name|optlist
modifier|*
name|sp
decl_stmt|;
name|u_char
name|sec
decl_stmt|;
name|int
name|j
decl_stmt|,
name|m
decl_stmt|;
name|sec
operator|=
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* classification */
for|for
control|(
name|j
operator|=
literal|3
operator|,
name|m
operator|=
literal|2
init|;
name|m
operator|>=
literal|0
condition|;
control|)
block|{
name|sp
operator|=
name|secopt
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|sp
operator|->
name|ol_val
condition|)
block|{
name|secmsk
operator||=
name|sp
operator|->
name|ol_bit
expr_stmt|;
name|auth
operator|=
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
expr_stmt|;
name|auth
operator|*=
literal|256
expr_stmt|;
name|auth
operator|+=
operator|*
operator|(
name|s
operator|+
literal|4
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sec
operator|<
name|sp
operator|->
name|ol_val
condition|)
name|j
operator|-=
name|m
expr_stmt|;
else|else
name|j
operator|+=
name|m
expr_stmt|;
name|m
operator|--
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|opt
operator|<
name|op
operator|->
name|ol_val
condition|)
name|i
operator|-=
name|mv
expr_stmt|;
else|else
name|i
operator|+=
name|mv
expr_stmt|;
name|mv
operator|--
expr_stmt|;
block|}
name|hlen
operator|-=
name|ol
expr_stmt|;
name|s
operator|+=
name|ol
expr_stmt|;
block|}
comment|/* 	 * 	 */
if|if
condition|(
name|auth
operator|&&
operator|!
operator|(
name|auth
operator|&
literal|0x0100
operator|)
condition|)
name|auth
operator|&=
literal|0xff00
expr_stmt|;
name|fi
operator|->
name|fi_optmsk
operator|=
name|optmsk
expr_stmt|;
name|fi
operator|->
name|fi_secmsk
operator|=
name|secmsk
expr_stmt|;
name|fi
operator|->
name|fi_auth
operator|=
name|auth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_makefrip                                                 */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  hlen(I) - length of IP packet header                        */
end_comment

begin_comment
comment|/*              ip(I)   - pointer to the IP header                          */
end_comment

begin_comment
comment|/*              fin(IO) - pointer to packet information                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compact the IP header into a structure which contains just the info.     */
end_comment

begin_comment
comment|/* which is useful for comparing IP headers with and store this information */
end_comment

begin_comment
comment|/* in the fr_info_t structure pointer to by fin.  At present, it is assumed */
end_comment

begin_comment
comment|/* this function will be called with either an IPv4 or IPv6 packet.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_makefrip
parameter_list|(
name|hlen
parameter_list|,
name|ip
parameter_list|,
name|fin
parameter_list|)
name|int
name|hlen
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
name|fin
operator|->
name|fin_nat
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_state
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_depth
operator|=
literal|0
expr_stmt|;
name|fin
operator|->
name|fin_hlen
operator|=
operator|(
name|u_short
operator|)
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|ip
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
literal|0xffffffff
expr_stmt|;
name|fin
operator|->
name|fin_group
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fin
operator|->
name|fin_group
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fin
operator|->
name|fin_dlen
operator|=
name|fin
operator|->
name|fin_plen
operator|-
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
name|v
operator|=
name|fin
operator|->
name|fin_v
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|4
condition|)
name|frpr_ipv4hdr
argument_list|(
name|fin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|frpr_ipv6hdr
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_portcheck                                                */
end_comment

begin_comment
comment|/* Returns:     int - 1 == port matched, 0 == port match failed             */
end_comment

begin_comment
comment|/* Parameters:  frp(I) - pointer to port check `expression'                 */
end_comment

begin_comment
comment|/*              pop(I) - pointer to port number to evaluate                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Perform a comparison of a port number against some other(s), using a     */
end_comment

begin_comment
comment|/* structure with compare information stored in it.                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fr_portcheck
parameter_list|(
name|frp
parameter_list|,
name|pop
parameter_list|)
name|frpcmp_t
modifier|*
name|frp
decl_stmt|;
name|u_short
modifier|*
name|pop
decl_stmt|;
block|{
name|u_short
name|tup
decl_stmt|,
name|po
decl_stmt|;
name|int
name|err
init|=
literal|1
decl_stmt|;
name|tup
operator|=
operator|*
name|pop
expr_stmt|;
name|po
operator|=
name|frp
operator|->
name|frp_port
expr_stmt|;
comment|/* 	 * Do opposite test to that required and continue if that succeeds. 	 */
switch|switch
condition|(
name|frp
operator|->
name|frp_cmp
condition|)
block|{
case|case
name|FR_EQUAL
case|:
if|if
condition|(
name|tup
operator|!=
name|po
condition|)
comment|/* EQUAL */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_NEQUAL
case|:
if|if
condition|(
name|tup
operator|==
name|po
condition|)
comment|/* NOTEQUAL */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_LESST
case|:
if|if
condition|(
name|tup
operator|>=
name|po
condition|)
comment|/* LESSTHAN */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_GREATERT
case|:
if|if
condition|(
name|tup
operator|<=
name|po
condition|)
comment|/* GREATERTHAN */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_LESSTE
case|:
if|if
condition|(
name|tup
operator|>
name|po
condition|)
comment|/* LT or EQ */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_GREATERTE
case|:
if|if
condition|(
name|tup
operator|<
name|po
condition|)
comment|/* GT or EQ */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_OUTRANGE
case|:
if|if
condition|(
name|tup
operator|>=
name|po
operator|&&
name|tup
operator|<=
name|frp
operator|->
name|frp_top
condition|)
comment|/* Out of range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_INRANGE
case|:
if|if
condition|(
name|tup
operator|<=
name|po
operator|||
name|tup
operator|>=
name|frp
operator|->
name|frp_top
condition|)
comment|/* In range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FR_INCRANGE
case|:
if|if
condition|(
name|tup
operator|<
name|po
operator|||
name|tup
operator|>
name|frp
operator|->
name|frp_top
condition|)
comment|/* Inclusive range */
name|err
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_tcpudpchk                                                */
end_comment

begin_comment
comment|/* Returns:     int - 1 == protocol matched, 0 == check failed              */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              ft(I)  - pointer to structure with comparison data          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Compares the current pcket (assuming it is TCP/UDP) information with a   */
end_comment

begin_comment
comment|/* structure containing information that we want to match against.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_tcpudpchk
parameter_list|(
name|fin
parameter_list|,
name|ft
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|frtuc_t
modifier|*
name|ft
decl_stmt|;
block|{
name|int
name|err
init|=
literal|1
decl_stmt|;
comment|/* 	 * Both ports should *always* be in the first fragment. 	 * So far, I cannot find any cases where they can not be. 	 * 	 * compare destination ports 	 */
if|if
condition|(
name|ft
operator|->
name|ftu_dcmp
condition|)
name|err
operator|=
name|fr_portcheck
argument_list|(
operator|&
name|ft
operator|->
name|ftu_dst
argument_list|,
operator|&
name|fin
operator|->
name|fin_dport
argument_list|)
expr_stmt|;
comment|/* 	 * compare source ports 	 */
if|if
condition|(
name|err
operator|&&
name|ft
operator|->
name|ftu_scmp
condition|)
name|err
operator|=
name|fr_portcheck
argument_list|(
operator|&
name|ft
operator|->
name|ftu_src
argument_list|,
operator|&
name|fin
operator|->
name|fin_sport
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have all the TCP/UDP header, then how can we 	 * expect to do any sort of match on it ?  If we were looking for 	 * TCP flags, then NO match.  If not, then match (which should 	 * satisfy the "short" class too). 	 */
if|if
condition|(
name|err
operator|&&
operator|(
name|fin
operator|->
name|fin_p
operator|==
name|IPPROTO_TCP
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
condition|)
return|return
operator|!
operator|(
name|ft
operator|->
name|ftu_tcpf
operator||
name|ft
operator|->
name|ftu_tcpfm
operator|)
return|;
comment|/* 		 * Match the flags ?  If not, abort this match. 		 */
if|if
condition|(
name|ft
operator|->
name|ftu_tcpfm
operator|&&
name|ft
operator|->
name|ftu_tcpf
operator|!=
operator|(
name|fin
operator|->
name|fin_tcpf
operator|&
name|ft
operator|->
name|ftu_tcpfm
operator|)
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"f. %#x& %#x != %#x\n"
operator|,
name|fin
operator|->
name|fin_tcpf
operator|,
name|ft
operator|->
name|ftu_tcpfm
operator|,
name|ft
operator|->
name|ftu_tcpf
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ipfcheck                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 == match, 1 == no match                             */
end_comment

begin_comment
comment|/* Parameters:  fin(I)     - pointer to packet information                  */
end_comment

begin_comment
comment|/*              fr(I)      - pointer to filter rule                         */
end_comment

begin_comment
comment|/*              portcmp(I) - flag indicating whether to attempt matching on */
end_comment

begin_comment
comment|/*                           TCP/UDP port data.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check to see if a packet matches an IPFilter rule.  Checks of addresses, */
end_comment

begin_comment
comment|/* port numbers, etc, for "standard" IPFilter rules are all orchestrated in */
end_comment

begin_comment
comment|/* this function.                                                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|fr_ipfcheck
parameter_list|(
name|fin
parameter_list|,
name|fr
parameter_list|,
name|portcmp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|int
name|portcmp
decl_stmt|;
block|{
name|u_32_t
modifier|*
name|ld
decl_stmt|,
modifier|*
name|lm
decl_stmt|,
modifier|*
name|lip
decl_stmt|;
name|fripf_t
modifier|*
name|fri
decl_stmt|;
name|fr_ip_t
modifier|*
name|fi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fi
operator|=
operator|&
name|fin
operator|->
name|fin_fi
expr_stmt|;
name|fri
operator|=
name|fr
operator|->
name|fr_ipf
expr_stmt|;
name|lip
operator|=
operator|(
name|u_32_t
operator|*
operator|)
name|fi
expr_stmt|;
name|lm
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fri
operator|->
name|fri_mip
expr_stmt|;
name|ld
operator|=
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fri
operator|->
name|fri_ip
expr_stmt|;
comment|/* 	 * first 32 bits to check coversion: 	 * IP version, TOS, TTL, protocol 	 */
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"0. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
literal|1
return|;
comment|/* 	 * Next 32 bits is a constructed bitmask indicating which IP options 	 * are present (if any) in this packet. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"1. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
literal|1
return|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
comment|/* 	 * Unrolled loops (4 each, for 32 bits) for address checks. 	 */
comment|/* 	 * Check the source address. 	 */
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
if|if
condition|(
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
condition|)
block|{
name|i
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_srcfunc
call|)
argument_list|(
name|fr
operator|->
name|fr_srcptr
argument_list|,
name|fi
operator|->
name|fi_v
argument_list|,
name|lip
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2a. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_v
operator|==
literal|6
condition|)
block|{
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2b. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2c. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"2d. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
block|}
endif|#
directive|endif
name|i
operator|^=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_NOTSRCIP
operator|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
literal|1
return|;
comment|/* 	 * Check the destination address. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
if|if
condition|(
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
condition|)
block|{
name|i
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_dstfunc
call|)
argument_list|(
name|fr
operator|->
name|fr_dstptr
argument_list|,
name|fi
operator|->
name|fi_v
argument_list|,
name|lip
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|i
operator|=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3a. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_v
operator|==
literal|6
condition|)
block|{
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3b. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3c. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"3d. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lip
operator|+=
literal|3
expr_stmt|;
name|lm
operator|+=
literal|3
expr_stmt|;
name|ld
operator|+=
literal|3
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
block|}
endif|#
directive|endif
name|i
operator|^=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_NOTDSTIP
operator|)
operator|>>
literal|7
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
literal|1
return|;
comment|/* 	 * IP addresses matched.  The next 32bits contains: 	 * mast of old IP header security& authentication bits. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"4. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Next we have 32 bits of packet flags. 	 */
name|lip
operator|++
operator|,
name|lm
operator|++
operator|,
name|ld
operator|++
expr_stmt|;
name|i
operator||=
operator|(
operator|(
operator|*
name|lip
operator|&
operator|*
name|lm
operator|)
operator|!=
operator|*
name|ld
operator|)
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"5. %#08x& %#08x != %#08x\n"
operator|,
operator|*
name|lip
operator|,
operator|*
name|lm
operator|,
operator|*
name|ld
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If a fragment, then only the first has what we're 		 * looking for here... 		 */
if|if
condition|(
name|portcmp
condition|)
block|{
if|if
condition|(
operator|!
name|fr_tcpudpchk
argument_list|(
name|fin
argument_list|,
operator|&
name|fr
operator|->
name|fr_tuc
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fr
operator|->
name|fr_dcmp
operator|||
name|fr
operator|->
name|fr_scmp
operator|||
name|fr
operator|->
name|fr_tcpf
operator|||
name|fr
operator|->
name|fr_tcpfm
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_icmpm
operator|||
name|fr
operator|->
name|fr_icmp
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|fi
operator|->
name|fi_p
operator|!=
name|IPPROTO_ICMP
operator|)
operator|&&
operator|(
name|fi
operator|->
name|fi_p
operator|!=
name|IPPROTO_ICMPV6
operator|)
operator|)
operator|||
name|fin
operator|->
name|fin_off
operator|||
operator|(
name|fin
operator|->
name|fin_dlen
operator|<
literal|2
operator|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|&
name|fr
operator|->
name|fr_icmpm
operator|)
operator|!=
name|fr
operator|->
name|fr_icmp
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"i. %#x& %#x != %#x\n"
operator|,
name|fin
operator|->
name|fin_data
index|[
literal|0
index|]
operator|,
name|fr
operator|->
name|fr_icmpm
operator|,
name|fr
operator|->
name|fr_icmp
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_scanlist                                                 */
end_comment

begin_comment
comment|/* Returns:     int - result flags of scanning filter list                  */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              pass(I) - default result to return for filtering            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check the input/output list of rules for a match to the current packet.  */
end_comment

begin_comment
comment|/* If a match is found, the value of fr_flags from the rule becomes the     */
end_comment

begin_comment
comment|/* return value and fin->fin_fr points to the matched rule.                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function may be called recusively upto 16 times (limit inbuilt.)    */
end_comment

begin_comment
comment|/* When unwinding, it should finish up with fin_depth as 0.                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Could be per interface, but this gets real nasty when you don't have,    */
end_comment

begin_comment
comment|/* or can't easily change, the kernel source code to .                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_scanlist
parameter_list|(
name|fin
parameter_list|,
name|pass
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
block|{
name|int
name|rulen
decl_stmt|,
name|portcmp
decl_stmt|,
name|off
decl_stmt|,
name|logged
decl_stmt|,
name|skip
decl_stmt|;
name|struct
name|frentry
modifier|*
name|fr
decl_stmt|,
modifier|*
name|fnext
decl_stmt|;
name|u_32_t
name|passt
decl_stmt|,
name|passo
decl_stmt|;
comment|/* 	 * Do not allow nesting deeper than 16 levels. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_depth
operator|>=
literal|16
condition|)
return|return
name|pass
return|;
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
comment|/* 	 * If there are no rules in this list, return now. 	 */
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
return|return
name|pass
return|;
name|skip
operator|=
literal|0
expr_stmt|;
name|logged
operator|=
literal|0
expr_stmt|;
name|portcmp
operator|=
literal|0
expr_stmt|;
name|fin
operator|->
name|fin_depth
operator|++
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
name|fin
operator|->
name|fin_off
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_TCPUDP
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_dlen
operator|>
literal|3
operator|)
operator|&&
operator|!
name|off
condition|)
name|portcmp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|rulen
operator|=
literal|0
init|;
name|fr
condition|;
name|fr
operator|=
name|fnext
operator|,
name|rulen
operator|++
control|)
block|{
name|fnext
operator|=
name|fr
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|FR_VERBOSE
argument_list|(
operator|(
literal|"%d (%#x)\n"
operator|,
name|skip
operator|,
name|fr
operator|->
name|fr_flags
operator|)
argument_list|)
expr_stmt|;
name|skip
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * In all checks below, a null (zero) value in the 		 * filter struture is taken to mean a wildcard. 		 * 		 * check that we are working for the right interface 		 */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|fr
operator|->
name|fr_ifa
operator|&&
name|fr
operator|->
name|fr_ifa
operator|!=
name|fin
operator|->
name|fin_ifp
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
name|opts
operator|&
operator|(
name|OPT_VERBOSE
operator||
name|OPT_DEBUG
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|FR_VERBOSE
argument_list|(
operator|(
literal|"%c"
operator|,
name|FR_ISSKIP
argument_list|(
name|pass
argument_list|)
condition|?
literal|'s'
else|:
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|?
literal|'p'
else|:
name|FR_ISACCOUNT
argument_list|(
name|pass
argument_list|)
condition|?
literal|'A'
else|:
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
condition|?
literal|'a'
else|:
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|?
literal|'n'
else|:
literal|'b'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ifa
operator|&&
name|fr
operator|->
name|fr_ifa
operator|!=
name|fin
operator|->
name|fin_ifp
condition|)
continue|continue;
name|FR_VERBOSE
argument_list|(
operator|(
literal|":i"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fr
operator|->
name|fr_type
condition|)
block|{
case|case
name|FR_T_IPF
case|:
case|case
name|FR_T_IPF
operator||
name|FR_T_BUILTIN
case|:
if|if
condition|(
name|fr_ipfcheck
argument_list|(
name|fin
argument_list|,
name|fr
argument_list|,
name|portcmp
argument_list|)
condition|)
continue|continue;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
case|case
name|FR_T_BPFOPC
case|:
case|case
name|FR_T_BPFOPC
operator||
name|FR_T_BUILTIN
case|:
block|{
name|u_char
modifier|*
name|mc
decl_stmt|;
if|if
condition|(
operator|*
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|!=
name|fr
operator|->
name|fr_v
condition|)
continue|continue;
name|mc
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fin
operator|->
name|fin_m
expr_stmt|;
if|if
condition|(
operator|!
name|bpf_filter
argument_list|(
name|fr
operator|->
name|fr_data
argument_list|,
name|mc
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
break|break;
block|}
endif|#
directive|endif
case|case
name|FR_T_CALLFUNC
operator||
name|FR_T_BUILTIN
case|:
block|{
name|frentry_t
modifier|*
name|f
decl_stmt|;
name|f
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_func
call|)
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|fr
operator|=
name|f
expr_stmt|;
else|else
continue|continue;
break|break;
block|}
default|default :
break|break;
block|}
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_nattag
operator|.
name|ipt_num
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_nattag
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|fr_matchtag
argument_list|(
operator|&
name|fr
operator|->
name|fr_nattag
argument_list|,
name|fin
operator|->
name|fin_nattag
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
name|FR_VERBOSE
argument_list|(
operator|(
literal|"=%s.%d *"
operator|,
name|fr
operator|->
name|fr_group
operator|,
name|rulen
operator|)
argument_list|)
expr_stmt|;
name|passt
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
comment|/* 		 * Allowing a rule with the "keep state" flag set to match 		 * packets that have been tagged "out of window" by the TCP 		 * state tracking is foolish as the attempt to add a new 		 * state entry to the table will fail. 		 */
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
operator|)
condition|)
continue|continue;
comment|/* 		 * If the rule is a "call now" rule, then call the function 		 * in the rule, if it exists and use the results from that. 		 * If the function pointer is bad, just make like we ignore 		 * it, except for increasing the hit counter. 		 */
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_CALLNOW
operator|)
operator|!=
literal|0
condition|)
block|{
name|ATOMIC_INC64
argument_list|(
name|fr
operator|->
name|fr_hits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_func
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_func
operator|!=
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|frentry_t
modifier|*
name|frs
decl_stmt|;
name|frs
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
name|fr
operator|=
call|(
modifier|*
name|fr
operator|->
name|fr_func
call|)
argument_list|(
name|fin
argument_list|,
operator|&
name|passt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_fr
operator|=
name|frs
expr_stmt|;
continue|continue;
block|}
name|passt
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
block|}
block|}
else|else
block|{
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
comment|/* 		 * Just log this packet... 		 */
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOG
condition|)
block|{
if|if
condition|(
name|ipflog
argument_list|(
name|fin
argument_list|,
name|passt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|passt
operator|&
name|FR_LOGORBLOCK
condition|)
block|{
name|passt
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|passt
operator||=
name|FR_BLOCK
operator||
name|FR_QUICK
expr_stmt|;
block|}
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_skip
argument_list|)
expr_stmt|;
block|}
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_pkl
argument_list|)
expr_stmt|;
name|logged
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPFILTER_LOG */
name|fr
operator|->
name|fr_bytes
operator|+=
operator|(
name|U_QUAD_T
operator|)
name|fin
operator|->
name|fin_plen
expr_stmt|;
name|passo
operator|=
name|pass
expr_stmt|;
if|if
condition|(
name|FR_ISSKIP
argument_list|(
name|passt
argument_list|)
condition|)
name|skip
operator|=
name|fr
operator|->
name|fr_arg
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|passt
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOG
condition|)
name|pass
operator|=
name|passt
expr_stmt|;
if|if
condition|(
name|passt
operator|&
operator|(
name|FR_RETICMP
operator||
name|FR_FAKEICMP
operator|)
condition|)
name|fin
operator|->
name|fin_icode
operator|=
name|fr
operator|->
name|fr_icode
expr_stmt|;
name|FR_DEBUG
argument_list|(
operator|(
literal|"pass %#x\n"
operator|,
name|pass
operator|)
argument_list|)
expr_stmt|;
name|ATOMIC_INC64
argument_list|(
name|fr
operator|->
name|fr_hits
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|fr
operator|->
name|fr_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_grp
operator|!=
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_fr
operator|=
operator|*
name|fr
operator|->
name|fr_grp
expr_stmt|;
name|pass
operator|=
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|==
name|NULL
condition|)
block|{
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|fr
operator|->
name|fr_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_DONTCACHE
condition|)
name|logged
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|&
name|FR_QUICK
condition|)
block|{
comment|/* 			 * Finally, if we've asked to track state for this 			 * packet, set it up.  Add state for "quick" rules 			 * here so that if the action fails we can consider 			 * the rule to "not match" and keep on processing 			 * filter rules. 			 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_STATE
operator|)
condition|)
block|{
name|int
name|out
init|=
name|fin
operator|->
name|fin_out
decl_stmt|;
if|if
condition|(
name|fr_addstate
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_ads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bads
argument_list|)
expr_stmt|;
name|pass
operator|=
name|passo
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|logged
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_DONTCACHE
expr_stmt|;
name|fin
operator|->
name|fin_depth
operator|--
expr_stmt|;
return|return
name|pass
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_acctpkt                                                  */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - always returns NULL                            */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Checks a packet against accounting rules, if there are any for the given */
end_comment

begin_comment
comment|/* IP protocol version.                                                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* N.B.: this function returns NULL to match the prototype used by other    */
end_comment

begin_comment
comment|/* functions called from the IPFilter "mainline" in fr_check().             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_acctpkt
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|char
name|group
index|[
name|FR_GROUPLEN
index|]
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|,
modifier|*
name|frsave
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|,
name|rulen
decl_stmt|;
name|passp
operator|=
name|passp
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
name|fr
operator|=
name|ipacct6
index|[
name|fin
operator|->
name|fin_out
index|]
index|[
name|fr_active
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|fr
operator|=
name|ipacct
index|[
name|fin
operator|->
name|fin_out
index|]
index|[
name|fr_active
index|]
expr_stmt|;
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|frsave
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
name|bcopy
argument_list|(
name|fin
operator|->
name|fin_group
argument_list|,
name|group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|rulen
operator|=
name|fin
operator|->
name|fin_rule
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
name|pass
operator|=
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
name|FR_NOMATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_acct
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_fr
operator|=
name|frsave
expr_stmt|;
name|bcopy
argument_list|(
name|group
argument_list|,
name|fin
operator|->
name|fin_group
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_rule
operator|=
name|rulen
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_firewall                                                 */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - returns pointer to matched rule, if no matches */
end_comment

begin_comment
comment|/*                           were found, returns NULL.                      */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Applies an appropriate set of firewall rules to the packet, to see if    */
end_comment

begin_comment
comment|/* there are any matches.  The first check is to see if a match can be seen */
end_comment

begin_comment
comment|/* in the cache.  If not, then search an appropriate list of rules.  Once a */
end_comment

begin_comment
comment|/* matching rule is found, take any appropriate actions as defined by the   */
end_comment

begin_comment
comment|/* rule - except logging.                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|frentry_t
modifier|*
name|fr_firewall
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|fr_info_t
modifier|*
name|fc
decl_stmt|;
name|u_32_t
name|pass
decl_stmt|;
name|int
name|out
decl_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|pass
operator|=
operator|*
name|passp
expr_stmt|;
comment|/* 	 * If a packet is found in the auth table, then skip checking 	 * the access lists for permission but we do need to consider 	 * the result as if it were from the ACL's. 	 */
name|fc
operator|=
operator|&
name|frcache
index|[
name|out
index|]
index|[
name|CACHE_HASH
argument_list|(
name|fin
argument_list|)
index|]
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fc
argument_list|,
name|FI_CSIZE
argument_list|)
condition|)
block|{
comment|/* 		 * copy cached data so we can unlock the mutexes earlier. 		 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
name|FI_COPYSIZE
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_chit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|=
name|fin
operator|->
name|fin_fr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ATOMIC_INC64
argument_list|(
name|fr
operator|->
name|fr_hits
argument_list|)
expr_stmt|;
name|pass
operator|=
name|fr
operator|->
name|fr_flags
expr_stmt|;
block|}
block|}
else|else
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|fin
operator|->
name|fin_v
operator|==
literal|6
condition|)
name|fin
operator|->
name|fin_fr
operator|=
name|ipfilter6
index|[
name|out
index|]
index|[
name|fr_active
index|]
expr_stmt|;
else|else
endif|#
directive|endif
name|fin
operator|->
name|fin_fr
operator|=
name|ipfilter
index|[
name|out
index|]
index|[
name|fr_active
index|]
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_fr
operator|!=
name|NULL
condition|)
name|pass
operator|=
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
name|fr_pass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_KEEPSTATE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_DONTCACHE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fc
argument_list|,
name|FI_COPYSIZE
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_nom
argument_list|)
expr_stmt|;
block|}
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
block|}
comment|/* 	 * Apply packets per second rate-limiting to a rule as required. 	 */
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_pps
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|ppsratecheck
argument_list|(
operator|&
name|fr
operator|->
name|fr_lastpkt
argument_list|,
operator|&
name|fr
operator|->
name|fr_curpps
argument_list|,
name|fr
operator|->
name|fr_pps
argument_list|)
condition|)
block|{
name|pass
operator|&=
operator|~
operator|(
name|FR_CMDMASK
operator||
name|FR_DUP
operator||
name|FR_RETICMP
operator||
name|FR_RETRST
operator|)
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_ppshit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we fail to add a packet to the authorization queue, then we 	 * drop the packet later.  However, if it was added then pretend 	 * we've dropped it already. 	 */
if|if
condition|(
name|FR_ISAUTH
argument_list|(
name|pass
argument_list|)
condition|)
block|{
if|if
condition|(
name|fr_newauth
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|fin
operator|->
name|fin_m
operator|=
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
name|fin
operator|->
name|fin_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fin
operator|->
name|fin_error
operator|=
name|ENOSPC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_func
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_func
operator|!=
operator|(
name|ipfunc_t
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|!
operator|(
name|pass
operator|&
name|FR_CALLNOW
operator|)
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fr
operator|->
name|fr_func
argument_list|)
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
comment|/* 	 * If a rule is a pre-auth rule, check again in the list of rules 	 * loaded for authenticated use.  It does not particulary matter 	 * if this search fails because a "preauth" result, from a rule, 	 * is treated as "not a pass", hence the packet is blocked. 	 */
if|if
condition|(
name|FR_ISPREAUTH
argument_list|(
name|pass
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_fr
operator|=
name|ipauth
operator|)
operator|!=
name|NULL
condition|)
name|pass
operator|=
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
name|fr_pass
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the rule has "keep frag" and the packet is actually a fragment, 	 * then create a fragment state entry. 	 */
if|if
condition|(
operator|(
name|pass
operator|&
operator|(
name|FR_KEEPFRAG
operator||
name|FR_KEEPSTATE
operator|)
operator|)
operator|==
name|FR_KEEPFRAG
condition|)
block|{
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
condition|)
block|{
if|if
condition|(
name|fr_newfrag
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bnfr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_nfr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_cfr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally, if we've asked to track state for this packet, set it up. 	 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_STATE
operator|)
condition|)
block|{
if|if
condition|(
name|fr_addstate
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_ads
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bads
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
block|}
block|}
block|}
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
if|if
condition|(
name|passp
operator|!=
name|NULL
condition|)
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_check                                                    */
end_comment

begin_comment
comment|/* Returns:     int -  0 == packet allowed through,                         */
end_comment

begin_comment
comment|/*              User space:                                                 */
end_comment

begin_comment
comment|/*                    -1 == packet blocked                                  */
end_comment

begin_comment
comment|/*                     1 == packet not matched                              */
end_comment

begin_comment
comment|/*                    -2 == requires authentication                         */
end_comment

begin_comment
comment|/*              Kernel:                                                     */
end_comment

begin_comment
comment|/*> 0 == filter error # for packet                       */
end_comment

begin_comment
comment|/* Parameters: ip(I)   - pointer to start of IPv4/6 packet                  */
end_comment

begin_comment
comment|/*             hlen(I) - length of header                                   */
end_comment

begin_comment
comment|/*             ifp(I)  - pointer to interface this packet is on             */
end_comment

begin_comment
comment|/*             out(I)  - 0 == packet going in, 1 == packet going out        */
end_comment

begin_comment
comment|/*             mp(IO)  - pointer to caller's buffer pointer that holds this */
end_comment

begin_comment
comment|/*                       IP packet.                                         */
end_comment

begin_comment
comment|/* Solaris& HP-UX ONLY :                                                   */
end_comment

begin_comment
comment|/*             qpi(I)  - pointer to STREAMS queue information for this      */
end_comment

begin_comment
comment|/*                       interface& direction.                             */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* fr_check() is the master function for all IPFilter packet processing.    */
end_comment

begin_comment
comment|/* It orchestrates: Network Address Translation (NAT), checking for packet  */
end_comment

begin_comment
comment|/* authorisation (or pre-authorisation), presence of related state info.,   */
end_comment

begin_comment
comment|/* generating log entries, IP packet accounting, routing of packets as      */
end_comment

begin_comment
comment|/* directed by firewall rules and of course whether or not to allow the     */
end_comment

begin_comment
comment|/* packet to be further processed by the kernel.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* For packets blocked, the contents of "mp" will be NULL'd and the buffer  */
end_comment

begin_comment
comment|/* freed.  Packets passed may be returned with the pointer pointed to by    */
end_comment

begin_comment
comment|/* by "mp" changed to a new buffer.                                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_decl_stmt
name|int
name|fr_check
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|,
name|ifp
argument_list|,
name|out
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|MENTAT
argument_list|)
argument_list|,
name|qif
argument_list|,
name|mp
argument_list|)
name|void
modifier|*
name|qif
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_operator
operator|,
end_operator

begin_expr_stmt
name|mp
end_expr_stmt

begin_endif
unit|)
endif|#
directive|endif
end_endif

begin_decl_stmt
name|mb_t
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ip_t
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * The above really sucks, but short of writing a diff 	 */
name|fr_info_t
name|frinfo
decl_stmt|;
name|fr_info_t
modifier|*
name|fin
init|=
operator|&
name|frinfo
decl_stmt|;
name|u_32_t
name|pass
init|=
name|fr_pass
decl_stmt|;
name|frentry_t
modifier|*
name|fr
init|=
name|NULL
decl_stmt|;
name|int
name|v
init|=
name|IP_V
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|mb_t
modifier|*
name|mc
init|=
name|NULL
decl_stmt|;
name|mb_t
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|SPL_INT
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The first part of fr_check() deals with making sure that what goes 	 * into the filtering engine makes some sense.  Information about the 	 * the packet is distilled, collected into a fr_info_t structure and 	 * the an attempt to ensure the buffer the packet is in is big enough 	 * to hold all the required packet headers. 	 */
ifdef|#
directive|ifdef
name|_KERNEL
ifdef|#
directive|ifdef
name|MENTAT
name|qpktinfo_t
modifier|*
name|qpi
init|=
name|qif
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|ip
operator|&
literal|0x3
condition|)
return|return
literal|2
return|;
endif|#
directive|endif
name|READ_ENTER
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MENTAT
if|if
condition|(
name|qpi
operator|->
name|qpi_flags
operator|&
name|QF_GROUP
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
expr_stmt|;
name|m
operator|=
name|qpi
operator|->
name|qpi_m
expr_stmt|;
name|fin
operator|->
name|fin_qfm
operator|=
name|m
expr_stmt|;
name|fin
operator|->
name|fin_qpi
operator|=
name|qpi
expr_stmt|;
else|#
directive|else
comment|/* MENTAT */
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|M_MCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_MLOOP
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MLOOP
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_MULTICAST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M_BCAST
argument_list|)
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|!=
literal|0
condition|)
name|fin
operator|->
name|fin_flx
operator||=
name|FI_MBCAST
operator||
name|FI_BROADCAST
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|M_CANFASTFWD
comment|/* 	 * XXX For now, IP Filter and fast-forwarding of cached flows 	 * XXX are mutually exclusive.  Eventually, IP Filter should 	 * XXX get a "can-fast-forward" filter rule. 	 */
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_CANFASTFWD
expr_stmt|;
endif|#
directive|endif
comment|/* M_CANFASTFWD */
ifdef|#
directive|ifdef
name|CSUM_DELAY_DATA
comment|/* 	 * disable delayed checksums. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CSUM_DELAY_DATA */
endif|#
directive|endif
comment|/* MENTAT */
else|#
directive|else
name|READ_ENTER
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fin
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
name|fin
operator|->
name|fin_v
operator|=
name|v
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|m
expr_stmt|;
name|fin
operator|->
name|fin_ip
operator|=
name|ip
expr_stmt|;
name|fin
operator|->
name|fin_mp
operator|=
name|mp
expr_stmt|;
name|fin
operator|->
name|fin_out
operator|=
name|out
expr_stmt|;
name|fin
operator|->
name|fin_ifp
operator|=
name|ifp
expr_stmt|;
name|fin
operator|->
name|fin_error
operator|=
name|ENETUNREACH
expr_stmt|;
name|fin
operator|->
name|fin_hlen
operator|=
operator|(
name|u_short
operator|)
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_dp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
expr_stmt|;
name|fin
operator|->
name|fin_ipoff
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|-
name|MTOD
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|SPL_NET
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_ipv6
argument_list|)
expr_stmt|;
comment|/* 		 * Jumbo grams are quite likely too big for internal buffer 		 * structures to handle comfortably, for now, so just drop 		 * them. 		 */
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
name|fin
operator|->
name|fin_plen
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_plen
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
name|fin
operator|->
name|fin_plen
operator|+=
sizeof|sizeof
argument_list|(
name|ip6_t
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|OpenBSD
argument_list|)
operator|&&
name|OpenBSD
operator|>=
literal|200311
operator|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fin
operator|->
name|fin_plen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
block|}
if|if
condition|(
name|fr_makefrip
argument_list|(
name|hlen
argument_list|,
name|ip
argument_list|,
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pass
operator|=
name|FR_BLOCK
operator||
name|FR_NOMATCH
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* 	 * For at least IPv6 packets, if a m_pullup() fails then this pointer 	 * becomes NULL and so we have no packet to free. 	 */
if|if
condition|(
operator|*
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
goto|goto
name|finished
goto|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|fr_chksrc
operator|&&
operator|!
name|fr_verifysrc
argument_list|(
name|fin
argument_list|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_badsrc
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_BADSRC
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fin
operator|->
name|fin_ip
operator|->
name|ip_ttl
operator|<
name|fr_minttl
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_badttl
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_LOWTTL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|<
name|fr_minttl
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_badttl
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_flx
operator||=
name|FI_LOWTTL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_short
argument_list|)
expr_stmt|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Check auth now.  This, combined with the check below to see if apass 	 * is 0 is to ensure that we don't count the packet twice, which can 	 * otherwise occur when we reprocess it.  As it is, we only count it 	 * after it has no auth. table matchup.  This also stops NAT from 	 * occuring until after the packet has been auth'd. 	 */
name|fr
operator|=
name|fr_checkauth
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|fr_checknatin
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|out
condition|)
operator|(
name|void
operator|)
name|fr_acctpkt
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_FRAG
operator||
name|FI_BAD
operator|)
operator|)
operator|==
name|FI_FRAG
condition|)
name|fr
operator|=
name|fr_knownfrag
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
name|fr
operator|=
name|fr_checkstate
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
operator|||
operator|(
name|fr
operator|==
name|NULL
operator|)
condition|)
name|fr
operator|=
name|fr_firewall
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fr
expr_stmt|;
comment|/* 	 * Only count/translate packets which will be passed on, out the 	 * interface. 	 */
if|if
condition|(
name|out
operator|&&
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fr_acctpkt
argument_list|(
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_checknatout
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fr_update_ipid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|v
operator|==
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|fr_updateipid
argument_list|(
name|fin
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_ipud
argument_list|)
expr_stmt|;
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_ipud
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
if|if
condition|(
operator|(
name|fr_flags
operator|&
name|FF_LOGGING
operator|)
operator|||
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fr_dolog
argument_list|(
name|fin
argument_list|,
operator|&
name|pass
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fin
operator|->
name|fin_state
operator|!=
name|NULL
condition|)
block|{
name|fr_statederef
argument_list|(
name|fin
argument_list|,
operator|(
name|ipstate_t
operator|*
operator|*
operator|)
operator|&
name|fin
operator|->
name|fin_state
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_state
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|->
name|fin_nat
operator|!=
name|NULL
condition|)
block|{
name|fr_natderef
argument_list|(
operator|(
name|nat_t
operator|*
operator|*
operator|)
operator|&
name|fin
operator|->
name|fin_nat
argument_list|)
expr_stmt|;
name|fin
operator|->
name|fin_nat
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Up the reference on fr_lock and exit ipf_mutex.  fr_fastroute 	 * only frees up the lock on ipf_global and the generation of a 	 * packet below could cause a recursive call into IPFilter. 	 * Hang onto the filter rule just in case someone decides to remove 	 * or flush it in the meantime. 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|&
operator|(
name|FR_RETRST
operator||
name|FR_RETICMP
operator|)
condition|)
block|{
comment|/* 		 * Should we return an ICMP packet to indicate error 		 * status passing through the packet filter ? 		 * WARNING: ICMP error packets AND TCP RST packets should 		 * ONLY be sent in repsonse to incoming packets.  Sending them 		 * in response to outbound packets can result in a panic on 		 * some operating systems. 		 */
if|if
condition|(
operator|!
name|out
condition|)
block|{
if|if
condition|(
name|pass
operator|&
name|FR_RETICMP
condition|)
block|{
name|int
name|dst
decl_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_FAKEICMP
condition|)
name|dst
operator|=
literal|1
expr_stmt|;
else|else
name|dst
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fr_send_icmp_err
argument_list|(
name|ICMP_UNREACH
argument_list|,
name|fin
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_ret
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_RETRST
operator|)
operator|&&
operator|!
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_SHORT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_OOW
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fr_send_reset
argument_list|(
name|fin
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|pass
operator|&
name|FR_RETRST
condition|)
name|fin
operator|->
name|fin_error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
block|}
comment|/* 	 * If we didn't drop off the bottom of the list of rules (and thus 	 * the 'current' rule fr is not NULL), then we may have some extra 	 * instructions about what to do with a packet. 	 * Once we're finished return to our caller, freeing the packet if 	 * we are dropping it (* BSD ONLY *). 	 */
if|if
condition|(
name|fr
operator|!=
name|NULL
condition|)
block|{
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
name|fin
operator|->
name|fin_rev
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|&&
operator|(
name|pass
operator|&
name|FR_FASTROUTE
operator|)
condition|)
block|{
comment|/* 			 * For fastroute rule, no destioation interface defined 			 * so pass NULL as the frdest_t parameter 			 */
operator|(
name|void
operator|)
name|fr_fastroute
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|mp
argument_list|,
name|fin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fdp
operator|->
name|fd_ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ifp
operator|!=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* this is for to rules: */
operator|(
name|void
operator|)
name|fr_fastroute
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|mp
argument_list|,
name|fin
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Generate a duplicated packet. 		 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_DUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|mc
operator|=
name|M_DUPLICATE
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fr_fastroute
argument_list|(
name|mc
argument_list|,
operator|&
name|mc
argument_list|,
name|fin
argument_list|,
operator|&
name|fr
operator|->
name|fr_dif
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fr_derefrule
argument_list|(
operator|&
name|fr
argument_list|)
expr_stmt|;
block|}
name|finished
label|:
if|if
condition|(
operator|!
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
block|{
name|FREE_MB_T
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pass
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sgi
argument_list|)
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_hbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mtod
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|!=
name|fin
operator|->
name|fin_ip
operator|)
condition|)
block|{
name|COPYBACK
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
literal|0
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|,
name|fin
operator|->
name|fin_hbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|SPL_X
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|#
directive|if
name|defined
argument_list|(
name|OpenBSD
argument_list|)
operator|&&
name|OpenBSD
operator|>=
literal|200311
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|v
operator|==
literal|4
operator|)
condition|)
block|{
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
operator|)
condition|?
literal|0
else|:
name|fin
operator|->
name|fin_error
return|;
else|#
directive|else
comment|/* _KERNEL */
name|FR_VERBOSE
argument_list|(
operator|(
literal|"fin_flx %#x pass %#x "
operator|,
name|fin
operator|->
name|fin_flx
operator|,
name|pass
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_RETMASK
operator|)
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|pass
operator|&
name|FR_RETMASK
condition|)
block|{
case|case
name|FR_RETRST
case|:
return|return
literal|3
return|;
case|case
name|FR_RETICMP
case|:
return|return
literal|4
return|;
case|case
name|FR_FAKEICMP
case|:
return|return
literal|5
return|;
block|}
switch|switch
condition|(
name|pass
operator|&
name|FR_CMDMASK
condition|)
block|{
case|case
name|FR_PASS
case|:
return|return
literal|0
return|;
case|case
name|FR_BLOCK
case|:
return|return
operator|-
literal|1
return|;
case|case
name|FR_AUTH
case|:
return|return
operator|-
literal|2
return|;
case|case
name|FR_ACCOUNT
case|:
return|return
operator|-
literal|3
return|;
case|case
name|FR_PREAUTH
case|:
return|return
operator|-
literal|4
return|;
block|}
return|return
literal|2
return|;
endif|#
directive|endif
comment|/* _KERNEL */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_dolog                                                    */
end_comment

begin_comment
comment|/* Returns:     frentry_t* - returns contents of fin_fr (no change made)    */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Checks flags set to see how a packet should be logged, if it is to be    */
end_comment

begin_comment
comment|/* logged.  Adjust statistics based on its success or not.                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_dolog
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|u_32_t
name|pass
decl_stmt|;
name|int
name|out
decl_stmt|;
name|out
operator|=
name|fin
operator|->
name|fin_out
expr_stmt|;
name|pass
operator|=
operator|*
name|passp
expr_stmt|;
if|if
condition|(
operator|(
name|fr_flags
operator|&
name|FF_LOGNOMATCH
operator|)
operator|&&
operator|(
name|pass
operator|&
name|FR_NOMATCH
operator|)
condition|)
block|{
name|pass
operator||=
name|FF_LOGNOMATCH
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_npkl
argument_list|)
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOGP
operator|)
operator|||
operator|(
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|fr_flags
operator|&
name|FF_LOGPASS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOGP
condition|)
name|pass
operator||=
name|FF_LOGPASS
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_ppkl
argument_list|)
expr_stmt|;
goto|goto
name|logit
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|==
name|FR_LOGB
operator|)
operator|||
operator|(
name|FR_ISBLOCK
argument_list|(
name|pass
argument_list|)
operator|&&
operator|(
name|fr_flags
operator|&
name|FF_LOGBLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGMASK
operator|)
operator|!=
name|FR_LOGB
condition|)
name|pass
operator||=
name|FF_LOGBLOCK
expr_stmt|;
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bpkl
argument_list|)
expr_stmt|;
name|logit
label|:
if|if
condition|(
name|ipflog
argument_list|(
name|fin
argument_list|,
name|pass
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|frstats
index|[
name|out
index|]
operator|.
name|fr_skip
argument_list|)
expr_stmt|;
comment|/* 			 * If the "or-block" option has been used then 			 * block the packet if we failed to log it. 			 */
if|if
condition|(
operator|(
name|pass
operator|&
name|FR_LOGORBLOCK
operator|)
operator|&&
name|FR_ISPASS
argument_list|(
name|pass
argument_list|)
condition|)
block|{
name|pass
operator|&=
operator|~
name|FR_CMDMASK
expr_stmt|;
name|pass
operator||=
name|FR_BLOCK
expr_stmt|;
block|}
block|}
operator|*
name|passp
operator|=
name|pass
expr_stmt|;
block|}
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    ipf_cksum                                                   */
end_comment

begin_comment
comment|/* Returns:     u_short - IP header checksum                                */
end_comment

begin_comment
comment|/* Parameters:  addr(I) - pointer to start of buffer to checksum            */
end_comment

begin_comment
comment|/*              len(I)  - length of buffer in bytes                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calculate the two's complement 16 bit checksum of the buffer passed.     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* N.B.: addr should be 16bit aligned.                                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_short
name|ipf_cksum
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|u_short
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_32_t
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
init|;
name|len
operator|>
literal|1
condition|;
name|len
operator|-=
literal|2
control|)
name|sum
operator|+=
operator|*
name|addr
operator|++
expr_stmt|;
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
return|return
call|(
name|u_short
call|)
argument_list|(
operator|~
name|sum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_cksum                                                    */
end_comment

begin_comment
comment|/* Returns:     u_short - layer 4 checksum                                  */
end_comment

begin_comment
comment|/* Parameters:  m(I  )     - pointer to buffer holding packet               */
end_comment

begin_comment
comment|/*              ip(I)      - pointer to IP header                           */
end_comment

begin_comment
comment|/*              l4proto(I) - protocol to caclulate checksum for             */
end_comment

begin_comment
comment|/*              l4hdr(I)   - pointer to layer 4 header                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calculates the TCP checksum for the packet held in "m", using the data   */
end_comment

begin_comment
comment|/* in the IP header "ip" to seed it.                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NB: This function assumes we've pullup'd enough for all of the IP header */
end_comment

begin_comment
comment|/* and the TCP header.  We also assume that data blocks aren't allocated in */
end_comment

begin_comment
comment|/* odd sizes.                                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Expects ip_len to be in host byte order when called.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|u_short
name|fr_cksum
parameter_list|(
name|m
parameter_list|,
name|ip
parameter_list|,
name|l4proto
parameter_list|,
name|l4hdr
parameter_list|)
name|mb_t
modifier|*
name|m
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|int
name|l4proto
decl_stmt|;
name|void
modifier|*
name|l4hdr
decl_stmt|;
block|{
name|u_short
modifier|*
name|sp
decl_stmt|,
name|slen
decl_stmt|,
name|sumsave
decl_stmt|,
name|l4hlen
decl_stmt|,
modifier|*
name|csump
decl_stmt|;
name|u_int
name|sum
decl_stmt|,
name|sum2
decl_stmt|;
name|int
name|hlen
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
name|ip6_t
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|csump
operator|=
name|NULL
expr_stmt|;
name|sumsave
operator|=
literal|0
expr_stmt|;
name|l4hlen
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add up IP Header portion 	 */
ifdef|#
directive|ifdef
name|USE_INET6
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|4
condition|)
block|{
endif|#
directive|endif
name|hlen
operator|=
name|IP_HL
argument_list|(
name|ip
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|slen
operator|=
name|ip
operator|->
name|ip_len
operator|-
name|hlen
expr_stmt|;
name|sum
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|l4proto
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|htons
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ip
operator|->
name|ip_src
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip_src */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip_dst */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
block|}
elseif|else
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|6
condition|)
block|{
name|ip6
operator|=
operator|(
name|ip6_t
operator|*
operator|)
name|ip
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|slen
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|sum
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|l4proto
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|htons
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip6_src */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ip6_dst */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|l4proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|udphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|uh_sum
expr_stmt|;
name|l4hlen
operator|=
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|tcphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|th_sum
expr_stmt|;
name|l4hlen
operator|=
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|icmphdr_t
operator|*
operator|)
name|l4hdr
operator|)
operator|->
name|icmp_cksum
expr_stmt|;
name|l4hlen
operator|=
literal|4
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
break|break;
block|}
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
block|{
name|sumsave
operator|=
operator|*
name|csump
expr_stmt|;
operator|*
name|csump
operator|=
literal|0
expr_stmt|;
block|}
name|l4hlen
operator|=
name|l4hlen
expr_stmt|;
comment|/* LINT */
ifdef|#
directive|ifdef
name|_KERNEL
ifdef|#
directive|ifdef
name|MENTAT
block|{
name|void
modifier|*
name|rp
init|=
name|m
operator|->
name|b_rptr
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|>
name|m
operator|->
name|b_rptr
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ip
operator|<
name|m
operator|->
name|b_wptr
condition|)
name|m
operator|->
name|b_rptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
name|sum2
operator|=
name|ip_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|,
name|sum
argument_list|)
expr_stmt|;
comment|/* hlen == offset */
name|m
operator|->
name|b_rptr
operator|=
name|rp
expr_stmt|;
name|sum2
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|~
name|sum2
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* MENTAT */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|sun
argument_list|)
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|sum2
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|hlen
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|m
operator|->
name|m_data
operator|-=
name|hlen
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_off
operator|-=
name|hlen
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Both sum and sum2 are partial sums, so combine them together. 	 */
name|sum
operator|+=
operator|~
name|sum2
operator|&
literal|0xffff
expr_stmt|;
while|while
condition|(
name|sum
operator|>
literal|0xffff
condition|)
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
name|sum2
operator|=
operator|~
name|sum
operator|&
literal|0xffff
expr_stmt|;
else|#
directive|else
comment|/* defined(BSD) || defined(sun) */
block|{
union|union
block|{
name|u_char
name|c
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|s
decl_stmt|;
block|}
name|bytes
union|;
name|u_short
name|len
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__sgi
argument_list|)
name|int
name|add
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Add up IP Header portion 	 */
if|if
condition|(
name|sp
operator|!=
operator|(
name|u_short
operator|*
operator|)
name|l4hdr
condition|)
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|l4hdr
expr_stmt|;
switch|switch
condition|(
name|l4proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* sport */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* dport */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* udp length */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* checksum */
break|break;
case|case
name|IPPROTO_TCP
case|:
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* sport */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* dport */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* seq */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* ack */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* off */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* win */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* checksum */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* urp */
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|sum
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* type/code */
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* checksum */
break|break;
block|}
ifdef|#
directive|ifdef
name|__sgi
comment|/* 	 * In case we had to copy the IP& TCP header out of mbufs, 	 * skip over the mbuf bits which are the header 	 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|ip
operator|!=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
condition|)
block|{
name|hlen
operator|=
operator|(
name|caddr_t
operator|)
name|sp
operator|-
operator|(
name|caddr_t
operator|)
name|ip
expr_stmt|;
while|while
condition|(
name|hlen
condition|)
block|{
name|add
operator|=
name|MIN
argument_list|(
name|hlen
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|add
operator|)
expr_stmt|;
name|hlen
operator|-=
name|add
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|!
name|hlen
condition|)
block|{
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|sp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
block|}
name|PANIC
argument_list|(
operator|(
operator|!
name|m
operator|)
argument_list|,
operator|(
literal|"fr_cksum(1): not enough data"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|len
operator|-=
operator|(
name|l4hlen
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|nodata
goto|;
while|while
condition|(
name|len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|sp
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|)
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|PANIC
argument_list|(
operator|(
operator|!
name|m
operator|)
argument_list|,
operator|(
literal|"fr_cksum(2): not enough data"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|)
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
name|bytes
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|sp
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|PANIC
argument_list|(
operator|(
operator|!
name|m
operator|)
argument_list|,
operator|(
literal|"fr_cksum(3): not enough data"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
name|bytes
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|sp
expr_stmt|;
name|sum
operator|+=
name|bytes
operator|.
name|s
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|sp
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|u_long
operator|)
name|sp
operator|&
literal|1
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|++
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bytes
operator|.
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|bytes
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|bytes
operator|.
name|s
expr_stmt|;
block|}
else|else
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|sum
operator|+=
name|ntohs
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|sp
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|nodata
label|:
while|while
condition|(
name|sum
operator|>
literal|0xffff
condition|)
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
name|sum2
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|~
name|sum
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  defined(BSD) || defined(sun) */
endif|#
directive|endif
comment|/* MENTAT */
else|#
directive|else
comment|/* _KERNEL */
for|for
control|(
init|;
name|slen
operator|>
literal|1
condition|;
name|slen
operator|-=
literal|2
control|)
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|slen
condition|)
name|sum
operator|+=
name|ntohs
argument_list|(
operator|*
operator|(
name|u_char
operator|*
operator|)
name|sp
operator|<<
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
name|sum
operator|>
literal|0xffff
condition|)
name|sum
operator|=
operator|(
name|sum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
name|sum2
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|~
name|sum
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
operator|*
name|csump
operator|=
name|sumsave
expr_stmt|;
return|return
name|sum2
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|BSD
operator|<
literal|199103
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_AIX51
argument_list|)
end_if

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)uipc_mbuf.c	8.2 (Berkeley) 1/4/94  * $Id: fil.c,v 2.243.2.70 2005/12/07 08:15:16 darrenr Exp $  */
end_comment

begin_comment
comment|/*  * Copy data from an mbuf chain starting "off" bytes from the beginning,  * continuing for "len" bytes, into the indicated buffer.  */
end_comment

begin_function
name|void
name|m_copydata
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|cp
parameter_list|)
name|mb_t
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
block|{
name|unsigned
name|count
decl_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|len
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"m_copydata"
argument_list|)
expr_stmt|;
while|while
condition|(
name|off
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"m_copydata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|m
operator|->
name|m_len
condition|)
break|break;
name|off
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"m_copydata"
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|cp
operator|+=
name|count
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy data from a buffer back into the indicated mbuf chain,  * starting "off" bytes from the beginning, extending the mbuf  * chain if necessary.  */
end_comment

begin_function
name|void
name|m_copyback
parameter_list|(
name|m0
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|cp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
block|{
name|int
name|mlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|totlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|off
operator|>
operator|(
name|mlen
operator|=
name|m
operator|->
name|m_len
operator|)
condition|)
block|{
name|off
operator|-=
name|mlen
expr_stmt|;
name|totlen
operator|+=
name|mlen
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|len
operator|+
name|off
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|mlen
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|off
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|mlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|mlen
expr_stmt|;
name|len
operator|-=
name|mlen
expr_stmt|;
name|mlen
operator|+=
name|off
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|totlen
operator|+=
name|mlen
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|n
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|out
label|:
if|#
directive|if
literal|0
block|if (((m = m0)->m_flags& M_PKTHDR)&& (m->m_pkthdr.len< totlen)) 		m->m_pkthdr.len = totlen;
endif|#
directive|endif
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (_KERNEL)&& ( ((BSD< 199103)&& !MENTAT) || __sgi) */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_findgroup                                                */
end_comment

begin_comment
comment|/* Returns:     frgroup_t * - NULL = group not found, else pointer to group */
end_comment

begin_comment
comment|/* Parameters:  group(I) - group name to search for                         */
end_comment

begin_comment
comment|/*              unit(I)  - device to which this group belongs               */
end_comment

begin_comment
comment|/*              set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/*              fgpp(O)  - pointer to place to store pointer to the pointer */
end_comment

begin_comment
comment|/*                         to where to add the next (last) group or where   */
end_comment

begin_comment
comment|/*                         to delete group from.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search amongst the defined groups for a particular group number.         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frgroup_t
modifier|*
name|fr_findgroup
parameter_list|(
name|group
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|,
name|fgpp
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|set
decl_stmt|;
name|frgroup_t
modifier|*
modifier|*
modifier|*
name|fgpp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
comment|/* 	 * Which list of groups to search in is dependent on which list of 	 * rules are being operated on. 	 */
name|fgp
operator|=
operator|&
name|ipfgroups
index|[
name|unit
index|]
index|[
name|set
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|fg
operator|=
operator|*
name|fgp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|group
argument_list|,
name|fg
operator|->
name|fg_name
argument_list|,
name|FR_GROUPLEN
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
name|fgp
operator|=
operator|&
name|fg
operator|->
name|fg_next
expr_stmt|;
block|}
if|if
condition|(
name|fgpp
operator|!=
name|NULL
condition|)
operator|*
name|fgpp
operator|=
name|fgp
expr_stmt|;
return|return
name|fg
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_addgroup                                                 */
end_comment

begin_comment
comment|/* Returns:     frgroup_t * - NULL == did not create group,                 */
end_comment

begin_comment
comment|/*                            != NULL == pointer to the group               */
end_comment

begin_comment
comment|/* Parameters:  num(I)   - group number to add                              */
end_comment

begin_comment
comment|/*              head(I)  - rule pointer that is using this as the head      */
end_comment

begin_comment
comment|/*              flags(I) - rule flags which describe the type of rule it is */
end_comment

begin_comment
comment|/*              unit(I)  - device to which this group will belong to        */
end_comment

begin_comment
comment|/*              set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add a new group head, or if it already exists, increase the reference    */
end_comment

begin_comment
comment|/* count to it.                                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frgroup_t
modifier|*
name|fr_addgroup
parameter_list|(
name|group
parameter_list|,
name|head
parameter_list|,
name|flags
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|void
modifier|*
name|head
decl_stmt|;
name|u_32_t
name|flags
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
name|u_32_t
name|gflags
decl_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGIPF
operator|&&
operator|*
name|group
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|fgp
operator|=
name|NULL
expr_stmt|;
name|gflags
operator|=
name|flags
operator|&
name|FR_INOUT
expr_stmt|;
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
operator|&
name|fgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|==
literal|0
condition|)
name|fg
operator|->
name|fg_flags
operator|=
name|gflags
expr_stmt|;
elseif|else
if|if
condition|(
name|gflags
operator|!=
name|fg
operator|->
name|fg_flags
condition|)
return|return
name|NULL
return|;
name|fg
operator|->
name|fg_ref
operator|++
expr_stmt|;
return|return
name|fg
return|;
block|}
name|KMALLOC
argument_list|(
name|fg
argument_list|,
name|frgroup_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
block|{
name|fg
operator|->
name|fg_head
operator|=
name|head
expr_stmt|;
name|fg
operator|->
name|fg_start
operator|=
name|NULL
expr_stmt|;
name|fg
operator|->
name|fg_next
operator|=
operator|*
name|fgp
expr_stmt|;
name|bcopy
argument_list|(
name|group
argument_list|,
name|fg
operator|->
name|fg_name
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|fg
operator|->
name|fg_flags
operator|=
name|gflags
expr_stmt|;
name|fg
operator|->
name|fg_ref
operator|=
literal|1
expr_stmt|;
operator|*
name|fgp
operator|=
name|fg
expr_stmt|;
block|}
return|return
name|fg
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_delgroup                                                 */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  group(I) - group name to delete                             */
end_comment

begin_comment
comment|/*              unit(I)  - device to which this group belongs               */
end_comment

begin_comment
comment|/*              set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Attempt to delete a group head.                                          */
end_comment

begin_comment
comment|/* Only do this when its reference count reaches 0.                         */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_delgroup
parameter_list|(
name|group
parameter_list|,
name|unit
parameter_list|,
name|set
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|,
modifier|*
modifier|*
name|fgp
decl_stmt|;
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
operator|&
name|fgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
return|return;
name|fg
operator|->
name|fg_ref
operator|--
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|fg_ref
operator|==
literal|0
condition|)
block|{
operator|*
name|fgp
operator|=
name|fg
operator|->
name|fg_next
expr_stmt|;
name|KFREE
argument_list|(
name|fg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_getrulen                                                 */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - NULL == not found, else pointer to rule n     */
end_comment

begin_comment
comment|/* Parameters:  unit(I)  - device for which to count the rule's number      */
end_comment

begin_comment
comment|/*              flags(I) - which set of rules to find the rule in           */
end_comment

begin_comment
comment|/*              group(I) - group name                                       */
end_comment

begin_comment
comment|/*              n(I)     - rule number to find                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Find rule # n in group # g and return a pointer to it.  Return NULl if   */
end_comment

begin_comment
comment|/* group # g doesn't exist or there are less than n rules in the group.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_getrulen
parameter_list|(
name|unit
parameter_list|,
name|group
parameter_list|,
name|n
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|u_32_t
name|n
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|group
argument_list|,
name|unit
argument_list|,
name|fr_active
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|fr
operator|=
name|fg
operator|->
name|fg_head
init|;
name|fr
operator|&&
name|n
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
operator|,
name|n
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_rulen                                                    */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - rule number, -1 == search failed               */
end_comment

begin_comment
comment|/* Parameters:  unit(I) - device for which to count the rule's number       */
end_comment

begin_comment
comment|/*              fr(I)   - pointer to rule to match                          */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Return the number for a rule on a specific filtering device.             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_rulen
parameter_list|(
name|unit
parameter_list|,
name|fr
parameter_list|)
name|int
name|unit
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fh
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|u_32_t
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|fr
operator|->
name|fr_group
argument_list|,
name|unit
argument_list|,
name|fr_active
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|fh
operator|=
name|fg
operator|->
name|fg_head
init|;
name|fh
condition|;
name|n
operator|++
operator|,
name|fh
operator|=
name|fh
operator|->
name|fr_next
control|)
if|if
condition|(
name|fh
operator|==
name|fr
condition|)
break|break;
if|if
condition|(
name|fh
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frflushlist                                                 */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of flushed rules                        */
end_comment

begin_comment
comment|/* Parameters:  set(I)   - which set of rules (inactive/inactive) this is   */
end_comment

begin_comment
comment|/*              unit(I)  - device for which to flush rules                  */
end_comment

begin_comment
comment|/*              flags(I) - which set of rules to flush                      */
end_comment

begin_comment
comment|/*              nfreedp(O) - pointer to int where flush count is stored     */
end_comment

begin_comment
comment|/*              listp(I)   - pointer to list to flush pointer               */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Recursively flush rules from the list, descending groups as they are     */
end_comment

begin_comment
comment|/* encountered.  if a rule is the head of a group and it has lost all its   */
end_comment

begin_comment
comment|/* group members, then also delete the group reference.  nfreedp is needed  */
end_comment

begin_comment
comment|/* to store the accumulating count of rules removed, whereas the returned   */
end_comment

begin_comment
comment|/* value is just the number removed from the current list.  The latter is   */
end_comment

begin_comment
comment|/* needed to correctly adjust reference counts on rules that define groups. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: Rules not loaded from user space cannot be flushed.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|frflushlist
parameter_list|(
name|set
parameter_list|,
name|unit
parameter_list|,
name|nfreedp
parameter_list|,
name|listp
parameter_list|)
name|int
name|set
decl_stmt|;
name|minor_t
name|unit
decl_stmt|;
name|int
modifier|*
name|nfreedp
decl_stmt|;
name|frentry_t
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|freed
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|frentry_t
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|listp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
name|FR_T_BUILTIN
operator|)
operator|||
operator|!
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
condition|)
block|{
name|listp
operator|=
operator|&
name|fp
operator|->
name|fr_next
expr_stmt|;
continue|continue;
block|}
operator|*
name|listp
operator|=
name|fp
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_grp
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
name|nfreedp
argument_list|,
name|fp
operator|->
name|fr_grp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_ref
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_grhead
operator|!=
name|NULL
condition|)
block|{
name|fr_delgroup
argument_list|(
name|fp
operator|->
name|fr_grhead
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|->
name|fr_grhead
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|fp
operator|->
name|fr_ref
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fr_derefrule
argument_list|(
operator|&
name|fp
argument_list|)
operator|==
literal|0
condition|)
name|freed
operator|++
expr_stmt|;
block|}
operator|*
name|nfreedp
operator|+=
name|freed
expr_stmt|;
return|return
name|freed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frflush                                                     */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of flushed rules                        */
end_comment

begin_comment
comment|/* Parameters:  unit(I)  - device for which to flush rules                  */
end_comment

begin_comment
comment|/*              flags(I) - which set of rules to flush                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Calls flushlist() for all filter rules (accounting, firewall - both IPv4 */
end_comment

begin_comment
comment|/* and IPv6) as defined by the value of flags.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|frflush
parameter_list|(
name|unit
parameter_list|,
name|proto
parameter_list|,
name|flags
parameter_list|)
name|minor_t
name|unit
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|int
name|flushed
init|=
literal|0
decl_stmt|,
name|set
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frcache
argument_list|,
sizeof|sizeof
argument_list|(
name|frcache
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|fr_active
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FR_INACTIVE
operator|)
operator|==
name|FR_INACTIVE
condition|)
name|set
operator|=
literal|1
operator|-
name|set
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FR_OUTQUE
condition|)
block|{
if|if
condition|(
name|proto
operator|==
literal|0
operator|||
name|proto
operator|==
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipfilter6
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipacct6
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|==
literal|0
operator|||
name|proto
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipfilter
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipacct
index|[
literal|1
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|FR_INQUE
condition|)
block|{
if|if
condition|(
name|proto
operator|==
literal|0
operator|||
name|proto
operator|==
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipfilter6
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipacct6
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|==
literal|0
operator|||
name|proto
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipfilter
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflushlist
argument_list|(
name|set
argument_list|,
name|unit
argument_list|,
operator|&
name|flushed
argument_list|,
operator|&
name|ipacct
index|[
literal|0
index|]
index|[
name|set
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGIPF
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|frflush
argument_list|(
name|IPL_LOGCOUNT
argument_list|,
name|proto
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|0
condition|)
name|flushed
operator|+=
name|tmp
expr_stmt|;
block|}
return|return
name|flushed
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    memstr                                                      */
end_comment

begin_comment
comment|/* Returns:     char *  - NULL if failed, != NULL pointer to matching bytes */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to byte sequence to match                 */
end_comment

begin_comment
comment|/*              dst(I)  - pointer to byte sequence to search                */
end_comment

begin_comment
comment|/*              slen(I) - match length                                      */
end_comment

begin_comment
comment|/*              dlen(I) - length available to search in                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search dst for a sequence of bytes matching those at src and extend for  */
end_comment

begin_comment
comment|/* slen bytes.                                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|char
modifier|*
name|memstr
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|slen
parameter_list|,
name|dlen
parameter_list|)
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|dlen
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|dlen
operator|>=
name|slen
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|dst
expr_stmt|;
break|break;
block|}
name|dst
operator|++
expr_stmt|;
name|dlen
operator|--
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_fixskip                                                  */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  listp(IO)    - pointer to start of list with skip rule      */
end_comment

begin_comment
comment|/*              rp(I)        - rule added/removed with skip in it.          */
end_comment

begin_comment
comment|/*              addremove(I) - adjustment (-1/+1) to make to skip count,    */
end_comment

begin_comment
comment|/*                             depending on whether a rule was just added   */
end_comment

begin_comment
comment|/*                             or removed.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Adjust all the rules in a list which would have skip'd past the position */
end_comment

begin_comment
comment|/* where we are inserting to skip to the right place given the change.      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_fixskip
parameter_list|(
name|listp
parameter_list|,
name|rp
parameter_list|,
name|addremove
parameter_list|)
name|frentry_t
modifier|*
modifier|*
name|listp
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|addremove
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rules
decl_stmt|,
name|rn
decl_stmt|;
name|frentry_t
modifier|*
name|fp
decl_stmt|;
name|rules
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
operator|*
name|listp
init|;
operator|(
name|fp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fp
operator|!=
name|rp
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_next
control|)
name|rules
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
for|for
control|(
name|rn
operator|=
literal|0
operator|,
name|fp
operator|=
operator|*
name|listp
init|;
name|fp
operator|&&
operator|(
name|fp
operator|!=
name|rp
operator|)
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_next
operator|,
name|rn
operator|++
control|)
if|if
condition|(
name|FR_ISSKIP
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
operator|&&
operator|(
name|rn
operator|+
name|fp
operator|->
name|fr_arg
operator|>=
name|rules
operator|)
condition|)
name|fp
operator|->
name|fr_arg
operator|+=
name|addremove
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    count4bits                                                  */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of consecutive bits in input            */
end_comment

begin_comment
comment|/* Parameters:  ip(I) - 32bit IP address                                    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv4 ONLY                                                                */
end_comment

begin_comment
comment|/* count consecutive 1's in bit mask.  If the mask generated by counting    */
end_comment

begin_comment
comment|/* consecutive 1's is different to that passed, return -1, else return #    */
end_comment

begin_comment
comment|/* of bits.                                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|count4bits
parameter_list|(
name|ip
parameter_list|)
name|u_32_t
name|ip
decl_stmt|;
block|{
name|u_32_t
name|ipn
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ip
operator|=
name|ipn
operator|=
name|ntohl
argument_list|(
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|ipn
operator|*=
literal|2
control|)
if|if
condition|(
name|ipn
operator|&
literal|0x80000000
condition|)
name|cnt
operator|++
expr_stmt|;
else|else
break|break;
name|ipn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
operator|,
name|j
operator|=
name|cnt
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|j
operator|--
control|)
block|{
name|ipn
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|ipn
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ipn
operator|==
name|ip
condition|)
return|return
name|cnt
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    count6bits                                                  */
end_comment

begin_comment
comment|/* Returns:     int ->= 0 - number of consecutive bits in input            */
end_comment

begin_comment
comment|/* Parameters:  msk(I) - pointer to start of IPv6 bitmask                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* IPv6 ONLY                                                                */
end_comment

begin_comment
comment|/* count consecutive 1's in bit mask.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_endif
unit|int count6bits(msk) u_32_t *msk; { 	int i = 0, k; 	u_32_t j;  	for (k = 3; k>= 0; k--) 		if (msk[k] == 0xffffffff) 			i += 32; 		else { 			for (j = msk[k]; j; j<<= 1) 				if (j& 0x80000000) 					i++; 		} 	return i; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frsynclist                                                  */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  fr(I)  - start of filter list to sync interface names for   */
end_comment

begin_comment
comment|/*              ifp(I) - interface pointer for limiting sync lookups        */
end_comment

begin_comment
comment|/* Write Locks: ipf_mutex                                                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Walk through a list of filter rules and resolve any interface names into */
end_comment

begin_comment
comment|/* pointers.  Where dynamic addresses are used, also update the IP address  */
end_comment

begin_comment
comment|/* used in the rule.  The interface pointer is used to limit the lookups to */
end_comment

begin_comment
comment|/* a specific set of matching names if it is non-NULL.                      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|frsynclist
parameter_list|(
name|fr
parameter_list|,
name|ifp
parameter_list|)
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|int
name|v
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
init|;
name|fr
condition|;
name|fr
operator|=
name|fr
operator|->
name|fr_next
control|)
block|{
name|v
operator|=
name|fr
operator|->
name|fr_v
expr_stmt|;
comment|/* 		 * Lookup all the interface names that are part of the rule. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|!=
name|ifp
operator|)
condition|)
continue|continue;
name|fr
operator|->
name|fr_ifas
index|[
name|i
index|]
operator|=
name|fr_resolvenic
argument_list|(
name|fr
operator|->
name|fr_ifnames
index|[
name|i
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_type
operator|==
name|FR_T_IPF
condition|)
block|{
if|if
condition|(
name|fr
operator|->
name|fr_satype
operator|!=
name|FRI_NORMAL
operator|&&
name|fr
operator|->
name|fr_satype
operator|!=
name|FRI_LOOKUP
condition|)
block|{
operator|(
name|void
operator|)
name|fr_ifpaddr
argument_list|(
name|v
argument_list|,
name|fr
operator|->
name|fr_satype
argument_list|,
name|fr
operator|->
name|fr_ifas
index|[
name|fr
operator|->
name|fr_sifpidx
index|]
argument_list|,
operator|&
name|fr
operator|->
name|fr_src
argument_list|,
operator|&
name|fr
operator|->
name|fr_smsk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_datype
operator|!=
name|FRI_NORMAL
operator|&&
name|fr
operator|->
name|fr_datype
operator|!=
name|FRI_LOOKUP
condition|)
block|{
operator|(
name|void
operator|)
name|fr_ifpaddr
argument_list|(
name|v
argument_list|,
name|fr
operator|->
name|fr_datype
argument_list|,
name|fr
operator|->
name|fr_ifas
index|[
name|fr
operator|->
name|fr_difpidx
index|]
argument_list|,
operator|&
name|fr
operator|->
name|fr_dst
argument_list|,
operator|&
name|fr
operator|->
name|fr_dmsk
argument_list|)
expr_stmt|;
block|}
block|}
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ifp
operator|==
name|ifp
operator|)
condition|)
name|fr_resolvedest
argument_list|(
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_tifs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ifp
operator|==
name|ifp
operator|)
condition|)
name|fr_resolvedest
argument_list|(
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fdp
operator|=
operator|&
name|fr
operator|->
name|fr_dif
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdp
operator|->
name|fd_ifp
operator|==
name|ifp
operator|)
condition|)
block|{
name|fr_resolvedest
argument_list|(
name|fdp
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_flags
operator|&=
operator|~
name|FR_DUP
expr_stmt|;
if|if
condition|(
operator|(
name|fdp
operator|->
name|fd_ifp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ifp
operator|!=
name|NULL
operator|)
condition|)
name|fr
operator|->
name|fr_flags
operator||=
name|FR_DUP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
if|if
condition|(
name|fr
operator|->
name|fr_type
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
operator|&&
name|fr
operator|->
name|fr_srcptr
operator|==
name|NULL
condition|)
block|{
name|fr
operator|->
name|fr_srcptr
operator|=
name|fr_resolvelookup
argument_list|(
name|fr
operator|->
name|fr_srctype
argument_list|,
name|fr
operator|->
name|fr_srcnum
argument_list|,
operator|&
name|fr
operator|->
name|fr_srcfunc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fr
operator|->
name|fr_type
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
operator|&&
name|fr
operator|->
name|fr_dstptr
operator|==
name|NULL
condition|)
block|{
name|fr
operator|->
name|fr_dstptr
operator|=
name|fr_resolvelookup
argument_list|(
name|fr
operator|->
name|fr_dsttype
argument_list|,
name|fr
operator|->
name|fr_dstnum
argument_list|,
operator|&
name|fr
operator|->
name|fr_dstfunc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frsync                                                      */
end_comment

begin_comment
comment|/* Returns:     void                                                        */
end_comment

begin_comment
comment|/* Parameters:  Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* frsync() is called when we suspect that the interface list or            */
end_comment

begin_comment
comment|/* information about interfaces (like IP#) has changed.  Go through all     */
end_comment

begin_comment
comment|/* filter rules, NAT entries and the state table and check if anything      */
end_comment

begin_comment
comment|/* needs to be changed/updated.                                             */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|frsync
parameter_list|(
name|ifp
parameter_list|)
name|void
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|SOLARIS
name|fr_natsync
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|fr_statesync
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipacct
index|[
literal|0
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipacct
index|[
literal|1
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipfilter
index|[
literal|0
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipfilter
index|[
literal|1
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipacct6
index|[
literal|0
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipacct6
index|[
literal|1
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipfilter6
index|[
literal|0
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|frsynclist
argument_list|(
name|ipfilter6
index|[
literal|1
index|]
index|[
name|fr_active
index|]
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPL_LOGSIZE
condition|;
name|i
operator|++
control|)
block|{
name|frgroup_t
modifier|*
name|g
decl_stmt|;
for|for
control|(
name|g
operator|=
name|ipfgroups
index|[
name|i
index|]
index|[
literal|0
index|]
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|fg_next
control|)
name|frsynclist
argument_list|(
name|g
operator|->
name|fg_start
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|ipfgroups
index|[
name|i
index|]
index|[
literal|1
index|]
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|fg_next
control|)
name|frsynclist
argument_list|(
name|g
operator|->
name|fg_start
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In the functions below, bcopy() is called because the pointer being  * copied _from_ in this instance is a pointer to a char buf (which could  * end up being unaligned) and on the kernel's local stack.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    copyinptr                                                   */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to the source address                     */
end_comment

begin_comment
comment|/*              dst(I)  - destination address                               */
end_comment

begin_comment
comment|/*              size(I) - number of bytes to copy                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy a block of data in from user space, given a pointer to the pointer  */
end_comment

begin_comment
comment|/* to start copying from (src) and a pointer to where to store it (dst).    */
end_comment

begin_comment
comment|/* NB: src - pointer to user space pointer, dst - kernel space pointer      */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|copyinptr
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|ca
decl_stmt|;
name|int
name|err
decl_stmt|;
if|#
directive|if
name|SOLARIS
name|err
operator|=
name|COPYIN
argument_list|(
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
else|#
directive|else
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|COPYIN
argument_list|(
name|ca
argument_list|,
name|dst
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    copyoutptr                                                  */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  src(I)  - pointer to the source address                     */
end_comment

begin_comment
comment|/*              dst(I)  - destination address                               */
end_comment

begin_comment
comment|/*              size(I) - number of bytes to copy                           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy a block of data out to user space, given a pointer to the pointer   */
end_comment

begin_comment
comment|/* to start copying from (src) and a pointer to where to store it (dst).    */
end_comment

begin_comment
comment|/* NB: src - kernel space pointer, dst - pointer to user space pointer.     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|copyoutptr
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|ca
decl_stmt|;
name|int
name|err
decl_stmt|;
if|#
directive|if
name|SOLARIS
name|err
operator|=
name|COPYIN
argument_list|(
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
else|#
directive|else
name|bcopy
argument_list|(
name|dst
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|COPYOUT
argument_list|(
name|src
argument_list|,
name|ca
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_lock                                                     */
end_comment

begin_comment
comment|/* Returns:     (void)                                                      */
end_comment

begin_comment
comment|/* Parameters:  data(I)  - pointer to lock value to set                     */
end_comment

begin_comment
comment|/*              lockp(O) - pointer to location to store old lock value      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Get the new value for the lock integer, set it and return the old value  */
end_comment

begin_comment
comment|/* in *lockp.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_lock
parameter_list|(
name|data
parameter_list|,
name|lockp
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
name|int
modifier|*
name|lockp
decl_stmt|;
block|{
name|int
name|arg
decl_stmt|;
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|BCOPYOUT
argument_list|(
operator|(
name|caddr_t
operator|)
name|lockp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lockp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lockp
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_getstat                                                  */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fiop(I)  - pointer to ipfilter stats structure              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Stores a copy of current pointers, counters, etc, in the friostat        */
end_comment

begin_comment
comment|/* structure.                                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_getstat
parameter_list|(
name|fiop
parameter_list|)
name|friostat_t
modifier|*
name|fiop
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frstats
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fiop
operator|->
name|f_st
argument_list|,
sizeof|sizeof
argument_list|(
name|filterstats_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGSTATE
index|]
operator|=
name|fr_state_lock
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGNAT
index|]
operator|=
name|fr_nat_lock
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGIPF
index|]
operator|=
name|fr_frag_lock
expr_stmt|;
name|fiop
operator|->
name|f_locks
index|[
name|IPL_LOGAUTH
index|]
operator|=
name|fr_auth_lock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|fiop
operator|->
name|f_ipf
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ipfilter
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ipacct
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|fiop
operator|->
name|f_ipf6
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ipfilter6
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|fiop
operator|->
name|f_acct6
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|ipacct6
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|fiop
operator|->
name|f_ticks
operator|=
name|fr_ticks
expr_stmt|;
name|fiop
operator|->
name|f_active
operator|=
name|fr_active
expr_stmt|;
name|fiop
operator|->
name|f_froute
index|[
literal|0
index|]
operator|=
name|fr_frouteok
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_froute
index|[
literal|1
index|]
operator|=
name|fr_frouteok
index|[
literal|1
index|]
expr_stmt|;
name|fiop
operator|->
name|f_running
operator|=
name|fr_running
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPL_LOGSIZE
condition|;
name|i
operator|++
control|)
block|{
name|fiop
operator|->
name|f_groups
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|ipfgroups
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fiop
operator|->
name|f_groups
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|ipfgroups
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|fiop
operator|->
name|f_logging
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|fiop
operator|->
name|f_logging
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fiop
operator|->
name|f_defpass
operator|=
name|fr_pass
expr_stmt|;
name|fiop
operator|->
name|f_features
operator|=
name|fr_features
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fiop
operator|->
name|f_version
argument_list|,
name|ipfilter_version
argument_list|,
sizeof|sizeof
argument_list|(
name|fiop
operator|->
name|f_version
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_decl_stmt
name|int
name|icmptoicmp6types
index|[
name|ICMP_MAXTYPE
operator|+
literal|1
index|]
init|=
block|{
name|ICMP6_ECHO_REPLY
block|,
comment|/* 0: ICMP_ECHOREPLY */
operator|-
literal|1
block|,
comment|/* 1: UNUSED */
operator|-
literal|1
block|,
comment|/* 2: UNUSED */
name|ICMP6_DST_UNREACH
block|,
comment|/* 3: ICMP_UNREACH */
operator|-
literal|1
block|,
comment|/* 4: ICMP_SOURCEQUENCH */
name|ND_REDIRECT
block|,
comment|/* 5: ICMP_REDIRECT */
operator|-
literal|1
block|,
comment|/* 6: UNUSED */
operator|-
literal|1
block|,
comment|/* 7: UNUSED */
name|ICMP6_ECHO_REQUEST
block|,
comment|/* 8: ICMP_ECHO */
operator|-
literal|1
block|,
comment|/* 9: UNUSED */
operator|-
literal|1
block|,
comment|/* 10: UNUSED */
name|ICMP6_TIME_EXCEEDED
block|,
comment|/* 11: ICMP_TIMXCEED */
name|ICMP6_PARAM_PROB
block|,
comment|/* 12: ICMP_PARAMPROB */
operator|-
literal|1
block|,
comment|/* 13: ICMP_TSTAMP */
operator|-
literal|1
block|,
comment|/* 14: ICMP_TSTAMPREPLY */
operator|-
literal|1
block|,
comment|/* 15: ICMP_IREQ */
operator|-
literal|1
block|,
comment|/* 16: ICMP_IREQREPLY */
operator|-
literal|1
block|,
comment|/* 17: ICMP_MASKREQ */
operator|-
literal|1
block|,
comment|/* 18: ICMP_MASKREPLY */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icmptoicmp6unreach
index|[
name|ICMP_MAX_UNREACH
index|]
init|=
block|{
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 0: ICMP_UNREACH_NET */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 1: ICMP_UNREACH_HOST */
operator|-
literal|1
block|,
comment|/* 2: ICMP_UNREACH_PROTOCOL */
name|ICMP6_DST_UNREACH_NOPORT
block|,
comment|/* 3: ICMP_UNREACH_PORT */
operator|-
literal|1
block|,
comment|/* 4: ICMP_UNREACH_NEEDFRAG */
name|ICMP6_DST_UNREACH_NOTNEIGHBOR
block|,
comment|/* 5: ICMP_UNREACH_SRCFAIL */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 6: ICMP_UNREACH_NET_UNKNOWN */
name|ICMP6_DST_UNREACH_ADDR
block|,
comment|/* 7: ICMP_UNREACH_HOST_UNKNOWN */
operator|-
literal|1
block|,
comment|/* 8: ICMP_UNREACH_ISOLATED */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 9: ICMP_UNREACH_NET_PROHIB */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 10: ICMP_UNREACH_HOST_PROHIB */
operator|-
literal|1
block|,
comment|/* 11: ICMP_UNREACH_TOSNET */
operator|-
literal|1
block|,
comment|/* 12: ICMP_UNREACH_TOSHOST */
name|ICMP6_DST_UNREACH_ADMIN
block|,
comment|/* 13: ICMP_UNREACH_ADMIN_PROHIBIT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icmpreplytype6
index|[
name|ICMP6_MAXTYPE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|icmpreplytype4
index|[
name|ICMP_MAXTYPE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_matchicmpqueryreply                                      */
end_comment

begin_comment
comment|/* Returns:     int - 1 if "icmp" is a valid reply to "ic" else 0.          */
end_comment

begin_comment
comment|/* Parameters:  v(I)    - IP protocol version (4 or 6)                      */
end_comment

begin_comment
comment|/*              ic(I)   - ICMP information                                  */
end_comment

begin_comment
comment|/*              icmp(I) - ICMP packet header                                */
end_comment

begin_comment
comment|/*              rev(I)  - direction (0 = forward/1 = reverse) of packet     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Check if the ICMP packet defined by the header pointed to by icmp is a   */
end_comment

begin_comment
comment|/* reply to one as described by what's in ic.  If it is a match, return 1,  */
end_comment

begin_comment
comment|/* else return 0 for no match.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_matchicmpqueryreply
parameter_list|(
name|v
parameter_list|,
name|ic
parameter_list|,
name|icmp
parameter_list|,
name|rev
parameter_list|)
name|int
name|v
decl_stmt|;
name|icmpinfo_t
modifier|*
name|ic
decl_stmt|;
name|icmphdr_t
modifier|*
name|icmp
decl_stmt|;
name|int
name|rev
decl_stmt|;
block|{
name|int
name|ictype
decl_stmt|;
name|ictype
operator|=
name|ic
operator|->
name|ici_type
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
comment|/* 		 * If we matched its type on the way in, then when going out 		 * it will still be the same type. 		 */
if|if
condition|(
operator|(
operator|!
name|rev
operator|&&
operator|(
name|icmp
operator|->
name|icmp_type
operator|==
name|ictype
operator|)
operator|)
operator|||
operator|(
name|rev
operator|&&
operator|(
name|icmpreplytype4
index|[
name|ictype
index|]
operator|==
name|icmp
operator|->
name|icmp_type
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP_ECHOREPLY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|icmp
operator|->
name|icmp_id
operator|==
name|ic
operator|->
name|ici_id
condition|)
return|return
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|rev
operator|&&
operator|(
name|icmp
operator|->
name|icmp_type
operator|==
name|ictype
operator|)
operator|)
operator|||
operator|(
name|rev
operator|&&
operator|(
name|icmpreplytype6
index|[
name|ictype
index|]
operator|==
name|icmp
operator|->
name|icmp_type
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|icmp
operator|->
name|icmp_type
operator|!=
name|ICMP6_ECHO_REPLY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|icmp
operator|->
name|icmp_id
operator|==
name|ic
operator|->
name|ici_id
condition|)
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_resolvelookup                                            */
end_comment

begin_comment
comment|/* Returns:     void * - NULL = failure, else success.                      */
end_comment

begin_comment
comment|/* Parameters:  type(I)     - type of lookup these parameters are for.      */
end_comment

begin_comment
comment|/*              number(I)   - table number to use when searching            */
end_comment

begin_comment
comment|/*              funcptr(IO) - pointer to pointer for storing IP address     */
end_comment

begin_comment
comment|/*                           searching function.                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for the "table" number passed in amongst those configured for     */
end_comment

begin_comment
comment|/* that particular type.  If the type is recognised then the function to    */
end_comment

begin_comment
comment|/* call to do the IP address search will be change, regardless of whether   */
end_comment

begin_comment
comment|/* or not the "table" number exists.                                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|fr_resolvelookup
parameter_list|(
name|type
parameter_list|,
name|number
parameter_list|,
name|funcptr
parameter_list|)
name|u_int
name|type
decl_stmt|,
name|number
decl_stmt|;
name|lookupfunc_t
modifier|*
name|funcptr
decl_stmt|;
block|{
name|char
name|name
index|[
name|FR_GROUPLEN
index|]
decl_stmt|;
name|iphtable_t
modifier|*
name|iph
decl_stmt|;
name|ip_pool_t
modifier|*
name|ipo
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SNPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|SNPRINTF
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|number
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%u"
argument_list|,
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|READ_ENTER
argument_list|(
operator|&
name|ip_poolrw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IPLT_POOL
case|:
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
name|ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|funcptr
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|ipo
operator|=
name|ip_pool_find
argument_list|(
name|IPL_LOGIPF
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ipo
expr_stmt|;
if|if
condition|(
name|ipo
operator|!=
name|NULL
condition|)
block|{
name|ATOMIC_INC32
argument_list|(
name|ipo
operator|->
name|ipo_ref
argument_list|)
expr_stmt|;
block|}
operator|*
name|funcptr
operator|=
name|ip_pool_search
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IPLT_HASH
case|:
name|iph
operator|=
name|fr_findhtable
argument_list|(
name|IPL_LOGIPF
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|iph
expr_stmt|;
if|if
condition|(
name|iph
operator|!=
name|NULL
condition|)
block|{
name|ATOMIC_INC32
argument_list|(
name|iph
operator|->
name|iph_ref
argument_list|)
expr_stmt|;
block|}
operator|*
name|funcptr
operator|=
name|fr_iphmfindip
expr_stmt|;
break|break;
default|default:
name|ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|funcptr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ip_poolrw
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    frrequest                                                   */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success,> 0 == errno value                      */
end_comment

begin_comment
comment|/* Parameters:  unit(I)     - device for which this is for                  */
end_comment

begin_comment
comment|/*              req(I)      - ioctl command (SIOC*)                         */
end_comment

begin_comment
comment|/*              data(I)     - pointr to ioctl data                          */
end_comment

begin_comment
comment|/*              set(I)      - 1 or 0 (filter set)                           */
end_comment

begin_comment
comment|/*              makecopy(I) - flag indicating whether data points to a rule */
end_comment

begin_comment
comment|/*                            in kernel space& hence doesn't need copying. */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function handles all the requests which operate on the list of      */
end_comment

begin_comment
comment|/* filter rules.  This includes adding, deleting, insertion.  It is also    */
end_comment

begin_comment
comment|/* responsible for creating groups when a "head" rule is loaded.  Interface */
end_comment

begin_comment
comment|/* names are resolved here and other sanity checks are made on the content  */
end_comment

begin_comment
comment|/* of the rule structure being loaded.  If a rule has user defined timeouts */
end_comment

begin_comment
comment|/* then make sure they are created and initialised before exiting.          */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|frrequest
parameter_list|(
name|unit
parameter_list|,
name|req
parameter_list|,
name|data
parameter_list|,
name|set
parameter_list|,
name|makecopy
parameter_list|)
name|int
name|unit
decl_stmt|;
name|ioctlcmd_t
name|req
decl_stmt|;
name|int
name|set
decl_stmt|,
name|makecopy
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|frentry_t
name|frd
decl_stmt|,
modifier|*
name|fp
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|fprev
decl_stmt|,
modifier|*
modifier|*
name|ftail
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|in
decl_stmt|,
name|v
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|uptr
decl_stmt|;
name|u_int
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|fg
operator|=
name|NULL
expr_stmt|;
name|fp
operator|=
operator|&
name|frd
expr_stmt|;
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
name|fp
argument_list|,
name|IPFOBJ_FRENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_T_BUILTIN
operator|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|fp
operator|->
name|fr_ref
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fr_flags
operator||=
name|FR_COPIED
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
operator|(
name|frentry_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_type
operator|&
name|FR_T_BUILTIN
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|fp
operator|->
name|fr_flags
operator|&=
operator|~
name|FR_COPIED
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|fp
operator|->
name|fr_dsize
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|fr_dsize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_data
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|v
operator|=
name|fp
operator|->
name|fr_v
expr_stmt|;
name|uptr
operator|=
name|fp
operator|->
name|fr_data
expr_stmt|;
comment|/* 	 * Only filter rules for IPv4 or IPv6 are accepted. 	 */
if|if
condition|(
name|v
operator|==
literal|4
condition|)
comment|/*EMPTY*/
empty_stmt|;
ifdef|#
directive|ifdef
name|USE_INET6
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
comment|/*EMPTY*/
empty_stmt|;
endif|#
directive|endif
else|else
block|{
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * If the rule is being loaded from user space, i.e. we had to copy it 	 * into kernel space, then do not trust the function pointer in the 	 * rule. 	 */
if|if
condition|(
operator|(
name|makecopy
operator|==
literal|1
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_func
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|fr_findfunc
argument_list|(
name|fp
operator|->
name|fr_func
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
name|error
operator|=
name|fr_funcinit
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
name|ptr
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Check that the group number does exist and that its use (in/out) 	 * matches what the rule is. 	 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|fp
operator|->
name|fr_grhead
argument_list|,
literal|"0"
argument_list|,
name|FR_GROUPLEN
argument_list|)
condition|)
operator|*
name|fp
operator|->
name|fr_grhead
operator|=
literal|'\0'
expr_stmt|;
name|group
operator|=
name|fp
operator|->
name|fr_group
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|group
argument_list|,
literal|"0"
argument_list|,
name|FR_GROUPLEN
argument_list|)
condition|)
operator|*
name|group
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|unit
operator|=
name|IPL_LOGCOUNT
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|!=
operator|(
name|int
operator|)
name|SIOCZRLST
operator|)
operator|&&
operator|(
operator|*
name|group
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|==
literal|0
condition|)
name|fg
operator|->
name|fg_flags
operator|=
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|fg
operator|->
name|fg_flags
operator|!=
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INOUT
operator|)
condition|)
return|return
name|ESRCH
return|;
block|}
name|in
operator|=
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INQUE
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* 	 * Work out which rule list this change is being applied to. 	 */
name|ftail
operator|=
name|NULL
expr_stmt|;
name|fprev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
name|fprev
operator|=
operator|&
name|ipauth
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|fprev
operator|=
operator|&
name|ipacct
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
operator|(
name|FR_OUTQUE
operator||
name|FR_INQUE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fprev
operator|=
operator|&
name|ipfilter
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|FR_ISACCOUNT
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|fprev
operator|=
operator|&
name|ipacct6
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
operator|(
name|FR_OUTQUE
operator||
name|FR_INQUE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fprev
operator|=
operator|&
name|ipfilter6
index|[
name|in
index|]
index|[
name|set
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fprev
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
operator|*
name|group
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fg
operator|&&
operator|!
operator|(
name|fg
operator|=
name|fr_findgroup
argument_list|(
name|group
argument_list|,
name|unit
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
name|ESRCH
return|;
name|fprev
operator|=
operator|&
name|fg
operator|->
name|fg_start
expr_stmt|;
block|}
name|ftail
operator|=
name|fprev
expr_stmt|;
for|for
control|(
name|f
operator|=
operator|*
name|ftail
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_collect
operator|<=
name|f
operator|->
name|fr_collect
condition|)
block|{
name|ftail
operator|=
name|fprev
expr_stmt|;
name|f
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|fprev
operator|=
name|ftail
expr_stmt|;
block|}
comment|/* 	 * Copy in extra data for the rule. 	 */
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
block|{
name|KMALLOCS
argument_list|(
name|ptr
argument_list|,
name|void
operator|*
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|COPYIN
argument_list|(
name|uptr
argument_list|,
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|uptr
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|KFREES
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|fp
operator|->
name|fr_data
operator|=
name|ptr
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|fr_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Perform per-rule type sanity checks of their members. 	 */
switch|switch
condition|(
name|fp
operator|->
name|fr_type
operator|&
operator|~
name|FR_T_BUILTIN
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPFILTER_BPF
argument_list|)
case|case
name|FR_T_BPFOPC
case|:
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|bpf_validate
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|makecopy
operator|&&
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|FR_T_IPF
case|:
if|if
condition|(
name|fp
operator|->
name|fr_dsize
operator|!=
sizeof|sizeof
argument_list|(
name|fripf_t
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 		 * Allowing a rule with both "keep state" and "with oow" is 		 * pointless because adding a state entry to the table will 		 * fail with the out of window (oow) flag set. 		 */
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_KEEPSTATE
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_flx
operator|&
name|FI_OOW
operator|)
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|fp
operator|->
name|fr_satype
condition|)
block|{
case|case
name|FRI_BROADCAST
case|:
case|case
name|FRI_DYNAMIC
case|:
case|case
name|FRI_NETWORK
case|:
case|case
name|FRI_NETMASKED
case|:
case|case
name|FRI_PEERADDR
case|:
if|if
condition|(
name|fp
operator|->
name|fr_sifpidx
operator|<
literal|0
operator|||
name|fp
operator|->
name|fr_sifpidx
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|makecopy
operator|&&
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
case|case
name|FRI_LOOKUP
case|:
name|fp
operator|->
name|fr_srcptr
operator|=
name|fr_resolvelookup
argument_list|(
name|fp
operator|->
name|fr_srctype
argument_list|,
name|fp
operator|->
name|fr_srcnum
argument_list|,
operator|&
name|fp
operator|->
name|fr_srcfunc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
break|break;
block|}
switch|switch
condition|(
name|fp
operator|->
name|fr_datype
condition|)
block|{
case|case
name|FRI_BROADCAST
case|:
case|case
name|FRI_DYNAMIC
case|:
case|case
name|FRI_NETWORK
case|:
case|case
name|FRI_NETMASKED
case|:
case|case
name|FRI_PEERADDR
case|:
if|if
condition|(
name|fp
operator|->
name|fr_difpidx
operator|<
literal|0
operator|||
name|fp
operator|->
name|fr_difpidx
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|makecopy
operator|&&
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
case|case
name|FRI_LOOKUP
case|:
name|fp
operator|->
name|fr_dstptr
operator|=
name|fr_resolvelookup
argument_list|(
name|fp
operator|->
name|fr_dsttype
argument_list|,
name|fp
operator|->
name|fr_dstnum
argument_list|,
operator|&
name|fp
operator|->
name|fr_dstfunc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
break|break;
block|}
break|break;
case|case
name|FR_T_NONE
case|:
break|break;
case|case
name|FR_T_CALLFUNC
case|:
break|break;
case|case
name|FR_T_COMPIPF
case|:
break|break;
default|default :
if|if
condition|(
name|makecopy
operator|&&
name|fp
operator|->
name|fr_data
operator|!=
name|NULL
condition|)
block|{
name|KFREES
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Lookup all the interface names that are part of the rule. 	 */
name|frsynclist
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_statecnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look for an existing matching filter rule, but don't include the 	 * next or interface pointer in the comparison (fr_next, fr_ifa). 	 * This elminates rules which are indentical being loaded.  Checksum 	 * the constant part of the filter rule to make comparisons quicker 	 * (this meaning no pointers are included). 	 */
for|for
control|(
name|fp
operator|->
name|fr_cksum
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_func
operator|,
name|pp
operator|=
operator|&
name|fp
operator|->
name|fr_cksum
init|;
name|p
operator|<
name|pp
condition|;
name|p
operator|++
control|)
name|fp
operator|->
name|fr_cksum
operator|+=
operator|*
name|p
expr_stmt|;
name|pp
operator|=
operator|(
name|u_int
operator|*
operator|)
operator|(
name|fp
operator|->
name|fr_caddr
operator|+
name|fp
operator|->
name|fr_dsize
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|u_int
operator|*
operator|)
name|fp
operator|->
name|fr_data
init|;
name|p
operator|<
name|pp
condition|;
name|p
operator|++
control|)
name|fp
operator|->
name|fr_cksum
operator|+=
operator|*
name|p
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frcache
argument_list|,
sizeof|sizeof
argument_list|(
name|frcache
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_cksum
operator|!=
name|f
operator|->
name|fr_cksum
operator|)
operator|||
operator|(
name|f
operator|->
name|fr_dsize
operator|!=
name|fp
operator|->
name|fr_dsize
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|f
operator|->
name|fr_func
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_func
argument_list|,
name|FR_CMPSIZ
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|!
name|ptr
operator|&&
operator|!
name|f
operator|->
name|fr_data
operator|)
operator|||
operator|(
name|ptr
operator|&&
name|f
operator|->
name|fr_data
operator|&&
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fr_data
argument_list|,
name|f
operator|->
name|fr_dsize
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* 	 * If zero'ing statistics, copy current to caller and zero. 	 */
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCZRLST
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
else|else
block|{
comment|/* 			 * Copy and reduce lock because of impending copyout. 			 * Well we should, but if we do then the atomicity of 			 * this call and the correctness of fr_hits and 			 * fr_bytes cannot be guaranteed.  As it is, this code 			 * only resets them to 0 if they are successfully 			 * copied out into user space. 			 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MUTEX_DOWNGRADE(&ipf_mutex); */
comment|/* 			 * When we copy this rule back out, set the data 			 * pointer to be what it was in user space. 			 */
name|fp
operator|->
name|fr_data
operator|=
name|uptr
expr_stmt|;
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
name|fp
argument_list|,
name|IPFOBJ_FRENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|fr_dsize
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|uptr
operator|!=
name|NULL
operator|)
condition|)
name|error
operator|=
name|COPYOUT
argument_list|(
name|f
operator|->
name|fr_data
argument_list|,
name|uptr
argument_list|,
name|f
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|f
operator|->
name|fr_hits
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|fr_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|makecopy
operator|!=
literal|0
operator|)
condition|)
block|{
name|KFREES
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* 		 * At the end of this, ftail must point to the place where the 		 * new rule is to be saved/inserted/added. 		 * For SIOCAD*FR, this should be the last rule in the group of 		 * rules that have equal fr_collect fields. 		 * For SIOCIN*FR, ... 		 */
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADIFR
condition|)
block|{
for|for
control|(
name|ftail
operator|=
name|fprev
init|;
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|>
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
name|f
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINIFR
condition|)
block|{
while|while
condition|(
operator|(
name|f
operator|=
operator|*
name|fprev
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|>=
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|fprev
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
block|}
name|ftail
operator|=
name|fprev
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_hits
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|fp
operator|->
name|fr_hits
operator|&&
operator|(
name|f
operator|=
operator|*
name|ftail
operator|)
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|fr_collect
operator|!=
name|fp
operator|->
name|fr_collect
condition|)
break|break;
name|fprev
operator|=
name|ftail
expr_stmt|;
name|ftail
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
name|fp
operator|->
name|fr_hits
operator|--
expr_stmt|;
block|}
block|}
name|f
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Request to remove a rule. 	 */
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCRMAFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCRMIFR
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
else|else
block|{
comment|/* 			 * Do not allow activity from user space to interfere 			 * with rules not loaded that way. 			 */
if|if
condition|(
operator|(
name|makecopy
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|f
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Return EBUSY if the rule is being reference by 			 * something else (eg state information. 			 */
if|if
condition|(
name|f
operator|->
name|fr_ref
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|f
operator|->
name|fr_isctag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|f
operator|->
name|fr_isc
operator|!=
operator|(
expr|struct
name|ipscan
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
name|ipsc_detachfr
argument_list|(
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fg
operator|->
name|fg_head
operator|!=
name|NULL
operator|)
condition|)
name|fg
operator|->
name|fg_head
operator|->
name|fr_ref
operator|--
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
block|{
name|error
operator|=
name|fr_preauthcmd
argument_list|(
name|req
argument_list|,
name|f
argument_list|,
name|ftail
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|f
operator|->
name|fr_grhead
operator|!=
literal|'\0'
condition|)
name|fr_delgroup
argument_list|(
name|f
operator|->
name|fr_grhead
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|fr_fixskip
argument_list|(
name|ftail
argument_list|,
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ftail
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
name|f
operator|->
name|fr_next
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fr_derefrule
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Not removing, so we must be adding/inserting a rule. 		 */
if|if
condition|(
name|f
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
if|if
condition|(
name|unit
operator|==
name|IPL_LOGAUTH
condition|)
block|{
name|error
operator|=
name|fr_preauthcmd
argument_list|(
name|req
argument_list|,
name|fp
argument_list|,
name|ftail
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|makecopy
condition|)
block|{
name|KMALLOC
argument_list|(
name|f
argument_list|,
name|frentry_t
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fg
operator|!=
name|NULL
operator|&&
name|fg
operator|->
name|fg_head
operator|!=
name|NULL
condition|)
name|fg
operator|->
name|fg_head
operator|->
name|fr_ref
operator|++
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|f
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|f
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|f
operator|->
name|fr_lock
argument_list|,
literal|"filter rule lock"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|f
operator|->
name|fr_isctag
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|ipsc_attachfr
argument_list|(
name|f
argument_list|)
condition|)
name|f
operator|->
name|fr_isc
operator|=
operator|(
expr|struct
name|ipscan
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|f
operator|->
name|fr_hits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|makecopy
operator|!=
literal|0
condition|)
name|f
operator|->
name|fr_ref
operator|=
literal|1
expr_stmt|;
name|f
operator|->
name|fr_next
operator|=
operator|*
name|ftail
expr_stmt|;
operator|*
name|ftail
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINIFR
operator|||
name|req
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCINAFR
condition|)
name|fr_fixskip
argument_list|(
name|ftail
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
operator|->
name|fr_grp
operator|=
name|NULL
expr_stmt|;
name|group
operator|=
name|f
operator|->
name|fr_grhead
expr_stmt|;
if|if
condition|(
operator|*
name|group
operator|!=
literal|'\0'
condition|)
block|{
name|fg
operator|=
name|fr_addgroup
argument_list|(
name|group
argument_list|,
name|f
argument_list|,
name|f
operator|->
name|fr_flags
argument_list|,
name|unit
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|NULL
condition|)
name|f
operator|->
name|fr_grp
operator|=
operator|&
name|fg
operator|->
name|fg_start
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
name|done
label|:
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|error
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|makecopy
operator|!=
literal|0
operator|)
condition|)
block|{
name|KFREES
argument_list|(
name|ptr
argument_list|,
name|fp
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_funcinit                                                 */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else ESRCH: cannot resolve rule details */
end_comment

begin_comment
comment|/* Parameters:  fr(I) - pointer to filter rule                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If a rule is a call rule, then check if the function it points to needs  */
end_comment

begin_comment
comment|/* an init function to be called now the rule has been loaded.              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_funcinit
parameter_list|(
name|fr
parameter_list|)
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|ipfunc_resolve_t
modifier|*
name|ft
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|ESRCH
expr_stmt|;
for|for
control|(
name|ft
operator|=
name|fr_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|fr
operator|->
name|fr_func
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|ipfu_init
operator|!=
name|NULL
condition|)
name|err
operator|=
call|(
modifier|*
name|ft
operator|->
name|ipfu_init
call|)
argument_list|(
name|fr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_findfunc                                                 */
end_comment

begin_comment
comment|/* Returns:     ipfunc_t - pointer to function if found, else NULL          */
end_comment

begin_comment
comment|/* Parameters:  funcptr(I) - function pointer to lookup                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a function in the table of known functions.                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipfunc_t
name|fr_findfunc
parameter_list|(
name|funcptr
parameter_list|)
name|ipfunc_t
name|funcptr
decl_stmt|;
block|{
name|ipfunc_resolve_t
modifier|*
name|ft
decl_stmt|;
for|for
control|(
name|ft
operator|=
name|fr_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|funcptr
condition|)
return|return
name|funcptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_resolvefunc                                              */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else error                              */
end_comment

begin_comment
comment|/* Parameters:  data(IO) - ioctl data pointer to ipfunc_resolve_t struct    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy in a ipfunc_resolve_t structure and then fill in the missing field. */
end_comment

begin_comment
comment|/* This will either be the function name (if the pointer is set) or the     */
end_comment

begin_comment
comment|/* function pointer if the name is set.  When found, fill in the other one  */
end_comment

begin_comment
comment|/* so that the entire, complete, structure can be copied back to user space.*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_resolvefunc
parameter_list|(
name|data
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|ipfunc_resolve_t
name|res
decl_stmt|,
modifier|*
name|ft
decl_stmt|;
name|BCOPYIN
argument_list|(
name|data
argument_list|,
operator|&
name|res
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|ipfu_addr
operator|==
name|NULL
operator|&&
name|res
operator|.
name|ipfu_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|ft
operator|=
name|fr_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|,
name|ft
operator|->
name|ipfu_name
argument_list|,
sizeof|sizeof
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|ipfu_addr
operator|=
name|ft
operator|->
name|ipfu_addr
expr_stmt|;
name|res
operator|.
name|ipfu_init
operator|=
name|ft
operator|->
name|ipfu_init
expr_stmt|;
if|if
condition|(
name|COPYOUT
argument_list|(
operator|&
name|res
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EFAULT
return|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|res
operator|.
name|ipfu_addr
operator|!=
name|NULL
operator|&&
name|res
operator|.
name|ipfu_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|ft
operator|=
name|fr_availfuncs
init|;
name|ft
operator|->
name|ipfu_addr
operator|!=
name|NULL
condition|;
name|ft
operator|++
control|)
if|if
condition|(
name|ft
operator|->
name|ipfu_addr
operator|==
name|res
operator|.
name|ipfu_addr
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|,
name|ft
operator|->
name|ipfu_name
argument_list|,
sizeof|sizeof
argument_list|(
name|res
operator|.
name|ipfu_name
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|ipfu_init
operator|=
name|ft
operator|->
name|ipfu_init
expr_stmt|;
if|if
condition|(
name|COPYOUT
argument_list|(
operator|&
name|res
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EFAULT
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ESRCH
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|<
literal|490000
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
operator|(
name|__NetBSD_Version__
operator|<
literal|105000000
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|(
name|OpenBSD
operator|<
literal|200006
operator|)
operator|)
end_if

begin_comment
comment|/*  * From: NetBSD  * ppsratecheck(): packets (or events) per second limitation.  */
end_comment

begin_function
name|int
name|ppsratecheck
parameter_list|(
name|lasttime
parameter_list|,
name|curpps
parameter_list|,
name|maxpps
parameter_list|)
name|struct
name|timeval
modifier|*
name|lasttime
decl_stmt|;
name|int
modifier|*
name|curpps
decl_stmt|;
name|int
name|maxpps
decl_stmt|;
comment|/* maximum pps allowed */
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|GETKTIME
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|delta
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|lasttime
operator|->
name|tv_sec
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
operator|-
name|lasttime
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|delta
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|delta
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
comment|/* 	 * check for 0,0 is so that the message will be seen at least once. 	 * if more than one second have passed since the last update of 	 * lasttime, reset the counter. 	 * 	 * we do increment *curpps even in *curpps< maxpps case, as some may 	 * try to use *curpps for stat purposes as well. 	 */
if|if
condition|(
operator|(
name|lasttime
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|lasttime
operator|->
name|tv_usec
operator|==
literal|0
operator|)
operator|||
name|delta
operator|.
name|tv_sec
operator|>=
literal|1
condition|)
block|{
operator|*
name|lasttime
operator|=
name|tv
expr_stmt|;
operator|*
name|curpps
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxpps
operator|<
literal|0
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|curpps
operator|<
name|maxpps
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
else|else
name|rv
operator|=
literal|0
expr_stmt|;
operator|*
name|curpps
operator|=
operator|*
name|curpps
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_derefrule                                                */
end_comment

begin_comment
comment|/* Returns:     int   - 0 == rule freed up, else rule not freed             */
end_comment

begin_comment
comment|/* Parameters:  fr(I) - pointer to filter rule                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Decrement the reference counter to a rule by one.  If it reaches zero,   */
end_comment

begin_comment
comment|/* free it and any associated storage space being used by it.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_derefrule
parameter_list|(
name|frp
parameter_list|)
name|frentry_t
modifier|*
modifier|*
name|frp
decl_stmt|;
block|{
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|fr
operator|=
operator|*
name|frp
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|fr
operator|->
name|fr_ref
operator|--
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_ref
operator|==
literal|0
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
if|if
condition|(
name|fr
operator|->
name|fr_type
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_satype
operator|==
name|FRI_LOOKUP
condition|)
name|ip_lookup_deref
argument_list|(
name|fr
operator|->
name|fr_srctype
argument_list|,
name|fr
operator|->
name|fr_srcptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fr_type
operator|==
name|FR_T_IPF
operator|&&
name|fr
operator|->
name|fr_datype
operator|==
name|FRI_LOOKUP
condition|)
name|ip_lookup_deref
argument_list|(
name|fr
operator|->
name|fr_dsttype
argument_list|,
name|fr
operator|->
name|fr_dstptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fr
operator|->
name|fr_dsize
condition|)
block|{
name|KFREES
argument_list|(
name|fr
operator|->
name|fr_data
argument_list|,
name|fr
operator|->
name|fr_dsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_COPIED
operator|)
operator|!=
literal|0
condition|)
block|{
name|KFREE
argument_list|(
name|fr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|fr
operator|->
name|fr_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|frp
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_grpmapinit                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else ESRCH because table entry not found*/
end_comment

begin_comment
comment|/* Parameters:  fr(I) - pointer to rule to find hash table for              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Looks for group hash table fr_arg and stores a pointer to it in fr_ptr.  */
end_comment

begin_comment
comment|/* fr_ptr is later used by fr_srcgrpmap and fr_dstgrpmap.                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_grpmapinit
parameter_list|(
name|fr
parameter_list|)
name|frentry_t
modifier|*
name|fr
decl_stmt|;
block|{
name|char
name|name
index|[
name|FR_GROUPLEN
index|]
decl_stmt|;
name|iphtable_t
modifier|*
name|iph
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SNPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|SNPRINTF
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|fr
operator|->
name|fr_arg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d"
argument_list|,
name|fr
operator|->
name|fr_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iph
operator|=
name|fr_findhtable
argument_list|(
name|IPL_LOGIPF
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
operator|(
name|iph
operator|->
name|iph_flags
operator|&
name|FR_INOUT
operator|)
operator|!=
operator|(
name|fr
operator|->
name|fr_flags
operator|&
name|FR_INOUT
operator|)
condition|)
return|return
name|ESRCH
return|;
name|fr
operator|->
name|fr_ptr
operator|=
name|iph
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_srcgrpmap                                                */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - pointer to "new last matching" rule or NULL   */
end_comment

begin_comment
comment|/* Parameters:  fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a rule group head in a hash table, using the source address as  */
end_comment

begin_comment
comment|/* the key, and descend into that group and continue matching rules against */
end_comment

begin_comment
comment|/* the packet.                                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_srcgrpmap
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|void
modifier|*
name|rval
decl_stmt|;
name|rval
operator|=
name|fr_iphmfindgroup
argument_list|(
name|fin
operator|->
name|fin_fr
operator|->
name|fr_ptr
argument_list|,
operator|&
name|fin
operator|->
name|fin_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fg
operator|=
name|rval
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
operator|(
name|void
operator|)
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
operator|*
name|passp
argument_list|)
expr_stmt|;
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_dstgrpmap                                                */
end_comment

begin_comment
comment|/* Returns:     frentry_t * - pointer to "new last matching" rule or NULL   */
end_comment

begin_comment
comment|/* Parameters:  fin(I)    - pointer to packet information                   */
end_comment

begin_comment
comment|/*              passp(IO) - pointer to current/new filter decision (unused) */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a rule group head in a hash table, using the destination        */
end_comment

begin_comment
comment|/* address as the key, and descend into that group and continue matching    */
end_comment

begin_comment
comment|/* rules against  the packet.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|frentry_t
modifier|*
name|fr_dstgrpmap
parameter_list|(
name|fin
parameter_list|,
name|passp
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
name|u_32_t
modifier|*
name|passp
decl_stmt|;
block|{
name|frgroup_t
modifier|*
name|fg
decl_stmt|;
name|void
modifier|*
name|rval
decl_stmt|;
name|rval
operator|=
name|fr_iphmfindgroup
argument_list|(
name|fin
operator|->
name|fin_fr
operator|->
name|fr_ptr
argument_list|,
operator|&
name|fin
operator|->
name|fin_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fg
operator|=
name|rval
expr_stmt|;
name|fin
operator|->
name|fin_fr
operator|=
name|fg
operator|->
name|fg_start
expr_stmt|;
operator|(
name|void
operator|)
name|fr_scanlist
argument_list|(
name|fin
argument_list|,
operator|*
name|passp
argument_list|)
expr_stmt|;
return|return
name|fin
operator|->
name|fin_fr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOOKUP */
end_comment

begin_comment
comment|/*  * Queue functions  * ===============  * These functions manage objects on queues for efficient timeouts.  There are  * a number of system defined queues as well as user defined timeouts.  It is  * expected that a lock is held in the domain in which the queue belongs  * (i.e. either state or NAT) when calling any of these functions that prevents  * fr_freetimeoutqueue() from being called at the same time as any other.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_addtimeoutqueue                                          */
end_comment

begin_comment
comment|/* Returns:     struct ifqtq * - NULL if malloc fails, else pointer to      */
end_comment

begin_comment
comment|/*                               timeout queue with given interval.         */
end_comment

begin_comment
comment|/* Parameters:  parent(I)  - pointer to pointer to parent node of this list */
end_comment

begin_comment
comment|/*                           of interface queues.                           */
end_comment

begin_comment
comment|/*              seconds(I) - timeout value in seconds for this queue.       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This routine first looks for a timeout queue that matches the interval   */
end_comment

begin_comment
comment|/* being requested.  If it finds one, increments the reference counter and  */
end_comment

begin_comment
comment|/* returns a pointer to it.  If none are found, it allocates a new one and  */
end_comment

begin_comment
comment|/* inserts it at the top of the list.                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking.                                                                 */
end_comment

begin_comment
comment|/* It is assumed that the caller of this function has an appropriate lock   */
end_comment

begin_comment
comment|/* held (exclusively) in the domain that encompases 'parent'.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|ipftq_t
modifier|*
name|fr_addtimeoutqueue
parameter_list|(
name|parent
parameter_list|,
name|seconds
parameter_list|)
name|ipftq_t
modifier|*
modifier|*
name|parent
decl_stmt|;
name|u_int
name|seconds
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|period
operator|=
name|seconds
operator|*
name|IPF_HZ_DIVIDE
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
for|for
control|(
name|ifq
operator|=
operator|*
name|parent
init|;
name|ifq
operator|!=
name|NULL
condition|;
name|ifq
operator|=
name|ifq
operator|->
name|ifq_next
control|)
block|{
if|if
condition|(
name|ifq
operator|->
name|ifq_ttl
operator|==
name|period
condition|)
block|{
comment|/* 			 * Reset the delete flag, if set, so the structure 			 * gets reused rather than freed and reallocated. 			 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|ifq
operator|->
name|ifq_flags
operator|&=
operator|~
name|IFQF_DELETE
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
return|return
name|ifq
return|;
block|}
block|}
name|KMALLOC
argument_list|(
name|ifq
argument_list|,
name|ipftq_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifq
operator|!=
name|NULL
condition|)
block|{
name|ifq
operator|->
name|ifq_ttl
operator|=
name|period
expr_stmt|;
name|ifq
operator|->
name|ifq_head
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
operator|&
name|ifq
operator|->
name|ifq_head
expr_stmt|;
name|ifq
operator|->
name|ifq_next
operator|=
operator|*
name|parent
expr_stmt|;
name|ifq
operator|->
name|ifq_pnext
operator|=
name|parent
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|=
literal|1
expr_stmt|;
name|ifq
operator|->
name|ifq_flags
operator|=
name|IFQF_USER
expr_stmt|;
operator|*
name|parent
operator|=
name|ifq
expr_stmt|;
name|fr_userifqs
operator|++
expr_stmt|;
name|MUTEX_NUKE
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|,
literal|"ipftq mutex"
argument_list|)
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipf_timeoutlock
argument_list|)
expr_stmt|;
return|return
name|ifq
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_deletetimeoutqueue                                       */
end_comment

begin_comment
comment|/* Returns:     int    - new reference count value of the timeout queue     */
end_comment

begin_comment
comment|/* Parameters:  ifq(I) - timeout queue which is losing a reference.         */
end_comment

begin_comment
comment|/* Locks:       ifq->ifq_lock                                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This routine must be called when we're discarding a pointer to a timeout */
end_comment

begin_comment
comment|/* queue object, taking care of the reference counter.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Now that this just sets a DELETE flag, it requires the expire code to    */
end_comment

begin_comment
comment|/* check the list of user defined timeout queues and call the free function */
end_comment

begin_comment
comment|/* below (currently commented out) to stop memory leaking.  It is done this */
end_comment

begin_comment
comment|/* way because the locking may not be sufficient to safely do a free when   */
end_comment

begin_comment
comment|/* this function is called.                                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_deletetimeoutqueue
parameter_list|(
name|ifq
parameter_list|)
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
block|{
name|ifq
operator|->
name|ifq_ref
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ifq
operator|->
name|ifq_ref
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_USER
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ifq
operator|->
name|ifq_flags
operator||=
name|IFQF_DELETE
expr_stmt|;
block|}
return|return
name|ifq
operator|->
name|ifq_ref
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_freetimeoutqueue                                         */
end_comment

begin_comment
comment|/* Parameters:  ifq(I) - timeout queue which is losing a reference.         */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Locking:                                                                 */
end_comment

begin_comment
comment|/* It is assumed that the caller of this function has an appropriate lock   */
end_comment

begin_comment
comment|/* held (exclusively) in the domain that encompases the callers "domain".   */
end_comment

begin_comment
comment|/* The ifq_lock for this structure should not be held.                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove a user definde timeout queue from the list of queues it is in and */
end_comment

begin_comment
comment|/* tidy up after this is done.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_freetimeoutqueue
parameter_list|(
name|ifq
parameter_list|)
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_DELETE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ifq
operator|->
name|ifq_ref
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|ifq
operator|->
name|ifq_flags
operator|&
name|IFQF_USER
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fr_freetimeoutqueue(%lx) flags 0x%x ttl %d ref %d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ifq
argument_list|,
name|ifq
operator|->
name|ifq_flags
argument_list|,
name|ifq
operator|->
name|ifq_ttl
argument_list|,
name|ifq
operator|->
name|ifq_ref
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove from its position in the list. 	 */
operator|*
name|ifq
operator|->
name|ifq_pnext
operator|=
name|ifq
operator|->
name|ifq_next
expr_stmt|;
if|if
condition|(
name|ifq
operator|->
name|ifq_next
operator|!=
name|NULL
condition|)
name|ifq
operator|->
name|ifq_next
operator|->
name|ifq_pnext
operator|=
name|ifq
operator|->
name|ifq_pnext
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|fr_userifqs
operator|--
expr_stmt|;
name|KFREE
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_deletequeueentry                                         */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I) - timeout queue entry to delete                      */
end_comment

begin_comment
comment|/*              ifq(I) - timeout queue to remove entry from                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Remove a tail queue entry from its queue and make it an orphan.          */
end_comment

begin_comment
comment|/* fr_deletetimeoutqueue is called to make sure the reference count on the  */
end_comment

begin_comment
comment|/* queue is correct.  We can't, however, call fr_freetimeoutqueue because   */
end_comment

begin_comment
comment|/* the correct lock(s) may not be held that would make it safe to do so.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_deletequeueentry
parameter_list|(
name|tqe
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|ifq
operator|==
name|NULL
condition|)
return|return;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_pnext
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
operator|!=
name|NULL
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
comment|/* we must be the tail anyway */
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fr_deletetimeoutqueue
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_queuefront                                               */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I) - pointer to timeout queue entry                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry to the front of the queue, if it isn't already there. */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_queuefront
parameter_list|(
name|tqe
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|ifq
operator|==
name|NULL
condition|)
return|return;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifq
operator|->
name|ifq_head
operator|!=
name|tqe
condition|)
block|{
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
name|ifq
operator|->
name|ifq_head
operator|->
name|tqe_pnext
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|ifq
operator|->
name|ifq_head
operator|=
name|tqe
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
operator|&
name|ifq
operator|->
name|ifq_head
expr_stmt|;
block|}
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_queueback                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I) - pointer to timeout queue entry                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry to the back of the queue, if it isn't already there.  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_queueback
parameter_list|(
name|tqe
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
block|{
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|ifq
operator|=
name|tqe
operator|->
name|tqe_ifq
expr_stmt|;
if|if
condition|(
name|ifq
operator|==
name|NULL
condition|)
return|return;
name|tqe
operator|->
name|tqe_die
operator|=
name|fr_ticks
operator|+
name|ifq
operator|->
name|ifq_ttl
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
operator|==
name|NULL
condition|)
block|{
comment|/* at the end already ? */
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove from list 	 */
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
comment|/* 	 * Make it the last entry. 	 */
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_queueappend                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tqe(I)    - pointer to timeout queue entry                  */
end_comment

begin_comment
comment|/*              ifq(I)    - pointer to timeout queue                        */
end_comment

begin_comment
comment|/*              parent(I) - owing object pointer                            */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Add a new item to this queue and put it on the very end.                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_queueappend
parameter_list|(
name|tqe
parameter_list|,
name|ifq
parameter_list|,
name|parent
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|ipftq_t
modifier|*
name|ifq
decl_stmt|;
name|void
modifier|*
name|parent
decl_stmt|;
block|{
name|MUTEX_ENTER
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqe_parent
operator|=
name|parent
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|ifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|ifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|ifq
expr_stmt|;
name|tqe
operator|->
name|tqe_die
operator|=
name|fr_ticks
operator|+
name|ifq
operator|->
name|ifq_ttl
expr_stmt|;
name|ifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_movequeue                                                */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  tq(I)   - pointer to timeout queue information              */
end_comment

begin_comment
comment|/*              oifp(I) - old timeout queue entry was on                    */
end_comment

begin_comment
comment|/*              nifp(I) - new timeout queue to put entry on                 */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Move a queue entry from one timeout queue to another timeout queue.      */
end_comment

begin_comment
comment|/* If it notices that the current entry is already last and does not need   */
end_comment

begin_comment
comment|/* to move queue, the return.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_movequeue
parameter_list|(
name|tqe
parameter_list|,
name|oifq
parameter_list|,
name|nifq
parameter_list|)
name|ipftqent_t
modifier|*
name|tqe
decl_stmt|;
name|ipftq_t
modifier|*
name|oifq
decl_stmt|,
decl|*
name|nifq
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * Is the operation here going to be a no-op ? 	 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|oifq
operator|==
name|nifq
operator|&&
operator|*
name|oifq
operator|->
name|ifq_tail
operator|==
name|tqe
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove from the old queue 	 */
operator|*
name|tqe
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_next
expr_stmt|;
if|if
condition|(
name|tqe
operator|->
name|tqe_next
condition|)
name|tqe
operator|->
name|tqe_next
operator|->
name|tqe_pnext
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
else|else
name|oifq
operator|->
name|ifq_tail
operator|=
name|tqe
operator|->
name|tqe_pnext
expr_stmt|;
name|tqe
operator|->
name|tqe_next
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we're moving from one queue to another, release the lock on the 	 * old queue and get a lock on the new queue.  For user defined queues, 	 * if we're moving off it, call delete in case it can now be freed. 	 */
if|if
condition|(
name|oifq
operator|!=
name|nifq
condition|)
block|{
name|tqe
operator|->
name|tqe_ifq
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fr_deletetimeoutqueue
argument_list|(
name|oifq
argument_list|)
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|oifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|MUTEX_ENTER
argument_list|(
operator|&
name|nifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqe_ifq
operator|=
name|nifq
expr_stmt|;
name|nifq
operator|->
name|ifq_ref
operator|++
expr_stmt|;
block|}
comment|/* 	 * Add to the bottom of the new queue 	 */
name|tqe
operator|->
name|tqe_die
operator|=
name|fr_ticks
operator|+
name|nifq
operator|->
name|ifq_ttl
expr_stmt|;
name|tqe
operator|->
name|tqe_pnext
operator|=
name|nifq
operator|->
name|ifq_tail
expr_stmt|;
operator|*
name|nifq
operator|->
name|ifq_tail
operator|=
name|tqe
expr_stmt|;
name|nifq
operator|->
name|ifq_tail
operator|=
operator|&
name|tqe
operator|->
name|tqe_next
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|nifq
operator|->
name|ifq_lock
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_updateipid                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, -1 == error (packet should be droppped) */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* When we are doing NAT, change the IP of every packet to represent a      */
end_comment

begin_comment
comment|/* single sequence of packets coming from the host, hiding any host         */
end_comment

begin_comment
comment|/* specific sequencing that might otherwise be revealed.  If the packet is  */
end_comment

begin_comment
comment|/* a fragment, then store the 'new' IPid in the fragment cache and look up  */
end_comment

begin_comment
comment|/* the fragment cache for non-leading fragments.  If a non-leading fragment */
end_comment

begin_comment
comment|/* has no match in the cache, return an error.                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|int
name|fr_updateipid
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|id
decl_stmt|,
name|ido
decl_stmt|,
name|sums
decl_stmt|;
name|u_32_t
name|sumd
decl_stmt|,
name|sum
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|!=
literal|0
condition|)
block|{
name|sum
operator|=
name|fr_ipid_knownfrag
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|0xffffffff
condition|)
return|return
operator|-
literal|1
return|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
name|id
operator|=
operator|(
name|u_short
operator|)
name|sum
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|fr_nextipid
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_off
operator|==
literal|0
operator|&&
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_FRAG
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fr_ipid_newfrag
argument_list|(
name|fin
argument_list|,
operator|(
name|u_32_t
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
name|ip
operator|=
name|fin
operator|->
name|fin_ip
expr_stmt|;
name|ido
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ido
condition|)
return|return
literal|0
return|;
name|ip
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|CALC_SUMD
argument_list|(
name|ido
argument_list|,
name|id
argument_list|,
name|sumd
argument_list|)
expr_stmt|;
comment|/* DESTRUCTIVE MACRO! id,ido change */
name|sum
operator|=
operator|(
operator|~
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|sum
operator|+=
name|sumd
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sums
operator|=
operator|~
operator|(
name|u_short
operator|)
name|sum
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|htons
argument_list|(
name|sums
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_FRGETIFNAME
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_getifname                                                */
end_comment

begin_comment
comment|/* Returns:     char *    - pointer to interface name                       */
end_comment

begin_comment
comment|/* Parameters:  ifp(I)    - pointer to network interface                    */
end_comment

begin_comment
comment|/*              buffer(O) - pointer to where to store interface name        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Constructs an interface name in the buffer passed.  The buffer passed is */
end_comment

begin_comment
comment|/* expected to be at least LIFNAMSIZ in bytes big.  If buffer is passed in  */
end_comment

begin_comment
comment|/* as a NULL pointer then return a pointer to a static array.               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|char
modifier|*
name|fr_getifname
parameter_list|(
name|ifp
parameter_list|,
name|buffer
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|char
name|namebuf
index|[
name|LIFNAMSIZ
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX51
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|)
name|int
name|unit
decl_stmt|,
name|space
decl_stmt|;
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
name|buffer
operator|=
name|namebuf
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|LIFNAMSIZ
argument_list|)
expr_stmt|;
name|buffer
index|[
name|LIFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MENTAT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__sgi
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX51
argument_list|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|)
for|for
control|(
name|s
operator|=
name|buffer
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|unit
operator|=
name|ifp
operator|->
name|if_unit
expr_stmt|;
name|space
operator|=
name|LIFNAMSIZ
operator|-
operator|(
name|s
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SNPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|SNPRINTF
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|s
argument_list|,
name|temp
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ioctlswitch                                              */
end_comment

begin_comment
comment|/* Returns:     int     - -1 continue processing, else ioctl return value   */
end_comment

begin_comment
comment|/* Parameters:  unit(I) - device unit opened                                */
end_comment

begin_comment
comment|/*              data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              cmd(I)  - ioctl command                                     */
end_comment

begin_comment
comment|/*              mode(I) - mode value                                        */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Based on the value of unit, call the appropriate ioctl handler or return */
end_comment

begin_comment
comment|/* EIO if ipfilter is not running.   Also checks if write perms are req'd   */
end_comment

begin_comment
comment|/* for the device in order to execute the ioctl.                            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_ioctlswitch
parameter_list|(
name|unit
parameter_list|,
name|data
parameter_list|,
name|cmd
parameter_list|,
name|mode
parameter_list|)
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|IPL_LOGIPF
case|:
name|error
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|IPL_LOGNAT
case|:
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|error
operator|=
name|fr_nat_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|IPL_LOGSTATE
case|:
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|error
operator|=
name|fr_state_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|IPL_LOGAUTH
case|:
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCADAFR
operator|)
operator|||
operator|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCRMAFR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|frrequest
argument_list|(
name|unit
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fr_active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|fr_auth_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|IPL_LOGSYNC
case|:
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|error
operator|=
name|fr_sync_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|IPL_LOGSCAN
case|:
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|error
operator|=
name|fr_scan_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|IPL_LOGLOOKUP
case|:
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|error
operator|=
name|ip_lookup_ioctl
argument_list|(
name|data
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This array defines the expected size of objects coming into the kernel  * for the various recognised object types.  */
end_comment

begin_define
define|#
directive|define
name|NUM_OBJ_TYPES
value|14
end_define

begin_decl_stmt
specifier|static
name|int
name|fr_objbytes
index|[
name|NUM_OBJ_TYPES
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
expr|sizeof
operator|(
expr|struct
name|frentry
operator|)
block|}
block|,
comment|/* frentry */
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|friostat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|fr_info
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|fr_authstat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|ipfrstat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|ipnat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|natstat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|ipstate_save
operator|)
block|}
block|,
block|{
literal|1
block|,
expr|sizeof
operator|(
expr|struct
name|nat_save
operator|)
block|}
block|,
comment|/* nat_save */
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|natlookup
operator|)
block|}
block|,
block|{
literal|1
block|,
expr|sizeof
operator|(
expr|struct
name|ipstate
operator|)
block|}
block|,
comment|/* ipstate */
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|ips_stat
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|frauth
operator|)
block|}
block|,
block|{
literal|0
block|,
expr|sizeof
operator|(
expr|struct
name|ipftune
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_inobj                                                    */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy in the contents of what the ipfobj_t points to.  In future, we      */
end_comment

begin_comment
comment|/* add things to check for version numbers, sizes, etc, to make it backward */
end_comment

begin_comment
comment|/* compatible at the ABI for user land.                                     */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_inobj
parameter_list|(
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
name|NUM_OBJ_TYPES
operator|-
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|BCOPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
return|return
name|EINVAL
return|;
ifndef|#
directive|ifndef
name|IPFILTER_COMPAT
if|if
condition|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
return|return
name|EINVAL
return|;
else|#
directive|else
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|!=
name|IPFILTER_VERSION
condition|)
comment|/* XXX compatibility hook here */
empty_stmt|;
if|if
condition|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|COPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|obj
operator|.
name|ipfo_ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|COPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|obj
operator|.
name|ipfo_ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
name|obj
operator|.
name|ipfo_size
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_inobjsz                                                  */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*              sz(I)   - size of data to copy                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* As per fr_inobj, except the size of the object to copy in is passed in   */
end_comment

begin_comment
comment|/* but it must not be smaller than the size defined for the type and the    */
end_comment

begin_comment
comment|/* type must allow for varied sized objects.  The extra requirement here is */
end_comment

begin_comment
comment|/* that sz must match the size of the object being passed in - this is not  */
end_comment

begin_comment
comment|/* not possible nor required in fr_inobj().                                 */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_inobjsz
parameter_list|(
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|,
name|sz
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|sz
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
name|NUM_OBJ_TYPES
operator|-
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sz
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
operator|)
condition|)
return|return
name|EINVAL
return|;
name|BCOPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
return|return
name|EINVAL
return|;
ifndef|#
directive|ifndef
name|IPFILTER_COMPAT
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|sz
condition|)
return|return
name|EINVAL
return|;
else|#
directive|else
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|!=
name|IPFILTER_VERSION
condition|)
comment|/* XXX compatibility hook here */
empty_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|sz
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
endif|#
directive|endif
name|error
operator|=
name|COPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|obj
operator|.
name|ipfo_ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_outobjsz                                                 */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*              sz(I)   - size of data to copy                              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* As per fr_outobj, except the size of the object to copy out is passed in */
end_comment

begin_comment
comment|/* but it must not be smaller than the size defined for the type and the    */
end_comment

begin_comment
comment|/* type must allow for varied sized objects.  The extra requirement here is */
end_comment

begin_comment
comment|/* that sz must match the size of the object being passed in - this is not  */
end_comment

begin_comment
comment|/* not possible nor required in fr_outobj().                                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_outobjsz
parameter_list|(
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|,
name|sz
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|sz
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
name|NUM_OBJ_TYPES
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sz
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
operator|)
condition|)
return|return
name|EINVAL
return|;
name|BCOPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
return|return
name|EINVAL
return|;
ifndef|#
directive|ifndef
name|IPFILTER_COMPAT
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|sz
condition|)
return|return
name|EINVAL
return|;
else|#
directive|else
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|!=
name|IPFILTER_VERSION
condition|)
comment|/* XXX compatibility hook here */
empty_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|sz
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
endif|#
directive|endif
name|error
operator|=
name|COPYOUT
argument_list|(
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|obj
operator|.
name|ipfo_ptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_outobj                                                   */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = success, else failure                         */
end_comment

begin_comment
comment|/* Parameters:  data(I) - pointer to ioctl data                             */
end_comment

begin_comment
comment|/*              ptr(I)  - pointer to store real data in                     */
end_comment

begin_comment
comment|/*              type(I) - type of structure being moved                     */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copy out the contents of what ptr is to where ipfobj points to.  In      */
end_comment

begin_comment
comment|/* future, we add things to check for version numbers, sizes, etc, to make  */
end_comment

begin_comment
comment|/* it backward  compatible at the ABI for user land.                        */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_outobj
parameter_list|(
name|data
parameter_list|,
name|ptr
parameter_list|,
name|type
parameter_list|)
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|ipfobj_t
name|obj
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|<
literal|0
operator|)
operator|||
operator|(
name|type
operator|>
name|NUM_OBJ_TYPES
operator|-
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|BCOPYIN
argument_list|(
operator|(
name|caddr_t
operator|)
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|.
name|ipfo_type
operator|!=
name|type
condition|)
return|return
name|EINVAL
return|;
ifndef|#
directive|ifndef
name|IPFILTER_COMPAT
if|if
condition|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
return|return
name|EINVAL
return|;
else|#
directive|else
if|if
condition|(
name|obj
operator|.
name|ipfo_rev
operator|!=
name|IPFILTER_VERSION
condition|)
comment|/* XXX compatibility hook here */
empty_stmt|;
if|if
condition|(
operator|(
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|<
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|.
name|ipfo_size
operator|!=
name|fr_objbytes
index|[
name|type
index|]
index|[
literal|1
index|]
condition|)
comment|/* XXX compatibility hook here */
return|return
name|EINVAL
return|;
endif|#
directive|endif
name|error
operator|=
name|COPYOUT
argument_list|(
operator|(
name|caddr_t
operator|)
name|ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|obj
operator|.
name|ipfo_ptr
argument_list|,
name|obj
operator|.
name|ipfo_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_checkl4sum                                               */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = good, -1 = bad, 1 = cannot check              */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* If possible, calculate the layer 4 checksum for the packet.  If this is  */
end_comment

begin_comment
comment|/* not possible, return without indicating a failure or success but in a    */
end_comment

begin_comment
comment|/* way that is ditinguishable.                                              */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_checkl4sum
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
name|u_short
name|sum
decl_stmt|,
name|hdrsum
decl_stmt|,
modifier|*
name|csump
decl_stmt|;
name|udphdr_t
modifier|*
name|udp
decl_stmt|;
name|int
name|dosum
decl_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_NOCKSUM
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * If the TCP packet isn't a fragment, isn't too short and otherwise 	 * isn't already considered "bad", then validate the checksum.  If 	 * this check fails then considered the packet to be "bad". 	 */
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
operator|(
name|FI_FRAG
operator||
name|FI_SHORT
operator||
name|FI_BAD
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|csump
operator|=
name|NULL
expr_stmt|;
name|hdrsum
operator|=
literal|0
expr_stmt|;
name|dosum
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|(
name|SOLARIS2
operator|>=
literal|6
operator|)
operator|&&
name|defined
argument_list|(
name|ICK_VALID
argument_list|)
if|if
condition|(
name|dohwcksum
operator|&&
operator|(
operator|(
operator|*
name|fin
operator|->
name|fin_mp
operator|)
operator|->
name|b_ick_flag
operator|==
name|ICK_VALID
operator|)
condition|)
block|{
name|hdrsum
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
switch|switch
condition|(
name|fin
operator|->
name|fin_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
name|tcphdr_t
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|)
operator|->
name|th_sum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|udp
operator|=
name|fin
operator|->
name|fin_dp
expr_stmt|;
if|if
condition|(
name|udp
operator|->
name|uh_sum
operator|!=
literal|0
condition|)
block|{
name|csump
operator|=
operator|&
name|udp
operator|->
name|uh_sum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|csump
operator|=
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|fin
operator|->
name|fin_dp
operator|)
operator|->
name|icmp_cksum
expr_stmt|;
name|dosum
operator|=
literal|1
expr_stmt|;
break|break;
default|default :
return|return
literal|1
return|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|csump
operator|!=
name|NULL
condition|)
name|hdrsum
operator|=
operator|*
name|csump
expr_stmt|;
if|if
condition|(
name|dosum
condition|)
name|sum
operator|=
name|fr_cksum
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
operator|->
name|fin_ip
argument_list|,
name|fin
operator|->
name|fin_p
argument_list|,
name|fin
operator|->
name|fin_dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SOLARIS
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|(
name|SOLARIS2
operator|>=
literal|6
operator|)
operator|&&
name|defined
argument_list|(
name|ICK_VALID
argument_list|)
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|sum
operator|==
name|hdrsum
condition|)
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"checkl4sum: %hx == %hx\n"
operator|,
name|sum
operator|,
name|hdrsum
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FR_DEBUG
argument_list|(
operator|(
literal|"checkl4sum: %hx != %hx\n"
operator|,
name|sum
operator|,
name|hdrsum
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hdrsum
operator|==
name|sum
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ifpfillv4addr                                            */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = address update, -1 = address not updated      */
end_comment

begin_comment
comment|/* Parameters:  atype(I)   - type of network address update to perform      */
end_comment

begin_comment
comment|/*              sin(I)     - pointer to source of address information       */
end_comment

begin_comment
comment|/*              mask(I)    - pointer to source of netmask information       */
end_comment

begin_comment
comment|/*              inp(I)     - pointer to destination address store           */
end_comment

begin_comment
comment|/*              inpmask(I) - pointer to destination netmask store           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a type of network address update (atype) to perform, copy          */
end_comment

begin_comment
comment|/* information from sin/mask into inp/inpmask.  If ipnmask is NULL then no  */
end_comment

begin_comment
comment|/* netmask update is performed unless FRI_NETMASKED is passed as atype, in  */
end_comment

begin_comment
comment|/* which case the operation fails.  For all values of atype other than      */
end_comment

begin_comment
comment|/* FRI_NETMASKED, if inpmask is non-NULL then the mask is set to an all 1s  */
end_comment

begin_comment
comment|/* value.                                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_ifpfillv4addr
parameter_list|(
name|atype
parameter_list|,
name|sin
parameter_list|,
name|mask
parameter_list|,
name|inp
parameter_list|,
name|inpmask
parameter_list|)
name|int
name|atype
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inpmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|inpmask
operator|!=
name|NULL
operator|&&
name|atype
operator|!=
name|FRI_NETMASKED
condition|)
name|inpmask
operator|->
name|s_addr
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|atype
operator|==
name|FRI_NETWORK
operator|||
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|inpmask
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|inpmask
operator|->
name|s_addr
operator|=
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
name|inp
operator|->
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_INET6
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ifpfillv6addr                                            */
end_comment

begin_comment
comment|/* Returns:     int     - 0 = address update, -1 = address not updated      */
end_comment

begin_comment
comment|/* Parameters:  atype(I)   - type of network address update to perform      */
end_comment

begin_comment
comment|/*              sin(I)     - pointer to source of address information       */
end_comment

begin_comment
comment|/*              mask(I)    - pointer to source of netmask information       */
end_comment

begin_comment
comment|/*              inp(I)     - pointer to destination address store           */
end_comment

begin_comment
comment|/*              inpmask(I) - pointer to destination netmask store           */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Given a type of network address update (atype) to perform, copy          */
end_comment

begin_comment
comment|/* information from sin/mask into inp/inpmask.  If ipnmask is NULL then no  */
end_comment

begin_comment
comment|/* netmask update is performed unless FRI_NETMASKED is passed as atype, in  */
end_comment

begin_comment
comment|/* which case the operation fails.  For all values of atype other than      */
end_comment

begin_comment
comment|/* FRI_NETMASKED, if inpmask is non-NULL then the mask is set to an all 1s  */
end_comment

begin_comment
comment|/* value.                                                                   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_ifpfillv6addr
parameter_list|(
name|atype
parameter_list|,
name|sin
parameter_list|,
name|mask
parameter_list|,
name|inp
parameter_list|,
name|inpmask
parameter_list|)
name|int
name|atype
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|in_addr
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inpmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|i6addr_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|and
decl_stmt|,
modifier|*
name|dmask
decl_stmt|;
name|src
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin6_addr
expr_stmt|;
name|and
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
operator|&
name|mask
operator|->
name|sin6_addr
expr_stmt|;
name|dst
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
name|inp
expr_stmt|;
name|dmask
operator|=
operator|(
name|i6addr_t
operator|*
operator|)
name|inpmask
expr_stmt|;
if|if
condition|(
name|inpmask
operator|!=
name|NULL
operator|&&
name|atype
operator|!=
name|FRI_NETMASKED
condition|)
block|{
name|dmask
operator|->
name|i6
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|2
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|3
index|]
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
name|atype
operator|==
name|FRI_NETWORK
operator|||
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|atype
operator|==
name|FRI_NETMASKED
condition|)
block|{
if|if
condition|(
name|inpmask
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|dmask
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|dmask
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|and
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
name|dst
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|0
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|1
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|2
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|3
index|]
operator|&
name|and
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|i6
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|0
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|2
index|]
expr_stmt|;
name|dst
operator|->
name|i6
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|i6
index|[
literal|3
index|]
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_matchtag                                                 */
end_comment

begin_comment
comment|/* Returns:     0 == mismatch, 1 == match.                                  */
end_comment

begin_comment
comment|/* Parameters:  tag1(I) - pointer to first tag to compare                   */
end_comment

begin_comment
comment|/*              tag2(I) - pointer to second tag to compare                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Returns true (non-zero) or false(0) if the two tag structures can be     */
end_comment

begin_comment
comment|/* considered to be a match or not match, respectively.  The tag is 16      */
end_comment

begin_comment
comment|/* bytes long (16 characters) but that is overlayed with 4 32bit ints so    */
end_comment

begin_comment
comment|/* compare the ints instead, for speed. tag1 is the master of the           */
end_comment

begin_comment
comment|/* comparison.  This function should only be called with both tag1 and tag2 */
end_comment

begin_comment
comment|/* as non-NULL pointers.                                                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_matchtag
parameter_list|(
name|tag1
parameter_list|,
name|tag2
parameter_list|)
name|ipftag_t
modifier|*
name|tag1
decl_stmt|,
decl|*
name|tag2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|tag1
operator|==
name|tag2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tag2
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|1
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|2
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|2
index|]
operator|)
operator|&&
operator|(
name|tag1
operator|->
name|ipt_num
index|[
literal|3
index|]
operator|==
name|tag2
operator|->
name|ipt_num
index|[
literal|3
index|]
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_coalesce                                                 */
end_comment

begin_comment
comment|/* Returns:     1 == success, -1 == failure, 0 == no change                 */
end_comment

begin_comment
comment|/* Parameters:  fin(I) - pointer to packet information                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Attempt to get all of the packet data into a single, contiguous buffer.  */
end_comment

begin_comment
comment|/* If this call returns a failure then the buffers have also been freed.    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_coalesce
parameter_list|(
name|fin
parameter_list|)
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_flx
operator|&
name|FI_COALESCE
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * If the mbuf pointers indicate that there is no mbuf to work with, 	 * return but do not indicate success or failure. 	 */
if|if
condition|(
name|fin
operator|->
name|fin_m
operator|==
name|NULL
operator|||
name|fin
operator|->
name|fin_mp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|fr_pullup
argument_list|(
name|fin
operator|->
name|fin_m
argument_list|,
name|fin
argument_list|,
name|fin
operator|->
name|fin_plen
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ATOMIC_INCL
argument_list|(
name|fr_badcoalesces
index|[
name|fin
operator|->
name|fin_out
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MENTAT
name|FREE_MB_T
argument_list|(
operator|*
name|fin
operator|->
name|fin_mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|fin
operator|->
name|fin_mp
operator|=
name|NULL
expr_stmt|;
name|fin
operator|->
name|fin_m
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|fin
operator|=
name|fin
expr_stmt|;
comment|/* LINT */
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The following table lists all of the tunable variables that can be  * accessed via SIOCIPFGET/SIOCIPFSET/SIOCIPFGETNEXt.  The format of each row  * in the table below is as follows:  *  * pointer to value, name of value, minimum, maximum, size of the value's  *     container, value attribute flags  *  * For convienience, IPFT_RDONLY means the value is read-only, IPFT_WRDISABLED  * means the value can only be written to when IPFilter is loaded but disabled.  * The obvious implication is if neither of these are set then the value can be  * changed at any time without harm.  */
end_comment

begin_decl_stmt
name|ipftuneable_t
name|ipf_tuneables
index|[]
init|=
block|{
comment|/* filtering */
block|{
block|{
operator|&
name|fr_flags
block|}
block|,
literal|"fr_flags"
block|,
literal|0
block|,
literal|0xffffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_flags
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_active
block|}
block|,
literal|"fr_active"
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|fr_active
argument_list|)
block|,
name|IPFT_RDONLY
block|}
block|,
block|{
block|{
operator|&
name|fr_control_forwarding
block|}
block|,
literal|"fr_control_forwarding"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_control_forwarding
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_update_ipid
block|}
block|,
literal|"fr_update_ipid"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_update_ipid
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_chksrc
block|}
block|,
literal|"fr_chksrc"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_chksrc
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_minttl
block|}
block|,
literal|"fr_minttl"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_minttl
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_icmpminfragmtu
block|}
block|,
literal|"fr_icmpminfragmtu"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_icmpminfragmtu
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_pass
block|}
block|,
literal|"fr_pass"
block|,
literal|0
block|,
literal|0xffffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_pass
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* state */
block|{
block|{
operator|&
name|fr_tcpidletimeout
block|}
block|,
literal|"fr_tcpidletimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcpidletimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_tcpclosewait
block|}
block|,
literal|"fr_tcpclosewait"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcpclosewait
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_tcplastack
block|}
block|,
literal|"fr_tcplastack"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcplastack
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_tcptimeout
block|}
block|,
literal|"fr_tcptimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcptimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_tcpclosed
block|}
block|,
literal|"fr_tcpclosed"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcpclosed
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_tcphalfclosed
block|}
block|,
literal|"fr_tcphalfclosed"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_tcphalfclosed
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_udptimeout
block|}
block|,
literal|"fr_udptimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_udptimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_udpacktimeout
block|}
block|,
literal|"fr_udpacktimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_udpacktimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_icmptimeout
block|}
block|,
literal|"fr_icmptimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_icmptimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_icmpacktimeout
block|}
block|,
literal|"fr_icmpacktimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_icmpacktimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_iptimeout
block|}
block|,
literal|"fr_iptimeout"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_iptimeout
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_statemax
block|}
block|,
literal|"fr_statemax"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_statemax
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_statesize
block|}
block|,
literal|"fr_statesize"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_statesize
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_state_lock
block|}
block|,
literal|"fr_state_lock"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_state_lock
argument_list|)
block|,
name|IPFT_RDONLY
block|}
block|,
block|{
block|{
operator|&
name|fr_state_maxbucket
block|}
block|,
literal|"fr_state_maxbucket"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_state_maxbucket
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_state_maxbucket_reset
block|}
block|,
literal|"fr_state_maxbucket_reset"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_state_maxbucket_reset
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|ipstate_logging
block|}
block|,
literal|"ipstate_logging"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|ipstate_logging
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* nat */
block|{
block|{
operator|&
name|fr_nat_lock
block|}
block|,
literal|"fr_nat_lock"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_nat_lock
argument_list|)
block|,
name|IPFT_RDONLY
block|}
block|,
block|{
block|{
operator|&
name|ipf_nattable_sz
block|}
block|,
literal|"ipf_nattable_sz"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipf_nattable_sz
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|ipf_nattable_max
block|}
block|,
literal|"ipf_nattable_max"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipf_nattable_max
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|ipf_natrules_sz
block|}
block|,
literal|"ipf_natrules_sz"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipf_natrules_sz
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|ipf_rdrrules_sz
block|}
block|,
literal|"ipf_rdrrules_sz"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipf_rdrrules_sz
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|ipf_hostmap_sz
block|}
block|,
literal|"ipf_hostmap_sz"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipf_hostmap_sz
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_nat_maxbucket
block|}
block|,
literal|"fr_nat_maxbucket"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_nat_maxbucket
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_nat_maxbucket_reset
block|}
block|,
literal|"fr_nat_maxbucket_reset"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|fr_nat_maxbucket_reset
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|nat_logging
block|}
block|,
literal|"nat_logging"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|nat_logging
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|fr_defnatage
block|}
block|,
literal|"fr_defnatage"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_defnatage
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_defnatipage
block|}
block|,
literal|"fr_defnatipage"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_defnatipage
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_defnaticmpage
block|}
block|,
literal|"fr_defnaticmpage"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_defnaticmpage
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
comment|/* frag */
block|{
block|{
operator|&
name|ipfr_size
block|}
block|,
literal|"ipfr_size"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipfr_size
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|fr_ipfrttl
block|}
block|,
literal|"fr_ipfrttl"
block|,
literal|1
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|fr_ipfrttl
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
ifdef|#
directive|ifdef
name|IPFILTER_LOG
comment|/* log */
block|{
block|{
operator|&
name|ipl_suppress
block|}
block|,
literal|"ipl_suppress"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|ipl_suppress
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|ipl_buffer_sz
block|}
block|,
literal|"ipl_buffer_sz"
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|ipl_buffer_sz
argument_list|)
block|,
name|IPFT_RDONLY
block|}
block|,
block|{
block|{
operator|&
name|ipl_logmax
block|}
block|,
literal|"ipl_logmax"
block|,
literal|0
block|,
literal|0x7fffffff
block|,
sizeof|sizeof
argument_list|(
name|ipl_logmax
argument_list|)
block|,
name|IPFT_WRDISABLED
block|}
block|,
block|{
block|{
operator|&
name|ipl_logall
block|}
block|,
literal|"ipl_logall"
block|,
literal|0
block|,
literal|1
block|,
sizeof|sizeof
argument_list|(
name|ipl_logall
argument_list|)
block|,
literal|0
block|}
block|,
block|{
block|{
operator|&
name|ipl_logsize
block|}
block|,
literal|"ipl_logsize"
block|,
literal|0
block|,
literal|0x80000
block|,
sizeof|sizeof
argument_list|(
name|ipl_logsize
argument_list|)
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
block|{
name|NULL
block|}
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ipftuneable_t
modifier|*
name|ipf_tunelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_findtunebycookie                                         */
end_comment

begin_comment
comment|/* Returns:     NULL = search failed, else pointer to tune struct           */
end_comment

begin_comment
comment|/* Parameters:  cookie(I) - cookie value to search for amongst tuneables    */
end_comment

begin_comment
comment|/*              next(O)   - pointer to place to store the cookie for the    */
end_comment

begin_comment
comment|/*                          "next" tuneable, if it is desired.              */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* This function is used to walk through all of the existing tunables with  */
end_comment

begin_comment
comment|/* successive calls.  It searches the known tunables for the one which has  */
end_comment

begin_comment
comment|/* a matching value for "cookie" - ie its address.  When returning a match, */
end_comment

begin_comment
comment|/* the next one to be found may be returned inside next.                    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipftuneable_t
modifier|*
name|fr_findtunebycookie
parameter_list|(
name|cookie
parameter_list|,
name|next
parameter_list|)
name|void
modifier|*
name|cookie
decl_stmt|,
decl|*
modifier|*
name|next
decl_stmt|;
end_function

begin_block
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
for|for
control|(
name|ta
operator|=
name|ipf_tuneables
init|;
name|ta
operator|->
name|ipft_name
operator|!=
name|NULL
condition|;
name|ta
operator|++
control|)
if|if
condition|(
name|ta
operator|==
name|cookie
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * If the next entry in the array has a name 				 * present, then return a pointer to it for 				 * where to go next, else return a pointer to 				 * the dynaminc list as a key to search there 				 * next.  This facilitates a weak linking of 				 * the two "lists" together. 				 */
if|if
condition|(
operator|(
name|ta
operator|+
literal|1
operator|)
operator|->
name|ipft_name
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
name|ta
operator|+
literal|1
expr_stmt|;
else|else
operator|*
name|next
operator|=
operator|&
name|ipf_tunelist
expr_stmt|;
block|}
return|return
name|ta
return|;
block|}
for|for
control|(
name|tap
operator|=
operator|&
name|ipf_tunelist
init|;
operator|(
name|ta
operator|=
operator|*
name|tap
operator|)
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
name|ta
operator|->
name|ipft_next
control|)
if|if
condition|(
name|tap
operator|==
name|cookie
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
operator|&
name|ta
operator|->
name|ipft_next
expr_stmt|;
return|return
name|ta
return|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_findtunebyname                                           */
end_comment

begin_comment
comment|/* Returns:     NULL = search failed, else pointer to tune struct           */
end_comment

begin_comment
comment|/* Parameters:  name(I) - name of the tuneable entry to find.               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search the static array of tuneables and the list of dynamic tuneables   */
end_comment

begin_comment
comment|/* for an entry with a matching name.  If we can find one, return a pointer */
end_comment

begin_comment
comment|/* to the matching structure.                                               */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|ipftuneable_t
modifier|*
name|fr_findtunebyname
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|;
for|for
control|(
name|ta
operator|=
name|ipf_tuneables
init|;
name|ta
operator|->
name|ipft_name
operator|!=
name|NULL
condition|;
name|ta
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|ta
return|;
block|}
for|for
control|(
name|ta
operator|=
name|ipf_tunelist
init|;
name|ta
operator|!=
name|NULL
condition|;
name|ta
operator|=
name|ta
operator|->
name|ipft_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return
name|ta
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_addipftune                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  newtune - pointer to new tune struct to add to tuneables    */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Appends the tune structure pointer to by "newtune" to the end of the     */
end_comment

begin_comment
comment|/* current list of "dynamic" tuneable parameters.  Once added, the owner    */
end_comment

begin_comment
comment|/* of the object is not expected to ever change "ipft_next".                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_addipftune
parameter_list|(
name|newtune
parameter_list|)
name|ipftuneable_t
modifier|*
name|newtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
name|ta
operator|=
name|fr_findtunebyname
argument_list|(
name|newtune
operator|->
name|ipft_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
return|return
name|EEXIST
return|;
for|for
control|(
name|tap
operator|=
operator|&
name|ipf_tunelist
init|;
operator|*
name|tap
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
operator|(
operator|*
name|tap
operator|)
operator|->
name|ipft_next
control|)
empty_stmt|;
name|newtune
operator|->
name|ipft_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|tap
operator|=
name|newtune
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_delipftune                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  oldtune - pointer to tune struct to remove from the list of */
end_comment

begin_comment
comment|/*                        current dynamic tuneables                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Search for the tune structure, by pointer, in the list of those that are */
end_comment

begin_comment
comment|/* dynamically added at run time.  If found, adjust the list so that this   */
end_comment

begin_comment
comment|/* structure is no longer part of it.                                       */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_delipftune
parameter_list|(
name|oldtune
parameter_list|)
name|ipftuneable_t
modifier|*
name|oldtune
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|,
modifier|*
modifier|*
name|tap
decl_stmt|;
for|for
control|(
name|tap
operator|=
operator|&
name|ipf_tunelist
init|;
operator|(
name|ta
operator|=
operator|*
name|tap
operator|)
operator|!=
name|NULL
condition|;
name|tap
operator|=
operator|&
name|ta
operator|->
name|ipft_next
control|)
if|if
condition|(
name|ta
operator|==
name|oldtune
condition|)
block|{
operator|*
name|tap
operator|=
name|oldtune
operator|->
name|ipft_next
expr_stmt|;
name|oldtune
operator|->
name|ipft_next
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ESRCH
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_ipftune                                                  */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success, else failure                            */
end_comment

begin_comment
comment|/* Parameters:  cmd(I)  - ioctl command number                              */
end_comment

begin_comment
comment|/*              data(I) - pointer to ioctl data structure                   */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Implement handling of SIOCIPFGETNEXT, SIOCIPFGET and SIOCIPFSET.  These  */
end_comment

begin_comment
comment|/* three ioctls provide the means to access and control global variables    */
end_comment

begin_comment
comment|/* within IPFilter, allowing (for example) timeouts and table sizes to be   */
end_comment

begin_comment
comment|/* changed without rebooting, reloading or recompiling.  The initialisation */
end_comment

begin_comment
comment|/* and 'destruction' routines of the various components of ipfilter are all */
end_comment

begin_comment
comment|/* each responsible for handling their own values being too big.            */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_ipftune
parameter_list|(
name|cmd
parameter_list|,
name|data
parameter_list|)
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|ipftuneable_t
modifier|*
name|ta
decl_stmt|;
name|ipftune_t
name|tu
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|fr_inobj
argument_list|(
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tu
operator|.
name|ipft_name
index|[
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cookie
operator|=
name|tu
operator|.
name|ipft_cookie
expr_stmt|;
name|ta
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCIPFGETNEXT
case|:
comment|/* 		 * If cookie is non-NULL, assume it to be a pointer to the last 		 * entry we looked at, so find it (if possible) and return a 		 * pointer to the next one after it.  The last entry in the 		 * the table is a NULL entry, so when we get to it, set cookie 		 * to NULL and return that, indicating end of list, erstwhile 		 * if we come in with cookie set to NULL, we are starting anew 		 * at the front of the list. 		 */
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
block|{
name|ta
operator|=
name|fr_findtunebycookie
argument_list|(
name|cookie
argument_list|,
operator|&
name|tu
operator|.
name|ipft_cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ta
operator|=
name|ipf_tuneables
expr_stmt|;
name|tu
operator|.
name|ipft_cookie
operator|=
name|ta
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Entry found, but does the data pointed to by that 			 * row fit in what we can return? 			 */
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|>
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_un
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|tu
operator|.
name|ipft_vlong
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
name|tu
operator|.
name|ipft_sz
operator|=
name|ta
operator|->
name|ipft_sz
expr_stmt|;
name|tu
operator|.
name|ipft_min
operator|=
name|ta
operator|->
name|ipft_min
expr_stmt|;
name|tu
operator|.
name|ipft_max
operator|=
name|ta
operator|->
name|ipft_max
expr_stmt|;
name|tu
operator|.
name|ipft_flags
operator|=
name|ta
operator|->
name|ipft_flags
expr_stmt|;
name|bcopy
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|,
name|tu
operator|.
name|ipft_name
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|tu
operator|.
name|ipft_name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|ta
operator|->
name|ipft_name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCIPFGET
case|:
case|case
name|SIOCIPFSET
case|:
comment|/* 		 * Search by name or by cookie value for a particular entry 		 * in the tuning paramter table. 		 */
name|error
operator|=
name|ESRCH
expr_stmt|;
if|if
condition|(
name|cookie
operator|!=
name|NULL
condition|)
block|{
name|ta
operator|=
name|fr_findtunebycookie
argument_list|(
name|cookie
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tu
operator|.
name|ipft_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ta
operator|=
name|fr_findtunebyname
argument_list|(
name|tu
operator|.
name|ipft_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ta
operator|!=
name|NULL
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCIPFGET
condition|)
block|{
comment|/* 			 * Fetch the tuning parameters for a particular value 			 */
name|tu
operator|.
name|ipft_vlong
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
name|tu
operator|.
name|ipft_cookie
operator|=
name|ta
expr_stmt|;
name|tu
operator|.
name|ipft_sz
operator|=
name|ta
operator|->
name|ipft_sz
expr_stmt|;
name|tu
operator|.
name|ipft_min
operator|=
name|ta
operator|->
name|ipft_min
expr_stmt|;
name|tu
operator|.
name|ipft_max
operator|=
name|ta
operator|->
name|ipft_max
expr_stmt|;
name|tu
operator|.
name|ipft_flags
operator|=
name|ta
operator|->
name|ipft_flags
expr_stmt|;
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
operator|(
name|ioctlcmd_t
operator|)
name|SIOCIPFSET
condition|)
block|{
comment|/* 			 * Set an internal parameter.  The hard part here is 			 * getting the new value safely and correctly out of 			 * the kernel (given we only know its size, not type.) 			 */
name|u_long
name|in
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ta
operator|->
name|ipft_flags
operator|&
name|IPFT_WRDISABLED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fr_running
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|in
operator|=
name|tu
operator|.
name|ipft_vlong
expr_stmt|;
if|if
condition|(
name|in
operator|<
name|ta
operator|->
name|ipft_min
operator|||
name|in
operator|>
name|ta
operator|->
name|ipft_max
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vlong
operator|=
operator|*
name|ta
operator|->
name|ipft_plong
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_plong
operator|=
name|in
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vint
operator|=
operator|*
name|ta
operator|->
name|ipft_pint
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pint
operator|=
call|(
name|u_int
call|)
argument_list|(
name|in
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vshort
operator|=
operator|*
name|ta
operator|->
name|ipft_pshort
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pshort
operator|=
call|(
name|u_short
call|)
argument_list|(
name|in
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ta
operator|->
name|ipft_sz
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|tu
operator|.
name|ipft_vchar
operator|=
operator|*
name|ta
operator|->
name|ipft_pchar
expr_stmt|;
operator|*
name|ta
operator|->
name|ipft_pchar
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|tu
argument_list|,
name|IPFOBJ_TUNEABLE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default :
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_initialise                                               */
end_comment

begin_comment
comment|/* Returns:     int - 0 == success,< 0 == failure                         */
end_comment

begin_comment
comment|/* Parameters:  None.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Call of the initialise functions for all the various subsystems inside   */
end_comment

begin_comment
comment|/* of IPFilter.  If any of them should fail, return immeadiately a failure  */
end_comment

begin_comment
comment|/* BUT do not try to recover from the error here.                           */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_initialise
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|i
operator|=
name|fr_loginit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|10
operator|+
name|i
return|;
endif|#
directive|endif
name|i
operator|=
name|fr_natinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|20
operator|+
name|i
return|;
name|i
operator|=
name|fr_stateinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|30
operator|+
name|i
return|;
name|i
operator|=
name|fr_authinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|40
operator|+
name|i
return|;
name|i
operator|=
name|fr_fraginit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|50
operator|+
name|i
return|;
name|i
operator|=
name|appr_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|60
operator|+
name|i
return|;
ifdef|#
directive|ifdef
name|IPFILTER_SYNC
name|i
operator|=
name|ipfsync_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|70
operator|+
name|i
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
name|i
operator|=
name|ipsc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|80
operator|+
name|i
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
name|i
operator|=
name|ip_lookup_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|-
literal|90
operator|+
name|i
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
name|ipfrule_add
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_deinitialise                                             */
end_comment

begin_comment
comment|/* Returns:     None.                                                       */
end_comment

begin_comment
comment|/* Parameters:  None.                                                       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Call all the various subsystem cleanup routines to deallocate memory or  */
end_comment

begin_comment
comment|/* destroy locks or whatever they've done that they need to now undo.       */
end_comment

begin_comment
comment|/* The order here IS important as there are some cross references of        */
end_comment

begin_comment
comment|/* internal data structures.                                                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_deinitialise
parameter_list|()
block|{
name|fr_fragunload
argument_list|()
expr_stmt|;
name|fr_authunload
argument_list|()
expr_stmt|;
name|fr_natunload
argument_list|()
expr_stmt|;
name|fr_stateunload
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
name|fr_scanunload
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|appr_unload
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_COMPILED
name|ipfrule_remove
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|frflush
argument_list|(
name|IPL_LOGIPF
argument_list|,
literal|0
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
operator||
name|FR_INACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflush
argument_list|(
name|IPL_LOGIPF
argument_list|,
literal|0
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflush
argument_list|(
name|IPL_LOGCOUNT
argument_list|,
literal|0
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
operator||
name|FR_INACTIVE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|frflush
argument_list|(
name|IPL_LOGCOUNT
argument_list|,
literal|0
argument_list|,
name|FR_INQUE
operator||
name|FR_OUTQUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_LOOKUP
name|ip_lookup_unload
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFILTER_LOG
name|fr_logunload
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_zerostats                                                */
end_comment

begin_comment
comment|/* Returns:     int - 0 = success, else failure                             */
end_comment

begin_comment
comment|/* Parameters:  data(O) - pointer to pointer for copying data back to       */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Copies the current statistics out to userspace and then zero's the       */
end_comment

begin_comment
comment|/* current ones in the kernel. The lock is only held across the bzero() as  */
end_comment

begin_comment
comment|/* the copyout may result in paging (ie network activity.)                  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|int
name|fr_zerostats
parameter_list|(
name|data
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
block|{
name|friostat_t
name|fio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fr_getstat
argument_list|(
operator|&
name|fio
argument_list|)
expr_stmt|;
name|error
operator|=
name|fr_outobj
argument_list|(
name|data
argument_list|,
operator|&
name|fio
argument_list|,
name|IPFOBJ_IPFSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|EFAULT
return|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frstats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frstats
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_resolvedest                                              */
end_comment

begin_comment
comment|/* Returns:     Nil                                                         */
end_comment

begin_comment
comment|/* Parameters:  fdp(IO) - pointer to destination information to resolve     */
end_comment

begin_comment
comment|/*              v(I)    - IP protocol version to match                      */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Looks up an interface name in the frdest structure pointed to by fdp and */
end_comment

begin_comment
comment|/* if a matching name can be found for the particular IP protocol version   */
end_comment

begin_comment
comment|/* then store the interface pointer in the frdest struct.  If no match is   */
end_comment

begin_comment
comment|/* found, then set the interface pointer to be -1 as NULL is considered to  */
end_comment

begin_comment
comment|/* indicate there is no information at all in the structure.                */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
name|fr_resolvedest
parameter_list|(
name|fdp
parameter_list|,
name|v
parameter_list|)
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|void
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|v
operator|=
name|v
expr_stmt|;
comment|/* LINT */
if|if
condition|(
operator|*
name|fdp
operator|->
name|fd_ifname
operator|!=
literal|'\0'
condition|)
block|{
name|ifp
operator|=
name|GETIFP
argument_list|(
name|fdp
operator|->
name|fd_ifname
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
name|ifp
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|fdp
operator|->
name|fd_ifp
operator|=
name|ifp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Function:    fr_resolvenic                                               */
end_comment

begin_comment
comment|/* Returns:     void* - NULL = wildcard name, -1 = failed to find NIC, else */
end_comment

begin_comment
comment|/*                      pointer to interface structure for NIC              */
end_comment

begin_comment
comment|/* Parameters:  name(I) - complete interface name                           */
end_comment

begin_comment
comment|/*              v(I)    - IP protocol version                               */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* Look for a network interface structure that firstly has a matching name  */
end_comment

begin_comment
comment|/* to that passed in and that is also being used for that IP protocol       */
end_comment

begin_comment
comment|/* version (necessary on some platforms where there are separate listings   */
end_comment

begin_comment
comment|/* for both IPv4 and IPv6 on the same physical NIC.                         */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* One might wonder why name gets terminated with a \0 byte in here.  The   */
end_comment

begin_comment
comment|/* reason is an interface name could get into the kernel structures of ipf  */
end_comment

begin_comment
comment|/* in any number of ways and so long as they all use the same sized array   */
end_comment

begin_comment
comment|/* to put the name in, it makes sense to ensure it gets null terminated     */
end_comment

begin_comment
comment|/* before it is used for its intended purpose - finding its match in the    */
end_comment

begin_comment
comment|/* kernel's list of configured interfaces.                                  */
end_comment

begin_comment
comment|/*                                                                          */
end_comment

begin_comment
comment|/* NOTE: This SHOULD ONLY be used with IPFilter structures that have an     */
end_comment

begin_comment
comment|/*       array for the name that is LIFNAMSIZ bytes (at least) in length.   */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_function
name|void
modifier|*
name|fr_resolvenic
parameter_list|(
name|name
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|v
decl_stmt|;
block|{
name|void
modifier|*
name|nic
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|name
index|[
name|LIFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nic
operator|=
name|GETIFP
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|nic
operator|==
name|NULL
condition|)
name|nic
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|nic
return|;
block|}
end_function

end_unit

